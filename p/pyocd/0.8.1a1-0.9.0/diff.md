# Comparing `tmp/pyOCD-0.8.1a1.tar.gz` & `tmp/pyOCD-0.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\pyOCD-0.8.1a1.tar", last modified: Thu Dec 22 04:17:17 2016, max compression
+gzip compressed data, was "dist/pyOCD-0.9.0.tar", last modified: Tue May  8 20:36:19 2018, max compression
```

## Comparing `pyOCD-0.8.1a1.tar` & `pyOCD-0.9.0.tar`

### file list

```diff
@@ -1,211 +1,220 @@
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/
--rw-rw-rw-   0        0        0      287 2016-06-23 14:40:37.000000 pyOCD-0.8.1a1/.editorconfig
--rw-rw-rw-   0        0        0      706 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/.gitignore
--rw-rw-rw-   0        0        0      184 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/.travis.yml
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/binaries/
--rw-rw-rw-   0        0        0    71144 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_k20d50m.bin
--rw-rw-rw-   0        0        0     2928 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_k22f.bin
--rw-rw-rw-   0        0        0     6996 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_k64f.bin
--rw-rw-rw-   0        0        0     2276 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_k66f.bin
--rw-rw-rw-   0        0        0    10288 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_ke15z7.bin
--rw-rw-rw-   0        0        0    10828 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_ke18f16.bin
--rw-rw-rw-   0        0        0     1904 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_kl25z.bin
--rw-rw-rw-   0        0        0      964 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_kl27z.bin
--rw-rw-rw-   0        0        0     8698 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/binaries/l1_kl28z.bin
--rw-rw-rw-   0        0        0    17368 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_kl46z.bin
--rw-rw-rw-   0        0        0     9144 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_kw40z.bin
--rw-rw-rw-   0        0        0     3828 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_lpc11u24.bin
--rw-rw-rw-   0        0        0     4132 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_lpc1768.bin
--rw-rw-rw-   0        0        0    16984 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_lpc4088dm.bin
--rw-rw-rw-   0        0        0    17128 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/binaries/l1_lpc4088qsb.bin
--rw-rw-rw-   0        0        0     2760 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_lpc4330.bin
--rw-rw-rw-   0        0        0     2592 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_lpc800.bin
--rw-rw-rw-   0        0        0     2640 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/binaries/l1_lpc824.bin
--rw-rw-rw-   0        0        0    30044 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_max32600mbed.bin
--rw-rw-rw-   0        0        0    33140 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_maxwsnenv.bin
--rw-rw-rw-   0        0        0     2580 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/binaries/l1_mbed_LPC1114FN28.bin
--rw-rw-rw-   0        0        0     3580 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/binaries/l1_microbit.bin
--rw-rw-rw-   0        0        0    24116 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/binaries/l1_ncs36510-evk.bin
--rw-rw-rw-   0        0        0      676 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_nrf51-dk.bin
--rw-rw-rw-   0        0        0      776 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_nrf51.bin
--rw-rw-rw-   0        0        0     2052 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/binaries/l1_nrf52-dk.bin
--rw-rw-rw-   0        0        0     2044 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/binaries/l1_w7500mbed.bin
--rw-rw-rw-   0        0        0      120 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/dev-requirements.txt
--rw-rw-rw-   0        0        0   105361 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/Doxyfile
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/elf_files/
--rw-rw-rw-   0        0        0   143556 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/elf_files/lpc11u24_l1_gcc_arm.elf
--rw-rw-rw-   0        0        0   154417 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/elf_files/lpc1768_l1_gcc_arm.elf
--rw-rw-rw-   0        0        0     1766 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/HOW_TO_BUILD.md
--rw-rw-rw-   0        0        0    10464 2015-08-06 19:18:23.000000 pyOCD-0.8.1a1/LICENSE
--rw-rw-rw-   0        0        0      107 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/MANIFEST.in
--rw-rw-rw-   0        0        0    10058 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/PKG-INFO
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/board/
--rw-rw-rw-   0        0        0     2592 2016-08-12 22:12:19.000000 pyOCD-0.8.1a1/pyOCD/board/board.py
--rw-rw-rw-   0        0        0    12979 2016-12-06 19:50:44.000000 pyOCD-0.8.1a1/pyOCD/board/mbed_board.py
--rw-rw-rw-   0        0        0      675 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/board/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/coresight/
--rw-rw-rw-   0        0        0    12490 2016-08-12 22:12:19.000000 pyOCD-0.8.1a1/pyOCD/coresight/ap.py
--rw-rw-rw-   0        0        0     9120 2016-08-12 22:12:19.000000 pyOCD-0.8.1a1/pyOCD/coresight/breakpoints.py
--rw-rw-rw-   0        0        0    34874 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/coresight/cortex_m.py
--rw-rw-rw-   0        0        0    10192 2016-11-17 16:21:10.000000 pyOCD-0.8.1a1/pyOCD/coresight/dap.py
--rw-rw-rw-   0        0        0     4679 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/coresight/dwt.py
--rw-rw-rw-   0        0        0     3843 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/coresight/fpb.py
--rw-rw-rw-   0        0        0     9342 2016-08-12 22:12:19.000000 pyOCD-0.8.1a1/pyOCD/coresight/rom_table.py
--rw-rw-rw-   0        0        0      726 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/coresight/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/flash/
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/
--rwxrwxrwx   0        0        0      477 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/build.bat
--rw-rw-rw-   0        0        0     1108 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/generate_python.py
--rw-rw-rw-   0        0        0     1484 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/linker_script.ld
--rw-rw-rw-   0        0        0     1757 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/main.c
--rw-rw-rw-   0        0        0      227 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/analyzer/readme.txt
--rw-rw-rw-   0        0        0    15977 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/flash/flash.py
--rw-rw-rw-   0        0        0    24797 2016-08-19 21:36:09.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_builder.py
--rw-rw-rw-   0        0        0     1547 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_cortex_m.py
--rw-rw-rw-   0        0        0     5271 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_k20d50m.py
--rw-rw-rw-   0        0        0     5379 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_k22f.py
--rw-rw-rw-   0        0        0     5302 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_k64f.py
--rw-rw-rw-   0        0        0     5143 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_k66f18.py
--rw-rw-rw-   0        0        0     5187 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_k82f25615.py
--rw-rw-rw-   0        0        0     5360 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_ke15z7.py
--rw-rw-rw-   0        0        0     5487 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_ke18f16.py
--rw-rw-rw-   0        0        0     3792 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kinetis.py
--rw-rw-rw-   0        0        0     6475 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kl27z4.py
--rw-rw-rw-   0        0        0     8191 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kl28z.py
--rw-rw-rw-   0        0        0     6449 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kl43z4.py
--rw-rw-rw-   0        0        0     7009 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_klxx.py
--rw-rw-rw-   0        0        0     6514 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kv10z7.py
--rw-rw-rw-   0        0        0     6600 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kv11z7.py
--rw-rw-rw-   0        0        0     6449 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kw01z4.py
--rw-rw-rw-   0        0        0     6538 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_kw40z4.py
--rw-rw-rw-   0        0        0     3437 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc11u24.py
--rw-rw-rw-   0        0        0     2959 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc11xx_32.py
--rw-rw-rw-   0        0        0     5046 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc1768.py
--rw-rw-rw-   0        0        0     3492 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4088.py
--rw-rw-rw-   0        0        0     4909 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4088qsb_dm.py
--rw-rw-rw-   0        0        0    34753 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4330.py
--rw-rw-rw-   0        0        0     3151 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc800.py
--rw-rw-rw-   0        0        0     2824 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_lpc824.py
--rw-rw-rw-   0        0        0     3232 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_max32600mbed.py
--rw-rw-rw-   0        0        0     3226 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_maxwsnenv.py
--rw-rw-rw-   0        0        0     5290 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_ncs36510.py
--rw-rw-rw-   0        0        0     2507 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_nrf51.py
--rw-rw-rw-   0        0        0     2509 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_nrf52.py
--rw-rw-rw-   0        0        0     3167 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_stm32f051.py
--rw-rw-rw-   0        0        0     2741 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_stm32f103rc.py
--rw-rw-rw-   0        0        0     1964 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/flash/flash_w7500.py
--rw-rw-rw-   0        0        0     3317 2016-12-06 16:19:16.000000 pyOCD-0.8.1a1/pyOCD/flash/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/
--rw-rw-rw-   0        0        0    39335 2016-08-19 21:36:09.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/gdbserver.py
--rw-rw-rw-   0        0        0     1933 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/gdb_socket.py
--rw-rw-rw-   0        0        0     1408 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/gdb_websocket.py
--rw-rw-rw-   0        0        0      698 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/signals.py
--rw-rw-rw-   0        0        0     4312 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/syscall.py
--rw-rw-rw-   0        0        0      655 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/gdbserver/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/
--rw-rw-rw-   0        0        0    11094 2016-12-08 03:05:51.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/cmsis_dap_core.py
--rw-rw-rw-   0        0        0     5340 2016-12-08 03:05:51.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/dap_access_api.py
--rw-rw-rw-   0        0        0    28211 2016-12-08 03:05:51.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/dap_access_cmsis_dap.py
--rw-rw-rw-   0        0        0      705 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/dap_settings.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/
--rw-rw-rw-   0        0        0     3784 2016-12-06 19:50:44.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/hidapi_backend.py
--rw-rw-rw-   0        0        0     1404 2016-03-14 20:25:32.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/interface.py
--rw-rw-rw-   0        0        0     9154 2016-12-22 04:07:10.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/pyusb_backend.py
--rw-rw-rw-   0        0        0     5866 2016-12-06 19:50:44.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/pywinusb_backend.py
--rw-rw-rw-   0        0        0     1670 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/ws_backend.py
--rw-rw-rw-   0        0        0     2041 2016-12-08 20:14:55.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/__init__.py
--rw-rw-rw-   0        0        0      800 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/pyDAPAccess/__init__.py
--rw-rw-rw-   0        0        0     2222 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/svd.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/pyOCD/target/
--rw-rw-rw-   0        0        0     7195 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/target/coresight_target.py
--rw-rw-rw-   0        0        0     5748 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/memory_map.py
--rw-rw-rw-   0        0        0    25653 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/semihost.py
--rw-rw-rw-   0        0        0     6298 2016-08-19 21:36:09.000000 pyOCD-0.8.1a1/pyOCD/target/target.py
--rw-rw-rw-   0        0        0     1232 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_k20d50m.py
--rw-rw-rw-   0        0        0     1278 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_k22f.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_k64f.py
--rw-rw-rw-   0        0        0     1283 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_k66f18.py
--rw-rw-rw-   0        0        0     1948 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_k82f25615.py
--rw-rw-rw-   0        0        0     1437 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_ke15z7.py
--rw-rw-rw-   0        0        0     1443 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_ke18f16.py
--rw-rw-rw-   0        0        0     6889 2016-11-07 19:39:46.000000 pyOCD-0.8.1a1/pyOCD/target/target_kinetis.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl02z.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl05z.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl25z.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl26z.py
--rw-rw-rw-   0        0        0     1228 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl27z4.py
--rw-rw-rw-   0        0        0     3166 2016-08-19 21:36:09.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl28z.py
--rw-rw-rw-   0        0        0     1226 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl43z4.py
--rw-rw-rw-   0        0        0     1230 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_kl46z.py
--rw-rw-rw-   0        0        0     1225 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kv10z7.py
--rw-rw-rw-   0        0        0     1226 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kv11z7.py
--rw-rw-rw-   0        0        0     1226 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kw01z4.py
--rw-rw-rw-   0        0        0     1226 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_kw40z4.py
--rw-rw-rw-   0        0        0     1623 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc11u24.py
--rw-rw-rw-   0        0        0     1522 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc11xx_32.py
--rw-rw-rw-   0        0        0     1837 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc1768.py
--rw-rw-rw-   0        0        0     1979 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc4088.py
--rw-rw-rw-   0        0        0     1219 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc4088dm.py
--rw-rw-rw-   0        0        0     1221 2016-08-15 16:39:26.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc4088qsb.py
--rw-rw-rw-   0        0        0     2870 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc4330.py
--rw-rw-rw-   0        0        0     1618 2016-10-25 15:11:35.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc800.py
--rw-rw-rw-   0        0        0     1522 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_lpc824.py
--rw-rw-rw-   0        0        0     1560 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_max32600mbed.py
--rw-rw-rw-   0        0        0     1554 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_maxwsnenv.py
--rw-rw-rw-   0        0        0     1161 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/target/target_ncs36510.py
--rw-rw-rw-   0        0        0     1809 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_nrf51.py
--rw-rw-rw-   0        0        0     1335 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_nrf52.py
--rw-rw-rw-   0        0        0     1942 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_stm32f051.py
--rw-rw-rw-   0        0        0     1453 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_stm32f103rc.py
--rw-rw-rw-   0        0        0     1059 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/target/target_w7500.py
--rw-rw-rw-   0        0        0     3270 2016-12-06 16:19:16.000000 pyOCD-0.8.1a1/pyOCD/target/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/test/
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/pyOCD/test/test_target/
--rw-rw-rw-   0        0        0    20360 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/test/test_target/test_semihosting.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/pyOCD/test/test_utility/
--rw-rw-rw-   0        0        0     1640 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/test/test_utility/test_cmdline.py
--rw-rw-rw-   0        0        0     2990 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/test/test_utility/test_conversion.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/pyOCD/tools/
--rw-rw-rw-   0        0        0     9753 2016-08-12 22:12:19.000000 pyOCD-0.8.1a1/pyOCD/tools/flash_tool.py
--rw-rw-rw-   0        0        0    13024 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/pyOCD/tools/gdb_server.py
--rw-rw-rw-   0        0        0    32018 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/tools/pyocd.py
--rw-rw-rw-   0        0        0      620 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/tools/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/pyOCD/utility/
--rw-rw-rw-   0        0        0     1601 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/pyOCD/utility/cmdline.py
--rw-rw-rw-   0        0        0     2831 2016-08-19 21:36:09.000000 pyOCD-0.8.1a1/pyOCD/utility/conversion.py
--rw-rw-rw-   0        0        0     2388 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/utility/mask.py
--rw-rw-rw-   0        0        0      665 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/utility/__init__.py
--rw-rw-rw-   0        0        0      122 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD/_version.py
--rw-rw-rw-   0        0        0      767 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/pyOCD/__init__.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/
--rw-rw-rw-   0        0        0        1 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      147 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0    10058 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0       86 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/requires.txt
--rw-rw-rw-   0        0        0     8745 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        6 2016-12-22 04:17:16.000000 pyOCD-0.8.1a1/pyOCD.egg-info/top_level.txt
--rw-rw-rw-   0        0        0     7600 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/README.rst
--rw-rw-rw-   0        0        0       64 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/setup.cfg
--rw-rw-rw-   0        0        0     2199 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/setup.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/test/
--rw-rw-rw-   0        0        0       67 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/test/.gitignore
--rw-rw-rw-   0        0        0     3658 2016-11-07 22:45:40.000000 pyOCD-0.8.1a1/test/automated_test.py
--rw-rw-rw-   0        0        0     8060 2016-08-12 21:04:30.000000 pyOCD-0.8.1a1/test/basic_test.py
--rw-rw-rw-   0        0        0     1946 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/blank_test.py
--rw-rw-rw-   0        0        0    11362 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/test/cortex_test.py
--rw-rw-rw-   0        0        0    16712 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/test/flash_test.py
--rw-rw-rw-   0        0        0    17478 2016-03-16 14:26:50.000000 pyOCD-0.8.1a1/test/gdb_script.py
--rw-rw-rw-   0        0        0     5791 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/test/gdb_server_json_test.py
--rw-rw-rw-   0        0        0     5829 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/test/gdb_test.py
-drwxrwxrwx   0        0        0        0 2016-12-22 04:17:17.000000 pyOCD-0.8.1a1/test/gdb_test_program/
--rwxrwxrwx   0        0        0      378 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/build.bat
--rw-rw-rw-   0        0        0      444 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/gdb_test.bin
--rw-rw-rw-   0        0        0    17271 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/gdb_test.elf
--rw-rw-rw-   0        0        0     1392 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/linker_script.ld
--rw-rw-rw-   0        0        0     2337 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/main.c
--rw-rw-rw-   0        0        0      294 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/gdb_test_program/readme.txt
--rw-rw-rw-   0        0        0     5313 2016-12-08 02:52:05.000000 pyOCD-0.8.1a1/test/parallel_test.py
--rw-rw-rw-   0        0        0     6055 2016-11-23 00:06:38.000000 pyOCD-0.8.1a1/test/speed_test.py
--rw-rw-rw-   0        0        0      445 2016-03-14 19:53:52.000000 pyOCD-0.8.1a1/test/test_pyocd_tool.sh
--rw-rw-rw-   0        0        0     2867 2016-08-09 20:27:47.000000 pyOCD-0.8.1a1/test/test_util.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/
+-rw-r--r--   0 creed      (501) staff       (20)     9796 2018-05-08 20:36:19.000000 pyOCD-0.9.0/PKG-INFO
+-rw-r--r--   0 creed      (501) staff       (20)       27 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pytest.ini
+-rw-r--r--   0 creed      (501) staff       (20)    10273 2018-05-08 20:18:56.000000 pyOCD-0.9.0/LICENSE
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/test/
+-rw-r--r--   0 creed      (501) staff       (20)     5600 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/gdb_server_json_test.py
+-rw-r--r--   0 creed      (501) staff       (20)     5157 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/parallel_test.py
+-rw-r--r--   0 creed      (501) staff       (20)    17272 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/gdb_script.py
+-rwxr-xr-x   0 creed      (501) staff       (20)      479 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/test_pyocd_tool.sh
+-rw-r--r--   0 creed      (501) staff       (20)     6074 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/speed_test.py
+-rw-r--r--   0 creed      (501) staff       (20)     2776 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/test_util.py
+-rw-r--r--   0 creed      (501) staff       (20)     3546 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/automated_test.py
+-rw-r--r--   0 creed      (501) staff       (20)    16474 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/flash_test.py
+-rw-r--r--   0 creed      (501) staff       (20)       62 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/.gitignore
+-rw-r--r--   0 creed      (501) staff       (20)     5412 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/gdb_test.py
+-rw-r--r--   0 creed      (501) staff       (20)     1885 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/blank_test.py
+-rw-r--r--   0 creed      (501) staff       (20)     7837 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/basic_test.py
+-rw-r--r--   0 creed      (501) staff       (20)    11198 2018-05-08 20:18:56.000000 pyOCD-0.9.0/test/cortex_test.py
+-rw-r--r--   0 creed      (501) staff       (20)      113 2018-05-08 20:18:56.000000 pyOCD-0.9.0/dev-requirements.txt
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/
+-rw-r--r--   0 creed      (501) staff       (20)    11271 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/cmsis_dap_core.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/
+-rw-r--r--   0 creed      (501) staff       (20)     8999 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/pyusb_backend.py
+-rw-r--r--   0 creed      (501) staff       (20)     1352 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/interface.py
+-rw-r--r--   0 creed      (501) staff       (20)     1981 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     3787 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/hidapi_backend.py
+-rw-r--r--   0 creed      (501) staff       (20)     1615 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/ws_backend.py
+-rw-r--r--   0 creed      (501) staff       (20)     5788 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/pywinusb_backend.py
+-rw-r--r--   0 creed      (501) staff       (20)      707 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/dap_settings.py
+-rw-r--r--   0 creed      (501) staff       (20)      779 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     5963 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/dap_access_api.py
+-rw-r--r--   0 creed      (501) staff       (20)    32695 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/pyDAPAccess/dap_access_cmsis_dap.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/tools/
+-rwxr-xr-x   0 creed      (501) staff       (20)     9871 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/tools/flash_tool.py
+-rwxr-xr-x   0 creed      (501) staff       (20)    46568 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/tools/pyocd.py
+-rw-r--r--   0 creed      (501) staff       (20)      604 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/tools/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)    14849 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/tools/gdb_server.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/core/
+-rw-r--r--   0 creed      (501) staff       (20)      599 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/core/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     7376 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/core/coresight_target.py
+-rw-r--r--   0 creed      (501) staff       (20)     6235 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/core/target.py
+-rw-r--r--   0 creed      (501) staff       (20)    10181 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/core/memory_map.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/test/
+-rw-r--r--   0 creed      (501) staff       (20)      841 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/conftest.py
+-rw-r--r--   0 creed      (501) staff       (20)     7911 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_memory_map.py
+-rw-r--r--   0 creed      (501) staff       (20)      605 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     1600 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_cmdline.py
+-rw-r--r--   0 creed      (501) staff       (20)     2901 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_conversion.py
+-rw-r--r--   0 creed      (501) staff       (20)     4206 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/mockcore.py
+-rw-r--r--   0 creed      (501) staff       (20)     3726 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_mockcore.py
+-rw-r--r--   0 creed      (501) staff       (20)     6761 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_memcache.py
+-rw-r--r--   0 creed      (501) staff       (20)    19911 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_semihosting.py
+-rw-r--r--   0 creed      (501) staff       (20)     6323 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/test/test_regcache.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/board/
+-rw-r--r--   0 creed      (501) staff       (20)     2495 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/board/board.py
+-rw-r--r--   0 creed      (501) staff       (20)      656 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/board/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)    13666 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/board/mbed_board.py
+-rw-r--r--   0 creed      (501) staff       (20)      116 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/_version.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/target/
+-rw-r--r--   0 creed      (501) staff       (20)     7148 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL26Z256xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     6162 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC1768.py
+-rw-r--r--   0 creed      (501) staff       (20)     6614 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL82Z128xxx7.py
+-rw-r--r--   0 creed      (501) staff       (20)     7104 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKV11Z128xxx7.py
+-rw-r--r--   0 creed      (501) staff       (20)     7022 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL02Z32xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     5800 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK20DX128xxx5.py
+-rw-r--r--   0 creed      (501) staff       (20)     4404 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_STM32F051T8.py
+-rw-r--r--   0 creed      (501) staff       (20)     5937 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKW41Z512xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     2361 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_w7500.py
+-rw-r--r--   0 creed      (501) staff       (20)     4089 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_lpc800.py
+-rw-r--r--   0 creed      (501) staff       (20)     7148 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL46Z256xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     5655 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_ncs36510.py
+-rw-r--r--   0 creed      (501) staff       (20)     6219 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK82FN256xxx15.py
+-rw-r--r--   0 creed      (501) staff       (20)     4103 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_max32600mbed.py
+-rw-r--r--   0 creed      (501) staff       (20)    36644 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC4330.py
+-rw-r--r--   0 creed      (501) staff       (20)     3620 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_nRF51822_xxAA.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/target/family/
+-rw-r--r--   0 creed      (501) staff       (20)     1512 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/family/flash_cortex_m.py
+-rw-r--r--   0 creed      (501) staff       (20)      599 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/family/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     6731 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/family/target_kinetis.py
+-rw-r--r--   0 creed      (501) staff       (20)     3702 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/family/flash_kinetis.py
+-rw-r--r--   0 creed      (501) staff       (20)     5344 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_lpc4088qsb.py
+-rw-r--r--   0 creed      (501) staff       (20)     6622 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     4375 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC11U24FBD64_401.py
+-rw-r--r--   0 creed      (501) staff       (20)     7022 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL05Z32xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     4474 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC54114J256BD64.py
+-rw-r--r--   0 creed      (501) staff       (20)     6955 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKW01Z128xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     6955 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL43Z256xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     4701 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC4088FBD144.py
+-rw-r--r--   0 creed      (501) staff       (20)     5721 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK66FN2M0xxx18.py
+-rw-r--r--   0 creed      (501) staff       (20)     5781 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK28FN2M0xxx15.py
+-rw-r--r--   0 creed      (501) staff       (20)     6582 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK22FN1M0Axxx12.py
+-rw-r--r--   0 creed      (501) staff       (20)     6984 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL27Z256xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     7018 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKV10Z128xxx7.py
+-rw-r--r--   0 creed      (501) staff       (20)     3315 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_nRF52832_xxAA.py
+-rw-r--r--   0 creed      (501) staff       (20)     3772 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC1114FN28_102.py
+-rw-r--r--   0 creed      (501) staff       (20)     1354 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_RTL8195AM.py
+-rw-r--r--   0 creed      (501) staff       (20)     5952 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK22FN512xxx12.py
+-rw-r--r--   0 creed      (501) staff       (20)     3327 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_nRF52840_xxAA.py
+-rw-r--r--   0 creed      (501) staff       (20)     3509 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_STM32F103RC.py
+-rw-r--r--   0 creed      (501) staff       (20)     4091 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_maxwsnenv.py
+-rw-r--r--   0 creed      (501) staff       (20)     6063 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKE15Z256xxx7.py
+-rw-r--r--   0 creed      (501) staff       (20)    10419 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL28Z512xxx7.py
+-rw-r--r--   0 creed      (501) staff       (20)     3628 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_LPC824M201JHI33.py
+-rw-r--r--   0 creed      (501) staff       (20)     5342 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_lpc4088dm.py
+-rw-r--r--   0 creed      (501) staff       (20)     7148 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKL25Z128xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     7043 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKW40Z160xxx4.py
+-rw-r--r--   0 creed      (501) staff       (20)     5829 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MK64FN1M0xxx12.py
+-rw-r--r--   0 creed      (501) staff       (20)     6195 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/target/target_MKE18F256xxx16.py
+-rw-r--r--   0 creed      (501) staff       (20)      766 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/__init__.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/coresight/
+-rw-r--r--   0 creed      (501) staff       (20)     9082 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/rom_table.py
+-rw-r--r--   0 creed      (501) staff       (20)     4783 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/dwt.py
+-rw-r--r--   0 creed      (501) staff       (20)    10042 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/dap.py
+-rw-r--r--   0 creed      (501) staff       (20)      605 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)    13815 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/ap.py
+-rw-r--r--   0 creed      (501) staff       (20)    31325 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/cortex_m.py
+-rw-r--r--   0 creed      (501) staff       (20)     4047 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/coresight/fpb.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/flash/
+-rw-r--r--   0 creed      (501) staff       (20)    24168 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/flash/flash_builder.py
+-rw-r--r--   0 creed      (501) staff       (20)      605 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/flash/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)    15358 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/flash/flash.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/rtos/
+-rw-r--r--   0 creed      (501) staff       (20)    18030 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/rtos/freertos.py
+-rw-r--r--   0 creed      (501) staff       (20)     2960 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/rtos/provider.py
+-rw-r--r--   0 creed      (501) staff       (20)    13738 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/rtos/argon.py
+-rw-r--r--   0 creed      (501) staff       (20)      793 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/rtos/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     5984 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/rtos/common.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/gdbserver/
+-rw-r--r--   0 creed      (501) staff       (20)      676 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/signals.py
+-rw-r--r--   0 creed      (501) staff       (20)     5157 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/context_facade.py
+-rw-r--r--   0 creed      (501) staff       (20)     1866 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/gdb_socket.py
+-rw-r--r--   0 creed      (501) staff       (20)     1354 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/gdb_websocket.py
+-rw-r--r--   0 creed      (501) staff       (20)      637 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)    47446 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/gdbserver.py
+-rw-r--r--   0 creed      (501) staff       (20)      889 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/symbols.py
+-rw-r--r--   0 creed      (501) staff       (20)     4186 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/gdbserver/syscall.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/debug/
+-rw-r--r--   0 creed      (501) staff       (20)    24965 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/semihost.py
+-rw-r--r--   0 creed      (501) staff       (20)    18848 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/cache.py
+-rw-r--r--   0 creed      (501) staff       (20)      599 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     2181 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/svd.py
+-rw-r--r--   0 creed      (501) staff       (20)      791 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/symbols.py
+-rw-r--r--   0 creed      (501) staff       (20)     4445 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/context.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/debug/breakpoints/
+-rw-r--r--   0 creed      (501) staff       (20)     1648 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/breakpoints/provider.py
+-rw-r--r--   0 creed      (501) staff       (20)      600 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/breakpoints/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)     6346 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/breakpoints/manager.py
+-rw-r--r--   0 creed      (501) staff       (20)     3293 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/debug/breakpoints/software.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD/utility/
+-rw-r--r--   0 creed      (501) staff       (20)     2311 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/utility/mask.py
+-rw-r--r--   0 creed      (501) staff       (20)     2907 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/utility/conversion.py
+-rw-r--r--   0 creed      (501) staff       (20)     2685 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/utility/cmdline.py
+-rw-r--r--   0 creed      (501) staff       (20)      645 2018-05-08 20:18:56.000000 pyOCD-0.9.0/pyOCD/utility/__init__.py
+-rw-r--r--   0 creed      (501) staff       (20)      104 2018-05-08 20:18:56.000000 pyOCD-0.9.0/MANIFEST.in
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/elf_files/
+-rw-r--r--   0 creed      (501) staff       (20)   154417 2018-05-08 20:18:56.000000 pyOCD-0.9.0/elf_files/lpc1768_l1_gcc_arm.elf
+-rw-r--r--   0 creed      (501) staff       (20)   143556 2018-05-08 20:18:56.000000 pyOCD-0.9.0/elf_files/lpc11u24_l1_gcc_arm.elf
+-rw-r--r--   0 creed      (501) staff       (20)     1721 2018-05-08 20:18:56.000000 pyOCD-0.9.0/HOW_TO_BUILD.md
+-rw-r--r--   0 creed      (501) staff       (20)      273 2018-05-08 20:18:56.000000 pyOCD-0.9.0/.editorconfig
+-rw-r--r--   0 creed      (501) staff       (20)     2148 2018-05-08 20:18:56.000000 pyOCD-0.9.0/setup.py
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/
+-rw-r--r--   0 creed      (501) staff       (20)     9796 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/PKG-INFO
+-rw-r--r--   0 creed      (501) staff       (20)     5447 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/SOURCES.txt
+-rw-r--r--   0 creed      (501) staff       (20)      147 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/entry_points.txt
+-rw-r--r--   0 creed      (501) staff       (20)       90 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/requires.txt
+-rw-r--r--   0 creed      (501) staff       (20)        6 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/top_level.txt
+-rw-r--r--   0 creed      (501) staff       (20)        1 2018-05-08 20:36:19.000000 pyOCD-0.9.0/pyOCD.egg-info/dependency_links.txt
+-rw-r--r--   0 creed      (501) staff       (20)      709 2018-05-08 20:18:56.000000 pyOCD-0.9.0/.gitignore
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/binaries/
+-rw-r--r--   0 creed      (501) staff       (20)      776 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_nrf51.bin
+-rw-r--r--   0 creed      (501) staff       (20)    33140 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_maxwsnenv.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2640 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc824.bin
+-rw-r--r--   0 creed      (501) staff       (20)     4132 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc1768.bin
+-rw-r--r--   0 creed      (501) staff       (20)    16660 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k82f.bin
+-rw-r--r--   0 creed      (501) staff       (20)     3828 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc11u24.bin
+-rw-r--r--   0 creed      (501) staff       (20)      964 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kl27z.bin
+-rw-r--r--   0 creed      (501) staff       (20)    17368 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kl46z.bin
+-rw-r--r--   0 creed      (501) staff       (20)    71144 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k20d50m.bin
+-rw-r--r--   0 creed      (501) staff       (20)     9364 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kl82z.bin
+-rw-r--r--   0 creed      (501) staff       (20)      676 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_nrf51-dk.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2580 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_mbed_LPC1114FN28.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2276 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k66f.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2276 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k28f.bin
+-rw-r--r--   0 creed      (501) staff       (20)    10288 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_ke15z7.bin
+-rw-r--r--   0 creed      (501) staff       (20)    24116 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_ncs36510-evk.bin
+-rw-r--r--   0 creed      (501) staff       (20)    30044 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_max32600mbed.bin
+-rw-r--r--   0 creed      (501) staff       (20)    10828 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_ke18f16.bin
+-rw-r--r--   0 creed      (501) staff       (20)     6996 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k64f.bin
+-rw-r--r--   0 creed      (501) staff       (20)     3580 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_microbit.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2760 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc4330.bin
+-rw-r--r--   0 creed      (501) staff       (20)    16984 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc4088dm.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2928 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_k22f.bin
+-rwxr-xr-x   0 creed      (501) staff       (20)     9144 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kw40z.bin
+-rw-r--r--   0 creed      (501) staff       (20)     8698 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kl28z.bin
+-rw-r--r--   0 creed      (501) staff       (20)    10376 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc54114.bin
+-rw-r--r--   0 creed      (501) staff       (20)    17128 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc4088qsb.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2044 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_w7500mbed.bin
+-rw-r--r--   0 creed      (501) staff       (20)     1904 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kl25z.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2592 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_lpc800.bin
+-rw-r--r--   0 creed      (501) staff       (20)     2052 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_nrf52-dk.bin
+-rw-r--r--   0 creed      (501) staff       (20)     5020 2018-05-08 20:18:56.000000 pyOCD-0.9.0/binaries/l1_kw41z.bin
+-rw-r--r--   0 creed      (501) staff       (20)       59 2018-05-08 20:36:19.000000 pyOCD-0.9.0/setup.cfg
+-rw-r--r--   0 creed      (501) staff       (20)     7353 2018-05-08 20:18:56.000000 pyOCD-0.9.0/README.rst
+-rw-r--r--   0 creed      (501) staff       (20)   102987 2018-05-08 20:18:56.000000 pyOCD-0.9.0/Doxyfile
+-rw-r--r--   0 creed      (501) staff       (20)      177 2018-05-08 20:18:56.000000 pyOCD-0.9.0/.travis.yml
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/src/
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/src/gdb_test_program/
+-rw-r--r--   0 creed      (501) staff       (20)      444 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/gdb_test.bin
+-rw-r--r--   0 creed      (501) staff       (20)      328 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/build.bat
+-rw-r--r--   0 creed      (501) staff       (20)     2236 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/main.c
+-rw-r--r--   0 creed      (501) staff       (20)      290 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/readme.txt
+-rw-r--r--   0 creed      (501) staff       (20)     1338 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/linker_script.ld
+-rw-r--r--   0 creed      (501) staff       (20)    17271 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/gdb_test_program/gdb_test.elf
+drwxr-xr-x   0 creed      (501) staff       (20)        0 2018-05-08 20:36:19.000000 pyOCD-0.9.0/src/analyzer/
+-rw-r--r--   0 creed      (501) staff       (20)      473 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/analyzer/build.bat
+-rw-r--r--   0 creed      (501) staff       (20)     1688 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/analyzer/main.c
+-rw-r--r--   0 creed      (501) staff       (20)      223 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/analyzer/readme.txt
+-rw-r--r--   0 creed      (501) staff       (20)     1069 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/analyzer/generate_python.py
+-rw-r--r--   0 creed      (501) staff       (20)     1423 2018-05-08 20:18:56.000000 pyOCD-0.9.0/src/analyzer/linker_script.ld
```

### Comparing `pyOCD-0.8.1a1/.gitignore` & `pyOCD-0.9.0/.gitignore`

 * *Files 4% similar despite different names*

```diff
@@ -67,10 +67,10 @@
 
 automated_test_result.txt
 test_params.txt
 output.txt
 gdb_test_raw.txt
 test_results.txt
 
-
-.eggs/
-pyOCD/_version.py
+.cache
+.eggs/
+pyOCD/_version.py
```

### Comparing `pyOCD-0.8.1a1/binaries/l1_k20d50m.bin` & `pyOCD-0.9.0/binaries/l1_k20d50m.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_k22f.bin` & `pyOCD-0.9.0/binaries/l1_k22f.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_k64f.bin` & `pyOCD-0.9.0/binaries/l1_k64f.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_k66f.bin` & `pyOCD-0.9.0/binaries/l1_k66f.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_ke15z7.bin` & `pyOCD-0.9.0/binaries/l1_ke15z7.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_ke18f16.bin` & `pyOCD-0.9.0/binaries/l1_ke18f16.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_kl25z.bin` & `pyOCD-0.9.0/binaries/l1_kl25z.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_kl27z.bin` & `pyOCD-0.9.0/binaries/l1_kl27z.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_kl28z.bin` & `pyOCD-0.9.0/binaries/l1_kl28z.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_kl46z.bin` & `pyOCD-0.9.0/binaries/l1_kl46z.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_kw40z.bin` & `pyOCD-0.9.0/binaries/l1_kw40z.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc11u24.bin` & `pyOCD-0.9.0/binaries/l1_lpc11u24.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc1768.bin` & `pyOCD-0.9.0/binaries/l1_lpc1768.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc4088dm.bin` & `pyOCD-0.9.0/binaries/l1_lpc4088dm.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc4088qsb.bin` & `pyOCD-0.9.0/binaries/l1_lpc4088qsb.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc4330.bin` & `pyOCD-0.9.0/binaries/l1_lpc4330.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc800.bin` & `pyOCD-0.9.0/binaries/l1_lpc800.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_lpc824.bin` & `pyOCD-0.9.0/binaries/l1_lpc824.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_max32600mbed.bin` & `pyOCD-0.9.0/binaries/l1_max32600mbed.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_maxwsnenv.bin` & `pyOCD-0.9.0/binaries/l1_maxwsnenv.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_mbed_LPC1114FN28.bin` & `pyOCD-0.9.0/binaries/l1_mbed_LPC1114FN28.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_microbit.bin` & `pyOCD-0.9.0/binaries/l1_microbit.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_ncs36510-evk.bin` & `pyOCD-0.9.0/binaries/l1_ncs36510-evk.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_nrf51-dk.bin` & `pyOCD-0.9.0/binaries/l1_nrf51-dk.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_nrf51.bin` & `pyOCD-0.9.0/binaries/l1_nrf51.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_nrf52-dk.bin` & `pyOCD-0.9.0/binaries/l1_nrf52-dk.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/binaries/l1_w7500mbed.bin` & `pyOCD-0.9.0/binaries/l1_w7500mbed.bin`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/Doxyfile` & `pyOCD-0.9.0/Doxyfile`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,2374 +1,2374 @@
-# Doxyfile 1.8.6
-
-# This file describes the settings to be used by the documentation system
-# doxygen (www.doxygen.org) for a project.
-#
-# All text after a double hash (##) is considered a comment and is placed in
-# front of the TAG it is preceding.
-#
-# All text after a single hash (#) is considered a comment and will be ignored.
-# The format is:
-# TAG = value [value, ...]
-# For lists, items can also be appended using:
-# TAG += value [value, ...]
-# Values that contain spaces should be placed between quotes (\" \").
-
-#---------------------------------------------------------------------------
-# Project related configuration options
-#---------------------------------------------------------------------------
-
-# This tag specifies the encoding used for all characters in the config file
-# that follow. The default is UTF-8 which is also the encoding used for all text
-# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
-# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
-# for the list of possible encodings.
-# The default value is: UTF-8.
-
-DOXYFILE_ENCODING      = UTF-8
-
-# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
-# double-quotes, unless you are using Doxywizard) that should identify the
-# project for which the documentation is generated. This name is used in the
-# title of most generated pages and in a few other places.
-# The default value is: My Project.
-
-PROJECT_NAME           = pyOCD
-
-# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
-# could be handy for archiving the generated documentation or if some version
-# control system is used.
-
-PROJECT_NUMBER         = 
-
-# Using the PROJECT_BRIEF tag one can provide an optional one line description
-# for a project that appears at the top of each page and should give viewer a
-# quick idea about the purpose of the project. Keep the description short.
-
-PROJECT_BRIEF          = 
-
-# With the PROJECT_LOGO tag one can specify an logo or icon that is included in
-# the documentation. The maximum height of the logo should not exceed 55 pixels
-# and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
-# to the output directory.
-
-PROJECT_LOGO           = 
-
-# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
-# into which the generated documentation will be written. If a relative path is
-# entered, it will be relative to the location where doxygen was started. If
-# left blank the current directory will be used.
-
-OUTPUT_DIRECTORY       = 
-
-# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
-# directories (in 2 levels) under the output directory of each output format and
-# will distribute the generated files over these directories. Enabling this
-# option can be useful when feeding doxygen a huge amount of source files, where
-# putting all generated files in the same directory would otherwise causes
-# performance problems for the file system.
-# The default value is: NO.
-
-CREATE_SUBDIRS         = NO
-
-# The OUTPUT_LANGUAGE tag is used to specify the language in which all
-# documentation generated by doxygen is written. Doxygen will use this
-# information to generate all constant output in the proper language.
-# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
-# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
-# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
-# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
-# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
-# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
-# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
-# Ukrainian and Vietnamese.
-# The default value is: English.
-
-OUTPUT_LANGUAGE        = English
-
-# If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
-# descriptions after the members that are listed in the file and class
-# documentation (similar to Javadoc). Set to NO to disable this.
-# The default value is: YES.
-
-BRIEF_MEMBER_DESC      = YES
-
-# If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
-# description of a member or function before the detailed description
-#
-# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
-# brief descriptions will be completely suppressed.
-# The default value is: YES.
-
-REPEAT_BRIEF           = YES
-
-# This tag implements a quasi-intelligent brief description abbreviator that is
-# used to form the text in various listings. Each string in this list, if found
-# as the leading text of the brief description, will be stripped from the text
-# and the result, after processing the whole list, is used as the annotated
-# text. Otherwise, the brief description is used as-is. If left blank, the
-# following values are used ($name is automatically replaced with the name of
-# the entity):The $name class, The $name widget, The $name file, is, provides,
-# specifies, contains, represents, a, an and the.
-
-ABBREVIATE_BRIEF       = "The $name class" \
-                         "The $name widget" \
-                         "The $name file" \
-                         is \
-                         provides \
-                         specifies \
-                         contains \
-                         represents \
-                         a \
-                         an \
-                         the
-
-# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
-# doxygen will generate a detailed section even if there is only a brief
-# description.
-# The default value is: NO.
-
-ALWAYS_DETAILED_SEC    = NO
-
-# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
-# inherited members of a class in the documentation of that class as if those
-# members were ordinary class members. Constructors, destructors and assignment
-# operators of the base classes will not be shown.
-# The default value is: NO.
-
-INLINE_INHERITED_MEMB  = NO
-
-# If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
-# before files name in the file list and in the header files. If set to NO the
-# shortest path that makes the file name unique will be used
-# The default value is: YES.
-
-FULL_PATH_NAMES        = NO
-
-# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
-# Stripping is only done if one of the specified strings matches the left-hand
-# part of the path. The tag can be used to show relative paths in the file list.
-# If left blank the directory from which doxygen is run is used as the path to
-# strip.
-#
-# Note that you can specify absolute paths here, but also relative paths, which
-# will be relative from the directory where doxygen is started.
-# This tag requires that the tag FULL_PATH_NAMES is set to YES.
-
-STRIP_FROM_PATH        = 
-
-# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
-# path mentioned in the documentation of a class, which tells the reader which
-# header file to include in order to use a class. If left blank only the name of
-# the header file containing the class definition is used. Otherwise one should
-# specify the list of include paths that are normally passed to the compiler
-# using the -I flag.
-
-STRIP_FROM_INC_PATH    = 
-
-# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
-# less readable) file names. This can be useful is your file systems doesn't
-# support long names like on DOS, Mac, or CD-ROM.
-# The default value is: NO.
-
-SHORT_NAMES            = NO
-
-# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
-# first line (until the first dot) of a Javadoc-style comment as the brief
-# description. If set to NO, the Javadoc-style will behave just like regular Qt-
-# style comments (thus requiring an explicit @brief command for a brief
-# description.)
-# The default value is: NO.
-
-JAVADOC_AUTOBRIEF      = NO
-
-# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
-# line (until the first dot) of a Qt-style comment as the brief description. If
-# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
-# requiring an explicit \brief command for a brief description.)
-# The default value is: NO.
-
-QT_AUTOBRIEF           = NO
-
-# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
-# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
-# a brief description. This used to be the default behavior. The new default is
-# to treat a multi-line C++ comment block as a detailed description. Set this
-# tag to YES if you prefer the old behavior instead.
-#
-# Note that setting this tag to YES also means that rational rose comments are
-# not recognized any more.
-# The default value is: NO.
-
-MULTILINE_CPP_IS_BRIEF = NO
-
-# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
-# documentation from any documented member that it re-implements.
-# The default value is: YES.
-
-INHERIT_DOCS           = YES
-
-# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
-# new page for each member. If set to NO, the documentation of a member will be
-# part of the file/class/namespace that contains it.
-# The default value is: NO.
-
-SEPARATE_MEMBER_PAGES  = NO
-
-# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
-# uses this value to replace tabs by spaces in code fragments.
-# Minimum value: 1, maximum value: 16, default value: 4.
-
-TAB_SIZE               = 4
-
-# This tag can be used to specify a number of aliases that act as commands in
-# the documentation. An alias has the form:
-# name=value
-# For example adding
-# "sideeffect=@par Side Effects:\n"
-# will allow you to put the command \sideeffect (or @sideeffect) in the
-# documentation, which will result in a user-defined paragraph with heading
-# "Side Effects:". You can put \n's in the value part of an alias to insert
-# newlines.
-
-ALIASES                = 
-
-# This tag can be used to specify a number of word-keyword mappings (TCL only).
-# A mapping has the form "name=value". For example adding "class=itcl::class"
-# will allow you to use the command class in the itcl::class meaning.
-
-TCL_SUBST              = 
-
-# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
-# only. Doxygen will then generate output that is more tailored for C. For
-# instance, some of the names that are used will be different. The list of all
-# members will be omitted, etc.
-# The default value is: NO.
-
-OPTIMIZE_OUTPUT_FOR_C  = NO
-
-# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
-# Python sources only. Doxygen will then generate output that is more tailored
-# for that language. For instance, namespaces will be presented as packages,
-# qualified scopes will look different, etc.
-# The default value is: NO.
-
-OPTIMIZE_OUTPUT_JAVA   = NO
-
-# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
-# sources. Doxygen will then generate output that is tailored for Fortran.
-# The default value is: NO.
-
-OPTIMIZE_FOR_FORTRAN   = NO
-
-# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
-# sources. Doxygen will then generate output that is tailored for VHDL.
-# The default value is: NO.
-
-OPTIMIZE_OUTPUT_VHDL   = NO
-
-# Doxygen selects the parser to use depending on the extension of the files it
-# parses. With this tag you can assign which parser to use for a given
-# extension. Doxygen has a built-in mapping, but you can override or extend it
-# using this tag. The format is ext=language, where ext is a file extension, and
-# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
-# C#, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL. For instance to make
-# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
-# (default is Fortran), use: inc=Fortran f=C.
-#
-# Note For files without extension you can use no_extension as a placeholder.
-#
-# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
-# the files are not read by doxygen.
-
-EXTENSION_MAPPING      = 
-
-# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
-# according to the Markdown format, which allows for more readable
-# documentation. See http://daringfireball.net/projects/markdown/ for details.
-# The output of markdown processing is further processed by doxygen, so you can
-# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
-# case of backward compatibilities issues.
-# The default value is: YES.
-
-MARKDOWN_SUPPORT       = YES
-
-# When enabled doxygen tries to link words that correspond to documented
-# classes, or namespaces to their corresponding documentation. Such a link can
-# be prevented in individual cases by by putting a % sign in front of the word
-# or globally by setting AUTOLINK_SUPPORT to NO.
-# The default value is: YES.
-
-AUTOLINK_SUPPORT       = YES
-
-# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
-# to include (a tag file for) the STL sources as input, then you should set this
-# tag to YES in order to let doxygen match functions declarations and
-# definitions whose arguments contain STL classes (e.g. func(std::string);
-# versus func(std::string) {}). This also make the inheritance and collaboration
-# diagrams that involve STL classes more complete and accurate.
-# The default value is: NO.
-
-BUILTIN_STL_SUPPORT    = YES
-
-# If you use Microsoft's C++/CLI language, you should set this option to YES to
-# enable parsing support.
-# The default value is: NO.
-
-CPP_CLI_SUPPORT        = NO
-
-# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
-# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
-# will parse them like normal C++ but will assume all classes use public instead
-# of private inheritance when no explicit protection keyword is present.
-# The default value is: NO.
-
-SIP_SUPPORT            = NO
-
-# For Microsoft's IDL there are propget and propput attributes to indicate
-# getter and setter methods for a property. Setting this option to YES will make
-# doxygen to replace the get and set methods by a property in the documentation.
-# This will only work if the methods are indeed getting or setting a simple
-# type. If this is not the case, or you want to show the methods anyway, you
-# should set this option to NO.
-# The default value is: YES.
-
-IDL_PROPERTY_SUPPORT   = YES
-
-# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
-# tag is set to YES, then doxygen will reuse the documentation of the first
-# member in the group (if any) for the other members of the group. By default
-# all members of a group must be documented explicitly.
-# The default value is: NO.
-
-DISTRIBUTE_GROUP_DOC   = NO
-
-# Set the SUBGROUPING tag to YES to allow class member groups of the same type
-# (for instance a group of public functions) to be put as a subgroup of that
-# type (e.g. under the Public Functions section). Set it to NO to prevent
-# subgrouping. Alternatively, this can be done per class using the
-# \nosubgrouping command.
-# The default value is: YES.
-
-SUBGROUPING            = YES
-
-# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
-# are shown inside the group in which they are included (e.g. using \ingroup)
-# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
-# and RTF).
-#
-# Note that this feature does not work in combination with
-# SEPARATE_MEMBER_PAGES.
-# The default value is: NO.
-
-INLINE_GROUPED_CLASSES = NO
-
-# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
-# with only public data fields or simple typedef fields will be shown inline in
-# the documentation of the scope in which they are defined (i.e. file,
-# namespace, or group documentation), provided this scope is documented. If set
-# to NO, structs, classes, and unions are shown on a separate page (for HTML and
-# Man pages) or section (for LaTeX and RTF).
-# The default value is: NO.
-
-INLINE_SIMPLE_STRUCTS  = YES
-
-# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
-# enum is documented as struct, union, or enum with the name of the typedef. So
-# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
-# with name TypeT. When disabled the typedef will appear as a member of a file,
-# namespace, or class. And the struct will be named TypeS. This can typically be
-# useful for C code in case the coding convention dictates that all compound
-# types are typedef'ed and only the typedef is referenced, never the tag name.
-# The default value is: NO.
-
-TYPEDEF_HIDES_STRUCT   = YES
-
-# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
-# cache is used to resolve symbols given their name and scope. Since this can be
-# an expensive process and often the same symbol appears multiple times in the
-# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
-# doxygen will become slower. If the cache is too large, memory is wasted. The
-# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
-# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
-# symbols. At the end of a run doxygen will report the cache usage and suggest
-# the optimal cache size from a speed point of view.
-# Minimum value: 0, maximum value: 9, default value: 0.
-
-LOOKUP_CACHE_SIZE      = 0
-
-#---------------------------------------------------------------------------
-# Build related configuration options
-#---------------------------------------------------------------------------
-
-# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
-# documentation are documented, even if no documentation was available. Private
-# class members and static file members will be hidden unless the
-# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
-# Note: This will also disable the warnings about undocumented members that are
-# normally produced when WARNINGS is set to YES.
-# The default value is: NO.
-
-EXTRACT_ALL            = NO
-
-# If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
-# be included in the documentation.
-# The default value is: NO.
-
-EXTRACT_PRIVATE        = NO
-
-# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
-# scope will be included in the documentation.
-# The default value is: NO.
-
-EXTRACT_PACKAGE        = YES
-
-# If the EXTRACT_STATIC tag is set to YES all static members of a file will be
-# included in the documentation.
-# The default value is: NO.
-
-EXTRACT_STATIC         = YES
-
-# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
-# locally in source files will be included in the documentation. If set to NO
-# only classes defined in header files are included. Does not have any effect
-# for Java sources.
-# The default value is: YES.
-
-EXTRACT_LOCAL_CLASSES  = YES
-
-# This flag is only useful for Objective-C code. When set to YES local methods,
-# which are defined in the implementation section but not in the interface are
-# included in the documentation. If set to NO only methods in the interface are
-# included.
-# The default value is: NO.
-
-EXTRACT_LOCAL_METHODS  = NO
-
-# If this flag is set to YES, the members of anonymous namespaces will be
-# extracted and appear in the documentation as a namespace called
-# 'anonymous_namespace{file}', where file will be replaced with the base name of
-# the file that contains the anonymous namespace. By default anonymous namespace
-# are hidden.
-# The default value is: NO.
-
-EXTRACT_ANON_NSPACES   = NO
-
-# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
-# undocumented members inside documented classes or files. If set to NO these
-# members will be included in the various overviews, but no documentation
-# section is generated. This option has no effect if EXTRACT_ALL is enabled.
-# The default value is: NO.
-
-HIDE_UNDOC_MEMBERS     = NO
-
-# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
-# undocumented classes that are normally visible in the class hierarchy. If set
-# to NO these classes will be included in the various overviews. This option has
-# no effect if EXTRACT_ALL is enabled.
-# The default value is: NO.
-
-HIDE_UNDOC_CLASSES     = NO
-
-# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
-# (class|struct|union) declarations. If set to NO these declarations will be
-# included in the documentation.
-# The default value is: NO.
-
-HIDE_FRIEND_COMPOUNDS  = NO
-
-# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
-# documentation blocks found inside the body of a function. If set to NO these
-# blocks will be appended to the function's detailed documentation block.
-# The default value is: NO.
-
-HIDE_IN_BODY_DOCS      = NO
-
-# The INTERNAL_DOCS tag determines if documentation that is typed after a
-# \internal command is included. If the tag is set to NO then the documentation
-# will be excluded. Set it to YES to include the internal documentation.
-# The default value is: NO.
-
-INTERNAL_DOCS          = NO
-
-# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
-# names in lower-case letters. If set to YES upper-case letters are also
-# allowed. This is useful if you have classes or files whose names only differ
-# in case and if your file system supports case sensitive file names. Windows
-# and Mac users are advised to set this option to NO.
-# The default value is: system dependent.
-
-CASE_SENSE_NAMES       = NO
-
-# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
-# their full class and namespace scopes in the documentation. If set to YES the
-# scope will be hidden.
-# The default value is: NO.
-
-HIDE_SCOPE_NAMES       = NO
-
-# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
-# the files that are included by a file in the documentation of that file.
-# The default value is: YES.
-
-SHOW_INCLUDE_FILES     = YES
-
-# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
-# grouped member an include statement to the documentation, telling the reader
-# which file to include in order to use the member.
-# The default value is: NO.
-
-SHOW_GROUPED_MEMB_INC  = NO
-
-# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
-# files with double quotes in the documentation rather than with sharp brackets.
-# The default value is: NO.
-
-FORCE_LOCAL_INCLUDES   = NO
-
-# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
-# documentation for inline members.
-# The default value is: YES.
-
-INLINE_INFO            = YES
-
-# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
-# (detailed) documentation of file and class members alphabetically by member
-# name. If set to NO the members will appear in declaration order.
-# The default value is: YES.
-
-SORT_MEMBER_DOCS       = YES
-
-# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
-# descriptions of file, namespace and class members alphabetically by member
-# name. If set to NO the members will appear in declaration order. Note that
-# this will also influence the order of the classes in the class list.
-# The default value is: NO.
-
-SORT_BRIEF_DOCS        = NO
-
-# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
-# (brief and detailed) documentation of class members so that constructors and
-# destructors are listed first. If set to NO the constructors will appear in the
-# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
-# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
-# member documentation.
-# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
-# detailed member documentation.
-# The default value is: NO.
-
-SORT_MEMBERS_CTORS_1ST = YES
-
-# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
-# of group names into alphabetical order. If set to NO the group names will
-# appear in their defined order.
-# The default value is: NO.
-
-SORT_GROUP_NAMES       = NO
-
-# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
-# fully-qualified names, including namespaces. If set to NO, the class list will
-# be sorted only by class name, not including the namespace part.
-# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
-# Note: This option applies only to the class list, not to the alphabetical
-# list.
-# The default value is: NO.
-
-SORT_BY_SCOPE_NAME     = NO
-
-# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
-# type resolution of all parameters of a function it will reject a match between
-# the prototype and the implementation of a member function even if there is
-# only one candidate or it is obvious which candidate to choose by doing a
-# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
-# accept a match between prototype and implementation in such cases.
-# The default value is: NO.
-
-STRICT_PROTO_MATCHING  = NO
-
-# The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
-# todo list. This list is created by putting \todo commands in the
-# documentation.
-# The default value is: YES.
-
-GENERATE_TODOLIST      = YES
-
-# The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
-# test list. This list is created by putting \test commands in the
-# documentation.
-# The default value is: YES.
-
-GENERATE_TESTLIST      = YES
-
-# The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
-# list. This list is created by putting \bug commands in the documentation.
-# The default value is: YES.
-
-GENERATE_BUGLIST       = YES
-
-# The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
-# the deprecated list. This list is created by putting \deprecated commands in
-# the documentation.
-# The default value is: YES.
-
-GENERATE_DEPRECATEDLIST= YES
-
-# The ENABLED_SECTIONS tag can be used to enable conditional documentation
-# sections, marked by \if <section_label> ... \endif and \cond <section_label>
-# ... \endcond blocks.
-
-ENABLED_SECTIONS       = 
-
-# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
-# initial value of a variable or macro / define can have for it to appear in the
-# documentation. If the initializer consists of more lines than specified here
-# it will be hidden. Use a value of 0 to hide initializers completely. The
-# appearance of the value of individual variables and macros / defines can be
-# controlled using \showinitializer or \hideinitializer command in the
-# documentation regardless of this setting.
-# Minimum value: 0, maximum value: 10000, default value: 30.
-
-MAX_INITIALIZER_LINES  = 0
-
-# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
-# the bottom of the documentation of classes and structs. If set to YES the list
-# will mention the files that were used to generate the documentation.
-# The default value is: YES.
-
-SHOW_USED_FILES        = NO
-
-# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
-# will remove the Files entry from the Quick Index and from the Folder Tree View
-# (if specified).
-# The default value is: YES.
-
-SHOW_FILES             = NO
-
-# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
-# page. This will remove the Namespaces entry from the Quick Index and from the
-# Folder Tree View (if specified).
-# The default value is: YES.
-
-SHOW_NAMESPACES        = YES
-
-# The FILE_VERSION_FILTER tag can be used to specify a program or script that
-# doxygen should invoke to get the current version for each file (typically from
-# the version control system). Doxygen will invoke the program by executing (via
-# popen()) the command command input-file, where command is the value of the
-# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
-# by doxygen. Whatever the program writes to standard output is used as the file
-# version. For an example see the documentation.
-
-FILE_VERSION_FILTER    = 
-
-# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
-# by doxygen. The layout file controls the global structure of the generated
-# output files in an output format independent way. To create the layout file
-# that represents doxygen's defaults, run doxygen with the -l option. You can
-# optionally specify a file name after the option, if omitted DoxygenLayout.xml
-# will be used as the name of the layout file.
-#
-# Note that if you run doxygen from a directory containing a file called
-# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
-# tag is left empty.
-
-LAYOUT_FILE            = DoxygenLayout.xml
-
-# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
-# the reference definitions. This must be a list of .bib files. The .bib
-# extension is automatically appended if omitted. This requires the bibtex tool
-# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
-# For LaTeX the style of the bibliography can be controlled using
-# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
-# search path. Do not use file names with spaces, bibtex cannot handle them. See
-# also \cite for info how to create references.
-
-CITE_BIB_FILES         = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to warning and progress messages
-#---------------------------------------------------------------------------
-
-# The QUIET tag can be used to turn on/off the messages that are generated to
-# standard output by doxygen. If QUIET is set to YES this implies that the
-# messages are off.
-# The default value is: NO.
-
-QUIET                  = NO
-
-# The WARNINGS tag can be used to turn on/off the warning messages that are
-# generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
-# this implies that the warnings are on.
-#
-# Tip: Turn warnings on while writing the documentation.
-# The default value is: YES.
-
-WARNINGS               = YES
-
-# If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
-# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
-# will automatically be disabled.
-# The default value is: YES.
-
-WARN_IF_UNDOCUMENTED   = YES
-
-# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
-# potential errors in the documentation, such as not documenting some parameters
-# in a documented function, or documenting parameters that don't exist or using
-# markup commands wrongly.
-# The default value is: YES.
-
-WARN_IF_DOC_ERROR      = YES
-
-# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
-# are documented, but have no documentation for their parameters or return
-# value. If set to NO doxygen will only warn about wrong or incomplete parameter
-# documentation, but not about the absence of documentation.
-# The default value is: NO.
-
-WARN_NO_PARAMDOC       = NO
-
-# The WARN_FORMAT tag determines the format of the warning messages that doxygen
-# can produce. The string should contain the $file, $line, and $text tags, which
-# will be replaced by the file and line number from which the warning originated
-# and the warning text. Optionally the format may contain $version, which will
-# be replaced by the version of the file (if it could be obtained via
-# FILE_VERSION_FILTER)
-# The default value is: $file:$line: $text.
-
-WARN_FORMAT            = "$file:$line: $text"
-
-# The WARN_LOGFILE tag can be used to specify a file to which warning and error
-# messages should be written. If left blank the output is written to standard
-# error (stderr).
-
-WARN_LOGFILE           = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the input files
-#---------------------------------------------------------------------------
-
-# The INPUT tag is used to specify the files and/or directories that contain
-# documented source files. You may enter file names like myfile.cpp or
-# directories like /usr/src/myproject. Separate the files or directories with
-# spaces.
-# Note: If this tag is empty the current directory is searched.
-
-INPUT                  = README.md \
-                         pyOCD
-
-# This tag can be used to specify the character encoding of the source files
-# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
-# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
-# documentation (see: http://www.gnu.org/software/libiconv) for the list of
-# possible encodings.
-# The default value is: UTF-8.
-
-INPUT_ENCODING         = UTF-8
-
-# If the value of the INPUT tag contains directories, you can use the
-# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
-# *.h) to filter out the source-files in the directories. If left blank the
-# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
-# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
-# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
-# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
-# *.qsf, *.as and *.js.
-
-FILE_PATTERNS          = *.c \
-                         *.cc \
-                         *.cxx \
-                         *.cpp \
-                         *.c++ \
-                         *.java \
-                         *.ii \
-                         *.ixx \
-                         *.ipp \
-                         *.i++ \
-                         *.inl \
-                         *.idl \
-                         *.ddl \
-                         *.odl \
-                         *.h \
-                         *.hh \
-                         *.hxx \
-                         *.hpp \
-                         *.h++ \
-                         *.cs \
-                         *.d \
-                         *.php \
-                         *.php4 \
-                         *.php5 \
-                         *.phtml \
-                         *.inc \
-                         *.m \
-                         *.markdown \
-                         *.md \
-                         *.mm \
-                         *.dox \
-                         *.py \
-                         *.f90 \
-                         *.f \
-                         *.for \
-                         *.tcl \
-                         *.vhd \
-                         *.vhdl \
-                         *.ucf \
-                         *.qsf \
-                         *.as \
-                         *.js
-
-# The RECURSIVE tag can be used to specify whether or not subdirectories should
-# be searched for input files as well.
-# The default value is: NO.
-
-RECURSIVE              = YES
-
-# The EXCLUDE tag can be used to specify files and/or directories that should be
-# excluded from the INPUT source files. This way you can easily exclude a
-# subdirectory from a directory tree whose root is specified with the INPUT tag.
-#
-# Note that relative paths are relative to the directory from which doxygen is
-# run.
-
-EXCLUDE                = 
-
-# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
-# directories that are symbolic links (a Unix file system feature) are excluded
-# from the input.
-# The default value is: NO.
-
-EXCLUDE_SYMLINKS       = NO
-
-# If the value of the INPUT tag contains directories, you can use the
-# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
-# certain files from those directories.
-#
-# Note that the wildcards are matched against the file with absolute path, so to
-# exclude all test directories for example use the pattern */test/*
-
-EXCLUDE_PATTERNS       = 
-
-# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
-# (namespaces, classes, functions, etc.) that should be excluded from the
-# output. The symbol name can be a fully qualified name, a word, or if the
-# wildcard * is used, a substring. Examples: ANamespace, AClass,
-# AClass::ANamespace, ANamespace::*Test
-#
-# Note that the wildcards are matched against the file with absolute path, so to
-# exclude all test directories use the pattern */test/*
-
-EXCLUDE_SYMBOLS        = 
-
-# The EXAMPLE_PATH tag can be used to specify one or more files or directories
-# that contain example code fragments that are included (see the \include
-# command).
-
-EXAMPLE_PATH           = 
-
-# If the value of the EXAMPLE_PATH tag contains directories, you can use the
-# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
-# *.h) to filter out the source-files in the directories. If left blank all
-# files are included.
-
-EXAMPLE_PATTERNS       = *
-
-# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
-# searched for input files to be used with the \include or \dontinclude commands
-# irrespective of the value of the RECURSIVE tag.
-# The default value is: NO.
-
-EXAMPLE_RECURSIVE      = NO
-
-# The IMAGE_PATH tag can be used to specify one or more files or directories
-# that contain images that are to be included in the documentation (see the
-# \image command).
-
-IMAGE_PATH             = 
-
-# The INPUT_FILTER tag can be used to specify a program that doxygen should
-# invoke to filter for each input file. Doxygen will invoke the filter program
-# by executing (via popen()) the command:
-#
-# <filter> <input-file>
-#
-# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
-# name of an input file. Doxygen will then use the output that the filter
-# program writes to standard output. If FILTER_PATTERNS is specified, this tag
-# will be ignored.
-#
-# Note that the filter must not add or remove lines; it is applied before the
-# code is scanned, but not when the output code is generated. If lines are added
-# or removed, the anchors will not be placed correctly.
-
-INPUT_FILTER           = 
-
-# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
-# basis. Doxygen will compare the file name with each pattern and apply the
-# filter if there is a match. The filters are a list of the form: pattern=filter
-# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
-# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
-# patterns match the file name, INPUT_FILTER is applied.
-
-FILTER_PATTERNS        = 
-
-# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
-# INPUT_FILTER ) will also be used to filter the input files that are used for
-# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
-# The default value is: NO.
-
-FILTER_SOURCE_FILES    = NO
-
-# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
-# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
-# it is also possible to disable source filtering for a specific pattern using
-# *.ext= (so without naming a filter).
-# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
-
-FILTER_SOURCE_PATTERNS = 
-
-# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
-# is part of the input, its contents will be placed on the main page
-# (index.html). This can be useful if you have a project on for instance GitHub
-# and want to reuse the introduction page also for the doxygen output.
-
-USE_MDFILE_AS_MAINPAGE = README.md
-
-#---------------------------------------------------------------------------
-# Configuration options related to source browsing
-#---------------------------------------------------------------------------
-
-# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
-# generated. Documented entities will be cross-referenced with these sources.
-#
-# Note: To get rid of all source code in the generated output, make sure that
-# also VERBATIM_HEADERS is set to NO.
-# The default value is: NO.
-
-SOURCE_BROWSER         = NO
-
-# Setting the INLINE_SOURCES tag to YES will include the body of functions,
-# classes and enums directly into the documentation.
-# The default value is: NO.
-
-INLINE_SOURCES         = NO
-
-# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
-# special comment blocks from generated source code fragments. Normal C, C++ and
-# Fortran comments will always remain visible.
-# The default value is: YES.
-
-STRIP_CODE_COMMENTS    = YES
-
-# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
-# function all documented functions referencing it will be listed.
-# The default value is: NO.
-
-REFERENCED_BY_RELATION = NO
-
-# If the REFERENCES_RELATION tag is set to YES then for each documented function
-# all documented entities called/used by that function will be listed.
-# The default value is: NO.
-
-REFERENCES_RELATION    = NO
-
-# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
-# to YES, then the hyperlinks from functions in REFERENCES_RELATION and
-# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
-# link to the documentation.
-# The default value is: YES.
-
-REFERENCES_LINK_SOURCE = YES
-
-# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
-# source code will show a tooltip with additional information such as prototype,
-# brief description and links to the definition and documentation. Since this
-# will make the HTML file larger and loading of large files a bit slower, you
-# can opt to disable this feature.
-# The default value is: YES.
-# This tag requires that the tag SOURCE_BROWSER is set to YES.
-
-SOURCE_TOOLTIPS        = YES
-
-# If the USE_HTAGS tag is set to YES then the references to source code will
-# point to the HTML generated by the htags(1) tool instead of doxygen built-in
-# source browser. The htags tool is part of GNU's global source tagging system
-# (see http://www.gnu.org/software/global/global.html). You will need version
-# 4.8.6 or higher.
-#
-# To use it do the following:
-# - Install the latest version of global
-# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
-# - Make sure the INPUT points to the root of the source tree
-# - Run doxygen as normal
-#
-# Doxygen will invoke htags (and that will in turn invoke gtags), so these
-# tools must be available from the command line (i.e. in the search path).
-#
-# The result: instead of the source browser generated by doxygen, the links to
-# source code will now point to the output of htags.
-# The default value is: NO.
-# This tag requires that the tag SOURCE_BROWSER is set to YES.
-
-USE_HTAGS              = NO
-
-# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
-# verbatim copy of the header file for each class for which an include is
-# specified. Set to NO to disable this.
-# See also: Section \class.
-# The default value is: YES.
-
-VERBATIM_HEADERS       = YES
-
-# If the CLANG_ASSISTED_PARSING tag is set to YES, then doxygen will use the
-# clang parser (see: http://clang.llvm.org/) for more acurate parsing at the
-# cost of reduced performance. This can be particularly helpful with template
-# rich C++ code for which doxygen's built-in parser lacks the necessary type
-# information.
-# Note: The availability of this option depends on whether or not doxygen was
-# compiled with the --with-libclang option.
-# The default value is: NO.
-
-CLANG_ASSISTED_PARSING = NO
-
-# If clang assisted parsing is enabled you can provide the compiler with command
-# line options that you would normally use when invoking the compiler. Note that
-# the include paths will already be set by doxygen for the files and directories
-# specified with INPUT and INCLUDE_PATH.
-# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
-
-CLANG_OPTIONS          = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the alphabetical class index
-#---------------------------------------------------------------------------
-
-# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
-# compounds will be generated. Enable this if the project contains a lot of
-# classes, structs, unions or interfaces.
-# The default value is: YES.
-
-ALPHABETICAL_INDEX     = YES
-
-# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
-# which the alphabetical index list will be split.
-# Minimum value: 1, maximum value: 20, default value: 5.
-# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
-
-COLS_IN_ALPHA_INDEX    = 5
-
-# In case all classes in a project start with a common prefix, all classes will
-# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
-# can be used to specify a prefix (or a list of prefixes) that should be ignored
-# while generating the index headers.
-# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
-
-IGNORE_PREFIX          = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the HTML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
-# The default value is: YES.
-
-GENERATE_HTML          = YES
-
-# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
-# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
-# it.
-# The default directory is: html.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_OUTPUT            = html
-
-# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
-# generated HTML page (for example: .htm, .php, .asp).
-# The default value is: .html.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_FILE_EXTENSION    = .html
-
-# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
-# each generated HTML page. If the tag is left blank doxygen will generate a
-# standard header.
-#
-# To get valid HTML the header file that includes any scripts and style sheets
-# that doxygen needs, which is dependent on the configuration options used (e.g.
-# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
-# default header using
-# doxygen -w html new_header.html new_footer.html new_stylesheet.css
-# YourConfigFile
-# and then modify the file new_header.html. See also section "Doxygen usage"
-# for information on how to generate the default header that doxygen normally
-# uses.
-# Note: The header is subject to change so you typically have to regenerate the
-# default header when upgrading to a newer version of doxygen. For a description
-# of the possible markers and block names see the documentation.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_HEADER            = 
-
-# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
-# generated HTML page. If the tag is left blank doxygen will generate a standard
-# footer. See HTML_HEADER for more information on how to generate a default
-# footer and what special commands can be used inside the footer. See also
-# section "Doxygen usage" for information on how to generate the default footer
-# that doxygen normally uses.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_FOOTER            = 
-
-# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
-# sheet that is used by each HTML page. It can be used to fine-tune the look of
-# the HTML output. If left blank doxygen will generate a default style sheet.
-# See also section "Doxygen usage" for information on how to generate the style
-# sheet that doxygen normally uses.
-# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
-# it is more robust and this tag (HTML_STYLESHEET) will in the future become
-# obsolete.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_STYLESHEET        = 
-
-# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional user-
-# defined cascading style sheet that is included after the standard style sheets
-# created by doxygen. Using this option one can overrule certain style aspects.
-# This is preferred over using HTML_STYLESHEET since it does not replace the
-# standard style sheet and is therefor more robust against future updates.
-# Doxygen will copy the style sheet file to the output directory. For an example
-# see the documentation.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_EXTRA_STYLESHEET  = 
-
-# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
-# other source files which should be copied to the HTML output directory. Note
-# that these files will be copied to the base HTML output directory. Use the
-# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
-# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
-# files will be copied as-is; there are no commands or markers available.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_EXTRA_FILES       = 
-
-# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
-# will adjust the colors in the stylesheet and background images according to
-# this color. Hue is specified as an angle on a colorwheel, see
-# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
-# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
-# purple, and 360 is red again.
-# Minimum value: 0, maximum value: 359, default value: 220.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_COLORSTYLE_HUE    = 220
-
-# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
-# in the HTML output. For a value of 0 the output will use grayscales only. A
-# value of 255 will produce the most vivid colors.
-# Minimum value: 0, maximum value: 255, default value: 100.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_COLORSTYLE_SAT    = 100
-
-# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
-# luminance component of the colors in the HTML output. Values below 100
-# gradually make the output lighter, whereas values above 100 make the output
-# darker. The value divided by 100 is the actual gamma applied, so 80 represents
-# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
-# change the gamma.
-# Minimum value: 40, maximum value: 240, default value: 80.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_COLORSTYLE_GAMMA  = 80
-
-# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
-# page will contain the date and time when the page was generated. Setting this
-# to NO can help when comparing the output of multiple runs.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_TIMESTAMP         = YES
-
-# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
-# documentation will contain sections that can be hidden and shown after the
-# page has loaded.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_DYNAMIC_SECTIONS  = YES
-
-# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
-# shown in the various tree structured indices initially; the user can expand
-# and collapse entries dynamically later on. Doxygen will expand the tree to
-# such a level that at most the specified number of entries are visible (unless
-# a fully collapsed tree already exceeds this amount). So setting the number of
-# entries 1 will produce a full collapsed tree by default. 0 is a special value
-# representing an infinite number of entries and will result in a full expanded
-# tree by default.
-# Minimum value: 0, maximum value: 9999, default value: 100.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-HTML_INDEX_NUM_ENTRIES = 100
-
-# If the GENERATE_DOCSET tag is set to YES, additional index files will be
-# generated that can be used as input for Apple's Xcode 3 integrated development
-# environment (see: http://developer.apple.com/tools/xcode/), introduced with
-# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
-# Makefile in the HTML output directory. Running make will produce the docset in
-# that directory and running make install will install the docset in
-# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
-# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
-# for more information.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-GENERATE_DOCSET        = NO
-
-# This tag determines the name of the docset feed. A documentation feed provides
-# an umbrella under which multiple documentation sets from a single provider
-# (such as a company or product suite) can be grouped.
-# The default value is: Doxygen generated docs.
-# This tag requires that the tag GENERATE_DOCSET is set to YES.
-
-DOCSET_FEEDNAME        = "Doxygen generated docs"
-
-# This tag specifies a string that should uniquely identify the documentation
-# set bundle. This should be a reverse domain-name style string, e.g.
-# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
-# The default value is: org.doxygen.Project.
-# This tag requires that the tag GENERATE_DOCSET is set to YES.
-
-DOCSET_BUNDLE_ID       = org.doxygen.Project
-
-# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
-# the documentation publisher. This should be a reverse domain-name style
-# string, e.g. com.mycompany.MyDocSet.documentation.
-# The default value is: org.doxygen.Publisher.
-# This tag requires that the tag GENERATE_DOCSET is set to YES.
-
-DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
-
-# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
-# The default value is: Publisher.
-# This tag requires that the tag GENERATE_DOCSET is set to YES.
-
-DOCSET_PUBLISHER_NAME  = Publisher
-
-# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
-# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
-# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
-# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
-# Windows.
-#
-# The HTML Help Workshop contains a compiler that can convert all HTML output
-# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
-# files are now used as the Windows 98 help format, and will replace the old
-# Windows help format (.hlp) on all Windows platforms in the future. Compressed
-# HTML files also contain an index, a table of contents, and you can search for
-# words in the documentation. The HTML workshop also contains a viewer for
-# compressed HTML files.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-GENERATE_HTMLHELP      = NO
-
-# The CHM_FILE tag can be used to specify the file name of the resulting .chm
-# file. You can add a path in front of the file if the result should not be
-# written to the html output directory.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-CHM_FILE               = 
-
-# The HHC_LOCATION tag can be used to specify the location (absolute path
-# including file name) of the HTML help compiler ( hhc.exe). If non-empty
-# doxygen will try to run the HTML help compiler on the generated index.hhp.
-# The file has to be specified with full path.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-HHC_LOCATION           = 
-
-# The GENERATE_CHI flag controls if a separate .chi index file is generated (
-# YES) or that it should be included in the master .chm file ( NO).
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-GENERATE_CHI           = NO
-
-# The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
-# and project file content.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-CHM_INDEX_ENCODING     = 
-
-# The BINARY_TOC flag controls whether a binary table of contents is generated (
-# YES) or a normal table of contents ( NO) in the .chm file.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-BINARY_TOC             = NO
-
-# The TOC_EXPAND flag can be set to YES to add extra items for group members to
-# the table of contents of the HTML help documentation and to the tree view.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
-
-TOC_EXPAND             = NO
-
-# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
-# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
-# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
-# (.qch) of the generated HTML documentation.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-GENERATE_QHP           = NO
-
-# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
-# the file name of the resulting .qch file. The path specified is relative to
-# the HTML output folder.
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QCH_FILE               = 
-
-# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
-# Project output. For more information please see Qt Help Project / Namespace
-# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
-# The default value is: org.doxygen.Project.
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHP_NAMESPACE          = org.doxygen.Project
-
-# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
-# Help Project output. For more information please see Qt Help Project / Virtual
-# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
-# folders).
-# The default value is: doc.
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHP_VIRTUAL_FOLDER     = doc
-
-# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
-# filter to add. For more information please see Qt Help Project / Custom
-# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
-# filters).
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHP_CUST_FILTER_NAME   = 
-
-# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
-# custom filter to add. For more information please see Qt Help Project / Custom
-# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
-# filters).
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHP_CUST_FILTER_ATTRS  = 
-
-# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
-# project's filter section matches. Qt Help Project / Filter Attributes (see:
-# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHP_SECT_FILTER_ATTRS  = 
-
-# The QHG_LOCATION tag can be used to specify the location of Qt's
-# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
-# generated .qhp file.
-# This tag requires that the tag GENERATE_QHP is set to YES.
-
-QHG_LOCATION           = 
-
-# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
-# generated, together with the HTML files, they form an Eclipse help plugin. To
-# install this plugin and make it available under the help contents menu in
-# Eclipse, the contents of the directory containing the HTML and XML files needs
-# to be copied into the plugins directory of eclipse. The name of the directory
-# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
-# After copying Eclipse needs to be restarted before the help appears.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-GENERATE_ECLIPSEHELP   = NO
-
-# A unique identifier for the Eclipse help plugin. When installing the plugin
-# the directory name containing the HTML and XML files should also have this
-# name. Each documentation set should have its own identifier.
-# The default value is: org.doxygen.Project.
-# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
-
-ECLIPSE_DOC_ID         = org.doxygen.Project
-
-# If you want full control over the layout of the generated HTML pages it might
-# be necessary to disable the index and replace it with your own. The
-# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
-# of each HTML page. A value of NO enables the index and the value YES disables
-# it. Since the tabs in the index contain the same information as the navigation
-# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-DISABLE_INDEX          = NO
-
-# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
-# structure should be generated to display hierarchical information. If the tag
-# value is set to YES, a side panel will be generated containing a tree-like
-# index structure (just like the one that is generated for HTML Help). For this
-# to work a browser that supports JavaScript, DHTML, CSS and frames is required
-# (i.e. any modern browser). Windows users are probably better off using the
-# HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
-# further fine-tune the look of the index. As an example, the default style
-# sheet generated by doxygen has an example that shows how to put an image at
-# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
-# the same information as the tab index, you could consider setting
-# DISABLE_INDEX to YES when enabling this option.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-GENERATE_TREEVIEW      = YES
-
-# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
-# doxygen will group on one line in the generated HTML documentation.
-#
-# Note that a value of 0 will completely suppress the enum values from appearing
-# in the overview section.
-# Minimum value: 0, maximum value: 20, default value: 4.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-ENUM_VALUES_PER_LINE   = 1
-
-# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
-# to set the initial width (in pixels) of the frame in which the tree is shown.
-# Minimum value: 0, maximum value: 1500, default value: 250.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-TREEVIEW_WIDTH         = 250
-
-# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
-# external symbols imported via tag files in a separate window.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-EXT_LINKS_IN_WINDOW    = NO
-
-# Use this tag to change the font size of LaTeX formulas included as images in
-# the HTML documentation. When you change the font size after a successful
-# doxygen run you need to manually remove any form_*.png images from the HTML
-# output directory to force them to be regenerated.
-# Minimum value: 8, maximum value: 50, default value: 10.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-FORMULA_FONTSIZE       = 10
-
-# Use the FORMULA_TRANPARENT tag to determine whether or not the images
-# generated for formulas are transparent PNGs. Transparent PNGs are not
-# supported properly for IE 6.0, but are supported on all modern browsers.
-#
-# Note that when changing this option you need to delete any form_*.png files in
-# the HTML output directory before the changes have effect.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-FORMULA_TRANSPARENT    = YES
-
-# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
-# http://www.mathjax.org) which uses client side Javascript for the rendering
-# instead of using prerendered bitmaps. Use this if you do not have LaTeX
-# installed or if you want to formulas look prettier in the HTML output. When
-# enabled you may also need to install MathJax separately and configure the path
-# to it using the MATHJAX_RELPATH option.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-USE_MATHJAX            = NO
-
-# When MathJax is enabled you can set the default output format to be used for
-# the MathJax output. See the MathJax site (see:
-# http://docs.mathjax.org/en/latest/output.html) for more details.
-# Possible values are: HTML-CSS (which is slower, but has the best
-# compatibility), NativeMML (i.e. MathML) and SVG.
-# The default value is: HTML-CSS.
-# This tag requires that the tag USE_MATHJAX is set to YES.
-
-MATHJAX_FORMAT         = HTML-CSS
-
-# When MathJax is enabled you need to specify the location relative to the HTML
-# output directory using the MATHJAX_RELPATH option. The destination directory
-# should contain the MathJax.js script. For instance, if the mathjax directory
-# is located at the same level as the HTML output directory, then
-# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
-# Content Delivery Network so you can quickly see the result without installing
-# MathJax. However, it is strongly recommended to install a local copy of
-# MathJax from http://www.mathjax.org before deployment.
-# The default value is: http://cdn.mathjax.org/mathjax/latest.
-# This tag requires that the tag USE_MATHJAX is set to YES.
-
-MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
-
-# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
-# extension names that should be enabled during MathJax rendering. For example
-# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
-# This tag requires that the tag USE_MATHJAX is set to YES.
-
-MATHJAX_EXTENSIONS     = 
-
-# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
-# of code that will be used on startup of the MathJax code. See the MathJax site
-# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
-# example see the documentation.
-# This tag requires that the tag USE_MATHJAX is set to YES.
-
-MATHJAX_CODEFILE       = 
-
-# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
-# the HTML output. The underlying search engine uses javascript and DHTML and
-# should work on any modern browser. Note that when using HTML help
-# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
-# there is already a search function so this one should typically be disabled.
-# For large projects the javascript based search engine can be slow, then
-# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
-# search using the keyboard; to jump to the search box use <access key> + S
-# (what the <access key> is depends on the OS and browser, but it is typically
-# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
-# key> to jump into the search results window, the results can be navigated
-# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
-# the search. The filter options can be selected when the cursor is inside the
-# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
-# to select a filter and <Enter> or <escape> to activate or cancel the filter
-# option.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_HTML is set to YES.
-
-SEARCHENGINE           = YES
-
-# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
-# implemented using a web server instead of a web client using Javascript. There
-# are two flavours of web server based searching depending on the
-# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
-# searching and an index file used by the script. When EXTERNAL_SEARCH is
-# enabled the indexing and searching needs to be provided by external tools. See
-# the section "External Indexing and Searching" for details.
-# The default value is: NO.
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-SERVER_BASED_SEARCH    = NO
-
-# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
-# script for searching. Instead the search results are written to an XML file
-# which needs to be processed by an external indexer. Doxygen will invoke an
-# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
-# search results.
-#
-# Doxygen ships with an example indexer ( doxyindexer) and search engine
-# (doxysearch.cgi) which are based on the open source search engine library
-# Xapian (see: http://xapian.org/).
-#
-# See the section "External Indexing and Searching" for details.
-# The default value is: NO.
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-EXTERNAL_SEARCH        = NO
-
-# The SEARCHENGINE_URL should point to a search engine hosted by a web server
-# which will return the search results when EXTERNAL_SEARCH is enabled.
-#
-# Doxygen ships with an example indexer ( doxyindexer) and search engine
-# (doxysearch.cgi) which are based on the open source search engine library
-# Xapian (see: http://xapian.org/). See the section "External Indexing and
-# Searching" for details.
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-SEARCHENGINE_URL       = 
-
-# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
-# search data is written to a file for indexing by an external tool. With the
-# SEARCHDATA_FILE tag the name of this file can be specified.
-# The default file is: searchdata.xml.
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-SEARCHDATA_FILE        = searchdata.xml
-
-# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
-# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
-# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
-# projects and redirect the results back to the right project.
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-EXTERNAL_SEARCH_ID     = 
-
-# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
-# projects other than the one defined by this configuration file, but that are
-# all added to the same external search index. Each project needs to have a
-# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
-# to a relative location where the documentation can be found. The format is:
-# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
-# This tag requires that the tag SEARCHENGINE is set to YES.
-
-EXTRA_SEARCH_MAPPINGS  = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the LaTeX output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
-# The default value is: YES.
-
-GENERATE_LATEX         = NO
-
-# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
-# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
-# it.
-# The default directory is: latex.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_OUTPUT           = latex
-
-# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
-# invoked.
-#
-# Note that when enabling USE_PDFLATEX this option is only used for generating
-# bitmaps for formulas in the HTML output, but not in the Makefile that is
-# written to the output directory.
-# The default file is: latex.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_CMD_NAME         = latex
-
-# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
-# index for LaTeX.
-# The default file is: makeindex.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-MAKEINDEX_CMD_NAME     = makeindex
-
-# If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
-# documents. This may be useful for small projects and may help to save some
-# trees in general.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-COMPACT_LATEX          = NO
-
-# The PAPER_TYPE tag can be used to set the paper type that is used by the
-# printer.
-# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
-# 14 inches) and executive (7.25 x 10.5 inches).
-# The default value is: a4.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-PAPER_TYPE             = a4
-
-# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
-# that should be included in the LaTeX output. To get the times font for
-# instance you can specify
-# EXTRA_PACKAGES=times
-# If left blank no extra packages will be included.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-EXTRA_PACKAGES         = 
-
-# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
-# generated LaTeX document. The header should contain everything until the first
-# chapter. If it is left blank doxygen will generate a standard header. See
-# section "Doxygen usage" for information on how to let doxygen write the
-# default header to a separate file.
-#
-# Note: Only use a user-defined header if you know what you are doing! The
-# following commands have a special meaning inside the header: $title,
-# $datetime, $date, $doxygenversion, $projectname, $projectnumber. Doxygen will
-# replace them by respectively the title of the page, the current date and time,
-# only the current date, the version number of doxygen, the project name (see
-# PROJECT_NAME), or the project number (see PROJECT_NUMBER).
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_HEADER           = 
-
-# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
-# generated LaTeX document. The footer should contain everything after the last
-# chapter. If it is left blank doxygen will generate a standard footer.
-#
-# Note: Only use a user-defined footer if you know what you are doing!
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_FOOTER           = 
-
-# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
-# other source files which should be copied to the LATEX_OUTPUT output
-# directory. Note that the files will be copied as-is; there are no commands or
-# markers available.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_EXTRA_FILES      = 
-
-# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
-# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
-# contain links (just like the HTML output) instead of page references. This
-# makes the output suitable for online browsing using a PDF viewer.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-PDF_HYPERLINKS         = YES
-
-# If the LATEX_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
-# the PDF file directly from the LaTeX files. Set this option to YES to get a
-# higher quality PDF documentation.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-USE_PDFLATEX           = YES
-
-# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
-# command to the generated LaTeX files. This will instruct LaTeX to keep running
-# if errors occur, instead of asking the user for help. This option is also used
-# when generating formulas in HTML.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_BATCHMODE        = NO
-
-# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
-# index chapters (such as File Index, Compound Index, etc.) in the output.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_HIDE_INDICES     = NO
-
-# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
-# code with syntax highlighting in the LaTeX output.
-#
-# Note that which sources are shown also depends on other settings such as
-# SOURCE_BROWSER.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_SOURCE_CODE      = NO
-
-# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
-# bibliography, e.g. plainnat, or ieeetr. See
-# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
-# The default value is: plain.
-# This tag requires that the tag GENERATE_LATEX is set to YES.
-
-LATEX_BIB_STYLE        = plain
-
-#---------------------------------------------------------------------------
-# Configuration options related to the RTF output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
-# RTF output is optimized for Word 97 and may not look too pretty with other RTF
-# readers/editors.
-# The default value is: NO.
-
-GENERATE_RTF           = NO
-
-# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
-# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
-# it.
-# The default directory is: rtf.
-# This tag requires that the tag GENERATE_RTF is set to YES.
-
-RTF_OUTPUT             = rtf
-
-# If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
-# documents. This may be useful for small projects and may help to save some
-# trees in general.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_RTF is set to YES.
-
-COMPACT_RTF            = NO
-
-# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
-# contain hyperlink fields. The RTF file will contain links (just like the HTML
-# output) instead of page references. This makes the output suitable for online
-# browsing using Word or some other Word compatible readers that support those
-# fields.
-#
-# Note: WordPad (write) and others do not support links.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_RTF is set to YES.
-
-RTF_HYPERLINKS         = NO
-
-# Load stylesheet definitions from file. Syntax is similar to doxygen's config
-# file, i.e. a series of assignments. You only have to provide replacements,
-# missing definitions are set to their default value.
-#
-# See also section "Doxygen usage" for information on how to generate the
-# default style sheet that doxygen normally uses.
-# This tag requires that the tag GENERATE_RTF is set to YES.
-
-RTF_STYLESHEET_FILE    = 
-
-# Set optional variables used in the generation of an RTF document. Syntax is
-# similar to doxygen's config file. A template extensions file can be generated
-# using doxygen -e rtf extensionFile.
-# This tag requires that the tag GENERATE_RTF is set to YES.
-
-RTF_EXTENSIONS_FILE    = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the man page output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
-# classes and files.
-# The default value is: NO.
-
-GENERATE_MAN           = NO
-
-# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
-# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
-# it. A directory man3 will be created inside the directory specified by
-# MAN_OUTPUT.
-# The default directory is: man.
-# This tag requires that the tag GENERATE_MAN is set to YES.
-
-MAN_OUTPUT             = man
-
-# The MAN_EXTENSION tag determines the extension that is added to the generated
-# man pages. In case the manual section does not start with a number, the number
-# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
-# optional.
-# The default value is: .3.
-# This tag requires that the tag GENERATE_MAN is set to YES.
-
-MAN_EXTENSION          = .3
-
-# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
-# will generate one additional man file for each entity documented in the real
-# man page(s). These additional files only source the real man page, but without
-# them the man command would be unable to find the correct page.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_MAN is set to YES.
-
-MAN_LINKS              = NO
-
-#---------------------------------------------------------------------------
-# Configuration options related to the XML output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
-# captures the structure of the code including all documentation.
-# The default value is: NO.
-
-GENERATE_XML           = NO
-
-# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
-# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
-# it.
-# The default directory is: xml.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_OUTPUT             = xml
-
-# The XML_SCHEMA tag can be used to specify a XML schema, which can be used by a
-# validating XML parser to check the syntax of the XML files.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_SCHEMA             = 
-
-# The XML_DTD tag can be used to specify a XML DTD, which can be used by a
-# validating XML parser to check the syntax of the XML files.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_DTD                = 
-
-# If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
-# listings (including syntax highlighting and cross-referencing information) to
-# the XML output. Note that enabling this will significantly increase the size
-# of the XML output.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_XML is set to YES.
-
-XML_PROGRAMLISTING     = YES
-
-#---------------------------------------------------------------------------
-# Configuration options related to the DOCBOOK output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
-# that can be used to generate PDF.
-# The default value is: NO.
-
-GENERATE_DOCBOOK       = NO
-
-# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
-# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
-# front of it.
-# The default directory is: docbook.
-# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
-
-DOCBOOK_OUTPUT         = docbook
-
-#---------------------------------------------------------------------------
-# Configuration options for the AutoGen Definitions output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
-# Definitions (see http://autogen.sf.net) file that captures the structure of
-# the code including all documentation. Note that this feature is still
-# experimental and incomplete at the moment.
-# The default value is: NO.
-
-GENERATE_AUTOGEN_DEF   = NO
-
-#---------------------------------------------------------------------------
-# Configuration options related to the Perl module output
-#---------------------------------------------------------------------------
-
-# If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
-# file that captures the structure of the code including all documentation.
-#
-# Note that this feature is still experimental and incomplete at the moment.
-# The default value is: NO.
-
-GENERATE_PERLMOD       = NO
-
-# If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
-# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
-# output from the Perl module output.
-# The default value is: NO.
-# This tag requires that the tag GENERATE_PERLMOD is set to YES.
-
-PERLMOD_LATEX          = NO
-
-# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
-# formatted so it can be parsed by a human reader. This is useful if you want to
-# understand what is going on. On the other hand, if this tag is set to NO the
-# size of the Perl module output will be much smaller and Perl will parse it
-# just the same.
-# The default value is: YES.
-# This tag requires that the tag GENERATE_PERLMOD is set to YES.
-
-PERLMOD_PRETTY         = YES
-
-# The names of the make variables in the generated doxyrules.make file are
-# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
-# so different doxyrules.make files included by the same Makefile don't
-# overwrite each other's variables.
-# This tag requires that the tag GENERATE_PERLMOD is set to YES.
-
-PERLMOD_MAKEVAR_PREFIX = 
-
-#---------------------------------------------------------------------------
-# Configuration options related to the preprocessor
-#---------------------------------------------------------------------------
-
-# If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
-# C-preprocessor directives found in the sources and include files.
-# The default value is: YES.
-
-ENABLE_PREPROCESSING   = YES
-
-# If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
-# in the source code. If set to NO only conditional compilation will be
-# performed. Macro expansion can be done in a controlled way by setting
-# EXPAND_ONLY_PREDEF to YES.
-# The default value is: NO.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-MACRO_EXPANSION        = NO
-
-# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
-# the macro expansion is limited to the macros specified with the PREDEFINED and
-# EXPAND_AS_DEFINED tags.
-# The default value is: NO.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-EXPAND_ONLY_PREDEF     = NO
-
-# If the SEARCH_INCLUDES tag is set to YES the includes files in the
-# INCLUDE_PATH will be searched if a #include is found.
-# The default value is: YES.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-SEARCH_INCLUDES        = YES
-
-# The INCLUDE_PATH tag can be used to specify one or more directories that
-# contain include files that are not input files but should be processed by the
-# preprocessor.
-# This tag requires that the tag SEARCH_INCLUDES is set to YES.
-
-INCLUDE_PATH           = 
-
-# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
-# patterns (like *.h and *.hpp) to filter out the header-files in the
-# directories. If left blank, the patterns specified with FILE_PATTERNS will be
-# used.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-INCLUDE_FILE_PATTERNS  = 
-
-# The PREDEFINED tag can be used to specify one or more macro names that are
-# defined before the preprocessor is started (similar to the -D option of e.g.
-# gcc). The argument of the tag is a list of macros of the form: name or
-# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
-# is assumed. To prevent a macro definition from being undefined via #undef or
-# recursively expanded use the := operator instead of the = operator.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-PREDEFINED             = 
-
-# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
-# tag can be used to specify a list of macro names that should be expanded. The
-# macro definition that is found in the sources will be used. Use the PREDEFINED
-# tag if you want to use a different macro definition that overrules the
-# definition found in the source code.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-EXPAND_AS_DEFINED      = 
-
-# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
-# remove all refrences to function-like macros that are alone on a line, have an
-# all uppercase name, and do not end with a semicolon. Such function macros are
-# typically used for boiler-plate code, and will confuse the parser if not
-# removed.
-# The default value is: YES.
-# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
-
-SKIP_FUNCTION_MACROS   = YES
-
-#---------------------------------------------------------------------------
-# Configuration options related to external references
-#---------------------------------------------------------------------------
-
-# The TAGFILES tag can be used to specify one or more tag files. For each tag
-# file the location of the external documentation should be added. The format of
-# a tag file without this location is as follows:
-# TAGFILES = file1 file2 ...
-# Adding location for the tag files is done as follows:
-# TAGFILES = file1=loc1 "file2 = loc2" ...
-# where loc1 and loc2 can be relative or absolute paths or URLs. See the
-# section "Linking to external documentation" for more information about the use
-# of tag files.
-# Note: Each tag file must have an unique name (where the name does NOT include
-# the path). If a tag file is not located in the directory in which doxygen is
-# run, you must also specify the path to the tagfile here.
-
-TAGFILES               = 
-
-# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
-# tag file that is based on the input files it reads. See section "Linking to
-# external documentation" for more information about the usage of tag files.
-
-GENERATE_TAGFILE       = 
-
-# If the ALLEXTERNALS tag is set to YES all external class will be listed in the
-# class index. If set to NO only the inherited external classes will be listed.
-# The default value is: NO.
-
-ALLEXTERNALS           = NO
-
-# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
-# the modules index. If set to NO, only the current project's groups will be
-# listed.
-# The default value is: YES.
-
-EXTERNAL_GROUPS        = YES
-
-# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
-# the related pages index. If set to NO, only the current project's pages will
-# be listed.
-# The default value is: YES.
-
-EXTERNAL_PAGES         = YES
-
-# The PERL_PATH should be the absolute path and name of the perl script
-# interpreter (i.e. the result of 'which perl').
-# The default file (with absolute path) is: /usr/bin/perl.
-
-PERL_PATH              = /usr/bin/perl
-
-#---------------------------------------------------------------------------
-# Configuration options related to the dot tool
-#---------------------------------------------------------------------------
-
-# If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
-# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
-# NO turns the diagrams off. Note that this option also works with HAVE_DOT
-# disabled, but it is recommended to install and use dot, since it yields more
-# powerful graphs.
-# The default value is: YES.
-
-CLASS_DIAGRAMS         = YES
-
-# You can define message sequence charts within doxygen comments using the \msc
-# command. Doxygen will then run the mscgen tool (see:
-# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
-# documentation. The MSCGEN_PATH tag allows you to specify the directory where
-# the mscgen tool resides. If left empty the tool is assumed to be found in the
-# default search path.
-
-MSCGEN_PATH            = 
-
-# You can include diagrams made with dia in doxygen documentation. Doxygen will
-# then run dia to produce the diagram and insert it in the documentation. The
-# DIA_PATH tag allows you to specify the directory where the dia binary resides.
-# If left empty dia is assumed to be found in the default search path.
-
-DIA_PATH               = 
-
-# If set to YES, the inheritance and collaboration graphs will hide inheritance
-# and usage relations if the target is undocumented or is not a class.
-# The default value is: YES.
-
-HIDE_UNDOC_RELATIONS   = YES
-
-# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
-# available from the path. This tool is part of Graphviz (see:
-# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
-# Bell Labs. The other options in this section have no effect if this option is
-# set to NO
-# The default value is: NO.
-
-HAVE_DOT               = NO
-
-# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
-# to run in parallel. When set to 0 doxygen will base this on the number of
-# processors available in the system. You can set it explicitly to a value
-# larger than 0 to get control over the balance between CPU load and processing
-# speed.
-# Minimum value: 0, maximum value: 32, default value: 0.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_NUM_THREADS        = 0
-
-# When you want a differently looking font n the dot files that doxygen
-# generates you can specify the font name using DOT_FONTNAME. You need to make
-# sure dot is able to find the font, which can be done by putting it in a
-# standard location or by setting the DOTFONTPATH environment variable or by
-# setting DOT_FONTPATH to the directory containing the font.
-# The default value is: Helvetica.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_FONTNAME           = Helvetica
-
-# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
-# dot graphs.
-# Minimum value: 4, maximum value: 24, default value: 10.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_FONTSIZE           = 10
-
-# By default doxygen will tell dot to use the default font as specified with
-# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
-# the path where dot can find it using this tag.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_FONTPATH           = 
-
-# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
-# each documented class showing the direct and indirect inheritance relations.
-# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-CLASS_GRAPH            = YES
-
-# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
-# graph for each documented class showing the direct and indirect implementation
-# dependencies (inheritance, containment, and class references variables) of the
-# class with other documented classes.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-COLLABORATION_GRAPH    = YES
-
-# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
-# groups, showing the direct groups dependencies.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-GROUP_GRAPHS           = YES
-
-# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
-# collaboration diagrams in a style similar to the OMG's Unified Modeling
-# Language.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-UML_LOOK               = NO
-
-# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
-# class node. If there are many fields or methods and many nodes the graph may
-# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
-# number of items for each type to make the size more manageable. Set this to 0
-# for no limit. Note that the threshold may be exceeded by 50% before the limit
-# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
-# but if the number exceeds 15, the total amount of fields shown is limited to
-# 10.
-# Minimum value: 0, maximum value: 100, default value: 10.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-UML_LIMIT_NUM_FIELDS   = 10
-
-# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
-# collaboration graphs will show the relations between templates and their
-# instances.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-TEMPLATE_RELATIONS     = NO
-
-# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
-# YES then doxygen will generate a graph for each documented file showing the
-# direct and indirect include dependencies of the file with other documented
-# files.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-INCLUDE_GRAPH          = YES
-
-# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
-# set to YES then doxygen will generate a graph for each documented file showing
-# the direct and indirect include dependencies of the file with other documented
-# files.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-INCLUDED_BY_GRAPH      = YES
-
-# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
-# dependency graph for every global function or class method.
-#
-# Note that enabling this option will significantly increase the time of a run.
-# So in most cases it will be better to enable call graphs for selected
-# functions only using the \callgraph command.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-CALL_GRAPH             = NO
-
-# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
-# dependency graph for every global function or class method.
-#
-# Note that enabling this option will significantly increase the time of a run.
-# So in most cases it will be better to enable caller graphs for selected
-# functions only using the \callergraph command.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-CALLER_GRAPH           = NO
-
-# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
-# hierarchy of all classes instead of a textual one.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-GRAPHICAL_HIERARCHY    = YES
-
-# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
-# dependencies a directory has on other directories in a graphical way. The
-# dependency relations are determined by the #include relations between the
-# files in the directories.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DIRECTORY_GRAPH        = YES
-
-# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
-# generated by dot.
-# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
-# to make the SVG files visible in IE 9+ (other browsers do not have this
-# requirement).
-# Possible values are: png, jpg, gif and svg.
-# The default value is: png.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_IMAGE_FORMAT       = png
-
-# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
-# enable generation of interactive SVG images that allow zooming and panning.
-#
-# Note that this requires a modern browser other than Internet Explorer. Tested
-# and working are Firefox, Chrome, Safari, and Opera.
-# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
-# the SVG files visible. Older versions of IE do not have SVG support.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-INTERACTIVE_SVG        = NO
-
-# The DOT_PATH tag can be used to specify the path where the dot tool can be
-# found. If left blank, it is assumed the dot tool can be found in the path.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_PATH               = /usr/local/bin/dot
-
-# The DOTFILE_DIRS tag can be used to specify one or more directories that
-# contain dot files that are included in the documentation (see the \dotfile
-# command).
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOTFILE_DIRS           = 
-
-# The MSCFILE_DIRS tag can be used to specify one or more directories that
-# contain msc files that are included in the documentation (see the \mscfile
-# command).
-
-MSCFILE_DIRS           = 
-
-# The DIAFILE_DIRS tag can be used to specify one or more directories that
-# contain dia files that are included in the documentation (see the \diafile
-# command).
-
-DIAFILE_DIRS           = 
-
-# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
-# that will be shown in the graph. If the number of nodes in a graph becomes
-# larger than this value, doxygen will truncate the graph, which is visualized
-# by representing a node as a red box. Note that doxygen if the number of direct
-# children of the root node in a graph is already larger than
-# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
-# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
-# Minimum value: 0, maximum value: 10000, default value: 50.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_GRAPH_MAX_NODES    = 50
-
-# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
-# generated by dot. A depth value of 3 means that only nodes reachable from the
-# root by following a path via at most 3 edges will be shown. Nodes that lay
-# further from the root node will be omitted. Note that setting this option to 1
-# or 2 may greatly reduce the computation time needed for large code bases. Also
-# note that the size of a graph can be further restricted by
-# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
-# Minimum value: 0, maximum value: 1000, default value: 0.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-MAX_DOT_GRAPH_DEPTH    = 0
-
-# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
-# background. This is disabled by default, because dot on Windows does not seem
-# to support this out of the box.
-#
-# Warning: Depending on the platform used, enabling this option may lead to
-# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
-# read).
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_TRANSPARENT        = NO
-
-# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
-# files in one run (i.e. multiple -o and -T options on the command line). This
-# makes dot run faster, but since only newer versions of dot (>1.8.10) support
-# this, this feature is disabled by default.
-# The default value is: NO.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_MULTI_TARGETS      = YES
-
-# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
-# explaining the meaning of the various boxes and arrows in the dot generated
-# graphs.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-GENERATE_LEGEND        = YES
-
-# If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
-# files that are used to generate the various graphs.
-# The default value is: YES.
-# This tag requires that the tag HAVE_DOT is set to YES.
-
-DOT_CLEANUP            = YES
+# Doxyfile 1.8.6
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+# for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = pyOCD
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         = 
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = 
+
+# With the PROJECT_LOGO tag one can specify an logo or icon that is included in
+# the documentation. The maximum height of the logo should not exceed 55 pixels
+# and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
+# to the output directory.
+
+PROJECT_LOGO           = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = 
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = NO
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
+# new page for each member. If set to NO, the documentation of a member will be
+# part of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                = 
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL. For instance to make
+# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
+# (default is Fortran), use: inc=Fortran f=C.
+#
+# Note For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by by putting a % sign in front of the word
+# or globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = YES
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = YES
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = YES
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO these classes will be included in the various overviews. This option has
+# no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = YES
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
+# todo list. This list is created by putting \todo commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
+# test list. This list is created by putting \test commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 0
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES the list
+# will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = NO
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            = DoxygenLayout.xml
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. Do not use file names with spaces, bibtex cannot handle them. See
+# also \cite for info how to create references.
+
+CITE_BIB_FILES         = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO doxygen will only warn about wrong or incomplete parameter
+# documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces.
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = README.md \
+                         pyOCD
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: http://www.gnu.org/software/libiconv) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank the
+# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
+# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
+# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
+# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
+# *.qsf, *.as and *.js.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.f90 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf \
+                         *.as \
+                         *.js
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER ) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS = 
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE = README.md
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES, then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see http://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES, then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more acurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# compiled with the --with-libclang option.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        = 
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional user-
+# defined cascading style sheet that is included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefor more robust against future updates.
+# Doxygen will copy the style sheet file to the output directory. For an example
+# see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  = 
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       = 
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the stylesheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = YES
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: http://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               = 
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler ( hhc.exe). If non-empty
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           = 
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated (
+# YES) or that it should be included in the master .chm file ( NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     = 
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated (
+# YES) or a normal table of contents ( NO) in the .chm file.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = YES
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 1
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# http://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using prerendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from http://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     = 
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       = 
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavours of web server based searching depending on the
+# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
+# searching and an index file used by the script. When EXTERNAL_SEARCH is
+# enabled the indexing and searching needs to be provided by external tools. See
+# the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       = 
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     = 
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. To get the times font for
+# instance you can specify
+# EXTRA_PACKAGES=times
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber. Doxygen will
+# replace them by respectively the title of the page, the current date and time,
+# only the current date, the version number of doxygen, the project name (see
+# PROJECT_NAME), or the project number (see PROJECT_NUMBER).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           = 
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           = 
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the LATEX_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify a XML schema, which can be used by a
+# validating XML parser to check the syntax of the XML files.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify a XML DTD, which can be used by a
+# validating XML parser to check the syntax of the XML files.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
+# Definitions (see http://autogen.sf.net) file that captures the structure of
+# the code including all documentation. Note that this feature is still
+# experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
+# in the source code. If set to NO only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES the includes files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all refrences to function-like macros that are alone on a line, have an
+# all uppercase name, and do not end with a semicolon. Such function macros are
+# typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have an unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external class will be listed in the
+# class index. If set to NO only the inherited external classes will be listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
+# the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            = 
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               = 
+
+# If set to YES, the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font n the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot.
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif and svg.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               = /usr/local/bin/dot
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           = 
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           = 
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = YES
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
```

### Comparing `pyOCD-0.8.1a1/elf_files/lpc11u24_l1_gcc_arm.elf` & `pyOCD-0.9.0/elf_files/lpc11u24_l1_gcc_arm.elf`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/elf_files/lpc1768_l1_gcc_arm.elf` & `pyOCD-0.9.0/elf_files/lpc1768_l1_gcc_arm.elf`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/HOW_TO_BUILD.md` & `pyOCD-0.9.0/HOW_TO_BUILD.md`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-How to Build PyOCD into Single Executable File
-==============================================
-This manual provides a step-by-step guide on how to build a single
-file executable using
-[pyinstaller](http://pythonhosted.org/PyInstaller/).  It should be
-possible for PyInstaller to work across all supported operating
-system, but these steps have only been tested on Windows 7 64-bit and
-Ubuntu 14.04.
-
-pyOCD is an open source GDB server library written in Python and
-maintained by pyOCD community, it depends on several libraries like
-pyusb under Linux, and pywinusb under Windows. Pyinstaller was chosen
-to bundle it into a single executable file, so that the pyOCD
-executable produced can be run on any computer, whether python and the
-related library are present or not on the system.
-
-Instructions
-------------
-
-Follow the following instructions from a fresh checkout of pyOCD to
-build a single file executable containing the pyOCD GDB server.  These
-instructions assume that you already have Python installed:
-
-The following script shows the basic steps that one must follow:
-
-```bash
-# Install pip and virtualenv
-sudo apt-get install python-pip python-virtualenv
-
-# Setup a virtualenv and install dependencies
-virtualenv env
-source env/bin/activate
-pip install --editable .
-
-# We need to use upstream version of pyinstaller due to
-# http://comments.gmane.org/gmane.comp.python.pyinstaller/6457
-pip install https://github.com/pyinstaller/pyinstaller/archive/develop.zip
-
-# Create single-file executables
-pyinstaller --onefile pyOCD/tools/gdb_server.py
-pyinstaller --onefile pyOCD/tools/flash_tool.py
-```
-
-In ./dist folder, there will be a single executable file which is
-ready to use or distribute it to other library.
+How to Build PyOCD into Single Executable File
+==============================================
+This manual provides a step-by-step guide on how to build a single
+file executable using
+[pyinstaller](http://pythonhosted.org/PyInstaller/).  It should be
+possible for PyInstaller to work across all supported operating
+system, but these steps have only been tested on Windows 7 64-bit and
+Ubuntu 14.04.
+
+pyOCD is an open source GDB server library written in Python and
+maintained by pyOCD community, it depends on several libraries like
+pyusb under Linux, and pywinusb under Windows. Pyinstaller was chosen
+to bundle it into a single executable file, so that the pyOCD
+executable produced can be run on any computer, whether python and the
+related library are present or not on the system.
+
+Instructions
+------------
+
+Follow the following instructions from a fresh checkout of pyOCD to
+build a single file executable containing the pyOCD GDB server.  These
+instructions assume that you already have Python installed:
+
+The following script shows the basic steps that one must follow:
+
+```bash
+# Install pip and virtualenv
+sudo apt-get install python-pip python-virtualenv
+
+# Setup a virtualenv and install dependencies
+virtualenv env
+source env/bin/activate
+pip install --editable .
+
+# We need to use upstream version of pyinstaller due to
+# http://comments.gmane.org/gmane.comp.python.pyinstaller/6457
+pip install https://github.com/pyinstaller/pyinstaller/archive/develop.zip
+
+# Create single-file executables
+pyinstaller --onefile pyOCD/tools/gdb_server.py
+pyinstaller --onefile pyOCD/tools/flash_tool.py
+```
+
+In ./dist folder, there will be a single executable file which is
+ready to use or distribute it to other library.
```

### Comparing `pyOCD-0.8.1a1/LICENSE` & `pyOCD-0.9.0/LICENSE`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,191 +1,191 @@
-Apache License
-Version 2.0, January 2004
-http://www.apache.org/licenses/
-
-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-1. Definitions.
-
-"License" shall mean the terms and conditions for use, reproduction, and
-distribution as defined by Sections 1 through 9 of this document.
-
-"Licensor" shall mean the copyright owner or entity authorized by the copyright
-owner that is granting the License.
-
-"Legal Entity" shall mean the union of the acting entity and all other entities
-that control, are controlled by, or are under common control with that entity.
-For the purposes of this definition, "control" means (i) the power, direct or
-indirect, to cause the direction or management of such entity, whether by
-contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
-outstanding shares, or (iii) beneficial ownership of such entity.
-
-"You" (or "Your") shall mean an individual or Legal Entity exercising
-permissions granted by this License.
-
-"Source" form shall mean the preferred form for making modifications, including
-but not limited to software source code, documentation source, and configuration
-files.
-
-"Object" form shall mean any form resulting from mechanical transformation or
-translation of a Source form, including but not limited to compiled object code,
-generated documentation, and conversions to other media types.
-
-"Work" shall mean the work of authorship, whether in Source or Object form, made
-available under the License, as indicated by a copyright notice that is included
-in or attached to the work (an example is provided in the Appendix below).
-
-"Derivative Works" shall mean any work, whether in Source or Object form, that
-is based on (or derived from) the Work and for which the editorial revisions,
-annotations, elaborations, or other modifications represent, as a whole, an
-original work of authorship. For the purposes of this License, Derivative Works
-shall not include works that remain separable from, or merely link (or bind by
-name) to the interfaces of, the Work and Derivative Works thereof.
-
-"Contribution" shall mean any work of authorship, including the original version
-of the Work and any modifications or additions to that Work or Derivative Works
-thereof, that is intentionally submitted to Licensor for inclusion in the Work
-by the copyright owner or by an individual or Legal Entity authorized to submit
-on behalf of the copyright owner. For the purposes of this definition,
-"submitted" means any form of electronic, verbal, or written communication sent
-to the Licensor or its representatives, including but not limited to
-communication on electronic mailing lists, source code control systems, and
-issue tracking systems that are managed by, or on behalf of, the Licensor for
-the purpose of discussing and improving the Work, but excluding communication
-that is conspicuously marked or otherwise designated in writing by the copyright
-owner as "Not a Contribution."
-
-"Contributor" shall mean Licensor and any individual or Legal Entity on behalf
-of whom a Contribution has been received by Licensor and subsequently
-incorporated within the Work.
-
-2. Grant of Copyright License.
-
-Subject to the terms and conditions of this License, each Contributor hereby
-grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
-irrevocable copyright license to reproduce, prepare Derivative Works of,
-publicly display, publicly perform, sublicense, and distribute the Work and such
-Derivative Works in Source or Object form.
-
-3. Grant of Patent License.
-
-Subject to the terms and conditions of this License, each Contributor hereby
-grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
-irrevocable (except as stated in this section) patent license to make, have
-made, use, offer to sell, sell, import, and otherwise transfer the Work, where
-such license applies only to those patent claims licensable by such Contributor
-that are necessarily infringed by their Contribution(s) alone or by combination
-of their Contribution(s) with the Work to which such Contribution(s) was
-submitted. If You institute patent litigation against any entity (including a
-cross-claim or counterclaim in a lawsuit) alleging that the Work or a
-Contribution incorporated within the Work constitutes direct or contributory
-patent infringement, then any patent licenses granted to You under this License
-for that Work shall terminate as of the date such litigation is filed.
-
-4. Redistribution.
-
-You may reproduce and distribute copies of the Work or Derivative Works thereof
-in any medium, with or without modifications, and in Source or Object form,
-provided that You meet the following conditions:
-
-You must give any other recipients of the Work or Derivative Works a copy of
-this License; and
-You must cause any modified files to carry prominent notices stating that You
-changed the files; and
-You must retain, in the Source form of any Derivative Works that You distribute,
-all copyright, patent, trademark, and attribution notices from the Source form
-of the Work, excluding those notices that do not pertain to any part of the
-Derivative Works; and
-If the Work includes a "NOTICE" text file as part of its distribution, then any
-Derivative Works that You distribute must include a readable copy of the
-attribution notices contained within such NOTICE file, excluding those notices
-that do not pertain to any part of the Derivative Works, in at least one of the
-following places: within a NOTICE text file distributed as part of the
-Derivative Works; within the Source form or documentation, if provided along
-with the Derivative Works; or, within a display generated by the Derivative
-Works, if and wherever such third-party notices normally appear. The contents of
-the NOTICE file are for informational purposes only and do not modify the
-License. You may add Your own attribution notices within Derivative Works that
-You distribute, alongside or as an addendum to the NOTICE text from the Work,
-provided that such additional attribution notices cannot be construed as
-modifying the License.
-You may add Your own copyright statement to Your modifications and may provide
-additional or different license terms and conditions for use, reproduction, or
-distribution of Your modifications, or for any such Derivative Works as a whole,
-provided Your use, reproduction, and distribution of the Work otherwise complies
-with the conditions stated in this License.
-
-5. Submission of Contributions.
-
-Unless You explicitly state otherwise, any Contribution intentionally submitted
-for inclusion in the Work by You to the Licensor shall be under the terms and
-conditions of this License, without any additional terms or conditions.
-Notwithstanding the above, nothing herein shall supersede or modify the terms of
-any separate license agreement you may have executed with Licensor regarding
-such Contributions.
-
-6. Trademarks.
-
-This License does not grant permission to use the trade names, trademarks,
-service marks, or product names of the Licensor, except as required for
-reasonable and customary use in describing the origin of the Work and
-reproducing the content of the NOTICE file.
-
-7. Disclaimer of Warranty.
-
-Unless required by applicable law or agreed to in writing, Licensor provides the
-Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
-including, without limitation, any warranties or conditions of TITLE,
-NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
-solely responsible for determining the appropriateness of using or
-redistributing the Work and assume any risks associated with Your exercise of
-permissions under this License.
-
-8. Limitation of Liability.
-
-In no event and under no legal theory, whether in tort (including negligence),
-contract, or otherwise, unless required by applicable law (such as deliberate
-and grossly negligent acts) or agreed to in writing, shall any Contributor be
-liable to You for damages, including any direct, indirect, special, incidental,
-or consequential damages of any character arising as a result of this License or
-out of the use or inability to use the Work (including but not limited to
-damages for loss of goodwill, work stoppage, computer failure or malfunction, or
-any and all other commercial damages or losses), even if such Contributor has
-been advised of the possibility of such damages.
-
-9. Accepting Warranty or Additional Liability.
-
-While redistributing the Work or Derivative Works thereof, You may choose to
-offer, and charge a fee for, acceptance of support, warranty, indemnity, or
-other liability obligations and/or rights consistent with this License. However,
-in accepting such obligations, You may act only on Your own behalf and on Your
-sole responsibility, not on behalf of any other Contributor, and only if You
-agree to indemnify, defend, and hold each Contributor harmless for any liability
-incurred by, or claims asserted against, such Contributor by reason of your
-accepting any such warranty or additional liability.
-
-END OF TERMS AND CONDITIONS
-
-APPENDIX: How to apply the Apache License to your work
-
-To apply the Apache License to your work, attach the following boilerplate
-notice, with the fields enclosed by brackets "[]" replaced with your own
-identifying information. (Don't include the brackets!) The text should be
-enclosed in the appropriate comment syntax for the file format. We also
-recommend that a file or class name and description of purpose be included on
-the same "printed page" as the copyright notice for easier identification within
-third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and
+distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright
+owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities
+that control, are controlled by, or are under common control with that entity.
+For the purposes of this definition, "control" means (i) the power, direct or
+indirect, to cause the direction or management of such entity, whether by
+contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
+outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising
+permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including
+but not limited to software source code, documentation source, and configuration
+files.
+
+"Object" form shall mean any form resulting from mechanical transformation or
+translation of a Source form, including but not limited to compiled object code,
+generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made
+available under the License, as indicated by a copyright notice that is included
+in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that
+is based on (or derived from) the Work and for which the editorial revisions,
+annotations, elaborations, or other modifications represent, as a whole, an
+original work of authorship. For the purposes of this License, Derivative Works
+shall not include works that remain separable from, or merely link (or bind by
+name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version
+of the Work and any modifications or additions to that Work or Derivative Works
+thereof, that is intentionally submitted to Licensor for inclusion in the Work
+by the copyright owner or by an individual or Legal Entity authorized to submit
+on behalf of the copyright owner. For the purposes of this definition,
+"submitted" means any form of electronic, verbal, or written communication sent
+to the Licensor or its representatives, including but not limited to
+communication on electronic mailing lists, source code control systems, and
+issue tracking systems that are managed by, or on behalf of, the Licensor for
+the purpose of discussing and improving the Work, but excluding communication
+that is conspicuously marked or otherwise designated in writing by the copyright
+owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf
+of whom a Contribution has been received by Licensor and subsequently
+incorporated within the Work.
+
+2. Grant of Copyright License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable copyright license to reproduce, prepare Derivative Works of,
+publicly display, publicly perform, sublicense, and distribute the Work and such
+Derivative Works in Source or Object form.
+
+3. Grant of Patent License.
+
+Subject to the terms and conditions of this License, each Contributor hereby
+grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
+irrevocable (except as stated in this section) patent license to make, have
+made, use, offer to sell, sell, import, and otherwise transfer the Work, where
+such license applies only to those patent claims licensable by such Contributor
+that are necessarily infringed by their Contribution(s) alone or by combination
+of their Contribution(s) with the Work to which such Contribution(s) was
+submitted. If You institute patent litigation against any entity (including a
+cross-claim or counterclaim in a lawsuit) alleging that the Work or a
+Contribution incorporated within the Work constitutes direct or contributory
+patent infringement, then any patent licenses granted to You under this License
+for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution.
+
+You may reproduce and distribute copies of the Work or Derivative Works thereof
+in any medium, with or without modifications, and in Source or Object form,
+provided that You meet the following conditions:
+
+You must give any other recipients of the Work or Derivative Works a copy of
+this License; and
+You must cause any modified files to carry prominent notices stating that You
+changed the files; and
+You must retain, in the Source form of any Derivative Works that You distribute,
+all copyright, patent, trademark, and attribution notices from the Source form
+of the Work, excluding those notices that do not pertain to any part of the
+Derivative Works; and
+If the Work includes a "NOTICE" text file as part of its distribution, then any
+Derivative Works that You distribute must include a readable copy of the
+attribution notices contained within such NOTICE file, excluding those notices
+that do not pertain to any part of the Derivative Works, in at least one of the
+following places: within a NOTICE text file distributed as part of the
+Derivative Works; within the Source form or documentation, if provided along
+with the Derivative Works; or, within a display generated by the Derivative
+Works, if and wherever such third-party notices normally appear. The contents of
+the NOTICE file are for informational purposes only and do not modify the
+License. You may add Your own attribution notices within Derivative Works that
+You distribute, alongside or as an addendum to the NOTICE text from the Work,
+provided that such additional attribution notices cannot be construed as
+modifying the License.
+You may add Your own copyright statement to Your modifications and may provide
+additional or different license terms and conditions for use, reproduction, or
+distribution of Your modifications, or for any such Derivative Works as a whole,
+provided Your use, reproduction, and distribution of the Work otherwise complies
+with the conditions stated in this License.
+
+5. Submission of Contributions.
+
+Unless You explicitly state otherwise, any Contribution intentionally submitted
+for inclusion in the Work by You to the Licensor shall be under the terms and
+conditions of this License, without any additional terms or conditions.
+Notwithstanding the above, nothing herein shall supersede or modify the terms of
+any separate license agreement you may have executed with Licensor regarding
+such Contributions.
+
+6. Trademarks.
+
+This License does not grant permission to use the trade names, trademarks,
+service marks, or product names of the Licensor, except as required for
+reasonable and customary use in describing the origin of the Work and
+reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty.
+
+Unless required by applicable law or agreed to in writing, Licensor provides the
+Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
+including, without limitation, any warranties or conditions of TITLE,
+NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
+solely responsible for determining the appropriateness of using or
+redistributing the Work and assume any risks associated with Your exercise of
+permissions under this License.
+
+8. Limitation of Liability.
+
+In no event and under no legal theory, whether in tort (including negligence),
+contract, or otherwise, unless required by applicable law (such as deliberate
+and grossly negligent acts) or agreed to in writing, shall any Contributor be
+liable to You for damages, including any direct, indirect, special, incidental,
+or consequential damages of any character arising as a result of this License or
+out of the use or inability to use the Work (including but not limited to
+damages for loss of goodwill, work stoppage, computer failure or malfunction, or
+any and all other commercial damages or losses), even if such Contributor has
+been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability.
+
+While redistributing the Work or Derivative Works thereof, You may choose to
+offer, and charge a fee for, acceptance of support, warranty, indemnity, or
+other liability obligations and/or rights consistent with this License. However,
+in accepting such obligations, You may act only on Your own behalf and on Your
+sole responsibility, not on behalf of any other Contributor, and only if You
+agree to indemnify, defend, and hold each Contributor harmless for any liability
+incurred by, or claims asserted against, such Contributor by reason of your
+accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work
+
+To apply the Apache License to your work, attach the following boilerplate
+notice, with the fields enclosed by brackets "[]" replaced with your own
+identifying information. (Don't include the brackets!) The text should be
+enclosed in the appropriate comment syntax for the file format. We also
+recommend that a file or class name and description of purpose be included on
+the same "printed page" as the copyright notice for easier identification within
+third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
```

### Comparing `pyOCD-0.8.1a1/PKG-INFO` & `pyOCD-0.9.0/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,265 +1,265 @@
-Metadata-Version: 1.1
-Name: pyOCD
-Version: 0.8.1a1
-Summary: CMSIS-DAP debugger for Python
-Home-page: https://github.com/mbedmicro/pyOCD
-Author: Martin Kojtal, Russ Butler
-Author-email: martin.kojtal@arm.com, russ.butler@arm.com
-License: Apache 2.0
-Description: pyOCD
-        =====
-        
-        pyOCD is an Open Source python 2.7 based library for programming and debugging 
-        ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
-        supported.
-        
-        You can use the following interfaces:
-        
-        #. From a python interpretor:
-        
-           -  halt, step, resume execution
-           -  read/write memory
-           -  read/write block memory
-           -  read-write core register
-           -  set/remove hardware breakpoints
-           -  flash new binary
-           -  reset
-        
-        #. From a GDB client, you have all the features provided by gdb:
-        
-           -  load a .elf file
-           -  read/write memory
-           -  read/write core register
-           -  set/remove hardware breakpoints
-           -  high level stepping
-           -  ...
-        
-        Installation
-        ------------
-        
-        The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
-        
-        .. code:: shell
-        
-            $ pip install --pre -U pyocd
-        
-        To install the latest development version (master branch), you can do
-        the following:
-        
-        .. code:: shell
-        
-            $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
-        
-        Note that you may run into permissions issues running these commands.
-        You have a few options here:
-        
-        #. Run with ``sudo -H`` to install pyOCD and dependencies globally
-        #. Specify the ``--user`` option to install local to your user
-        #. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
-           local to a specific project working set.
-        
-        You can also install from source by cloning the git repository and running
-        
-        .. code:: shell
-        
-            python setup.py install
-        
-        Standalone GDB Server
-        ---------------------
-        
-        When you install pyOCD via pip, you should be able to execute the
-        following in order to start a GDB server powered by pyOCD:
-        
-        .. code:: shell
-        
-            pyocd-gdbserver
-        
-        You can get additional help by running ``pyocd-gdbserver --help``.
-        
-        Recommended GDB and IDE setup
-        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-        
-        The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
-        To view register the Embedded System Register Viewer plugin can be used.
-        These can be installed from inside eclipse using the following links:
-        GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
-        Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
-        
-        The pyOCD gdb server executable will run as a drop in place replacement for
-        OpenOCD. If a supported mbed development board is being debugged the target
-        does not need to be specified, as pyOCD will automatically determine this.
-        If an external processor is being debugged then ``-t [processor]`` must
-        be added to the command line. For more information on setup see
-        `this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
-        
-        Development Setup
-        -----------------
-        
-        PyOCD developers are recommended to setup a working environment using
-        `virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
-        the code, you can setup a virtualenv and install the PyOCD
-        dependencies for the current platform by doing the following:
-        
-        .. code:: console
-        
-            $ virtualenv env
-            $ source env/bin/activate
-            $ pip install -r dev-requirements.txt
-        
-        On Windows, the virtualenv would be activated by executing
-        ``env\Scripts\activate``.
-        
-        To run the unittests, you can execute the following.  Because of how
-        nose searches for tests, specifying the directory is important as it
-        will otherwise attempt to run non-unit tests as well (which will
-        hang).
-        
-        .. code:: console
-        
-            $ nosetests pyOCD/tests
-        
-        To get code coverage results, do the following:
-        
-        .. code:: console
-        
-            $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
-            $ firefox cover/index.html
-        
-        Examples
-        --------
-        
-        Tests
-        ~~~~~
-        
-        A series of tests are provided in the test directory:
-        
-        -  basic\_test.py: a simple test that checks:
-        
-           -  read/write core registers
-           -  read/write memory
-           -  stop/resume/step the execution
-           -  reset the target
-           -  erase pages
-           -  flash a binary
-            
-        -  gdb\_test.py: launch a gdbserver
-        -  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
-        
-           -  "-p", "--port", help = "Write the port number that GDB server will open."
-           -  "-b", "--board", help="Connect to board by board id."
-           -  "-l", "--list", help = "List all connected boards."
-           -  "-d", "--debug", help = "Set the level of system logging output."
-           -  "-t", "--target", help = "Override target to debug."
-           -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
-           -  "-r", "--reset-break", help = "Halt the target when reset."
-           -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
-           -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
-           -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
-           -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
-           -  "-ce", "--chip\_erase", help="Use chip erase when programming."
-           -  "-se", "--sector\_erase", help="Use sector erase when programming."
-           -  "-hp", "--hide\_progress", help = "Don't display programming progress."
-           -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
-        
-        Hello World example code
-        ~~~~~~~~~~~~~~~~~~~~~~~~
-        
-        .. code:: python
-        
-            from pyOCD.board import MbedBoard
-        
-            import logging
-            logging.basicConfig(level=logging.INFO)
-        
-            board = MbedBoard.chooseBoard()
-        
-            target = board.target
-            flash = board.flash
-            target.resume()
-            target.halt()
-        
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-                pc: 0xA64
-        
-            target.step()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-                pc: 0xA30
-        
-            target.step()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0xA32
-        
-            flash.flashBinary("binaries/l1_lpc1768.bin")
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0x10000000
-        
-            target.reset()
-            target.halt()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0xAAC
-        
-            board.uninit()
-        
-        GDB server example
-        ~~~~~~~~~~~~~~~~~~
-        
-        Python:
-        
-        .. code:: python
-        
-            from pyOCD.gdbserver import GDBServer
-            from pyOCD.board import MbedBoard
-        
-            import logging
-            logging.basicConfig(level=logging.INFO)
-        
-            board = MbedBoard.chooseBoard()
-        
-            # start gdbserver
-            gdb = GDBServer(board, 3333)
-        
-        gdb server:
-        
-        ::
-        
-            arm-none-eabi-gdb basic.elf
-        
-            <gdb> target remote localhost:3333
-            <gdb> load
-            <gdb> continue
-        
-        Architecture
-        ------------
-        Target
-        ~~~~~~
-        
-        A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
-        ``readMemory``, etc. You can inherit from Target to implement your own methods.
-        
-        Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
-        
-        Transport
-        ~~~~~~~~~
-        
-        Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
-        Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
-        
-        You can inherit from ``Transport`` and implement your own methods.
-        Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
-        
-        Flash
-        ~~~~~
-        
-        Contains flash algorithm in order to flash a new binary into the target.
-        
-        gdbserver
-        ~~~~~~~~~
-        Start a GDB server. The server listens on a specific port. You can then
-        connect a GDB client to it and debug/program the target.
-        
-        Then you can debug a board which is composed by an interface, a target, a transport and a flash
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python
+Metadata-Version: 1.1
+Name: pyOCD
+Version: 0.9.0
+Summary: CMSIS-DAP debugger for Python
+Home-page: https://github.com/mbedmicro/pyOCD
+Author: Martin Kojtal, Russ Butler
+Author-email: martin.kojtal@arm.com, russ.butler@arm.com
+License: Apache 2.0
+Description: pyOCD
+        =====
+        
+        pyOCD is an Open Source python 2.7 based library for programming and debugging 
+        ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
+        supported.
+        
+        You can use the following interfaces:
+        
+        #. From a python interpretor:
+        
+           -  halt, step, resume execution
+           -  read/write memory
+           -  read/write block memory
+           -  read-write core register
+           -  set/remove hardware breakpoints
+           -  flash new binary
+           -  reset
+        
+        #. From a GDB client, you have all the features provided by gdb:
+        
+           -  load a .elf file
+           -  read/write memory
+           -  read/write core register
+           -  set/remove hardware breakpoints
+           -  high level stepping
+           -  ...
+        
+        Installation
+        ------------
+        
+        The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
+        
+        .. code:: shell
+        
+            $ pip install --pre -U pyocd
+        
+        To install the latest development version (master branch), you can do
+        the following:
+        
+        .. code:: shell
+        
+            $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
+        
+        Note that you may run into permissions issues running these commands.
+        You have a few options here:
+        
+        #. Run with ``sudo -H`` to install pyOCD and dependencies globally
+        #. Specify the ``--user`` option to install local to your user
+        #. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
+           local to a specific project working set.
+        
+        You can also install from source by cloning the git repository and running
+        
+        .. code:: shell
+        
+            python setup.py install
+        
+        Standalone GDB Server
+        ---------------------
+        
+        When you install pyOCD via pip, you should be able to execute the
+        following in order to start a GDB server powered by pyOCD:
+        
+        .. code:: shell
+        
+            pyocd-gdbserver
+        
+        You can get additional help by running ``pyocd-gdbserver --help``.
+        
+        Recommended GDB and IDE setup
+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+        
+        The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
+        To view register the Embedded System Register Viewer plugin can be used.
+        These can be installed from inside eclipse using the following links:
+        GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
+        Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
+        
+        The pyOCD gdb server executable will run as a drop in place replacement for
+        OpenOCD. If a supported mbed development board is being debugged the target
+        does not need to be specified, as pyOCD will automatically determine this.
+        If an external processor is being debugged then ``-t [processor]`` must
+        be added to the command line. For more information on setup see
+        `this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
+        
+        Development Setup
+        -----------------
+        
+        PyOCD developers are recommended to setup a working environment using
+        `virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
+        the code, you can setup a virtualenv and install the PyOCD
+        dependencies for the current platform by doing the following:
+        
+        .. code:: console
+        
+            $ virtualenv env
+            $ source env/bin/activate
+            $ pip install -r dev-requirements.txt
+        
+        On Windows, the virtualenv would be activated by executing
+        ``env\Scripts\activate``.
+        
+        To run the unittests, you can execute the following.  Because of how
+        nose searches for tests, specifying the directory is important as it
+        will otherwise attempt to run non-unit tests as well (which will
+        hang).
+        
+        .. code:: console
+        
+            $ nosetests pyOCD/tests
+        
+        To get code coverage results, do the following:
+        
+        .. code:: console
+        
+            $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
+            $ firefox cover/index.html
+        
+        Examples
+        --------
+        
+        Tests
+        ~~~~~
+        
+        A series of tests are provided in the test directory:
+        
+        -  basic\_test.py: a simple test that checks:
+        
+           -  read/write core registers
+           -  read/write memory
+           -  stop/resume/step the execution
+           -  reset the target
+           -  erase pages
+           -  flash a binary
+            
+        -  gdb\_test.py: launch a gdbserver
+        -  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
+        
+           -  "-p", "--port", help = "Write the port number that GDB server will open."
+           -  "-b", "--board", help="Connect to board by board id."
+           -  "-l", "--list", help = "List all connected boards."
+           -  "-d", "--debug", help = "Set the level of system logging output."
+           -  "-t", "--target", help = "Override target to debug."
+           -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
+           -  "-r", "--reset-break", help = "Halt the target when reset."
+           -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
+           -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
+           -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
+           -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
+           -  "-ce", "--chip\_erase", help="Use chip erase when programming."
+           -  "-se", "--sector\_erase", help="Use sector erase when programming."
+           -  "-hp", "--hide\_progress", help = "Don't display programming progress."
+           -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
+        
+        Hello World example code
+        ~~~~~~~~~~~~~~~~~~~~~~~~
+        
+        .. code:: python
+        
+            from pyOCD.board import MbedBoard
+        
+            import logging
+            logging.basicConfig(level=logging.INFO)
+        
+            board = MbedBoard.chooseBoard()
+        
+            target = board.target
+            flash = board.flash
+            target.resume()
+            target.halt()
+        
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #    pc: 0xA64
+        
+            target.step()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #    pc: 0xA30
+        
+            target.step()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0xA32
+        
+            flash.flashBinary("binaries/l1_lpc1768.bin")
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0x10000000
+        
+            target.reset()
+            target.halt()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0xAAC
+        
+            board.uninit()
+        
+        GDB server example
+        ~~~~~~~~~~~~~~~~~~
+        
+        Python:
+        
+        .. code:: python
+        
+            from pyOCD.gdbserver import GDBServer
+            from pyOCD.board import MbedBoard
+        
+            import logging
+            logging.basicConfig(level=logging.INFO)
+        
+            board = MbedBoard.chooseBoard()
+        
+            # start gdbserver
+            gdb = GDBServer(board, 3333)
+        
+        gdb server:
+        
+        ::
+        
+            arm-none-eabi-gdb basic.elf
+        
+            <gdb> target remote localhost:3333
+            <gdb> load
+            <gdb> continue
+        
+        Architecture
+        ------------
+        Target
+        ~~~~~~
+        
+        A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
+        ``readMemory``, etc. You can inherit from Target to implement your own methods.
+        
+        Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
+        
+        Transport
+        ~~~~~~~~~
+        
+        Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
+        Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
+        
+        You can inherit from ``Transport`` and implement your own methods.
+        Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
+        
+        Flash
+        ~~~~~
+        
+        Contains flash algorithm in order to flash a new binary into the target.
+        
+        gdbserver
+        ~~~~~~~~~
+        Start a GDB server. The server listens on a specific port. You can then
+        connect a GDB client to it and debug/program the target.
+        
+        Then you can debug a board which is composed by an interface, a target, a transport and a flash
+        
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python
```

### Comparing `pyOCD-0.8.1a1/pyOCD/board/mbed_board.py` & `pyOCD-0.9.0/pyOCD/board/mbed_board.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,269 +1,278 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import sys, os
-import logging, array
-
-from time import sleep
-from board import Board
-from pyOCD.pyDAPAccess import DAPAccess
-
-class BoardInfo(object):
-    def __init__(self, name, target, binary):
-        self.name = name
-        self.target = target
-        self.binary = binary
-
-BOARD_ID_TO_INFO = {
-              # Note: please keep board list sorted by ID!
-              #
-              # Board ID            Board Name              Target              Test Binary
-                "0200": BoardInfo(  "FRDM-KL25Z",           "kl25z",            "l1_kl25z.bin"          ),
-                "0203": BoardInfo(  "TWR-KL28Z72M",         "kl28z",            "l1_kl28z.bin",         ),
-                "0205": BoardInfo(  "FRDM-KL28Z",           "kl28z",            "l1_kl28z.bin",         ),
-                "0206": BoardInfo(  "TWR-KE18F",            "ke18f16",          "l1_ke18f16.bin",       ),
-                "0210": BoardInfo(  "FRDM-KL05Z",           "kl05z",            "l1_kl05z.bin",         ),
-                "0213": BoardInfo(  "FRDM-KE15Z",           "ke15z7",           "l1_ke15z7.bin",        ),
-                "0214": BoardInfo(  "Hexiwear",             "k64f",             "l1_k64f.bin",          ),
-                "0215": BoardInfo(  "HVP-KE18F",            "ke18f16",          "l1_ke18f16.bin",       ),
-                "0220": BoardInfo(  "FRDM-KL46Z",           "kl46z",            "l1_kl46z.bin",         ),
-                "0230": BoardInfo(  "FRDM-K20D50M",         "k20d50m",          "l1_k20d50m.bin",       ),
-                "0231": BoardInfo(  "FRDM-K22F",            "k22f",             "l1_k22f.bin",          ),
-                "0240": BoardInfo(  "FRDM-K64F",            "k64f",             "l1_k64f.bin",          ),
-                "0250": BoardInfo(  "FRDM-KL02Z",           "kl02z",            "l1_kl02z.bin",         ),
-                "0260": BoardInfo(  "FRDM-KL26Z",           "kl26z",            "l1_kl26z.bin",         ),
-                "0261": BoardInfo(  "FRDM-KL27Z",           "kl27z",            "l1_kl27z.bin",         ),
-                "0262": BoardInfo(  "FRDM-KL43Z",           "kl43z4",           "l1_kl26z.bin",         ),
-                "0290": BoardInfo(  "FRDM-KW40Z",           "kw40z4",           "l1_kw40z.bin",         ),
-                "0298": BoardInfo(  "FRDM-KV10Z",           "kv10z7",           "l1_kl25z.bin"          ),
-                "0300": BoardInfo(  "TWR-KV11Z75M",         "kv11z7",           "l1_kl25z.bin"          ),
-                "0311": BoardInfo(  "FRDM-K66F",            "k66f18",           "l1_k66f.bin",          ),
-                "0320": BoardInfo(  "FRDM-KW01Z9032",       "kw01z4",           "l1_kl26z.bin"          ),
-                "0321": BoardInfo(  "USB-KW01Z",            "kw01z4",           "l1_kl25z.bin"          ),
-                "0324": BoardInfo(  "USB-KW40Z",            "kw40z4",           "l1_kl25z.bin"          ),
-                "0340": BoardInfo(  "FRDM-K82F",            "k82f25615",        "l1_k64f.bin",          ),
-                "0341": BoardInfo(  "FRDM-KV31Z",           "kv31f12",          "l1_kl25z.bin"          ),
-                "0400": BoardInfo(  "maxwsnenv",            "maxwsnenv",        "l1_maxwsnenv.bin",     ),
-                "0405": BoardInfo(  "max32600mbed",         "max32600mbed",     "l1_max32600mbed.bin",  ),
-                "0824": BoardInfo(  "LPCXpresso824-MAX",    "lpc824",           "l1_lpc824.bin",        ),
-                "1010": BoardInfo(  "mbed NXP LPC1768",     "lpc1768",          "l1_lpc1768.bin",       ),
-                "1017": BoardInfo(  "mbed HRM1017",         "nrf51",            "l1_nrf51.bin",         ),
-                "1018": BoardInfo(  "Switch-Science-mbed-LPC824", "lpc824",     "l1_lpc824.bin",        ),
-                "1019": BoardInfo(  "mbed TY51822r3",       "nrf51",            "l1_nrf51.bin",         ),
-                "1040": BoardInfo(  "mbed NXP LPC11U24",    "lpc11u24",         "l1_lpc11u24.bin",      ),
-                "1050": BoardInfo(  "NXP LPC800-MAX",       "lpc800",           "l1_lpc800.bin",        ),
-                "1060": BoardInfo(  "EA-LPC4088",           "lpc4088qsb",       "l1_lpc4088qsb.bin",    ),
-                "1062": BoardInfo(  "EA-LPC4088-Display-Module", "lpc4088dm",   "l1_lpc4088dm.bin",     ),
-                "1070": BoardInfo(  "nRF51822-mKIT",        "nrf51",            "l1_nrf51.bin",         ),
-                "1080": BoardInfo(  "DT01 + MB2001",        "stm32f103rc",      "l1_stm32f103rc.bin",   ),
-                "1090": BoardInfo(  "DT01 + MB00xx",        "stm32f051",        "l1_stm32f051.bin",     ),
-                "1090": BoardInfo(  "RedBearLab-nRF51822",  "nrf51",            "l1_nrf51.bin",         ),
-                "1095": BoardInfo(  "RedBearLab-BLE-Nano",  "nrf51",            "l1_nrf51.bin",         ),
-                "1100": BoardInfo(  "nRF51-DK",             "nrf51",            "l1_nrf51-dk.bin",      ),
-                "1101": BoardInfo(  "nRF52-DK",             "nrf52",            "l1_nrf52-dk.bin",      ),
-                "1200": BoardInfo(  "NCS36510-EVK",         "ncs36510",         "l1_ncs36510-evk.bin",  ),
-                "1114": BoardInfo(  "mbed LPC1114FN28",     "lpc11xx_32",       "l1_mbed_LPC1114FN28.bin",),
-                "1120": BoardInfo(  "nRF51-Dongle",         "nrf51",            "l1_nrf51.bin",         ),
-                "1234": BoardInfo(  "u-blox-C027",          "lpc1768",          "l1_lpc1768.bin",       ),
-                "1600": BoardInfo(  "Bambino 210",          "lpc4330",          "l1_lpc4330.bin",       ),
-                "1605": BoardInfo(  "Bambino 210E",         "lpc4330",          "l1_lpc4330.bin",       ),
-                "2201": BoardInfo(  "WIZwik_W7500",         "w7500",            "l1_w7500mbed.bin",     ),
-                "9004": BoardInfo(  "Arch Pro",             "lpc1768",          "l1_lpc1768.bin",       ),
-                "9009": BoardInfo(  "Arch BLE",             "nrf51",            "l1_nrf51.bin",         ),
-                "9012": BoardInfo(  "Seeed Tiny BLE",       "nrf51",            "l1_nrf51.bin",         ),
-                "9900": BoardInfo(  "Microbit",             "nrf51",            "l1_microbit.bin",      ),
-                "C004": BoardInfo(  "tinyK20",              "k20d50m",          "l1_k20d50m.bin",       ),
-              }
-
-mbed_vid = 0x0d28
-mbed_pid = 0x0204
-
-class MbedBoard(Board):
-    """
-    This class inherits from Board and is specific to mbed boards.
-    Particularly, this class allows you to dynamically determine
-    the type of all boards connected based on the id board
-    """
-    def __init__(self, link, target=None, frequency=1000000):
-        """
-        Init the board
-        """
-        self.native_target = None
-        self.test_binary = None
-        unique_id = link.get_unique_id()
-        board_id = unique_id[0:4]
-        self.name = "Unknown Board"
-        if board_id in BOARD_ID_TO_INFO:
-            board_info = BOARD_ID_TO_INFO[board_id]
-            self.name = board_info.name
-            self.native_target = board_info.target
-            self.test_binary = board_info.binary
-
-        # Unless overridden use the native target
-        if target is None:
-            target = self.native_target
-
-        if target is None:
-            logging.warning("Unsupported board found %s", board_id)
-            target = "cortex_m"
-
-        super(MbedBoard, self).__init__(target, target, link, frequency)
-        self.unique_id = unique_id
-        self.target_type = target
-
-    def getUniqueID(self):
-        """
-        Return the unique id of the board
-        """
-        return self.unique_id
-
-    def getTargetType(self):
-        """
-        Return the type of the board
-        """
-        return self.target_type
-
-    def getTestBinary(self):
-        """
-        Return name of test binary file
-        """
-        return self.test_binary
-
-    def getBoardName(self):
-        """
-        Return board name
-        """
-        return self.name
-
-    def getInfo(self):
-        """
-        Return info on the board
-        """
-        return self.name + " [" + self.target_type + "]"
-
-    @staticmethod
-    def listConnectedBoards(dap_class=DAPAccess):
-        """
-        List the connected board info
-        """
-        all_mbeds = MbedBoard.getAllConnectedBoards(dap_class, close=True,
-                                                    blocking=False)
-        index = 0
-        if len(all_mbeds) > 0:
-            for mbed in all_mbeds:
-                print("%d => %s boardId => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'), mbed.unique_id))
-                index += 1
-        else:
-            print("No available boards are connected")
-
-    @staticmethod
-    def getAllConnectedBoards(dap_class=DAPAccess, close=False, blocking=True,
-                              target_override=None, frequency=1000000):
-        """
-        Return an array of all mbed boards connected
-        """
-
-        mbed_list = []
-        while True:
-
-            connected_daps = dap_class.get_connected_devices()
-            for dap_access in connected_daps:
-                new_mbed = MbedBoard(dap_access, target_override, frequency)
-                mbed_list.append(new_mbed)
-
-            #TODO - handle exception on open
-            if not close:
-                for dap_access in connected_daps:
-                    dap_access.open()
-
-            if not blocking:
-                break
-            elif len(mbed_list) > 0:
-                break
-            else:
-                sleep(0.01)
-            assert len(mbed_list) == 0
-
-        return mbed_list
-
-    @staticmethod
-    def chooseBoard(dap_class=DAPAccess, blocking=True, return_first=False,
-                    board_id=None, target_override=None, frequency=1000000,
-                    init_board=True):
-        """
-        Allow you to select a board among all boards connected
-        """
-        all_mbeds = MbedBoard.getAllConnectedBoards(dap_class, True, blocking,
-                                                    target_override, frequency)
-
-        # If a board ID is specified remove all other boards
-        if board_id != None:
-            new_mbed_list = []
-            for mbed in all_mbeds:
-                if mbed.unique_id == (board_id):
-                    new_mbed_list.append(mbed)
-            assert len(new_mbed_list) <= 1
-            all_mbeds = new_mbed_list
-
-        # Return if no boards are connected
-        if all_mbeds == None or len(all_mbeds) <= 0:
-            if board_id is None:
-                print("No connected boards")
-            else:
-                print("Board %s is not connected" % board_id)
-            return None # No boards to close so it is safe to return
-
-        # Select first board
-        if return_first:
-            all_mbeds = all_mbeds[0:1]
-
-        # Ask use to select boards if there is more than 1 left
-        if len(all_mbeds) > 1:
-            index = 0
-            print "id => usbinfo | boardname"
-            for mbed in all_mbeds:
-                print "%d => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'))
-                index += 1
-            while True:
-                print "input id num to choice your board want to connect"
-                line = sys.stdin.readline()
-                valid = False
-                try:
-                    ch = int(line)
-                    valid = 0 <= ch < len(all_mbeds)
-                except ValueError:
-                    pass
-                if not valid:
-                    logging.info("BAD CHOICE: %s", line)
-                    index = 0
-                    for mbed in all_mbeds:
-                        print "%d => %s" % (index, mbed.getInfo())
-                        index += 1
-                else:
-                    break
-            all_mbeds = all_mbeds[ch:ch + 1]
-
-        assert len(all_mbeds) == 1
-        mbed = all_mbeds[0]
-        mbed.link.open()
-        if init_board:
-            try:
-                mbed.init()
-            except:
-                mbed.link.close()
-                raise
-        return mbed
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import sys, os
+import logging, array
+
+from time import sleep
+from board import Board
+from pyOCD.pyDAPAccess import DAPAccess
+
+class BoardInfo(object):
+    def __init__(self, name, target, binary):
+        self.name = name
+        self.target = target
+        self.binary = binary
+
+BOARD_ID_TO_INFO = {
+              # Note: please keep board list sorted by ID!
+              #
+              # Board ID            Board Name              Target              Test Binary
+                "0200": BoardInfo(  "FRDM-KL25Z",           "kl25z",            "l1_kl25z.bin"          ),
+                "0201": BoardInfo(  "FRDM-KW41Z",           "kw41z4",           "l1_kw41z4.bin"         ),
+                "0202": BoardInfo(  "USB-KW41Z",            "kw41z4",           "l1_kw41z4.bin"         ),
+                "0203": BoardInfo(  "TWR-KL28Z72M",         "kl28z",            "l1_kl28z.bin",         ),
+                "0204": BoardInfo(  "FRDM-KL02Z",           "kl02z",            "l1_kl02z.bin",         ),
+                "0205": BoardInfo(  "FRDM-KL28Z",           "kl28z",            "l1_kl28z.bin",         ),
+                "0215": BoardInfo(  "FRDM-KL28ZEM",         "kl28z",            "l1_kl28z.bin",         ),
+                "0206": BoardInfo(  "TWR-KE18F",            "ke18f16",          "l1_ke18f16.bin",       ),
+                "0210": BoardInfo(  "FRDM-KL05Z",           "kl05z",            "l1_kl05z.bin",         ),
+                "0213": BoardInfo(  "FRDM-KE15Z",           "ke15z7",           "l1_ke15z7.bin",        ),
+                "0214": BoardInfo(  "Hexiwear",             "k64f",             "l1_k64f.bin",          ),
+                "0216": BoardInfo(  "HVP-KE18F",            "ke18f16",          "l1_ke18f16.bin",       ),
+                "0217": BoardInfo(  "FRDM-K82F",            "k82f25615",        "l1_k82f.bin",          ),
+                "0218": BoardInfo(  "FRDM-KL82Z",           "kl82z7",           "l1_kl82z.bin",         ),
+                "0220": BoardInfo(  "FRDM-KL46Z",           "kl46z",            "l1_kl46z.bin",         ),
+                "0224": BoardInfo(  "FRDM-K28F",            "k28f15",           "l1_k28f.bin",          ),
+                "0230": BoardInfo(  "FRDM-K20D50M",         "k20d50m",          "l1_k20d50m.bin",       ),
+                "0231": BoardInfo(  "FRDM-K22F",            "k22f",             "l1_k22f.bin",          ),
+                "0240": BoardInfo(  "FRDM-K64F",            "k64f",             "l1_k64f.bin",          ),
+                "0260": BoardInfo(  "FRDM-KL26Z",           "kl26z",            "l1_kl26z.bin",         ),
+                "0261": BoardInfo(  "FRDM-KL27Z",           "kl27z4",            "l1_kl27z.bin",         ),
+                "0262": BoardInfo(  "FRDM-KL43Z",           "kl43z4",           "l1_kl26z.bin",         ),
+                "0290": BoardInfo(  "FRDM-KW40Z",           "kw40z4",           "l1_kw40z.bin",         ),
+                "0298": BoardInfo(  "FRDM-KV10Z",           "kv10z7",           "l1_kl25z.bin"          ),
+                "0300": BoardInfo(  "TWR-KV11Z75M",         "kv11z7",           "l1_kl25z.bin"          ),
+                "0311": BoardInfo(  "FRDM-K66F",            "k66f18",           "l1_k66f.bin",          ),
+                "0320": BoardInfo(  "FRDM-KW01Z9032",       "kw01z4",           "l1_kl26z.bin"          ),
+                "0321": BoardInfo(  "USB-KW01Z",            "kw01z4",           "l1_kl25z.bin"          ),
+                "0324": BoardInfo(  "USB-KW40Z",            "kw40z4",           "l1_kl25z.bin"          ),
+                "0400": BoardInfo(  "maxwsnenv",            "maxwsnenv",        "l1_maxwsnenv.bin",     ),
+                "0405": BoardInfo(  "max32600mbed",         "max32600mbed",     "l1_max32600mbed.bin",  ),
+                "0824": BoardInfo(  "LPCXpresso824-MAX",    "lpc824",           "l1_lpc824.bin",        ),
+                "1054": BoardInfo(  "LPCXpresso54114-MAX",  "lpc54114",         "l1_lpc54114.bin",      ),
+                "1010": BoardInfo(  "mbed NXP LPC1768",     "lpc1768",          "l1_lpc1768.bin",       ),
+                "1017": BoardInfo(  "mbed HRM1017",         "nrf51",            "l1_nrf51.bin",         ),
+                "1018": BoardInfo(  "Switch-Science-mbed-LPC824", "lpc824",     "l1_lpc824.bin",        ),
+                "1019": BoardInfo(  "mbed TY51822r3",       "nrf51",            "l1_nrf51.bin",         ),
+                "1040": BoardInfo(  "mbed NXP LPC11U24",    "lpc11u24",         "l1_lpc11u24.bin",      ),
+                "1050": BoardInfo(  "NXP LPC800-MAX",       "lpc800",           "l1_lpc800.bin",        ),
+                "1060": BoardInfo(  "EA-LPC4088",           "lpc4088qsb",       "l1_lpc4088qsb.bin",    ),
+                "1062": BoardInfo(  "EA-LPC4088-Display-Module", "lpc4088dm",   "l1_lpc4088dm.bin",     ),
+                "1070": BoardInfo(  "nRF51822-mKIT",        "nrf51",            "l1_nrf51.bin",         ),
+                "1080": BoardInfo(  "DT01 + MB2001",        "stm32f103rc",      "l1_stm32f103rc.bin",   ),
+                "1090": BoardInfo(  "DT01 + MB00xx",        "stm32f051",        "l1_stm32f051.bin",     ),
+                "1090": BoardInfo(  "RedBearLab-nRF51822",  "nrf51",            "l1_nrf51.bin",         ),
+                "1095": BoardInfo(  "RedBearLab-BLE-Nano",  "nrf51",            "l1_nrf51.bin",         ),
+                "1100": BoardInfo(  "nRF51-DK",             "nrf51",            "l1_nrf51-dk.bin",      ),
+                "1101": BoardInfo(  "nRF52-DK",             "nrf52",            "l1_nrf52-dk.bin",      ),
+                "1102": BoardInfo(  "nRF52840-DK",          "nrf52840",         "l1_nrf52840-dk.bin",   ),
+                "1200": BoardInfo(  "NCS36510-EVK",         "ncs36510",         "l1_ncs36510-evk.bin",  ),
+                "1114": BoardInfo(  "mbed LPC1114FN28",     "lpc11xx_32",       "l1_mbed_LPC1114FN28.bin",),
+                "1120": BoardInfo(  "nRF51-Dongle",         "nrf51",            "l1_nrf51.bin",         ),
+                "1234": BoardInfo(  "u-blox-C027",          "lpc1768",          "l1_lpc1768.bin",       ),
+                "1600": BoardInfo(  "Bambino 210",          "lpc4330",          "l1_lpc4330.bin",       ),
+                "1605": BoardInfo(  "Bambino 210E",         "lpc4330",          "l1_lpc4330.bin",       ),
+                "2201": BoardInfo(  "WIZwik_W7500",         "w7500",            "l1_w7500mbed.bin",     ),
+                "4600": BoardInfo(  "Realtek RTL8195AM",    "rtl8195am",        "l1_rtl8195am.bin",     ),
+                "7402": BoardInfo(  "mbed 6LoWPAN Border Router HAT", "k64f",   "l1_k64f.bin",          ),
+                "9004": BoardInfo(  "Arch Pro",             "lpc1768",          "l1_lpc1768.bin",       ),
+                "9009": BoardInfo(  "Arch BLE",             "nrf51",            "l1_nrf51.bin",         ),
+                "9012": BoardInfo(  "Seeed Tiny BLE",       "nrf51",            "l1_nrf51.bin",         ),
+                "9900": BoardInfo(  "Microbit",             "nrf51",            "l1_microbit.bin",      ),
+                "C004": BoardInfo(  "tinyK20",              "k20d50m",          "l1_k20d50m.bin",       ),
+                "C006": BoardInfo(  "VBLUno51",             "nrf51",            "l1_nrf51.bin",         ),
+              }
+
+mbed_vid = 0x0d28
+mbed_pid = 0x0204
+
+class MbedBoard(Board):
+    """
+    This class inherits from Board and is specific to mbed boards.
+    Particularly, this class allows you to dynamically determine
+    the type of all boards connected based on the id board
+    """
+    def __init__(self, link, target=None, frequency=1000000):
+        """
+        Init the board
+        """
+        self.native_target = None
+        self.test_binary = None
+        unique_id = link.get_unique_id()
+        board_id = unique_id[0:4]
+        self.name = "Unknown Board"
+        if board_id in BOARD_ID_TO_INFO:
+            board_info = BOARD_ID_TO_INFO[board_id]
+            self.name = board_info.name
+            self.native_target = board_info.target
+            self.test_binary = board_info.binary
+
+        # Unless overridden use the native target
+        if target is None:
+            target = self.native_target
+
+        if target is None:
+            logging.warning("Unsupported board found %s", board_id)
+            target = "cortex_m"
+
+        super(MbedBoard, self).__init__(target, link, frequency)
+        self.unique_id = unique_id
+        self.target_type = target
+
+    def getUniqueID(self):
+        """
+        Return the unique id of the board
+        """
+        return self.unique_id
+
+    def getTargetType(self):
+        """
+        Return the type of the board
+        """
+        return self.target_type
+
+    def getTestBinary(self):
+        """
+        Return name of test binary file
+        """
+        return self.test_binary
+
+    def getBoardName(self):
+        """
+        Return board name
+        """
+        return self.name
+
+    def getInfo(self):
+        """
+        Return info on the board
+        """
+        return self.name + " [" + self.target_type + "]"
+
+    @staticmethod
+    def listConnectedBoards(dap_class=DAPAccess):
+        """
+        List the connected board info
+        """
+        all_mbeds = MbedBoard.getAllConnectedBoards(dap_class, close=True,
+                                                    blocking=False)
+        index = 0
+        if len(all_mbeds) > 0:
+            for mbed in all_mbeds:
+                print("%d => %s boardId => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'), mbed.unique_id))
+                index += 1
+        else:
+            print("No available boards are connected")
+
+    @staticmethod
+    def getAllConnectedBoards(dap_class=DAPAccess, close=False, blocking=True,
+                              target_override=None, frequency=1000000):
+        """
+        Return an array of all mbed boards connected
+        """
+
+        mbed_list = []
+        while True:
+
+            connected_daps = dap_class.get_connected_devices()
+            for dap_access in connected_daps:
+                new_mbed = MbedBoard(dap_access, target_override, frequency)
+                mbed_list.append(new_mbed)
+
+            #TODO - handle exception on open
+            if not close:
+                for dap_access in connected_daps:
+                    dap_access.open()
+
+            if not blocking:
+                break
+            elif len(mbed_list) > 0:
+                break
+            else:
+                sleep(0.01)
+            assert len(mbed_list) == 0
+
+        return mbed_list
+
+    @staticmethod
+    def chooseBoard(dap_class=DAPAccess, blocking=True, return_first=False,
+                    board_id=None, target_override=None, frequency=1000000,
+                    init_board=True):
+        """
+        Allow you to select a board among all boards connected
+        """
+        all_mbeds = MbedBoard.getAllConnectedBoards(dap_class, True, blocking,
+                                                    target_override, frequency)
+
+        # If a board ID is specified remove all other boards
+        if board_id != None:
+            new_mbed_list = []
+            for mbed in all_mbeds:
+                if mbed.unique_id == (board_id):
+                    new_mbed_list.append(mbed)
+            assert len(new_mbed_list) <= 1
+            all_mbeds = new_mbed_list
+
+        # Return if no boards are connected
+        if all_mbeds == None or len(all_mbeds) <= 0:
+            if board_id is None:
+                print("No connected boards")
+            else:
+                print("Board %s is not connected" % board_id)
+            return None # No boards to close so it is safe to return
+
+        # Select first board
+        if return_first:
+            all_mbeds = all_mbeds[0:1]
+
+        # Ask use to select boards if there is more than 1 left
+        if len(all_mbeds) > 1:
+            index = 0
+            print "id => usbinfo | boardname"
+            for mbed in all_mbeds:
+                print "%d => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'))
+                index += 1
+            while True:
+                print "input id num to choice your board want to connect"
+                line = sys.stdin.readline()
+                valid = False
+                try:
+                    ch = int(line)
+                    valid = 0 <= ch < len(all_mbeds)
+                except ValueError:
+                    pass
+                if not valid:
+                    logging.info("BAD CHOICE: %s", line)
+                    index = 0
+                    for mbed in all_mbeds:
+                        print "%d => %s" % (index, mbed.getInfo())
+                        index += 1
+                else:
+                    break
+            all_mbeds = all_mbeds[ch:ch + 1]
+
+        assert len(all_mbeds) == 1
+        mbed = all_mbeds[0]
+        mbed.link.open()
+        if init_board:
+            try:
+                mbed.init()
+            except:
+                mbed.link.close()
+                raise
+        return mbed
```

### Comparing `pyOCD-0.8.1a1/pyOCD/board/__init__.py` & `pyOCD-0.9.0/pyOCD/gdbserver/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import mbed_board
-from mbed_board import MbedBoard
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from gdbserver import GDBServer
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/ap.py` & `pyOCD-0.9.0/pyOCD/coresight/ap.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,355 +1,397 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from ..pyDAPAccess import DAPAccess
-from .rom_table import ROMTable
-from .dap import (AP_REG, _ap_addr_to_reg, READ, WRITE, AP_ACC, APSEL_SHIFT, LOG_DAP)
-from ..utility import conversion
-import logging
-
-AP_ROM_TABLE_ADDR_REG = 0xf8
-AP_ROM_TABLE_FORMAT_MASK = 0x2
-AP_ROM_TABLE_ENTRY_PRESENT_MASK = 0x1
-
-MEM_AP_IDR_TO_WRAP_SIZE = {
-    0x24770011 : 0x1000,    # Used on m4 & m3 - Documented in arm_cortexm4_processor_trm_100166_0001_00_en.pdf
-                            #                   and arm_cortexm3_processor_trm_100165_0201_00_en.pdf
-    0x44770001 : 0x400,     # Used on m1 - Documented in DDI0413D_cortexm1_r1p0_trm.pdf
-    0x04770031 : 0x400,     # Used on m0+? at least on KL25Z, KL46, LPC812
-    0x04770021 : 0x400,     # Used on m0? used on nrf51, lpc11u24
-    0x64770001 : 0x400,     # Used on m7
-    0x74770001 : 0x400,     # Used on m0+ on KL28Z
-    }
-
-# AP Control and Status Word definitions
-CSW_SIZE     =  0x00000007
-CSW_SIZE8    =  0x00000000
-CSW_SIZE16   =  0x00000001
-CSW_SIZE32   =  0x00000002
-CSW_ADDRINC  =  0x00000030
-CSW_NADDRINC =  0x00000000
-CSW_SADDRINC =  0x00000010
-CSW_PADDRINC =  0x00000020
-CSW_DBGSTAT  =  0x00000040
-CSW_TINPROG  =  0x00000080
-CSW_HPROT    =  0x02000000
-CSW_MSTRTYPE =  0x20000000
-CSW_MSTRCORE =  0x00000000
-CSW_MSTRDBG  =  0x20000000
-CSW_RESERVED =  0x01000000
-
-CSW_VALUE = (CSW_RESERVED | CSW_MSTRDBG | CSW_HPROT | CSW_DBGSTAT | CSW_SADDRINC)
-
-TRANSFER_SIZE = {8: CSW_SIZE8,
-                 16: CSW_SIZE16,
-                 32: CSW_SIZE32
-                 }
-
-class AccessPort(object):
-    def __init__(self, dp, ap_num):
-        self.dp = dp
-        self.ap_num = ap_num
-        self.link = dp.link
-        self.idr = 0
-        self.rom_addr = 0
-        self.has_rom_table = False
-        self.rom_table = None
-        self.inited_primary = False
-        self.inited_secondary = False
-        if LOG_DAP:
-            self.logger = self.dp.logger.getChild('ap%d' % ap_num)
-
-    def init(self, bus_accessible=True):
-        if not self.inited_primary:
-            self.idr = self.read_reg(AP_REG['IDR'])
-
-            # Init ROM table
-            self.rom_addr = self.read_reg(AP_ROM_TABLE_ADDR_REG)
-            self.has_rom_table = (self.rom_addr != 0xffffffff) and ((self.rom_addr & AP_ROM_TABLE_ENTRY_PRESENT_MASK) != 0)
-            self.rom_addr &= 0xfffffffc # clear format and present bits
-
-            self.inited_primary = True
-        if not self.inited_secondary and self.has_rom_table and bus_accessible:
-            self.init_rom_table()
-            self.inited_secondary = True
-
-    def init_rom_table(self):
-        self.rom_table = ROMTable(self)
-        self.rom_table.init()
-
-    def read_reg(self, addr, now=True):
-        return self.dp.readAP((self.ap_num << APSEL_SHIFT) | addr, now)
-
-    def write_reg(self, addr, data):
-        self.dp.writeAP((self.ap_num << APSEL_SHIFT) | addr, data)
-
-class MEM_AP(AccessPort):
-    def __init__(self, dp, ap_num):
-        super(MEM_AP, self).__init__(dp, ap_num)
-
-        # Default to the smallest size supported by all targets.
-        # A size smaller than the supported size will decrease performance
-        # due to the extra address writes, but will not create any
-        # read/write errors.
-        self.auto_increment_page_size = 0x400
-
-    def init(self, bus_accessible=True):
-        super(MEM_AP, self).init(bus_accessible)
-
-        # Look up the page size based on AP ID.
-        try:
-            self.auto_increment_page_size = MEM_AP_IDR_TO_WRAP_SIZE[self.idr]
-        except KeyError:
-            logging.warning("Unknown MEM-AP IDR: 0x%x" % self.idr)
-
-    ## @brief Write a single memory location.
-    #
-    # By default the transfer size is a word
-    def writeMemory(self, addr, data, transfer_size=32):
-        num = self.dp.next_access_number
-        if LOG_DAP:
-            self.logger.info("writeMem:%06d (addr=0x%08x, size=%d) = 0x%08x {", num, addr, transfer_size, data)
-        self.write_reg(AP_REG['CSW'], CSW_VALUE | TRANSFER_SIZE[transfer_size])
-        if transfer_size == 8:
-            data = data << ((addr & 0x03) << 3)
-        elif transfer_size == 16:
-            data = data << ((addr & 0x02) << 3)
-
-        try:
-            self.write_reg(AP_REG['TAR'], addr)
-            self.write_reg(AP_REG['DRW'], data)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-        if LOG_DAP:
-            self.logger.info("writeMem:%06d }", num)
-
-    ## @brief Read a memory location.
-    #
-    # By default, a word will be read.
-    def readMemory(self, addr, transfer_size=32, now=True):
-        num = self.dp.next_access_number
-        if LOG_DAP:
-            self.logger.info("readMem:%06d (addr=0x%08x, size=%d) {", num, addr, transfer_size)
-        res = None
-        try:
-            self.write_reg(AP_REG['CSW'], CSW_VALUE |
-                         TRANSFER_SIZE[transfer_size])
-            self.write_reg(AP_REG['TAR'], addr)
-            result_cb = self.read_reg(AP_REG['DRW'], now=False)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-
-        def readMemCb():
-            try:
-                res = result_cb()
-                if transfer_size == 8:
-                    res = (res >> ((addr & 0x03) << 3) & 0xff)
-                elif transfer_size == 16:
-                    res = (res >> ((addr & 0x02) << 3) & 0xffff)
-                if LOG_DAP:
-                    self.logger.info("readMem:%06d %s(addr=0x%08x, size=%d) -> 0x%08x }", num, "" if now else "...", addr, transfer_size, res)
-            except DAPAccess.Error as error:
-                self._handle_error(error, num)
-                raise
-            return res
-
-        if now:
-            result = readMemCb()
-            return result
-        else:
-            return readMemCb
-
-    # write aligned word ("data" are words)
-    def _writeBlock32(self, addr, data):
-        num = self.dp.next_access_number
-        if LOG_DAP:
-            self.logger.info("_writeBlock32:%06d (addr=0x%08x, size=%d) {", num, addr, len(data))
-        # put address in TAR
-        self.write_reg(AP_REG['CSW'], CSW_VALUE | CSW_SIZE32)
-        self.write_reg(AP_REG['TAR'], addr)
-        try:
-            reg = _ap_addr_to_reg((self.ap_num << APSEL_SHIFT) | WRITE | AP_ACC | AP_REG['DRW'])
-            self.link.reg_write_repeat(len(data), reg, data)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-        if LOG_DAP:
-            self.logger.info("_writeBlock32:%06d }", num)
-
-    # read aligned word (the size is in words)
-    def _readBlock32(self, addr, size):
-        num = self.dp.next_access_number
-        if LOG_DAP:
-            self.logger.info("_readBlock32:%06d (addr=0x%08x, size=%d) {", num, addr, size)
-        # put address in TAR
-        self.write_reg(AP_REG['CSW'], CSW_VALUE | CSW_SIZE32)
-        self.write_reg(AP_REG['TAR'], addr)
-        try:
-            reg = _ap_addr_to_reg((self.ap_num << APSEL_SHIFT) | READ | AP_ACC | AP_REG['DRW'])
-            resp = self.link.reg_read_repeat(size, reg)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-        if LOG_DAP:
-            self.logger.info("_readBlock32:%06d }", num)
-        return resp
-
-    ## @brief Shorthand to write a 32-bit word.
-    def write32(self, addr, value):
-        self.writeMemory(addr, value, 32)
-
-    ## @brief Shorthand to write a 16-bit halfword.
-    def write16(self, addr, value):
-        self.writeMemory(addr, value, 16)
-
-    ## @brief Shorthand to write a byte.
-    def write8(self, addr, value):
-        self.writeMemory(addr, value, 8)
-
-    ## @brief Shorthand to read a 32-bit word.
-    def read32(self, addr, now=True):
-        return self.readMemory(addr, 32, now)
-
-    ## @brief Shorthand to read a 16-bit halfword.
-    def read16(self, addr, now=True):
-        return self.readMemory(addr, 16, now)
-
-    ## @brief Shorthand to read a byte.
-    def read8(self, addr, now=True):
-        return self.readMemory(addr, 8, now)
-
-    ## @brief Read a block of unaligned bytes in memory.
-    # @return an array of byte values
-    def readBlockMemoryUnaligned8(self, addr, size):
-        res = []
-
-        # try to read 8bits data
-        if (size > 0) and (addr & 0x01):
-            mem = self.readMemory(addr, 8)
-            res.append(mem)
-            size -= 1
-            addr += 1
-
-        # try to read 16bits data
-        if (size > 1) and (addr & 0x02):
-            mem = self.readMemory(addr, 16)
-            res.append(mem & 0xff)
-            res.append((mem >> 8) & 0xff)
-            size -= 2
-            addr += 2
-
-        # try to read aligned block of 32bits
-        if (size >= 4):
-            mem = self.readBlockMemoryAligned32(addr, size/4)
-            res += conversion.u32leListToByteList(mem)
-            size -= 4*len(mem)
-            addr += 4*len(mem)
-
-        if (size > 1):
-            mem = self.readMemory(addr, 16)
-            res.append(mem & 0xff)
-            res.append((mem >> 8) & 0xff)
-            size -= 2
-            addr += 2
-
-        if (size > 0):
-            mem = self.readMemory(addr, 8)
-            res.append(mem)
-            size -= 1
-            addr += 1
-
-        return res
-
-    ## @brief Write a block of unaligned bytes in memory.
-    def writeBlockMemoryUnaligned8(self, addr, data):
-        size = len(data)
-        idx = 0
-
-        #try to write 8 bits data
-        if (size > 0) and (addr & 0x01):
-            self.writeMemory(addr, data[idx], 8)
-            size -= 1
-            addr += 1
-            idx += 1
-
-        # try to write 16 bits data
-        if (size > 1) and (addr & 0x02):
-            self.writeMemory(addr, data[idx] | (data[idx+1] << 8), 16)
-            size -= 2
-            addr += 2
-            idx += 2
-
-        # write aligned block of 32 bits
-        if (size >= 4):
-            data32 = conversion.byteListToU32leList(data[idx:idx + (size & ~0x03)])
-            self.writeBlockMemoryAligned32(addr, data32)
-            addr += size & ~0x03
-            idx += size & ~0x03
-            size -= size & ~0x03
-
-        # try to write 16 bits data
-        if (size > 1):
-            self.writeMemory(addr, data[idx] | (data[idx+1] << 8), 16)
-            size -= 2
-            addr += 2
-            idx += 2
-
-        #try to write 8 bits data
-        if (size > 0):
-            self.writeMemory(addr, data[idx], 8)
-            size -= 1
-            addr += 1
-            idx += 1
-
-        return
-
-    ## @brief Write a block of aligned words in memory.
-    def writeBlockMemoryAligned32(self, addr, data):
-        size = len(data)
-        while size > 0:
-            n = self.auto_increment_page_size - (addr & (self.auto_increment_page_size - 1))
-            if size*4 < n:
-                n = (size*4) & 0xfffffffc
-            self._writeBlock32(addr, data[:n/4])
-            data = data[n/4:]
-            size -= n/4
-            addr += n
-        return
-
-    ## @brief Read a block of aligned words in memory.
-    #
-    # @return An array of word values
-    def readBlockMemoryAligned32(self, addr, size):
-        resp = []
-        while size > 0:
-            n = self.auto_increment_page_size - (addr & (self.auto_increment_page_size - 1))
-            if size*4 < n:
-                n = (size*4) & 0xfffffffc
-            resp += self._readBlock32(addr, n/4)
-            size -= n/4
-            addr += n
-        return resp
-
-    def _handle_error(self, error, num):
-        self.dp._handle_error(error, num)
-
-class AHB_AP(MEM_AP):
-    pass
-
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..pyDAPAccess import DAPAccess
+from .rom_table import ROMTable
+from .dap import (AP_REG, _ap_addr_to_reg, READ, WRITE, AP_ACC, APSEL_SHIFT, LOG_DAP)
+from ..utility import conversion
+import logging
+
+AP_ROM_TABLE_ADDR_REG = 0xf8
+AP_ROM_TABLE_FORMAT_MASK = 0x2
+AP_ROM_TABLE_ENTRY_PRESENT_MASK = 0x1
+
+MEM_AP_IDR_TO_WRAP_SIZE = {
+    0x24770011 : 0x1000,    # Used on m4 & m3 - Documented in arm_cortexm4_processor_trm_100166_0001_00_en.pdf
+                            #                   and arm_cortexm3_processor_trm_100165_0201_00_en.pdf
+    0x44770001 : 0x400,     # Used on m1 - Documented in DDI0413D_cortexm1_r1p0_trm.pdf
+    0x04770031 : 0x400,     # Used on m0+? at least on KL25Z, KL46, LPC812
+    0x04770021 : 0x400,     # Used on m0? used on nrf51, lpc11u24
+    0x64770001 : 0x400,     # Used on m7
+    0x74770001 : 0x400,     # Used on m0+ on KL28Z
+    }
+
+# AP Control and Status Word definitions
+CSW_SIZE     =  0x00000007
+CSW_SIZE8    =  0x00000000
+CSW_SIZE16   =  0x00000001
+CSW_SIZE32   =  0x00000002
+CSW_ADDRINC  =  0x00000030
+CSW_NADDRINC =  0x00000000
+CSW_SADDRINC =  0x00000010
+CSW_PADDRINC =  0x00000020
+CSW_DBGSTAT  =  0x00000040
+CSW_TINPROG  =  0x00000080
+CSW_HPROT    =  0x02000000
+CSW_MSTRTYPE =  0x20000000
+CSW_MSTRCORE =  0x00000000
+CSW_MSTRDBG  =  0x20000000
+CSW_RESERVED =  0x01000000
+
+CSW_VALUE = (CSW_RESERVED | CSW_MSTRDBG | CSW_HPROT | CSW_DBGSTAT | CSW_SADDRINC)
+
+TRANSFER_SIZE = {8: CSW_SIZE8,
+                 16: CSW_SIZE16,
+                 32: CSW_SIZE32
+                 }
+
+# Debug Exception and Monitor Control Register
+DEMCR = 0xE000EDFC
+# DWTENA in armv6 architecture reference manual
+DEMCR_TRCENA = (1 << 24)
+
+class AccessPort(object):
+    def __init__(self, dp, ap_num):
+        self.dp = dp
+        self.ap_num = ap_num
+        self.link = dp.link
+        self.idr = 0
+        self.rom_addr = 0
+        self.has_rom_table = False
+        self.rom_table = None
+        self.inited_primary = False
+        self.inited_secondary = False
+        if LOG_DAP:
+            self.logger = self.dp.logger.getChild('ap%d' % ap_num)
+
+    def init(self, bus_accessible=True):
+        if not self.inited_primary:
+            self.idr = self.read_reg(AP_REG['IDR'])
+
+            # Init ROM table
+            self.rom_addr = self.read_reg(AP_ROM_TABLE_ADDR_REG)
+            self.has_rom_table = (self.rom_addr != 0xffffffff) and ((self.rom_addr & AP_ROM_TABLE_ENTRY_PRESENT_MASK) != 0)
+            self.rom_addr &= 0xfffffffc # clear format and present bits
+
+            self.inited_primary = True
+        if not self.inited_secondary and self.has_rom_table and bus_accessible:
+            self.init_rom_table()
+            self.inited_secondary = True
+
+    def init_rom_table(self):
+        self.rom_table = ROMTable(self)
+        self.rom_table.init()
+
+    def read_reg(self, addr, now=True):
+        return self.dp.readAP((self.ap_num << APSEL_SHIFT) | addr, now)
+
+    def write_reg(self, addr, data):
+        self.dp.writeAP((self.ap_num << APSEL_SHIFT) | addr, data)
+
+class MEM_AP(AccessPort):
+    def __init__(self, dp, ap_num):
+        super(MEM_AP, self).__init__(dp, ap_num)
+
+        # Default to the smallest size supported by all targets.
+        # A size smaller than the supported size will decrease performance
+        # due to the extra address writes, but will not create any
+        # read/write errors.
+        self.auto_increment_page_size = 0x400
+
+    def init(self, bus_accessible=True):
+        super(MEM_AP, self).init(bus_accessible)
+
+        # Look up the page size based on AP ID.
+        try:
+            self.auto_increment_page_size = MEM_AP_IDR_TO_WRAP_SIZE[self.idr]
+        except KeyError:
+            logging.warning("Unknown MEM-AP IDR: 0x%x" % self.idr)
+
+    ## @brief Write a single memory location.
+    #
+    # By default the transfer size is a word
+    def writeMemory(self, addr, data, transfer_size=32):
+        num = self.dp.next_access_number
+        if LOG_DAP:
+            self.logger.info("writeMem:%06d (addr=0x%08x, size=%d) = 0x%08x {", num, addr, transfer_size, data)
+        self.write_reg(AP_REG['CSW'], CSW_VALUE | TRANSFER_SIZE[transfer_size])
+        if transfer_size == 8:
+            data = data << ((addr & 0x03) << 3)
+        elif transfer_size == 16:
+            data = data << ((addr & 0x02) << 3)
+
+        try:
+            self.write_reg(AP_REG['TAR'], addr)
+            self.write_reg(AP_REG['DRW'], data)
+        except DAPAccess.TransferFaultError as error:
+            # Annotate error with target address.
+            self._handle_error(error, num)
+            error.fault_address = addr
+            raise
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+        if LOG_DAP:
+            self.logger.info("writeMem:%06d }", num)
+
+    ## @brief Read a memory location.
+    #
+    # By default, a word will be read.
+    def readMemory(self, addr, transfer_size=32, now=True):
+        num = self.dp.next_access_number
+        if LOG_DAP:
+            self.logger.info("readMem:%06d (addr=0x%08x, size=%d) {", num, addr, transfer_size)
+        res = None
+        try:
+            self.write_reg(AP_REG['CSW'], CSW_VALUE |
+                         TRANSFER_SIZE[transfer_size])
+            self.write_reg(AP_REG['TAR'], addr)
+            result_cb = self.read_reg(AP_REG['DRW'], now=False)
+        except DAPAccess.TransferFaultError as error:
+            # Annotate error with target address.
+            self._handle_error(error, num)
+            error.fault_address = addr
+            raise
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+
+        def readMemCb():
+            try:
+                res = result_cb()
+                if transfer_size == 8:
+                    res = (res >> ((addr & 0x03) << 3) & 0xff)
+                elif transfer_size == 16:
+                    res = (res >> ((addr & 0x02) << 3) & 0xffff)
+                if LOG_DAP:
+                    self.logger.info("readMem:%06d %s(addr=0x%08x, size=%d) -> 0x%08x }", num, "" if now else "...", addr, transfer_size, res)
+            except DAPAccess.TransferFaultError as error:
+                # Annotate error with target address.
+                self._handle_error(error, num)
+                error.fault_address = addr
+                raise
+            except DAPAccess.Error as error:
+                self._handle_error(error, num)
+                raise
+            return res
+
+        if now:
+            result = readMemCb()
+            return result
+        else:
+            return readMemCb
+
+    # write aligned word ("data" are words)
+    def _writeBlock32(self, addr, data):
+        num = self.dp.next_access_number
+        if LOG_DAP:
+            self.logger.info("_writeBlock32:%06d (addr=0x%08x, size=%d) {", num, addr, len(data))
+        # put address in TAR
+        self.write_reg(AP_REG['CSW'], CSW_VALUE | CSW_SIZE32)
+        self.write_reg(AP_REG['TAR'], addr)
+        try:
+            reg = _ap_addr_to_reg((self.ap_num << APSEL_SHIFT) | WRITE | AP_ACC | AP_REG['DRW'])
+            self.link.reg_write_repeat(len(data), reg, data)
+        except DAPAccess.TransferFaultError as error:
+            # Annotate error with target address.
+            self._handle_error(error, num)
+            error.fault_address = addr
+            raise
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+        if LOG_DAP:
+            self.logger.info("_writeBlock32:%06d }", num)
+
+    # read aligned word (the size is in words)
+    def _readBlock32(self, addr, size):
+        num = self.dp.next_access_number
+        if LOG_DAP:
+            self.logger.info("_readBlock32:%06d (addr=0x%08x, size=%d) {", num, addr, size)
+        # put address in TAR
+        self.write_reg(AP_REG['CSW'], CSW_VALUE | CSW_SIZE32)
+        self.write_reg(AP_REG['TAR'], addr)
+        try:
+            reg = _ap_addr_to_reg((self.ap_num << APSEL_SHIFT) | READ | AP_ACC | AP_REG['DRW'])
+            resp = self.link.reg_read_repeat(size, reg)
+        except DAPAccess.TransferFaultError as error:
+            # Annotate error with target address.
+            self._handle_error(error, num)
+            error.fault_address = addr
+            raise
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+        if LOG_DAP:
+            self.logger.info("_readBlock32:%06d }", num)
+        return resp
+
+    ## @brief Shorthand to write a 32-bit word.
+    def write32(self, addr, value):
+        self.writeMemory(addr, value, 32)
+
+    ## @brief Shorthand to write a 16-bit halfword.
+    def write16(self, addr, value):
+        self.writeMemory(addr, value, 16)
+
+    ## @brief Shorthand to write a byte.
+    def write8(self, addr, value):
+        self.writeMemory(addr, value, 8)
+
+    ## @brief Shorthand to read a 32-bit word.
+    def read32(self, addr, now=True):
+        return self.readMemory(addr, 32, now)
+
+    ## @brief Shorthand to read a 16-bit halfword.
+    def read16(self, addr, now=True):
+        return self.readMemory(addr, 16, now)
+
+    ## @brief Shorthand to read a byte.
+    def read8(self, addr, now=True):
+        return self.readMemory(addr, 8, now)
+
+    ## @brief Read a block of unaligned bytes in memory.
+    # @return an array of byte values
+    def readBlockMemoryUnaligned8(self, addr, size):
+        res = []
+
+        # try to read 8bits data
+        if (size > 0) and (addr & 0x01):
+            mem = self.readMemory(addr, 8)
+            res.append(mem)
+            size -= 1
+            addr += 1
+
+        # try to read 16bits data
+        if (size > 1) and (addr & 0x02):
+            mem = self.readMemory(addr, 16)
+            res.append(mem & 0xff)
+            res.append((mem >> 8) & 0xff)
+            size -= 2
+            addr += 2
+
+        # try to read aligned block of 32bits
+        if (size >= 4):
+            mem = self.readBlockMemoryAligned32(addr, size/4)
+            res += conversion.u32leListToByteList(mem)
+            size -= 4*len(mem)
+            addr += 4*len(mem)
+
+        if (size > 1):
+            mem = self.readMemory(addr, 16)
+            res.append(mem & 0xff)
+            res.append((mem >> 8) & 0xff)
+            size -= 2
+            addr += 2
+
+        if (size > 0):
+            mem = self.readMemory(addr, 8)
+            res.append(mem)
+            size -= 1
+            addr += 1
+
+        return res
+
+    ## @brief Write a block of unaligned bytes in memory.
+    def writeBlockMemoryUnaligned8(self, addr, data):
+        size = len(data)
+        idx = 0
+
+        #try to write 8 bits data
+        if (size > 0) and (addr & 0x01):
+            self.writeMemory(addr, data[idx], 8)
+            size -= 1
+            addr += 1
+            idx += 1
+
+        # try to write 16 bits data
+        if (size > 1) and (addr & 0x02):
+            self.writeMemory(addr, data[idx] | (data[idx+1] << 8), 16)
+            size -= 2
+            addr += 2
+            idx += 2
+
+        # write aligned block of 32 bits
+        if (size >= 4):
+            data32 = conversion.byteListToU32leList(data[idx:idx + (size & ~0x03)])
+            self.writeBlockMemoryAligned32(addr, data32)
+            addr += size & ~0x03
+            idx += size & ~0x03
+            size -= size & ~0x03
+
+        # try to write 16 bits data
+        if (size > 1):
+            self.writeMemory(addr, data[idx] | (data[idx+1] << 8), 16)
+            size -= 2
+            addr += 2
+            idx += 2
+
+        #try to write 8 bits data
+        if (size > 0):
+            self.writeMemory(addr, data[idx], 8)
+            size -= 1
+            addr += 1
+            idx += 1
+
+        return
+
+    ## @brief Write a block of aligned words in memory.
+    def writeBlockMemoryAligned32(self, addr, data):
+        size = len(data)
+        while size > 0:
+            n = self.auto_increment_page_size - (addr & (self.auto_increment_page_size - 1))
+            if size*4 < n:
+                n = (size*4) & 0xfffffffc
+            self._writeBlock32(addr, data[:n//4])
+            data = data[n//4:]
+            size -= n//4
+            addr += n
+        return
+
+    ## @brief Read a block of aligned words in memory.
+    #
+    # @return An array of word values
+    def readBlockMemoryAligned32(self, addr, size):
+        resp = []
+        while size > 0:
+            n = self.auto_increment_page_size - (addr & (self.auto_increment_page_size - 1))
+            if size*4 < n:
+                n = (size*4) & 0xfffffffc
+            resp += self._readBlock32(addr, n//4)
+            size -= n//4
+            addr += n
+        return resp
+
+    def _handle_error(self, error, num):
+        self.dp._handle_error(error, num)
+
+class AHB_AP(MEM_AP):
+    def init_rom_table(self):
+        # Turn on DEMCR.TRCENA before reading the ROM table. Some ROM table entries will
+        # come back as garbage if TRCENA is not set.
+        try:
+            demcr = self.read32(DEMCR)
+            self.write32(DEMCR, demcr | DEMCR_TRCENA)
+            self.dp.flush()
+        except DAPAccess.Error:
+            # Ignore exception and read whatever we can of the ROM table.
+            pass
+
+        # Invoke superclass.
+        super(AHB_AP, self).init_rom_table()
+
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/cortex_m.py` & `pyOCD-0.9.0/pyOCD/coresight/cortex_m.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,914 +1,848 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from xml.etree.ElementTree import (Element, SubElement, tostring)
-
-from ..target.target import Target
-from pyOCD.pyDAPAccess import DAPAccess
-from ..gdbserver import signals
-from ..utility import conversion
-from .fpb import FPB
-from .dwt import DWT
-from .breakpoints import (Breakpoint, Watchpoint, SoftwareBreakpointProvider, BreakpointManager)
-from . import (dap, ap)
-import logging
-import struct
-from time import (time, sleep)
-
-# CPUID PARTNO values
-ARM_CortexM0 = 0xC20
-ARM_CortexM1 = 0xC21
-ARM_CortexM3 = 0xC23
-ARM_CortexM4 = 0xC24
-ARM_CortexM0p = 0xC60
-
-# User-friendly names for core types.
-CORE_TYPE_NAME = {
-                 ARM_CortexM0 : "Cortex-M0",
-                 ARM_CortexM1 : "Cortex-M1",
-                 ARM_CortexM3 : "Cortex-M3",
-                 ARM_CortexM4 : "Cortex-M4",
-                 ARM_CortexM0p : "Cortex-M0+"
-               }
-
-# Maps the fault code found in the IPSR to a GDB signal value.
-FAULT = [
-            signals.SIGSTOP,
-            signals.SIGSTOP,    # Reset
-            signals.SIGINT,     # NMI
-            signals.SIGSEGV,    # HardFault
-            signals.SIGSEGV,    # MemManage
-            signals.SIGBUS,     # BusFault
-            signals.SIGILL,     # UsageFault
-                                                # The rest are not faults
-         ]
-
-
-# Map from register name to DCRSR register index.
-#
-# The CONTROL, FAULTMASK, BASEPRI, and PRIMASK registers are special in that they share the
-# same DCRSR register index and are returned as a single value. In this dict, these registers
-# have negative values to signal to the register read/write functions that special handling
-# is necessary. The values are the byte number containing the register value, plus 1 and then
-# negated. So -1 means a mask of 0xff, -2 is 0xff00, and so on. The actual DCRSR register index
-# for these combined registers has the key of 'cfbp'.
-CORE_REGISTER = {
-                 'r0': 0,
-                 'r1': 1,
-                 'r2': 2,
-                 'r3': 3,
-                 'r4': 4,
-                 'r5': 5,
-                 'r6': 6,
-                 'r7': 7,
-                 'r8': 8,
-                 'r9': 9,
-                 'r10': 10,
-                 'r11': 11,
-                 'r12': 12,
-                 'sp': 13,
-                 'r13': 13,
-                 'lr': 14,
-                 'r14': 14,
-                 'pc': 15,
-                 'r15': 15,
-                 'xpsr': 16,
-                 'msp': 17,
-                 'psp': 18,
-                 'cfbp': 20,
-                 'control':-4,
-                 'faultmask':-3,
-                 'basepri':-2,
-                 'primask':-1,
-                 'fpscr': 33,
-                 's0': 0x40,
-                 's1': 0x41,
-                 's2': 0x42,
-                 's3': 0x43,
-                 's4': 0x44,
-                 's5': 0x45,
-                 's6': 0x46,
-                 's7': 0x47,
-                 's8': 0x48,
-                 's9': 0x49,
-                 's10': 0x4a,
-                 's11': 0x4b,
-                 's12': 0x4c,
-                 's13': 0x4d,
-                 's14': 0x4e,
-                 's15': 0x4f,
-                 's16': 0x50,
-                 's17': 0x51,
-                 's18': 0x52,
-                 's19': 0x53,
-                 's20': 0x54,
-                 's21': 0x55,
-                 's22': 0x56,
-                 's23': 0x57,
-                 's24': 0x58,
-                 's25': 0x59,
-                 's26': 0x5a,
-                 's27': 0x5b,
-                 's28': 0x5c,
-                 's29': 0x5d,
-                 's30': 0x5e,
-                 's31': 0x5f,
-                 }
-
-class CortexM(Target):
-
-    """
-    This class has basic functions to access a Cortex M core:
-       - init
-       - read/write memory
-       - read/write core registers
-       - set/remove hardware breakpoints
-    """
-
-    # Debug Fault Status Register
-    DFSR = 0xE000ED30
-    DFSR_EXTERNAL = (1 << 4)
-    DFSR_VCATCH = (1 << 3)
-    DFSR_DWTTRAP = (1 << 2)
-    DFSR_BKPT = (1 << 1)
-    DFSR_HALTED = (1 << 0)
-
-    # Debug Exception and Monitor Control Register
-    DEMCR = 0xE000EDFC
-    # DWTENA in armv6 architecture reference manual
-    DEMCR_TRCENA = (1 << 24)
-    DEMCR_VC_HARDERR = (1 << 10)
-    DEMCR_VC_BUSERR = (1 << 8)
-    DEMCR_VC_CORERESET = (1 << 0)
-
-    # CPUID Register
-    CPUID = 0xE000ED00
-
-    # CPUID masks
-    CPUID_IMPLEMENTER_MASK = 0xff000000
-    CPUID_IMPLEMENTER_POS = 24
-    CPUID_VARIANT_MASK = 0x00f00000
-    CPUID_VARIANT_POS = 20
-    CPUID_ARCHITECTURE_MASK = 0x000f0000
-    CPUID_ARCHITECTURE_POS = 16
-    CPUID_PARTNO_MASK = 0x0000fff0
-    CPUID_PARTNO_POS = 4
-    CPUID_REVISION_MASK = 0x0000000f
-    CPUID_REVISION_POS = 0
-
-    CPUID_IMPLEMENTER_ARM = 0x41
-    ARMv6M = 0xC
-    ARMv7M = 0xF
-
-    # Debug Core Register Selector Register
-    DCRSR = 0xE000EDF4
-    DCRSR_REGWnR = (1 << 16)
-    DCRSR_REGSEL = 0x1F
-
-    # Debug Halting Control and Status Register
-    DHCSR = 0xE000EDF0
-    C_DEBUGEN = (1 << 0)
-    C_HALT = (1 << 1)
-    C_STEP = (1 << 2)
-    C_MASKINTS = (1 << 3)
-    C_SNAPSTALL = (1 << 5)
-    S_REGRDY = (1 << 16)
-    S_HALT = (1 << 17)
-    S_SLEEP = (1 << 18)
-    S_LOCKUP = (1 << 19)
-    S_RETIRE_ST = (1 << 24)
-    S_RESET_ST = (1 << 25)
-
-    # Debug Core Register Data Register
-    DCRDR = 0xE000EDF8
-
-    # Coprocessor Access Control Register
-    CPACR = 0xE000ED88
-    CPACR_CP10_CP11_MASK = (3 << 20) | (3 << 22)
-
-    NVIC_AIRCR = (0xE000ED0C)
-    NVIC_AIRCR_VECTKEY = (0x5FA << 16)
-    NVIC_AIRCR_VECTRESET = (1 << 0)
-    NVIC_AIRCR_SYSRESETREQ = (1 << 2)
-
-    DBGKEY = (0xA05F << 16)
-
-    class RegisterInfo(object):
-        def __init__(self, name, bitsize, reg_type, reg_group):
-            self.name = name
-            self.reg_num = CORE_REGISTER[name]
-            self.gdb_xml_attrib = {}
-            self.gdb_xml_attrib['name'] = str(name)
-            self.gdb_xml_attrib['bitsize'] = str(bitsize)
-            self.gdb_xml_attrib['type'] = str(reg_type)
-            self.gdb_xml_attrib['group'] = str(reg_group)
-
-    regs_general = [
-        #            Name       bitsize     type            group
-        RegisterInfo('r0',      32,         'int',          'general'),
-        RegisterInfo('r1',      32,         'int',          'general'),
-        RegisterInfo('r2',      32,         'int',          'general'),
-        RegisterInfo('r3',      32,         'int',          'general'),
-        RegisterInfo('r4',      32,         'int',          'general'),
-        RegisterInfo('r5',      32,         'int',          'general'),
-        RegisterInfo('r6',      32,         'int',          'general'),
-        RegisterInfo('r7',      32,         'int',          'general'),
-        RegisterInfo('r8',      32,         'int',          'general'),
-        RegisterInfo('r9',      32,         'int',          'general'),
-        RegisterInfo('r10',     32,         'int',          'general'),
-        RegisterInfo('r11',     32,         'int',          'general'),
-        RegisterInfo('r12',     32,         'int',          'general'),
-        RegisterInfo('sp',      32,         'data_ptr',     'general'),
-        RegisterInfo('lr',      32,         'int',          'general'),
-        RegisterInfo('pc',      32,         'code_ptr',     'general'),
-        RegisterInfo('xpsr',    32,         'int',          'general'),
-        RegisterInfo('msp',     32,         'int',          'general'),
-        RegisterInfo('psp',     32,         'int',          'general'),
-        RegisterInfo('primask', 32,         'int',          'general'),
-        RegisterInfo('control', 32,         'int',          'general'),
-        ]
-
-    regs_system_armv7_only = [
-        #            Name       bitsize     type            group
-        RegisterInfo('basepri',     32,     'int',          'general'),
-        RegisterInfo('faultmask',   32,     'int',          'general'),
-        ]
-
-    regs_float = [
-        #            Name       bitsize     type            group
-        RegisterInfo('fpscr',   32,         'int',          'float'),
-        RegisterInfo('s0' ,     32,         'float',        'float'),
-        RegisterInfo('s1' ,     32,         'float',        'float'),
-        RegisterInfo('s2' ,     32,         'float',        'float'),
-        RegisterInfo('s3' ,     32,         'float',        'float'),
-        RegisterInfo('s4' ,     32,         'float',        'float'),
-        RegisterInfo('s5' ,     32,         'float',        'float'),
-        RegisterInfo('s6' ,     32,         'float',        'float'),
-        RegisterInfo('s7' ,     32,         'float',        'float'),
-        RegisterInfo('s8' ,     32,         'float',        'float'),
-        RegisterInfo('s9' ,     32,         'float',        'float'),
-        RegisterInfo('s10',     32,         'float',        'float'),
-        RegisterInfo('s11',     32,         'float',        'float'),
-        RegisterInfo('s12',     32,         'float',        'float'),
-        RegisterInfo('s13',     32,         'float',        'float'),
-        RegisterInfo('s14',     32,         'float',        'float'),
-        RegisterInfo('s15',     32,         'float',        'float'),
-        RegisterInfo('s16',     32,         'float',        'float'),
-        RegisterInfo('s17',     32,         'float',        'float'),
-        RegisterInfo('s18',     32,         'float',        'float'),
-        RegisterInfo('s19',     32,         'float',        'float'),
-        RegisterInfo('s20',     32,         'float',        'float'),
-        RegisterInfo('s21',     32,         'float',        'float'),
-        RegisterInfo('s22',     32,         'float',        'float'),
-        RegisterInfo('s23',     32,         'float',        'float'),
-        RegisterInfo('s24',     32,         'float',        'float'),
-        RegisterInfo('s25',     32,         'float',        'float'),
-        RegisterInfo('s26',     32,         'float',        'float'),
-        RegisterInfo('s27',     32,         'float',        'float'),
-        RegisterInfo('s28',     32,         'float',        'float'),
-        RegisterInfo('s29',     32,         'float',        'float'),
-        RegisterInfo('s30',     32,         'float',        'float'),
-        RegisterInfo('s31',     32,         'float',        'float'),
-        ]
-
-    def __init__(self, link, dp, ap, memoryMap=None, core_num=0):
-        super(CortexM, self).__init__(link, memoryMap)
-
-        self.arch = 0
-        self.core_type = 0
-        self.has_fpu = False
-        self.dp = dp
-        self.ap = ap
-        self.core_number = core_num
-
-        # Set up breakpoints manager.
-        self.fpb = FPB(self.ap)
-        self.dwt = DWT(self.ap)
-        self.sw_bp = SoftwareBreakpointProvider(self)
-        self.bp_manager = BreakpointManager(self)
-        self.bp_manager.add_provider(self.fpb, Target.BREAKPOINT_HW)
-        self.bp_manager.add_provider(self.sw_bp, Target.BREAKPOINT_SW)
-
-    def init(self):
-        """
-        Cortex M initialization. The bus must be accessible when this method is called.
-        """
-        if self.halt_on_connect:
-            self.halt()
-        self.readCoreType()
-        self.checkForFPU()
-        self.buildTargetXML()
-        self.fpb.init()
-        self.dwt.init()
-        self.sw_bp.init()
-
-    def disconnect(self):
-        # Remove breakpoints.
-        self.bp_manager.remove_all_breakpoints()
-
-        # Disable other debug blocks.
-        self.write32(CortexM.DEMCR, 0)
-
-        # Disable core debug.
-        self.write32(CortexM.DHCSR, CortexM.DBGKEY | 0x0000)
-
-    def buildTargetXML(self):
-        # Build register_list and targetXML
-        self.register_list = []
-        xml_root = Element('target')
-        xml_regs_general = SubElement(xml_root, "feature", name="org.gnu.gdb.arm.m-profile")
-        for reg in self.regs_general:
-            self.register_list.append(reg)
-            SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
-        # Check if target has ARMv7 registers
-        if self.core_type in  (ARM_CortexM3, ARM_CortexM4):
-            for reg in self.regs_system_armv7_only:
-                self.register_list.append(reg)
-                SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
-        # Check if target has FPU registers
-        if self.has_fpu:
-            #xml_regs_fpu = SubElement(xml_root, "feature", name="org.gnu.gdb.arm.vfp")
-            for reg in self.regs_float:
-                self.register_list.append(reg)
-                SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
-        self.targetXML = '<?xml version="1.0"?><!DOCTYPE feature SYSTEM "gdb-target.dtd">' + tostring(xml_root)
-
-    ## @brief Read the CPUID register and determine core type.
-    def readCoreType(self):
-        # Read CPUID register
-        cpuid = self.read32(CortexM.CPUID)
-
-        implementer = (cpuid & CortexM.CPUID_IMPLEMENTER_MASK) >> CortexM.CPUID_IMPLEMENTER_POS
-        if implementer != CortexM.CPUID_IMPLEMENTER_ARM:
-            logging.warning("CPU implementer is not ARM!")
-
-        self.arch = (cpuid & CortexM.CPUID_ARCHITECTURE_MASK) >> CortexM.CPUID_ARCHITECTURE_POS
-        self.core_type = (cpuid & CortexM.CPUID_PARTNO_MASK) >> CortexM.CPUID_PARTNO_POS
-        logging.info("CPU core is %s", CORE_TYPE_NAME[self.core_type])
-
-    ## @brief Determine if a Cortex-M4 has an FPU.
-    #
-    # The core type must have been identified prior to calling this function.
-    def checkForFPU(self):
-        if self.core_type != ARM_CortexM4:
-            self.has_fpu = False
-            return
-
-        originalCpacr = self.read32(CortexM.CPACR)
-        cpacr = originalCpacr | CortexM.CPACR_CP10_CP11_MASK
-        self.write32(CortexM.CPACR, cpacr)
-
-        cpacr = self.read32(CortexM.CPACR)
-        self.has_fpu = (cpacr & CortexM.CPACR_CP10_CP11_MASK) != 0
-
-        # Restore previous value.
-        self.write32(CortexM.CPACR, originalCpacr)
-
-        if self.has_fpu:
-            logging.info("FPU present")
-
-    def readIDCode(self):
-        """
-        return the IDCODE of the core
-        """
-        return self.dp.read_id_code()
-
-    def writeMemory(self, addr, value, transfer_size=32):
-        """
-        write a memory location.
-        By default the transfer size is a word
-        """
-        self.ap.writeMemory(addr, value, transfer_size)
-
-    def readMemory(self, addr, transfer_size=32, now=True):
-        """
-        read a memory location. By default, a word will
-        be read
-        """
-        result = self.ap.readMemory(addr, transfer_size, now)
-
-        # Read callback returned for async reads.
-        def readMemoryCb():
-            return self.bp_manager.filter_memory(addr, transfer_size, result())
-
-        if now:
-            return self.bp_manager.filter_memory(addr, transfer_size, result)
-        else:
-            return readMemoryCb
-
-    def readBlockMemoryUnaligned8(self, addr, size):
-        """
-        read a block of unaligned bytes in memory. Returns
-        an array of byte values
-        """
-        data = self.ap.readBlockMemoryUnaligned8(addr, size)
-        return self.bp_manager.filter_memory_unaligned_8(addr, size, data)
-
-    def writeBlockMemoryUnaligned8(self, addr, data):
-        """
-        write a block of unaligned bytes in memory.
-        """
-        self.ap.writeBlockMemoryUnaligned8(addr, data)
-
-    def writeBlockMemoryAligned32(self, addr, data):
-        """
-        write a block of aligned words in memory.
-        """
-        self.ap.writeBlockMemoryAligned32(addr, data)
-
-    def readBlockMemoryAligned32(self, addr, size):
-        """
-        read a block of aligned words in memory. Returns
-        an array of word values
-        """
-        data = self.ap.readBlockMemoryAligned32(addr, size)
-        return self.bp_manager.filter_memory_aligned_32(addr, size, data)
-
-    def halt(self):
-        """
-        halt the core
-        """
-        self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT)
-        self.dp.flush()
-
-    def step(self, disable_interrupts=True):
-        """
-        perform an instruction level step.  This function preserves the previous
-        interrupt mask state
-        """
-        # Was 'if self.getState() != TARGET_HALTED:'
-        # but now value of dhcsr is saved
-        dhcsr = self.readMemory(CortexM.DHCSR)
-        if not (dhcsr & (CortexM.C_STEP | CortexM.C_HALT)):
-            logging.error('cannot step: target not halted')
-            return
-
-        self.clearDebugCauseBits()
-
-        # Save previous interrupt mask state
-        interrupts_masked = (CortexM.C_MASKINTS & dhcsr) != 0
-
-        # Mask interrupts - C_HALT must be set when changing to C_MASKINTS
-        if not interrupts_masked and disable_interrupts:
-            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT | CortexM.C_MASKINTS)
-
-        # Single step using current C_MASKINTS setting
-        if disable_interrupts or interrupts_masked:
-            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_MASKINTS | CortexM.C_STEP)
-        else:
-            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_STEP)
-
-        # Wait for halt to auto set (This should be done before the first read)
-        while not self.readMemory(CortexM.DHCSR) & CortexM.C_HALT:
-            pass
-
-        # Restore interrupt mask state
-        if not interrupts_masked and disable_interrupts:
-            # Unmask interrupts - C_HALT must be set when changing to C_MASKINTS
-            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT)
-
-        self.dp.flush()
-
-    def clearDebugCauseBits(self):
-        self.writeMemory(CortexM.DFSR, CortexM.DFSR_DWTTRAP | CortexM.DFSR_BKPT | CortexM.DFSR_HALTED)
-
-    def reset(self, software_reset=None):
-        """
-        reset a core. After a call to this function, the core
-        is running
-        """
-        if software_reset == None:
-            # Default to software reset if nothing is specified
-            software_reset = True
-
-        if software_reset:
-            # Perform the reset.
-            try:
-                self.writeMemory(CortexM.NVIC_AIRCR, CortexM.NVIC_AIRCR_VECTKEY | CortexM.NVIC_AIRCR_SYSRESETREQ)
-                # Without a flush a transfer error can occur
-                self.dp.flush()
-            except DAPAccess.TransferError:
-                self.dp.flush()
-
-        else:
-            self.dp.reset()
-
-        # Now wait for the system to come out of reset. Keep reading the DHCSR until
-        # we get a good response with S_RESET_ST cleared, or we time out.
-        startTime = time()
-        while time() - startTime < 2.0:
-            try:
-                dhcsr = self.read32(CortexM.DHCSR)
-                if (dhcsr & CortexM.S_RESET_ST) == 0:
-                    break
-            except DAPAccess.TransferError:
-                self.dp.flush()
-                sleep(0.01)
-
-    def resetStopOnReset(self, software_reset=None):
-        """
-        perform a reset and stop the core on the reset handler
-        """
-        logging.debug("reset stop on Reset")
-
-        # halt the target
-        self.halt()
-
-        # Save CortexM.DEMCR
-        demcr = self.readMemory(CortexM.DEMCR)
-
-        # enable the vector catch
-        self.writeMemory(CortexM.DEMCR, demcr | CortexM.DEMCR_VC_CORERESET)
-
-        self.reset(software_reset)
-
-        # wait until the unit resets
-        while (self.isRunning()):
-            pass
-
-        # restore vector catch setting
-        self.writeMemory(CortexM.DEMCR, demcr)
-
-    def setTargetState(self, state):
-        if state == "PROGRAM":
-            self.resetStopOnReset(True)
-            # Write the thumb bit in case the reset handler
-            # points to an ARM address
-            self.writeCoreRegister('xpsr', 0x1000000)
-
-    def getState(self):
-        dhcsr = self.readMemory(CortexM.DHCSR)
-        if dhcsr & CortexM.S_RESET_ST:
-            # Reset is a special case because the bit is sticky and really means
-            # "core was reset since last read of DHCSR". We have to re-read the
-            # DHCSR, check if S_RESET_ST is still set and make sure no instructions
-            # were executed by checking S_RETIRE_ST.
-            newDhcsr = self.readMemory(CortexM.DHCSR)
-            if (newDhcsr & CortexM.S_RESET_ST) and not (newDhcsr & CortexM.S_RETIRE_ST):
-                return Target.TARGET_RESET
-        if dhcsr & CortexM.S_LOCKUP:
-            return Target.TARGET_LOCKUP
-        elif dhcsr & CortexM.S_SLEEP:
-            return Target.TARGET_SLEEPING
-        elif dhcsr & CortexM.S_HALT:
-            return Target.TARGET_HALTED
-        else:
-            return Target.TARGET_RUNNING
-
-    def isRunning(self):
-        return self.getState() == Target.TARGET_RUNNING
-
-    def isHalted(self):
-        return self.getState() == Target.TARGET_HALTED
-
-    def resume(self):
-        """
-        resume the execution
-        """
-        if self.getState() != Target.TARGET_HALTED:
-            logging.debug('cannot resume: target not halted')
-            return
-        self.clearDebugCauseBits()
-        self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
-        self.dp.flush()
-
-    def findBreakpoint(self, addr):
-        return self.bp_manager.find_breakpoint(addr)
-
-    def readCoreRegister(self, reg):
-        """
-        read CPU register
-        Unpack floating point register values
-        """
-        regIndex = self.registerNameToIndex(reg)
-        regValue = self.readCoreRegisterRaw(regIndex)
-        # Convert int to float.
-        if regIndex >= 0x40:
-            regValue = conversion.u32BEToFloat32BE(regValue)
-        return regValue
-
-    def registerNameToIndex(self, reg):
-        """
-        return register index based on name.
-        If reg is a string, find the number associated to this register
-        in the lookup table CORE_REGISTER
-        """
-        if isinstance(reg, str):
-            try:
-                reg = CORE_REGISTER[reg.lower()]
-            except KeyError:
-                logging.error('cannot find %s core register', reg)
-                return
-        return reg
-
-    def readCoreRegisterRaw(self, reg):
-        """
-        read a core register (r0 .. r16).
-        If reg is a string, find the number associated to this register
-        in the lookup table CORE_REGISTER
-        """
-        vals = self.readCoreRegistersRaw([reg])
-        return vals[0]
-
-    def readCoreRegistersRaw(self, reg_list):
-        """
-        Read one or more core registers
-
-        Read core registers in reg_list and return a list of values.
-        If any register in reg_list is a string, find the number
-        associated to this register in the lookup table CORE_REGISTER.
-        """
-        # convert to index only
-        reg_list = [self.registerNameToIndex(reg) for reg in reg_list]
-
-        # Sanity check register values
-        for reg in reg_list:
-            if reg not in CORE_REGISTER.values():
-                raise ValueError("unknown reg: %d" % reg)
-            elif ((reg >= 128) or (reg == 33)) and (not self.has_fpu):
-                raise ValueError("attempt to read FPU register without FPU")
-
-        # Begin all reads and writes
-        dhcsr_cb_list = []
-        reg_cb_list = []
-        for reg in reg_list:
-            if (reg < 0) and (reg >= -4):
-                reg = CORE_REGISTER['cfbp']
-
-            # write id in DCRSR
-            self.writeMemory(CortexM.DCRSR, reg)
-
-            # Technically, we need to poll S_REGRDY in DHCSR here before reading DCRDR. But
-            # we're running so slow compared to the target that it's not necessary.
-            # Read it and assert that S_REGRDY is set
-
-            dhcsr_cb = self.readMemory(CortexM.DHCSR, now=False)
-            reg_cb = self.readMemory(CortexM.DCRDR, now=False)
-            dhcsr_cb_list.append(dhcsr_cb)
-            reg_cb_list.append(reg_cb)
-
-        # Read all results
-        reg_vals = []
-        for reg, reg_cb, dhcsr_cb in zip(reg_list, reg_cb_list, dhcsr_cb_list):
-            dhcsr_val = dhcsr_cb()
-            assert dhcsr_val & CortexM.S_REGRDY
-            val = reg_cb()
-
-            # Special handling for registers that are combined into a single DCRSR number.
-            if (reg < 0) and (reg >= -4):
-                val = (val >> ((-reg - 1) * 8)) & 0xff
-
-            reg_vals.append(val)
-
-        return reg_vals
-
-    def writeCoreRegister(self, reg, data):
-        """
-        write a CPU register.
-        Will need to pack floating point register values before writing.
-        """
-        regIndex = self.registerNameToIndex(reg)
-        # Convert float to int.
-        if regIndex >= 0x40:
-            data = conversion.float32beToU32be(data)
-        self.writeCoreRegisterRaw(regIndex, data)
-
-    def writeCoreRegisterRaw(self, reg, data):
-        """
-        write a core register (r0 .. r16)
-        If reg is a string, find the number associated to this register
-        in the lookup table CORE_REGISTER
-        """
-        self.writeCoreRegistersRaw([reg], [data])
-
-    def writeCoreRegistersRaw(self, reg_list, data_list):
-        """
-        Write one or more core registers
-
-        Write core registers in reg_list with the associated value in
-        data_list.  If any register in reg_list is a string, find the number
-        associated to this register in the lookup table CORE_REGISTER.
-        """
-        assert len(reg_list) == len(data_list)
-        # convert to index only
-        reg_list = [self.registerNameToIndex(reg) for reg in reg_list]
-
-        # Sanity check register values
-        for reg in reg_list:
-            if reg not in CORE_REGISTER.values():
-                raise ValueError("unknown reg: %d" % reg)
-            elif ((reg >= 128) or (reg == 33)) and (not self.has_fpu):
-                raise ValueError("attempt to write FPU register without FPU")
-
-        # Read special register if it is present in the list
-        for reg in reg_list:
-            if (reg < 0) and (reg >= -4):
-                specialRegValue = self.readCoreRegister(CORE_REGISTER['cfbp'])
-                break
-
-        # Write out registers
-        dhcsr_cb_list = []
-        for reg, data in zip(reg_list, data_list):
-            if (reg < 0) and (reg >= -4):
-                # Mask in the new special register value so we don't modify the other register
-                # values that share the same DCRSR number.
-                shift = (-reg - 1) * 8
-                mask = 0xffffffff ^ (0xff << shift)
-                data = (specialRegValue & mask) | ((data & 0xff) << shift)
-                specialRegValue = data # update special register for other writes that might be in the list
-                reg = CORE_REGISTER['cfbp']
-
-            # write DCRDR
-            self.writeMemory(CortexM.DCRDR, data)
-
-            # write id in DCRSR and flag to start write transfer
-            self.writeMemory(CortexM.DCRSR, reg | CortexM.DCRSR_REGWnR)
-
-            # Technically, we need to poll S_REGRDY in DHCSR here to ensure the
-            # register write has completed.
-            # Read it and assert that S_REGRDY is set
-            dhcsr_cb = self.readMemory(CortexM.DHCSR, now=False)
-            dhcsr_cb_list.append(dhcsr_cb)
-
-        # Make sure S_REGRDY was set for all register
-        # writes
-        for dhcsr_cb in dhcsr_cb_list:
-            dhcsr_val = dhcsr_cb()
-            assert dhcsr_val & CortexM.S_REGRDY
-
-    ## @brief Set a hardware or software breakpoint at a specific location in memory.
-    #
-    # @retval True Breakpoint was set.
-    # @retval False Breakpoint could not be set.
-    def setBreakpoint(self, addr, type=Target.BREAKPOINT_AUTO):
-        return self.bp_manager.set_breakpoint(addr, type)
-
-    ## @brief Remove a breakpoint at a specific location.
-    def removeBreakpoint(self, addr):
-        self.bp_manager.remove_breakpoint(addr)
-
-    def getBreakpointType(self, addr):
-        return self.bp_manager.get_breakpoint_type(addr)
-
-    def availableBreakpoint(self):
-        return self.fpb.available_breakpoints()
-
-    def findWatchpoint(self, addr, size, type):
-        return self.dwt.find_watchpoint(addr, size, type)
-
-    def setWatchpoint(self, addr, size, type):
-        """
-        set a hardware watchpoint
-        """
-        return self.dwt.set_watchpoint(addr, size, type)
-
-    def removeWatchpoint(self, addr, size, type):
-        """
-        remove a hardware watchpoint
-        """
-        return self.dwt.remove_watchpoint(addr, size, type)
-
-    def setVectorCatchFault(self, enable):
-        demcr = self.readMemory(CortexM.DEMCR)
-        if enable:
-            demcr = demcr | CortexM.DEMCR_VC_HARDERR
-        else:
-            demcr = demcr & ~CortexM.DEMCR_VC_HARDERR
-        self.writeMemory(CortexM.DEMCR, demcr)
-
-    def getVectorCatchFault(self):
-        return bool(self.readMemory(CortexM.DEMCR) & CortexM.DEMCR_VC_HARDERR)
-
-    def setVectorCatchReset(self, enable):
-        demcr = self.readMemory(CortexM.DEMCR)
-        if enable:
-            demcr = demcr | CortexM.DEMCR_VC_CORERESET
-        else:
-            demcr = demcr & ~CortexM.DEMCR_VC_CORERESET
-        self.writeMemory(CortexM.DEMCR, demcr)
-
-    def getVectorCatchReset(self):
-        return bool(self.readMemory(CortexM.DEMCR) & CortexM.DEMCR_VC_CORERESET)
-
-    # GDB functions
-    def getTargetXML(self):
-        return self.targetXML
-
-    def getRegisterContext(self):
-        """
-        return hexadecimal dump of registers as expected by GDB
-        """
-        logging.debug("GDB getting register context")
-        resp = ''
-        reg_num_list = map(lambda reg:reg.reg_num, self.register_list)
-        vals = self.readCoreRegistersRaw(reg_num_list)
-        #print("Vals: %s" % vals)
-        for reg, regValue in zip(self.register_list, vals):
-            resp += conversion.u32beToHex8le(regValue)
-            logging.debug("GDB reg: %s = 0x%X", reg.name, regValue)
-
-        return resp
-
-    def setRegisterContext(self, data):
-        """
-        Set registers from GDB hexadecimal string.
-        """
-        logging.debug("GDB setting register context")
-        reg_num_list = []
-        reg_data_list = []
-        for reg in self.register_list:
-            regValue = conversion.hex8leToU32be(data)
-            reg_num_list.append(reg.reg_num)
-            reg_data_list.append(regValue)
-            logging.debug("GDB reg: %s = 0x%X", reg.name, regValue)
-            data = data[8:]
-        self.writeCoreRegistersRaw(reg_num_list, reg_data_list)
-
-    def setRegister(self, reg, data):
-        """
-        Set single register from GDB hexadecimal string.
-        reg parameter is the index of register in targetXML sent to GDB.
-        """
-        if reg < 0:
-            return
-        elif reg < len(self.register_list):
-            regName = self.register_list[reg].name
-            value = conversion.hex8leToU32be(data)
-            logging.debug("GDB: write reg %s: 0x%X", regName, value)
-            self.writeCoreRegisterRaw(regName, value)
-
-    def gdbGetRegister(self, reg):
-        resp = ''
-        if reg < len(self.register_list):
-            regName = self.register_list[reg].name
-            regValue = self.readCoreRegisterRaw(regName)
-            resp = conversion.u32beToHex8le(regValue)
-            logging.debug("GDB reg: %s = 0x%X", regName, regValue)
-        return resp
-
-    def getTResponse(self, forceSignal=None):
-        """
-        Returns a GDB T response string.  This includes:
-            The signal encountered.
-            The current value of the important registers (sp, lr, pc).
-        """
-        if forceSignal is not None:
-            response = 'T' + conversion.byteToHex2(forceSignal)
-        else:
-            response = 'T' + conversion.byteToHex2(self.getSignalValue())
-
-        # Append fp(r7), sp(r13), lr(r14), pc(r15)
-        response += self.getRegIndexValuePairs([7, 13, 14, 15])
-
-        # Append thread and core
-        response += "thread:%x;core:%x;" % (self.core_number + 1, self.core_number)
-
-        return response
-
-    def getSignalValue(self):
-        if self.isDebugTrap():
-            return signals.SIGTRAP
-
-        fault = self.readCoreRegister('xpsr') & 0xff
-        try:
-            signal = FAULT[fault]
-        except:
-            # If not a fault then default to SIGSTOP
-            signal = signals.SIGSTOP
-        logging.debug("GDB lastSignal: %d", signal)
-        return signal
-
-    def isDebugTrap(self):
-        debugEvents = self.readMemory(CortexM.DFSR) & (CortexM.DFSR_DWTTRAP | CortexM.DFSR_BKPT | CortexM.DFSR_HALTED)
-        return debugEvents != 0
-
-    def getRegIndexValuePairs(self, regIndexList):
-        """
-        Returns a string like NN:MMMMMMMM;NN:MMMMMMMM;...
-            for the T response string.  NN is the index of the
-            register to follow MMMMMMMM is the value of the register.
-        """
-        str = ''
-        regList = self.readCoreRegistersRaw(regIndexList)
-        for regIndex, reg in zip(regIndexList, regList):
-            str += conversion.byteToHex2(regIndex) + ':' + conversion.u32beToHex8le(reg) + ';'
-        return str
-
-    def getThreadsXML(self):
-        root = Element('threads')
-        t = SubElement(root, 'thread', id="1", core="0")
-        t.text = "Thread mode"
-        return '<?xml version="1.0"?><!DOCTYPE feature SYSTEM "threads.dtd">' + tostring(root)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from xml.etree.ElementTree import (Element, SubElement, tostring)
+
+from ..core.target import Target
+from pyOCD.pyDAPAccess import DAPAccess
+from ..utility import conversion
+from .fpb import FPB
+from .dwt import DWT
+from ..debug.breakpoints.manager import BreakpointManager
+from ..debug.breakpoints.software import SoftwareBreakpointProvider
+from . import (dap, ap)
+import logging
+import struct
+from time import (time, sleep)
+
+# CPUID PARTNO values
+ARM_CortexM0 = 0xC20
+ARM_CortexM1 = 0xC21
+ARM_CortexM3 = 0xC23
+ARM_CortexM4 = 0xC24
+ARM_CortexM0p = 0xC60
+
+# User-friendly names for core types.
+CORE_TYPE_NAME = {
+                 ARM_CortexM0 : "Cortex-M0",
+                 ARM_CortexM1 : "Cortex-M1",
+                 ARM_CortexM3 : "Cortex-M3",
+                 ARM_CortexM4 : "Cortex-M4",
+                 ARM_CortexM0p : "Cortex-M0+"
+               }
+
+# Map from register name to DCRSR register index.
+#
+# The CONTROL, FAULTMASK, BASEPRI, and PRIMASK registers are special in that they share the
+# same DCRSR register index and are returned as a single value. In this dict, these registers
+# have negative values to signal to the register read/write functions that special handling
+# is necessary. The values are the byte number containing the register value, plus 1 and then
+# negated. So -1 means a mask of 0xff, -2 is 0xff00, and so on. The actual DCRSR register index
+# for these combined registers has the key of 'cfbp'.
+CORE_REGISTER = {
+                 'r0': 0,
+                 'r1': 1,
+                 'r2': 2,
+                 'r3': 3,
+                 'r4': 4,
+                 'r5': 5,
+                 'r6': 6,
+                 'r7': 7,
+                 'r8': 8,
+                 'r9': 9,
+                 'r10': 10,
+                 'r11': 11,
+                 'r12': 12,
+                 'sp': 13,
+                 'r13': 13,
+                 'lr': 14,
+                 'r14': 14,
+                 'pc': 15,
+                 'r15': 15,
+                 'xpsr': 16,
+                 'msp': 17,
+                 'psp': 18,
+                 'cfbp': 20,
+                 'control':-4,
+                 'faultmask':-3,
+                 'basepri':-2,
+                 'primask':-1,
+                 'fpscr': 33,
+                 's0': 0x40,
+                 's1': 0x41,
+                 's2': 0x42,
+                 's3': 0x43,
+                 's4': 0x44,
+                 's5': 0x45,
+                 's6': 0x46,
+                 's7': 0x47,
+                 's8': 0x48,
+                 's9': 0x49,
+                 's10': 0x4a,
+                 's11': 0x4b,
+                 's12': 0x4c,
+                 's13': 0x4d,
+                 's14': 0x4e,
+                 's15': 0x4f,
+                 's16': 0x50,
+                 's17': 0x51,
+                 's18': 0x52,
+                 's19': 0x53,
+                 's20': 0x54,
+                 's21': 0x55,
+                 's22': 0x56,
+                 's23': 0x57,
+                 's24': 0x58,
+                 's25': 0x59,
+                 's26': 0x5a,
+                 's27': 0x5b,
+                 's28': 0x5c,
+                 's29': 0x5d,
+                 's30': 0x5e,
+                 's31': 0x5f,
+                 }
+
+def register_name_to_index(reg):
+    if isinstance(reg, str):
+        try:
+            reg = CORE_REGISTER[reg.lower()]
+        except KeyError:
+            raise KeyError('cannot find %s core register' % reg)
+    return reg
+
+class CortexM(Target):
+
+    """
+    This class has basic functions to access a Cortex M core:
+       - init
+       - read/write memory
+       - read/write core registers
+       - set/remove hardware breakpoints
+    """
+
+    # Debug Fault Status Register
+    DFSR = 0xE000ED30
+    DFSR_EXTERNAL = (1 << 4)
+    DFSR_VCATCH = (1 << 3)
+    DFSR_DWTTRAP = (1 << 2)
+    DFSR_BKPT = (1 << 1)
+    DFSR_HALTED = (1 << 0)
+
+    # Debug Exception and Monitor Control Register
+    DEMCR = 0xE000EDFC
+    # DWTENA in armv6 architecture reference manual
+    DEMCR_TRCENA = (1 << 24)
+    DEMCR_VC_HARDERR = (1 << 10)
+    DEMCR_VC_INTERR = (1 << 9)
+    DEMCR_VC_BUSERR = (1 << 8)
+    DEMCR_VC_STATERR = (1 << 7)
+    DEMCR_VC_CHKERR = (1 << 6)
+    DEMCR_VC_NOCPERR = (1 << 5)
+    DEMCR_VC_MMERR = (1 << 4)
+    DEMCR_VC_CORERESET = (1 << 0)
+
+    # CPUID Register
+    CPUID = 0xE000ED00
+
+    # CPUID masks
+    CPUID_IMPLEMENTER_MASK = 0xff000000
+    CPUID_IMPLEMENTER_POS = 24
+    CPUID_VARIANT_MASK = 0x00f00000
+    CPUID_VARIANT_POS = 20
+    CPUID_ARCHITECTURE_MASK = 0x000f0000
+    CPUID_ARCHITECTURE_POS = 16
+    CPUID_PARTNO_MASK = 0x0000fff0
+    CPUID_PARTNO_POS = 4
+    CPUID_REVISION_MASK = 0x0000000f
+    CPUID_REVISION_POS = 0
+
+    CPUID_IMPLEMENTER_ARM = 0x41
+    ARMv6M = 0xC
+    ARMv7M = 0xF
+
+    # Debug Core Register Selector Register
+    DCRSR = 0xE000EDF4
+    DCRSR_REGWnR = (1 << 16)
+    DCRSR_REGSEL = 0x1F
+
+    # Debug Halting Control and Status Register
+    DHCSR = 0xE000EDF0
+    C_DEBUGEN = (1 << 0)
+    C_HALT = (1 << 1)
+    C_STEP = (1 << 2)
+    C_MASKINTS = (1 << 3)
+    C_SNAPSTALL = (1 << 5)
+    S_REGRDY = (1 << 16)
+    S_HALT = (1 << 17)
+    S_SLEEP = (1 << 18)
+    S_LOCKUP = (1 << 19)
+    S_RETIRE_ST = (1 << 24)
+    S_RESET_ST = (1 << 25)
+
+    # Debug Core Register Data Register
+    DCRDR = 0xE000EDF8
+
+    # Coprocessor Access Control Register
+    CPACR = 0xE000ED88
+    CPACR_CP10_CP11_MASK = (3 << 20) | (3 << 22)
+
+    NVIC_AIRCR = (0xE000ED0C)
+    NVIC_AIRCR_VECTKEY = (0x5FA << 16)
+    NVIC_AIRCR_VECTRESET = (1 << 0)
+    NVIC_AIRCR_SYSRESETREQ = (1 << 2)
+
+    DBGKEY = (0xA05F << 16)
+
+    class RegisterInfo(object):
+        def __init__(self, name, bitsize, reg_type, reg_group):
+            self.name = name
+            self.reg_num = CORE_REGISTER[name]
+            self.gdb_xml_attrib = {}
+            self.gdb_xml_attrib['name'] = str(name)
+            self.gdb_xml_attrib['bitsize'] = str(bitsize)
+            self.gdb_xml_attrib['type'] = str(reg_type)
+            self.gdb_xml_attrib['group'] = str(reg_group)
+
+    regs_general = [
+        #            Name       bitsize     type            group
+        RegisterInfo('r0',      32,         'int',          'general'),
+        RegisterInfo('r1',      32,         'int',          'general'),
+        RegisterInfo('r2',      32,         'int',          'general'),
+        RegisterInfo('r3',      32,         'int',          'general'),
+        RegisterInfo('r4',      32,         'int',          'general'),
+        RegisterInfo('r5',      32,         'int',          'general'),
+        RegisterInfo('r6',      32,         'int',          'general'),
+        RegisterInfo('r7',      32,         'int',          'general'),
+        RegisterInfo('r8',      32,         'int',          'general'),
+        RegisterInfo('r9',      32,         'int',          'general'),
+        RegisterInfo('r10',     32,         'int',          'general'),
+        RegisterInfo('r11',     32,         'int',          'general'),
+        RegisterInfo('r12',     32,         'int',          'general'),
+        RegisterInfo('sp',      32,         'data_ptr',     'general'),
+        RegisterInfo('lr',      32,         'int',          'general'),
+        RegisterInfo('pc',      32,         'code_ptr',     'general'),
+        RegisterInfo('xpsr',    32,         'int',          'general'),
+        RegisterInfo('msp',     32,         'int',          'general'),
+        RegisterInfo('psp',     32,         'int',          'general'),
+        RegisterInfo('primask', 32,         'int',          'general'),
+        RegisterInfo('control', 32,         'int',          'general'),
+        ]
+
+    regs_system_armv7_only = [
+        #            Name       bitsize     type            group
+        RegisterInfo('basepri',     32,     'int',          'general'),
+        RegisterInfo('faultmask',   32,     'int',          'general'),
+        ]
+
+    regs_float = [
+        #            Name       bitsize     type            group
+        RegisterInfo('fpscr',   32,         'int',          'float'),
+        RegisterInfo('s0' ,     32,         'float',        'float'),
+        RegisterInfo('s1' ,     32,         'float',        'float'),
+        RegisterInfo('s2' ,     32,         'float',        'float'),
+        RegisterInfo('s3' ,     32,         'float',        'float'),
+        RegisterInfo('s4' ,     32,         'float',        'float'),
+        RegisterInfo('s5' ,     32,         'float',        'float'),
+        RegisterInfo('s6' ,     32,         'float',        'float'),
+        RegisterInfo('s7' ,     32,         'float',        'float'),
+        RegisterInfo('s8' ,     32,         'float',        'float'),
+        RegisterInfo('s9' ,     32,         'float',        'float'),
+        RegisterInfo('s10',     32,         'float',        'float'),
+        RegisterInfo('s11',     32,         'float',        'float'),
+        RegisterInfo('s12',     32,         'float',        'float'),
+        RegisterInfo('s13',     32,         'float',        'float'),
+        RegisterInfo('s14',     32,         'float',        'float'),
+        RegisterInfo('s15',     32,         'float',        'float'),
+        RegisterInfo('s16',     32,         'float',        'float'),
+        RegisterInfo('s17',     32,         'float',        'float'),
+        RegisterInfo('s18',     32,         'float',        'float'),
+        RegisterInfo('s19',     32,         'float',        'float'),
+        RegisterInfo('s20',     32,         'float',        'float'),
+        RegisterInfo('s21',     32,         'float',        'float'),
+        RegisterInfo('s22',     32,         'float',        'float'),
+        RegisterInfo('s23',     32,         'float',        'float'),
+        RegisterInfo('s24',     32,         'float',        'float'),
+        RegisterInfo('s25',     32,         'float',        'float'),
+        RegisterInfo('s26',     32,         'float',        'float'),
+        RegisterInfo('s27',     32,         'float',        'float'),
+        RegisterInfo('s28',     32,         'float',        'float'),
+        RegisterInfo('s29',     32,         'float',        'float'),
+        RegisterInfo('s30',     32,         'float',        'float'),
+        RegisterInfo('s31',     32,         'float',        'float'),
+        ]
+
+    def __init__(self, link, dp, ap, memoryMap=None, core_num=0):
+        super(CortexM, self).__init__(link, memoryMap)
+
+        self.arch = 0
+        self.core_type = 0
+        self.has_fpu = False
+        self.dp = dp
+        self.ap = ap
+        self.core_number = core_num
+        self._run_token = 0
+        self._target_context = None
+
+        # Set up breakpoints manager.
+        self.fpb = FPB(self.ap)
+        self.dwt = DWT(self.ap)
+        self.sw_bp = SoftwareBreakpointProvider(self)
+        self.bp_manager = BreakpointManager(self)
+        self.bp_manager.add_provider(self.fpb, Target.BREAKPOINT_HW)
+        self.bp_manager.add_provider(self.sw_bp, Target.BREAKPOINT_SW)
+
+    def init(self):
+        """
+        Cortex M initialization. The bus must be accessible when this method is called.
+        """
+        if self.halt_on_connect:
+            self.halt()
+        self.readCoreType()
+        self.checkForFPU()
+        self.buildTargetXML()
+        self.fpb.init()
+        self.dwt.init()
+        self.sw_bp.init()
+
+    def disconnect(self):
+        # Remove breakpoints.
+        self.bp_manager.remove_all_breakpoints()
+
+        # Disable other debug blocks.
+        self.write32(CortexM.DEMCR, 0)
+
+        # Disable core debug.
+        self.write32(CortexM.DHCSR, CortexM.DBGKEY | 0x0000)
+
+    def buildTargetXML(self):
+        # Build register_list and targetXML
+        self.register_list = []
+        xml_root = Element('target')
+        xml_regs_general = SubElement(xml_root, "feature", name="org.gnu.gdb.arm.m-profile")
+        for reg in self.regs_general:
+            self.register_list.append(reg)
+            SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
+        # Check if target has ARMv7 registers
+        if self.core_type in  (ARM_CortexM3, ARM_CortexM4):
+            for reg in self.regs_system_armv7_only:
+                self.register_list.append(reg)
+                SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
+        # Check if target has FPU registers
+        if self.has_fpu:
+            #xml_regs_fpu = SubElement(xml_root, "feature", name="org.gnu.gdb.arm.vfp")
+            for reg in self.regs_float:
+                self.register_list.append(reg)
+                SubElement(xml_regs_general, 'reg', **reg.gdb_xml_attrib)
+        self.targetXML = b'<?xml version="1.0"?><!DOCTYPE feature SYSTEM "gdb-target.dtd">' + tostring(xml_root)
+
+    ## @brief Read the CPUID register and determine core type.
+    def readCoreType(self):
+        # Read CPUID register
+        cpuid = self.read32(CortexM.CPUID)
+
+        implementer = (cpuid & CortexM.CPUID_IMPLEMENTER_MASK) >> CortexM.CPUID_IMPLEMENTER_POS
+        if implementer != CortexM.CPUID_IMPLEMENTER_ARM:
+            logging.warning("CPU implementer is not ARM!")
+
+        self.arch = (cpuid & CortexM.CPUID_ARCHITECTURE_MASK) >> CortexM.CPUID_ARCHITECTURE_POS
+        self.core_type = (cpuid & CortexM.CPUID_PARTNO_MASK) >> CortexM.CPUID_PARTNO_POS
+        logging.info("CPU core is %s", CORE_TYPE_NAME[self.core_type])
+
+    ## @brief Determine if a Cortex-M4 has an FPU.
+    #
+    # The core type must have been identified prior to calling this function.
+    def checkForFPU(self):
+        if self.core_type != ARM_CortexM4:
+            self.has_fpu = False
+            return
+
+        originalCpacr = self.read32(CortexM.CPACR)
+        cpacr = originalCpacr | CortexM.CPACR_CP10_CP11_MASK
+        self.write32(CortexM.CPACR, cpacr)
+
+        cpacr = self.read32(CortexM.CPACR)
+        self.has_fpu = (cpacr & CortexM.CPACR_CP10_CP11_MASK) != 0
+
+        # Restore previous value.
+        self.write32(CortexM.CPACR, originalCpacr)
+
+        if self.has_fpu:
+            logging.info("FPU present")
+
+    def readIDCode(self):
+        """
+        return the IDCODE of the core
+        """
+        return self.dp.read_id_code()
+
+    def flush(self):
+        self.dp.flush()
+
+    def writeMemory(self, addr, value, transfer_size=32):
+        """
+        write a memory location.
+        By default the transfer size is a word
+        """
+        self.ap.writeMemory(addr, value, transfer_size)
+
+    def readMemory(self, addr, transfer_size=32, now=True):
+        """
+        read a memory location. By default, a word will
+        be read
+        """
+        result = self.ap.readMemory(addr, transfer_size, now)
+
+        # Read callback returned for async reads.
+        def readMemoryCb():
+            return self.bp_manager.filter_memory(addr, transfer_size, result())
+
+        if now:
+            return self.bp_manager.filter_memory(addr, transfer_size, result)
+        else:
+            return readMemoryCb
+
+    def readBlockMemoryUnaligned8(self, addr, size):
+        """
+        read a block of unaligned bytes in memory. Returns
+        an array of byte values
+        """
+        data = self.ap.readBlockMemoryUnaligned8(addr, size)
+        return self.bp_manager.filter_memory_unaligned_8(addr, size, data)
+
+    def writeBlockMemoryUnaligned8(self, addr, data):
+        """
+        write a block of unaligned bytes in memory.
+        """
+        self.ap.writeBlockMemoryUnaligned8(addr, data)
+
+    def writeBlockMemoryAligned32(self, addr, data):
+        """
+        write a block of aligned words in memory.
+        """
+        self.ap.writeBlockMemoryAligned32(addr, data)
+
+    def readBlockMemoryAligned32(self, addr, size):
+        """
+        read a block of aligned words in memory. Returns
+        an array of word values
+        """
+        data = self.ap.readBlockMemoryAligned32(addr, size)
+        return self.bp_manager.filter_memory_aligned_32(addr, size, data)
+
+    def halt(self):
+        """
+        halt the core
+        """
+        self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT)
+        self.dp.flush()
+
+    def step(self, disable_interrupts=True):
+        """
+        perform an instruction level step.  This function preserves the previous
+        interrupt mask state
+        """
+        # Was 'if self.getState() != TARGET_HALTED:'
+        # but now value of dhcsr is saved
+        dhcsr = self.readMemory(CortexM.DHCSR)
+        if not (dhcsr & (CortexM.C_STEP | CortexM.C_HALT)):
+            logging.error('cannot step: target not halted')
+            return
+
+        self.clearDebugCauseBits()
+
+        # Save previous interrupt mask state
+        interrupts_masked = (CortexM.C_MASKINTS & dhcsr) != 0
+
+        # Mask interrupts - C_HALT must be set when changing to C_MASKINTS
+        if not interrupts_masked and disable_interrupts:
+            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT | CortexM.C_MASKINTS)
+
+        # Single step using current C_MASKINTS setting
+        if disable_interrupts or interrupts_masked:
+            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_MASKINTS | CortexM.C_STEP)
+        else:
+            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_STEP)
+
+        # Wait for halt to auto set (This should be done before the first read)
+        while not self.readMemory(CortexM.DHCSR) & CortexM.C_HALT:
+            pass
+
+        # Restore interrupt mask state
+        if not interrupts_masked and disable_interrupts:
+            # Unmask interrupts - C_HALT must be set when changing to C_MASKINTS
+            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN | CortexM.C_HALT)
+
+        self.dp.flush()
+
+        self._run_token += 1
+
+    def clearDebugCauseBits(self):
+        self.writeMemory(CortexM.DFSR, CortexM.DFSR_DWTTRAP | CortexM.DFSR_BKPT | CortexM.DFSR_HALTED)
+
+    def reset(self, software_reset=None):
+        """
+        reset a core. After a call to this function, the core
+        is running
+        """
+        if software_reset == None:
+            # Default to software reset if nothing is specified
+            software_reset = True
+
+        self._run_token += 1
+
+        if software_reset:
+            # Perform the reset.
+            try:
+                self.writeMemory(CortexM.NVIC_AIRCR, CortexM.NVIC_AIRCR_VECTKEY | CortexM.NVIC_AIRCR_SYSRESETREQ)
+                # Without a flush a transfer error can occur
+                self.dp.flush()
+            except DAPAccess.TransferError:
+                self.dp.flush()
+
+        else:
+            self.dp.reset()
+
+        # Now wait for the system to come out of reset. Keep reading the DHCSR until
+        # we get a good response with S_RESET_ST cleared, or we time out.
+        startTime = time()
+        while time() - startTime < 2.0:
+            try:
+                dhcsr = self.read32(CortexM.DHCSR)
+                if (dhcsr & CortexM.S_RESET_ST) == 0:
+                    break
+            except DAPAccess.TransferError:
+                self.dp.flush()
+                sleep(0.01)
+
+    def resetStopOnReset(self, software_reset=None):
+        """
+        perform a reset and stop the core on the reset handler
+        """
+        logging.debug("reset stop on Reset")
+
+        # halt the target
+        self.halt()
+
+        # Save CortexM.DEMCR
+        demcr = self.readMemory(CortexM.DEMCR)
+
+        # enable the vector catch
+        self.writeMemory(CortexM.DEMCR, demcr | CortexM.DEMCR_VC_CORERESET)
+
+        self.reset(software_reset)
+
+        # wait until the unit resets
+        while (self.isRunning()):
+            pass
+
+        # restore vector catch setting
+        self.writeMemory(CortexM.DEMCR, demcr)
+
+    def setTargetState(self, state):
+        if state == "PROGRAM":
+            self.resetStopOnReset(True)
+            # Write the thumb bit in case the reset handler
+            # points to an ARM address
+            self.writeCoreRegister('xpsr', 0x1000000)
+
+    def getState(self):
+        dhcsr = self.readMemory(CortexM.DHCSR)
+        if dhcsr & CortexM.S_RESET_ST:
+            # Reset is a special case because the bit is sticky and really means
+            # "core was reset since last read of DHCSR". We have to re-read the
+            # DHCSR, check if S_RESET_ST is still set and make sure no instructions
+            # were executed by checking S_RETIRE_ST.
+            newDhcsr = self.readMemory(CortexM.DHCSR)
+            if (newDhcsr & CortexM.S_RESET_ST) and not (newDhcsr & CortexM.S_RETIRE_ST):
+                return Target.TARGET_RESET
+        if dhcsr & CortexM.S_LOCKUP:
+            return Target.TARGET_LOCKUP
+        elif dhcsr & CortexM.S_SLEEP:
+            return Target.TARGET_SLEEPING
+        elif dhcsr & CortexM.S_HALT:
+            return Target.TARGET_HALTED
+        else:
+            return Target.TARGET_RUNNING
+
+    @property
+    def run_token(self):
+        return self._run_token
+
+    def isRunning(self):
+        return self.getState() == Target.TARGET_RUNNING
+
+    def isHalted(self):
+        return self.getState() == Target.TARGET_HALTED
+
+    def resume(self):
+        """
+        resume the execution
+        """
+        if self.getState() != Target.TARGET_HALTED:
+            logging.debug('cannot resume: target not halted')
+            return
+        self._run_token += 1
+        self.clearDebugCauseBits()
+        self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
+        self.dp.flush()
+
+    def findBreakpoint(self, addr):
+        return self.bp_manager.find_breakpoint(addr)
+
+    def readCoreRegister(self, reg):
+        """
+        read CPU register
+        Unpack floating point register values
+        """
+        regIndex = register_name_to_index(reg)
+        regValue = self.readCoreRegisterRaw(regIndex)
+        # Convert int to float.
+        if regIndex >= 0x40:
+            regValue = conversion.u32BEToFloat32BE(regValue)
+        return regValue
+
+    def readCoreRegisterRaw(self, reg):
+        """
+        read a core register (r0 .. r16).
+        If reg is a string, find the number associated to this register
+        in the lookup table CORE_REGISTER
+        """
+        vals = self.readCoreRegistersRaw([reg])
+        return vals[0]
+
+    def readCoreRegistersRaw(self, reg_list):
+        """
+        Read one or more core registers
+
+        Read core registers in reg_list and return a list of values.
+        If any register in reg_list is a string, find the number
+        associated to this register in the lookup table CORE_REGISTER.
+        """
+        # convert to index only
+        reg_list = [register_name_to_index(reg) for reg in reg_list]
+
+        # Sanity check register values
+        for reg in reg_list:
+            if reg not in CORE_REGISTER.values():
+                raise ValueError("unknown reg: %d" % reg)
+            elif ((reg >= 0x40) or (reg == 33)) and (not self.has_fpu):
+                raise ValueError("attempt to read FPU register without FPU")
+
+        # Begin all reads and writes
+        dhcsr_cb_list = []
+        reg_cb_list = []
+        for reg in reg_list:
+            if (reg < 0) and (reg >= -4):
+                reg = CORE_REGISTER['cfbp']
+
+            # write id in DCRSR
+            self.writeMemory(CortexM.DCRSR, reg)
+
+            # Technically, we need to poll S_REGRDY in DHCSR here before reading DCRDR. But
+            # we're running so slow compared to the target that it's not necessary.
+            # Read it and assert that S_REGRDY is set
+
+            dhcsr_cb = self.readMemory(CortexM.DHCSR, now=False)
+            reg_cb = self.readMemory(CortexM.DCRDR, now=False)
+            dhcsr_cb_list.append(dhcsr_cb)
+            reg_cb_list.append(reg_cb)
+
+        # Read all results
+        reg_vals = []
+        for reg, reg_cb, dhcsr_cb in zip(reg_list, reg_cb_list, dhcsr_cb_list):
+            dhcsr_val = dhcsr_cb()
+            assert dhcsr_val & CortexM.S_REGRDY
+            val = reg_cb()
+
+            # Special handling for registers that are combined into a single DCRSR number.
+            if (reg < 0) and (reg >= -4):
+                val = (val >> ((-reg - 1) * 8)) & 0xff
+
+            reg_vals.append(val)
+
+        return reg_vals
+
+    def writeCoreRegister(self, reg, data):
+        """
+        write a CPU register.
+        Will need to pack floating point register values before writing.
+        """
+        regIndex = register_name_to_index(reg)
+        # Convert float to int.
+        if regIndex >= 0x40:
+            data = conversion.float32beToU32be(data)
+        self.writeCoreRegisterRaw(regIndex, data)
+
+    def writeCoreRegisterRaw(self, reg, data):
+        """
+        write a core register (r0 .. r16)
+        If reg is a string, find the number associated to this register
+        in the lookup table CORE_REGISTER
+        """
+        self.writeCoreRegistersRaw([reg], [data])
+
+    def writeCoreRegistersRaw(self, reg_list, data_list):
+        """
+        Write one or more core registers
+
+        Write core registers in reg_list with the associated value in
+        data_list.  If any register in reg_list is a string, find the number
+        associated to this register in the lookup table CORE_REGISTER.
+        """
+        assert len(reg_list) == len(data_list)
+        # convert to index only
+        reg_list = [register_name_to_index(reg) for reg in reg_list]
+
+        # Sanity check register values
+        for reg in reg_list:
+            if reg not in CORE_REGISTER.values():
+                raise ValueError("unknown reg: %d" % reg)
+            elif ((reg >= 0x40) or (reg == 33)) and (not self.has_fpu):
+                raise ValueError("attempt to write FPU register without FPU")
+
+        # Read special register if it is present in the list
+        for reg in reg_list:
+            if (reg < 0) and (reg >= -4):
+                specialRegValue = self.readCoreRegister(CORE_REGISTER['cfbp'])
+                break
+
+        # Write out registers
+        dhcsr_cb_list = []
+        for reg, data in zip(reg_list, data_list):
+            if (reg < 0) and (reg >= -4):
+                # Mask in the new special register value so we don't modify the other register
+                # values that share the same DCRSR number.
+                shift = (-reg - 1) * 8
+                mask = 0xffffffff ^ (0xff << shift)
+                data = (specialRegValue & mask) | ((data & 0xff) << shift)
+                specialRegValue = data # update special register for other writes that might be in the list
+                reg = CORE_REGISTER['cfbp']
+
+            # write DCRDR
+            self.writeMemory(CortexM.DCRDR, data)
+
+            # write id in DCRSR and flag to start write transfer
+            self.writeMemory(CortexM.DCRSR, reg | CortexM.DCRSR_REGWnR)
+
+            # Technically, we need to poll S_REGRDY in DHCSR here to ensure the
+            # register write has completed.
+            # Read it and assert that S_REGRDY is set
+            dhcsr_cb = self.readMemory(CortexM.DHCSR, now=False)
+            dhcsr_cb_list.append(dhcsr_cb)
+
+        # Make sure S_REGRDY was set for all register
+        # writes
+        for dhcsr_cb in dhcsr_cb_list:
+            dhcsr_val = dhcsr_cb()
+            assert dhcsr_val & CortexM.S_REGRDY
+
+    ## @brief Set a hardware or software breakpoint at a specific location in memory.
+    #
+    # @retval True Breakpoint was set.
+    # @retval False Breakpoint could not be set.
+    def setBreakpoint(self, addr, type=Target.BREAKPOINT_AUTO):
+        return self.bp_manager.set_breakpoint(addr, type)
+
+    ## @brief Remove a breakpoint at a specific location.
+    def removeBreakpoint(self, addr):
+        self.bp_manager.remove_breakpoint(addr)
+
+    def getBreakpointType(self, addr):
+        return self.bp_manager.get_breakpoint_type(addr)
+
+    def availableBreakpoint(self):
+        return self.fpb.available_breakpoints()
+
+    def findWatchpoint(self, addr, size, type):
+        return self.dwt.find_watchpoint(addr, size, type)
+
+    def setWatchpoint(self, addr, size, type):
+        """
+        set a hardware watchpoint
+        """
+        return self.dwt.set_watchpoint(addr, size, type)
+
+    def removeWatchpoint(self, addr, size, type):
+        """
+        remove a hardware watchpoint
+        """
+        return self.dwt.remove_watchpoint(addr, size, type)
+
+    @staticmethod
+    def _map_to_vector_catch_mask(mask):
+        result = 0
+        if mask & Target.CATCH_HARD_FAULT:
+            result |= CortexM.DEMCR_VC_HARDERR
+        if mask & Target.CATCH_BUS_FAULT:
+            result |= CortexM.DEMCR_VC_BUSERR
+        if mask & Target.CATCH_MEM_FAULT:
+            result |= CortexM.DEMCR_VC_MMERR
+        if mask & Target.CATCH_INTERRUPT_ERR:
+            result |= CortexM.DEMCR_VC_INTERR
+        if mask & Target.CATCH_STATE_ERR:
+            result |= CortexM.DEMCR_VC_STATERR
+        if mask & Target.CATCH_CHECK_ERR:
+            result |= CortexM.DEMCR_VC_CHKERR
+        if mask & Target.CATCH_COPROCESSOR_ERR:
+            result |= CortexM.DEMCR_VC_NOCPERR
+        if mask & Target.CATCH_CORE_RESET:
+            result |= CortexM.DEMCR_VC_CORERESET
+        return result
+
+    @staticmethod
+    def _map_from_vector_catch_mask(mask):
+        result = 0
+        if mask & CortexM.DEMCR_VC_HARDERR:
+            result |= Target.CATCH_HARD_FAULT
+        if mask & CortexM.DEMCR_VC_BUSERR:
+            result |= Target.CATCH_BUS_FAULT
+        if mask & CortexM.DEMCR_VC_MMERR:
+            result |= Target.CATCH_MEM_FAULT
+        if mask & CortexM.DEMCR_VC_INTERR:
+            result |= Target.CATCH_INTERRUPT_ERR
+        if mask & CortexM.DEMCR_VC_STATERR:
+            result |= Target.CATCH_STATE_ERR
+        if mask & CortexM.DEMCR_VC_CHKERR:
+            result |= Target.CATCH_CHECK_ERR
+        if mask & CortexM.DEMCR_VC_NOCPERR:
+            result |= Target.CATCH_COPROCESSOR_ERR
+        if mask & CortexM.DEMCR_VC_CORERESET:
+            result |= Target.CATCH_CORE_RESET
+        return result
+
+    def setVectorCatch(self, enableMask):
+        demcr = self.readMemory(CortexM.DEMCR)
+        demcr |= CortexM._map_to_vector_catch_mask(enableMask)
+        demcr &= ~CortexM._map_to_vector_catch_mask(~enableMask)
+        self.writeMemory(CortexM.DEMCR, demcr)
+
+    def getVectorCatch(self):
+        demcr = self.readMemory(CortexM.DEMCR)
+        return CortexM._map_from_vector_catch_mask(demcr)
+
+    # GDB functions
+    def getTargetXML(self):
+        return self.targetXML
+
+    def isDebugTrap(self):
+        debugEvents = self.readMemory(CortexM.DFSR) & (CortexM.DFSR_DWTTRAP | CortexM.DFSR_BKPT | CortexM.DFSR_HALTED)
+        return debugEvents != 0
+
+    def getTargetContext(self, core=None):
+        return self._target_context
+
+    def setTargetContext(self, context):
+        self._target_context = context
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/dap.py` & `pyOCD-0.9.0/pyOCD/coresight/dap.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,315 +1,319 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from ..pyDAPAccess import DAPAccess
-import logging
-import logging.handlers
-import os
-import os.path
-import six
-
-# !! This value are A[2:3] and not A[3:2]
-DP_REG = {'IDCODE': DAPAccess.REG.DP_0x0,
-          'ABORT': DAPAccess.REG.DP_0x0,
-          'CTRL_STAT': DAPAccess.REG.DP_0x4,
-          'SELECT': DAPAccess.REG.DP_0x8
-          }
-AP_REG = {'CSW' : 0x00,
-          'TAR' : 0x04,
-          'DRW' : 0x0C,
-          'IDR' : 0xFC
-          }
-
-# DP Control / Status Register bit definitions
-CTRLSTAT_STICKYORUN = 0x00000002
-CTRLSTAT_STICKYCMP = 0x00000010
-CTRLSTAT_STICKYERR = 0x00000020
-
-IDCODE = 0 << 2
-AP_ACC = 1 << 0
-DP_ACC = 0 << 0
-READ = 1 << 1
-WRITE = 0 << 1
-VALUE_MATCH = 1 << 4
-MATCH_MASK = 1 << 5
-
-A32 = 0x0c
-APSEL_SHIFT = 24
-APSEL = 0xff000000
-APBANKSEL = 0x000000f0
-APREG_MASK = 0x000000fc
-
-DPIDR_MIN_MASK = 0x10000
-DPIDR_VERSION_MASK = 0xf000
-DPIDR_VERSION_SHIFT = 12
-
-CSYSPWRUPACK = 0x80000000
-CDBGPWRUPACK = 0x20000000
-CSYSPWRUPREQ = 0x40000000
-CDBGPWRUPREQ = 0x10000000
-
-TRNNORMAL = 0x00000000
-MASKLANE = 0x00000f00
-
-# Set to True to enable logging of all DP and AP accesses.
-LOG_DAP = False
-
-def _ap_addr_to_reg(addr):
-    return DAPAccess.REG(4 + ((addr & A32) >> 2))
-
-class DebugPort(object):
-    # DAP log file name.
-    DAP_LOG_FILE = "pyocd_dap.log"
-
-    def __init__(self, link):
-        self.link = link
-        self._csw = {}
-        self._dp_select = -1
-        self._access_number = 0
-        if LOG_DAP:
-            self._setup_logging()
-
-    @property
-    def next_access_number(self):
-        self._access_number += 1
-        return self._access_number
-
-    ## @brief Set up DAP logging.
-    #
-    # A memory handler is created that buffers log records before flushing them to a file
-    # handler that writes to DAP_LOG_FILE. This improves logging performance by writing to the
-    # log file less often.
-    def _setup_logging(self):
-        cwd = os.getcwd()
-        logfile = os.path.join(cwd, self.DAP_LOG_FILE)
-        logging.info("dap logfile: %s", logfile)
-        self.logger = logging.getLogger('dap')
-        self.logger.propagate = False
-        formatter = logging.Formatter('%(relativeCreated)010dms:%(levelname)s:%(name)s:%(message)s')
-        fileHandler = logging.FileHandler(logfile, mode='w+', delay=True)
-        fileHandler.setFormatter(formatter)
-        memHandler = logging.handlers.MemoryHandler(capacity=128, target=fileHandler)
-        self.logger.addHandler(memHandler)
-        self.logger.setLevel(logging.DEBUG)
-
-    def init(self):
-        # Connect to the target.
-        self.link.connect()
-        self.read_id_code()
-        self.clear_sticky_err()
-
-    def read_id_code(self):
-        # Read ID register and get DP version
-        self.dpidr = self.read_reg(DP_REG['IDCODE'])
-        self.dp_version = (self.dpidr & DPIDR_VERSION_MASK) >> DPIDR_VERSION_SHIFT
-        self.is_mindp = (self.dpidr & DPIDR_MIN_MASK) != 0
-        return self.dpidr
-
-    def flush(self):
-        try:
-            self.link.flush()
-        finally:
-            self._csw = {}
-            self._dp_select = -1
-
-    def read_reg(self, addr, now=True):
-        return self.readDP(addr, now)
-
-    def write_reg(self, addr, data):
-        self.writeDP(addr, data)
-
-    def power_up_debug(self):
-        # select bank 0 (to access DRW and TAR)
-        self.write_reg(DP_REG['SELECT'], 0)
-        self.write_reg(DP_REG['CTRL_STAT'], CSYSPWRUPREQ | CDBGPWRUPREQ)
-
-        while True:
-            r = self.read_reg(DP_REG['CTRL_STAT'])
-            if (r & (CDBGPWRUPACK | CSYSPWRUPACK)) == (CDBGPWRUPACK | CSYSPWRUPACK):
-                break
-
-        self.write_reg(DP_REG['CTRL_STAT'], CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)
-        self.write_reg(DP_REG['SELECT'], 0)
-
-    def power_down_debug(self):
-        # select bank 0 (to access DRW and TAR)
-        self.write_reg(DP_REG['SELECT'], 0)
-        self.write_reg(DP_REG['CTRL_STAT'], 0)
-
-    def reset(self):
-        try:
-            self.link.reset()
-        finally:
-            self._csw = {}
-            self._dp_select = -1
-
-    def assert_reset(self, asserted):
-        self.link.assert_reset(asserted)
-        self._csw = {}
-        self._dp_select = -1
-
-    def set_clock(self, frequency):
-        self.link.set_clock(frequency)
-
-    def find_aps(self):
-        ap_num = 0
-        while True:
-            try:
-                idr = self.readAP((ap_num << APSEL_SHIFT) | AP_REG['IDR'])
-                if idr == 0:
-                    break
-                logging.info("AP#%d IDR = 0x%08x", ap_num, idr)
-            except Exception, e:
-                logging.error("Exception reading AP#%d IDR", ap_num, e)
-                break
-            ap_num += 1
-
-    def readDP(self, addr, now=True):
-        assert addr in DAPAccess.REG
-        num = self.next_access_number
-
-        try:
-            result_cb = self.link.read_reg(addr, now=False)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-
-        # Read callback returned for async reads.
-        def readDPCb():
-            try:
-                result = result_cb()
-                if LOG_DAP:
-                    self.logger.info("readDP:%06d %s(addr=0x%08x) -> 0x%08x", num, "" if now else "...", addr.value, result)
-                return result
-            except DAPAccess.Error as error:
-                self._handle_error(error, num)
-                raise
-
-        if now:
-            return readDPCb()
-        else:
-            if LOG_DAP:
-                self.logger.info("readDP:%06d (addr=0x%08x) -> ...", num, addr.value)
-            return readDPCb
-
-    def writeDP(self, addr, data):
-        assert addr in DAPAccess.REG
-        num = self.next_access_number
-
-        # Skip writing DP SELECT register if its value is not changing.
-        if addr == DP_REG['SELECT']:
-            if data == self._dp_select:
-                if LOG_DAP:
-                    self.logger.info("writeDP:%06d cached (addr=0x%08x) = 0x%08x", num, addr.value, data)
-                return
-            self._dp_select = data
-
-        # Write the DP register.
-        try:
-            if LOG_DAP:
-                self.logger.info("writeDP:%06d (addr=0x%08x) = 0x%08x", num, addr.value, data)
-            self.link.write_reg(addr, data)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-
-        return True
-
-    def writeAP(self, addr, data):
-        assert type(addr) in (six.integer_types)
-        num = self.next_access_number
-        ap_sel = addr & APSEL
-        bank_sel = addr & APBANKSEL
-        ap_regaddr = addr & APREG_MASK
-
-        # Don't need to write CSW if it's not changing value.
-        if ap_regaddr == AP_REG['CSW']:
-            if self._csw.has_key(ap_sel) and data == self._csw[ap_sel]:
-                if LOG_DAP:
-                    self.logger.info("writeAP:%06d cached (addr=0x%08x) = 0x%08x", num, addr, data)
-                return
-            self._csw[ap_sel] = data
-
-        # Select the AP and bank.
-        self.writeDP(DP_REG['SELECT'], ap_sel | bank_sel)
-
-        # Perform the AP register write.
-        ap_reg = _ap_addr_to_reg(WRITE | AP_ACC | (addr & A32))
-        try:
-            if LOG_DAP:
-                self.logger.info("writeAP:%06d (addr=0x%08x) = 0x%08x", num, addr, data)
-            self.link.write_reg(ap_reg, data)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-
-        return True
-
-    def readAP(self, addr, now=True):
-        assert type(addr) in (six.integer_types)
-        num = self.next_access_number
-        res = None
-        ap_reg = _ap_addr_to_reg(READ | AP_ACC | (addr & A32))
-
-        try:
-            ap_sel = addr & APSEL
-            bank_sel = addr & APBANKSEL
-            self.writeDP(DP_REG['SELECT'], ap_sel | bank_sel)
-            result_cb = self.link.read_reg(ap_reg, now=False)
-        except DAPAccess.Error as error:
-            self._handle_error(error, num)
-            raise
-
-        # Read callback returned for async reads.
-        def readAPCb():
-            try:
-                result = result_cb()
-                if LOG_DAP:
-                    self.logger.info("readAP:%06d %s(addr=0x%08x) -> 0x%08x", num, "" if now else "...", addr, result)
-                return result
-            except DAPAccess.Error as error:
-                self._handle_error(error, num)
-                raise
-
-        if now:
-            return readAPCb()
-        else:
-            if LOG_DAP:
-                self.logger.info("readAP:%06d (addr=0x%08x) -> ...", num, addr)
-            return readAPCb
-
-    def _handle_error(self, error, num):
-        if LOG_DAP:
-            self.logger.info("error:%06d %s", num, error)
-        # Invalidate cached registers
-        self._csw = {}
-        self._dp_select = -1
-        # Clear sticky error for Fault errors only
-        if isinstance(error, DAPAccess.TransferFaultError):
-            self.clear_sticky_err()
-
-    def clear_sticky_err(self):
-        mode = self.link.get_swj_mode()
-        if mode == DAPAccess.PORT.SWD:
-            self.link.write_reg(DAPAccess.REG.DP_0x0, (1 << 2))
-        elif mode == DAPAccess.PORT.JTAG:
-            self.link.write_reg(DP_REG['CTRL_STAT'], CTRLSTAT_STICKYERR)
-        else:
-            assert False
-
-
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..pyDAPAccess import DAPAccess
+import logging
+import logging.handlers
+import os
+import os.path
+import six
+
+# !! This value are A[2:3] and not A[3:2]
+DP_REG = {'IDCODE': DAPAccess.REG.DP_0x0,
+          'ABORT': DAPAccess.REG.DP_0x0,
+          'CTRL_STAT': DAPAccess.REG.DP_0x4,
+          'SELECT': DAPAccess.REG.DP_0x8
+          }
+AP_REG = {'CSW' : 0x00,
+          'TAR' : 0x04,
+          'DRW' : 0x0C,
+          'IDR' : 0xFC
+          }
+
+# DP Control / Status Register bit definitions
+CTRLSTAT_STICKYORUN = 0x00000002
+CTRLSTAT_STICKYCMP = 0x00000010
+CTRLSTAT_STICKYERR = 0x00000020
+
+IDCODE = 0 << 2
+AP_ACC = 1 << 0
+DP_ACC = 0 << 0
+READ = 1 << 1
+WRITE = 0 << 1
+VALUE_MATCH = 1 << 4
+MATCH_MASK = 1 << 5
+
+A32 = 0x0c
+APSEL_SHIFT = 24
+APSEL = 0xff000000
+APBANKSEL = 0x000000f0
+APREG_MASK = 0x000000fc
+
+DPIDR_MIN_MASK = 0x10000
+DPIDR_VERSION_MASK = 0xf000
+DPIDR_VERSION_SHIFT = 12
+
+CSYSPWRUPACK = 0x80000000
+CDBGPWRUPACK = 0x20000000
+CSYSPWRUPREQ = 0x40000000
+CDBGPWRUPREQ = 0x10000000
+
+TRNNORMAL = 0x00000000
+MASKLANE = 0x00000f00
+
+# Set to True to enable logging of all DP and AP accesses.
+LOG_DAP = False
+
+def _ap_addr_to_reg(addr):
+    return DAPAccess.REG(4 + ((addr & A32) >> 2))
+
+class DebugPort(object):
+    # DAP log file name.
+    DAP_LOG_FILE = "pyocd_dap.log"
+
+    def __init__(self, link):
+        self.link = link
+        self._csw = {}
+        self._dp_select = -1
+        self._access_number = 0
+        if LOG_DAP:
+            self._setup_logging()
+
+    @property
+    def next_access_number(self):
+        self._access_number += 1
+        return self._access_number
+
+    ## @brief Set up DAP logging.
+    #
+    # A memory handler is created that buffers log records before flushing them to a file
+    # handler that writes to DAP_LOG_FILE. This improves logging performance by writing to the
+    # log file less often.
+    def _setup_logging(self):
+        cwd = os.getcwd()
+        logfile = os.path.join(cwd, self.DAP_LOG_FILE)
+        logging.info("dap logfile: %s", logfile)
+        self.logger = logging.getLogger('dap')
+        self.logger.propagate = False
+        formatter = logging.Formatter('%(relativeCreated)010dms:%(levelname)s:%(name)s:%(message)s')
+        fileHandler = logging.FileHandler(logfile, mode='w+', delay=True)
+        fileHandler.setFormatter(formatter)
+        memHandler = logging.handlers.MemoryHandler(capacity=128, target=fileHandler)
+        self.logger.addHandler(memHandler)
+        self.logger.setLevel(logging.DEBUG)
+
+    def init(self):
+        # Connect to the target.
+        self.link.connect()
+        self.link.swj_sequence()
+        self.read_id_code()
+        self.clear_sticky_err()
+
+    def read_id_code(self):
+        # Read ID register and get DP version
+        self.dpidr = self.read_reg(DP_REG['IDCODE'])
+        self.dp_version = (self.dpidr & DPIDR_VERSION_MASK) >> DPIDR_VERSION_SHIFT
+        self.is_mindp = (self.dpidr & DPIDR_MIN_MASK) != 0
+        return self.dpidr
+
+    def flush(self):
+        try:
+            self.link.flush()
+        except DAPAccess.Error as error:
+            self._handle_error(error, self.next_access_number)
+            raise
+        finally:
+            self._csw = {}
+            self._dp_select = -1
+
+    def read_reg(self, addr, now=True):
+        return self.readDP(addr, now)
+
+    def write_reg(self, addr, data):
+        self.writeDP(addr, data)
+
+    def power_up_debug(self):
+        # select bank 0 (to access DRW and TAR)
+        self.write_reg(DP_REG['SELECT'], 0)
+        self.write_reg(DP_REG['CTRL_STAT'], CSYSPWRUPREQ | CDBGPWRUPREQ)
+
+        while True:
+            r = self.read_reg(DP_REG['CTRL_STAT'])
+            if (r & (CDBGPWRUPACK | CSYSPWRUPACK)) == (CDBGPWRUPACK | CSYSPWRUPACK):
+                break
+
+        self.write_reg(DP_REG['CTRL_STAT'], CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)
+        self.write_reg(DP_REG['SELECT'], 0)
+
+    def power_down_debug(self):
+        # select bank 0 (to access DRW and TAR)
+        self.write_reg(DP_REG['SELECT'], 0)
+        self.write_reg(DP_REG['CTRL_STAT'], 0)
+
+    def reset(self):
+        try:
+            self.link.reset()
+        finally:
+            self._csw = {}
+            self._dp_select = -1
+
+    def assert_reset(self, asserted):
+        self.link.assert_reset(asserted)
+        self._csw = {}
+        self._dp_select = -1
+
+    def set_clock(self, frequency):
+        self.link.set_clock(frequency)
+
+    def find_aps(self):
+        ap_num = 0
+        while True:
+            try:
+                idr = self.readAP((ap_num << APSEL_SHIFT) | AP_REG['IDR'])
+                if idr == 0:
+                    break
+                logging.info("AP#%d IDR = 0x%08x", ap_num, idr)
+            except Exception, e:
+                logging.error("Exception reading AP#%d IDR: %s", ap_num, repr(e))
+                break
+            ap_num += 1
+
+    def readDP(self, addr, now=True):
+        assert addr in DAPAccess.REG
+        num = self.next_access_number
+
+        try:
+            result_cb = self.link.read_reg(addr, now=False)
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+
+        # Read callback returned for async reads.
+        def readDPCb():
+            try:
+                result = result_cb()
+                if LOG_DAP:
+                    self.logger.info("readDP:%06d %s(addr=0x%08x) -> 0x%08x", num, "" if now else "...", addr.value, result)
+                return result
+            except DAPAccess.Error as error:
+                self._handle_error(error, num)
+                raise
+
+        if now:
+            return readDPCb()
+        else:
+            if LOG_DAP:
+                self.logger.info("readDP:%06d (addr=0x%08x) -> ...", num, addr.value)
+            return readDPCb
+
+    def writeDP(self, addr, data):
+        assert addr in DAPAccess.REG
+        num = self.next_access_number
+
+        # Skip writing DP SELECT register if its value is not changing.
+        if addr == DP_REG['SELECT']:
+            if data == self._dp_select:
+                if LOG_DAP:
+                    self.logger.info("writeDP:%06d cached (addr=0x%08x) = 0x%08x", num, addr.value, data)
+                return
+            self._dp_select = data
+
+        # Write the DP register.
+        try:
+            if LOG_DAP:
+                self.logger.info("writeDP:%06d (addr=0x%08x) = 0x%08x", num, addr.value, data)
+            self.link.write_reg(addr, data)
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+
+        return True
+
+    def writeAP(self, addr, data):
+        assert type(addr) in (six.integer_types)
+        num = self.next_access_number
+        ap_sel = addr & APSEL
+        bank_sel = addr & APBANKSEL
+        ap_regaddr = addr & APREG_MASK
+
+        # Don't need to write CSW if it's not changing value.
+        if ap_regaddr == AP_REG['CSW']:
+            if self._csw.has_key(ap_sel) and data == self._csw[ap_sel]:
+                if LOG_DAP:
+                    self.logger.info("writeAP:%06d cached (addr=0x%08x) = 0x%08x", num, addr, data)
+                return
+            self._csw[ap_sel] = data
+
+        # Select the AP and bank.
+        self.writeDP(DP_REG['SELECT'], ap_sel | bank_sel)
+
+        # Perform the AP register write.
+        ap_reg = _ap_addr_to_reg(WRITE | AP_ACC | (addr & A32))
+        try:
+            if LOG_DAP:
+                self.logger.info("writeAP:%06d (addr=0x%08x) = 0x%08x", num, addr, data)
+            self.link.write_reg(ap_reg, data)
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+
+        return True
+
+    def readAP(self, addr, now=True):
+        assert type(addr) in (six.integer_types)
+        num = self.next_access_number
+        res = None
+        ap_reg = _ap_addr_to_reg(READ | AP_ACC | (addr & A32))
+
+        try:
+            ap_sel = addr & APSEL
+            bank_sel = addr & APBANKSEL
+            self.writeDP(DP_REG['SELECT'], ap_sel | bank_sel)
+            result_cb = self.link.read_reg(ap_reg, now=False)
+        except DAPAccess.Error as error:
+            self._handle_error(error, num)
+            raise
+
+        # Read callback returned for async reads.
+        def readAPCb():
+            try:
+                result = result_cb()
+                if LOG_DAP:
+                    self.logger.info("readAP:%06d %s(addr=0x%08x) -> 0x%08x", num, "" if now else "...", addr, result)
+                return result
+            except DAPAccess.Error as error:
+                self._handle_error(error, num)
+                raise
+
+        if now:
+            return readAPCb()
+        else:
+            if LOG_DAP:
+                self.logger.info("readAP:%06d (addr=0x%08x) -> ...", num, addr)
+            return readAPCb
+
+    def _handle_error(self, error, num):
+        if LOG_DAP:
+            self.logger.info("error:%06d %s", num, error)
+        # Invalidate cached registers
+        self._csw = {}
+        self._dp_select = -1
+        # Clear sticky error for Fault errors only
+        if isinstance(error, DAPAccess.TransferFaultError):
+            self.clear_sticky_err()
+
+    def clear_sticky_err(self):
+        mode = self.link.get_swj_mode()
+        if mode == DAPAccess.PORT.SWD:
+            self.link.write_reg(DAPAccess.REG.DP_0x0, (1 << 2))
+        elif mode == DAPAccess.PORT.JTAG:
+            self.link.write_reg(DP_REG['CTRL_STAT'], CTRLSTAT_STICKYERR)
+        else:
+            assert False
+
+
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/dwt.py` & `pyOCD-0.9.0/pyOCD/coresight/dwt.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,124 +1,131 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from .breakpoints import Watchpoint
-from ..target.target import Target
-import logging
-
-# Need a local copy to prevent circular import.
-# Debug Exception and Monitor Control Register
-DEMCR = 0xE000EDFC
-# DWTENA in armv6 architecture reference manual
-DEMCR_TRCENA = (1 << 24)
-DEMCR_VC_HARDERR = (1 << 10)
-DEMCR_VC_BUSERR = (1 << 8)
-DEMCR_VC_CORERESET = (1 << 0)
-
-class DWT(object):
-    # DWT (data watchpoint & trace)
-    DWT_CTRL = 0xE0001000
-    DWT_COMP_BASE = 0xE0001020
-    DWT_MASK_OFFSET = 4
-    DWT_FUNCTION_OFFSET = 8
-    DWT_COMP_BLOCK_SIZE = 0x10
-
-    WATCH_TYPE_TO_FUNCT = {
-                            Target.WATCHPOINT_READ: 5,
-                            Target.WATCHPOINT_WRITE: 6,
-                            Target.WATCHPOINT_READ_WRITE: 7
-                            }
-
-    # Only sizes that are powers of 2 are supported
-    # Breakpoint size = MASK**2
-    WATCH_SIZE_TO_MASK = dict((2**i, i) for i in range(0,32))
-
-    def __init__(self, ap):
-        super(DWT, self).__init__()
-        self.ap = ap
-        self.watchpoints = []
-        self.watchpoint_used = 0
-        self.dwt_configured = False
-
-    ## @brief Inits the DWT.
-    #
-    # Reads the number of hardware watchpoints available on the core  and makes sure that they
-    # are all disabled and ready for future use.
-    def init(self):
-        demcr = self.ap.readMemory(DEMCR)
-        demcr = demcr | DEMCR_TRCENA
-        self.ap.writeMemory(DEMCR, demcr)
-        dwt_ctrl = self.ap.readMemory(DWT.DWT_CTRL)
-        watchpoint_count = (dwt_ctrl >> 28) & 0xF
-        logging.info("%d hardware watchpoints", watchpoint_count)
-        for i in range(watchpoint_count):
-            self.watchpoints.append(Watchpoint(DWT.DWT_COMP_BASE + DWT.DWT_COMP_BLOCK_SIZE*i, self))
-            self.ap.writeMemory(DWT.DWT_COMP_BASE + DWT.DWT_COMP_BLOCK_SIZE*i + DWT.DWT_FUNCTION_OFFSET, 0)
-        self.dwt_configured = True
-
-    def find_watchpoint(self, addr, size, type):
-        for watch in self.watchpoints:
-            if watch.addr == addr and watch.size == size and watch.func == DWT.WATCH_TYPE_TO_FUNCT[type]:
-                return watch
-        return None
-
-    ## @brief Set a hardware watchpoint.
-    def set_watchpoint(self, addr, size, type):
-        if self.dwt_configured is False:
-            self.init()
-
-        watch = self.find_watchpoint(addr, size, type)
-        if watch != None:
-            return True
-
-        if type not in DWT.WATCH_TYPE_TO_FUNCT:
-            logging.error("Invalid watchpoint type %i", type)
-            return False
-
-        for watch in self.watchpoints:
-            if watch.func == 0:
-                watch.addr = addr
-                watch.func = DWT.WATCH_TYPE_TO_FUNCT[type]
-                watch.size = size
-
-                if size not in DWT.WATCH_SIZE_TO_MASK:
-                    logging.error('Watchpoint of size %d not supported by device', size)
-                    return False
-
-                mask = DWT.WATCH_SIZE_TO_MASK[size]
-                self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_MASK_OFFSET, mask)
-                if self.ap.readMemory(watch.comp_register_addr + DWT.DWT_MASK_OFFSET) != mask:
-                    logging.error('Watchpoint of size %d not supported by device', size)
-                    return False
-
-                self.ap.writeMemory(watch.comp_register_addr, addr)
-                self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_FUNCTION_OFFSET, watch.func)
-                self.watchpoint_used += 1
-                return True
-
-        logging.error('No more available watchpoint!!, dropped watch at 0x%X', addr)
-        return False
-
-    ## @brief Remove a hardware watchpoint.
-    def remove_watchpoint(self, addr, size, type):
-        watch = self.find_watchpoint(addr, size, type)
-        if watch is None:
-            return
-
-        watch.func = 0
-        self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_FUNCTION_OFFSET, 0)
-        self.watchpoint_used -= 1
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .fpb import HardwareBreakpoint
+from ..core.target import Target
+import logging
+
+# Need a local copy to prevent circular import.
+# Debug Exception and Monitor Control Register
+DEMCR = 0xE000EDFC
+# DWTENA in armv6 architecture reference manual
+DEMCR_TRCENA = (1 << 24)
+DEMCR_VC_HARDERR = (1 << 10)
+DEMCR_VC_BUSERR = (1 << 8)
+DEMCR_VC_CORERESET = (1 << 0)
+
+class Watchpoint(HardwareBreakpoint):
+    def __init__(self, comp_register_addr, provider):
+        super(Watchpoint, self).__init__(comp_register_addr, provider)
+        self.addr = 0
+        self.size = 0
+        self.func = 0
+
+class DWT(object):
+    # DWT (data watchpoint & trace)
+    DWT_CTRL = 0xE0001000
+    DWT_COMP_BASE = 0xE0001020
+    DWT_MASK_OFFSET = 4
+    DWT_FUNCTION_OFFSET = 8
+    DWT_COMP_BLOCK_SIZE = 0x10
+
+    WATCH_TYPE_TO_FUNCT = {
+                            Target.WATCHPOINT_READ: 5,
+                            Target.WATCHPOINT_WRITE: 6,
+                            Target.WATCHPOINT_READ_WRITE: 7
+                            }
+
+    # Only sizes that are powers of 2 are supported
+    # Breakpoint size = MASK**2
+    WATCH_SIZE_TO_MASK = dict((2**i, i) for i in range(0,32))
+
+    def __init__(self, ap):
+        super(DWT, self).__init__()
+        self.ap = ap
+        self.watchpoints = []
+        self.watchpoint_used = 0
+        self.dwt_configured = False
+
+    ## @brief Inits the DWT.
+    #
+    # Reads the number of hardware watchpoints available on the core  and makes sure that they
+    # are all disabled and ready for future use.
+    def init(self):
+        demcr = self.ap.readMemory(DEMCR)
+        demcr = demcr | DEMCR_TRCENA
+        self.ap.writeMemory(DEMCR, demcr)
+        dwt_ctrl = self.ap.readMemory(DWT.DWT_CTRL)
+        watchpoint_count = (dwt_ctrl >> 28) & 0xF
+        logging.info("%d hardware watchpoints", watchpoint_count)
+        for i in range(watchpoint_count):
+            self.watchpoints.append(Watchpoint(DWT.DWT_COMP_BASE + DWT.DWT_COMP_BLOCK_SIZE*i, self))
+            self.ap.writeMemory(DWT.DWT_COMP_BASE + DWT.DWT_COMP_BLOCK_SIZE*i + DWT.DWT_FUNCTION_OFFSET, 0)
+        self.dwt_configured = True
+
+    def find_watchpoint(self, addr, size, type):
+        for watch in self.watchpoints:
+            if watch.addr == addr and watch.size == size and watch.func == DWT.WATCH_TYPE_TO_FUNCT[type]:
+                return watch
+        return None
+
+    ## @brief Set a hardware watchpoint.
+    def set_watchpoint(self, addr, size, type):
+        if self.dwt_configured is False:
+            self.init()
+
+        watch = self.find_watchpoint(addr, size, type)
+        if watch != None:
+            return True
+
+        if type not in DWT.WATCH_TYPE_TO_FUNCT:
+            logging.error("Invalid watchpoint type %i", type)
+            return False
+
+        for watch in self.watchpoints:
+            if watch.func == 0:
+                watch.addr = addr
+                watch.func = DWT.WATCH_TYPE_TO_FUNCT[type]
+                watch.size = size
+
+                if size not in DWT.WATCH_SIZE_TO_MASK:
+                    logging.error('Watchpoint of size %d not supported by device', size)
+                    return False
+
+                mask = DWT.WATCH_SIZE_TO_MASK[size]
+                self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_MASK_OFFSET, mask)
+                if self.ap.readMemory(watch.comp_register_addr + DWT.DWT_MASK_OFFSET) != mask:
+                    logging.error('Watchpoint of size %d not supported by device', size)
+                    return False
+
+                self.ap.writeMemory(watch.comp_register_addr, addr)
+                self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_FUNCTION_OFFSET, watch.func)
+                self.watchpoint_used += 1
+                return True
+
+        logging.error('No more available watchpoint!!, dropped watch at 0x%X', addr)
+        return False
+
+    ## @brief Remove a hardware watchpoint.
+    def remove_watchpoint(self, addr, size, type):
+        watch = self.find_watchpoint(addr, size, type)
+        if watch is None:
+            return
+
+        watch.func = 0
+        self.ap.writeMemory(watch.comp_register_addr + DWT.DWT_FUNCTION_OFFSET, 0)
+        self.watchpoint_used -= 1
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/fpb.py` & `pyOCD-0.9.0/pyOCD/coresight/fpb.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,106 +1,113 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import logging
-from .breakpoints import Breakpoint, BreakpointProvider
-
-class FPB(BreakpointProvider):
-    FP_CTRL = 0xE0002000
-    FP_CTRL_KEY = 1 << 1
-    FP_COMP0 = 0xE0002008
-
-    def __init__(self, ap):
-        super(FPB, self).__init__()
-        self.ap = ap
-        self.hw_breakpoints = []
-        self.nb_code = 0
-        self.nb_lit = 0
-        self.num_hw_breakpoint_used = 0
-        self.enabled = False
-
-    ## @brief Inits the FPB.
-    #
-    # Reads the number of hardware breakpoints available on the core and disable the FPB
-    # (Flash Patch and Breakpoint Unit), which will be enabled when the first breakpoint is set.
-    def init(self):
-        # setup FPB (breakpoint)
-        fpcr = self.ap.readMemory(FPB.FP_CTRL)
-        self.nb_code = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xF)
-        self.nb_lit = (fpcr >> 7) & 0xf
-        logging.info("%d hardware breakpoints, %d literal comparators", self.nb_code, self.nb_lit)
-        for i in range(self.nb_code):
-            self.hw_breakpoints.append(Breakpoint(FPB.FP_COMP0 + 4*i, self))
-
-        # disable FPB (will be enabled on first bp set)
-        self.disable()
-        for bp in self.hw_breakpoints:
-            self.ap.writeMemory(bp.comp_register_addr, 0)
-
-    def bp_type(self):
-        return Target.BREAKPOINT_HW
-
-    def enable(self):
-        self.ap.writeMemory(FPB.FP_CTRL, FPB.FP_CTRL_KEY | 1)
-        self.enabled = True
-        logging.debug('fpb has been enabled')
-        return
-
-    def disable(self):
-        self.ap.writeMemory(FPB.FP_CTRL, FPB.FP_CTRL_KEY | 0)
-        self.enabled = False
-        logging.debug('fpb has been disabled')
-        return
-
-    def available_breakpoints(self):
-        return len(self.hw_breakpoints) - self.num_hw_breakpoint_used
-
-    ## @brief Set a hardware breakpoint at a specific location in flash.
-    def set_breakpoint(self, addr):
-        if not self.enabled:
-            self.enable()
-
-        if addr >= 0x20000000:
-            # Hardware breakpoints are only supported in the range
-            # 0x00000000 - 0x1fffffff on cortex-m devices
-            logging.error('Breakpoint out of range 0x%X', addr)
-            return None
-
-        if self.available_breakpoints() == 0:
-            logging.error('No more available breakpoint!!, dropped bp at 0x%X', addr)
-            return None
-
-        for bp in self.hw_breakpoints:
-            if not bp.enabled:
-                bp.enabled = True
-                bp_match = (1 << 30)
-                if addr & 0x2:
-                    bp_match = (2 << 30)
-                self.ap.writeMemory(bp.comp_register_addr, addr & 0x1ffffffc | bp_match | 1)
-                bp.addr = addr
-                self.num_hw_breakpoint_used += 1
-                return bp
-        return None
-
-    ## @brief Remove a hardware breakpoint at a specific location in flash.
-    def remove_breakpoint(self, bp):
-        for hwbp in self.hw_breakpoints:
-            if hwbp.enabled and hwbp.addr == bp.addr:
-                hwbp.enabled = False
-                self.ap.writeMemory(hwbp.comp_register_addr, 0)
-                self.num_hw_breakpoint_used -= 1
-                return
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015-2017 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..core.target import Target
+from ..debug.breakpoints.provider import (Breakpoint, BreakpointProvider)
+import logging
+
+class HardwareBreakpoint(Breakpoint):
+    def __init__(self, comp_register_addr, provider):
+        super(HardwareBreakpoint, self).__init__(provider)
+        self.comp_register_addr = comp_register_addr
+        self.type = Target.BREAKPOINT_HW
+
+class FPB(BreakpointProvider):
+    FP_CTRL = 0xE0002000
+    FP_CTRL_KEY = 1 << 1
+    FP_COMP0 = 0xE0002008
+
+    def __init__(self, ap):
+        super(FPB, self).__init__()
+        self.ap = ap
+        self.hw_breakpoints = []
+        self.nb_code = 0
+        self.nb_lit = 0
+        self.num_hw_breakpoint_used = 0
+        self.enabled = False
+
+    ## @brief Inits the FPB.
+    #
+    # Reads the number of hardware breakpoints available on the core and disable the FPB
+    # (Flash Patch and Breakpoint Unit), which will be enabled when the first breakpoint is set.
+    def init(self):
+        # setup FPB (breakpoint)
+        fpcr = self.ap.readMemory(FPB.FP_CTRL)
+        self.nb_code = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xF)
+        self.nb_lit = (fpcr >> 7) & 0xf
+        logging.info("%d hardware breakpoints, %d literal comparators", self.nb_code, self.nb_lit)
+        for i in range(self.nb_code):
+            self.hw_breakpoints.append(HardwareBreakpoint(FPB.FP_COMP0 + 4*i, self))
+
+        # disable FPB (will be enabled on first bp set)
+        self.disable()
+        for bp in self.hw_breakpoints:
+            self.ap.writeMemory(bp.comp_register_addr, 0)
+
+    def bp_type(self):
+        return Target.BREAKPOINT_HW
+
+    def enable(self):
+        self.ap.writeMemory(FPB.FP_CTRL, FPB.FP_CTRL_KEY | 1)
+        self.enabled = True
+        logging.debug('fpb has been enabled')
+        return
+
+    def disable(self):
+        self.ap.writeMemory(FPB.FP_CTRL, FPB.FP_CTRL_KEY | 0)
+        self.enabled = False
+        logging.debug('fpb has been disabled')
+        return
+
+    def available_breakpoints(self):
+        return len(self.hw_breakpoints) - self.num_hw_breakpoint_used
+
+    ## @brief Set a hardware breakpoint at a specific location in flash.
+    def set_breakpoint(self, addr):
+        if not self.enabled:
+            self.enable()
+
+        if addr >= 0x20000000:
+            # Hardware breakpoints are only supported in the range
+            # 0x00000000 - 0x1fffffff on cortex-m devices
+            logging.error('Breakpoint out of range 0x%X', addr)
+            return None
+
+        if self.available_breakpoints() == 0:
+            logging.error('No more available breakpoint!!, dropped bp at 0x%X', addr)
+            return None
+
+        for bp in self.hw_breakpoints:
+            if not bp.enabled:
+                bp.enabled = True
+                bp_match = (1 << 30)
+                if addr & 0x2:
+                    bp_match = (2 << 30)
+                self.ap.writeMemory(bp.comp_register_addr, addr & 0x1ffffffc | bp_match | 1)
+                bp.addr = addr
+                self.num_hw_breakpoint_used += 1
+                return bp
+        return None
+
+    ## @brief Remove a hardware breakpoint at a specific location in flash.
+    def remove_breakpoint(self, bp):
+        for hwbp in self.hw_breakpoints:
+            if hwbp.enabled and hwbp.addr == bp.addr:
+                hwbp.enabled = False
+                self.ap.writeMemory(hwbp.comp_register_addr, 0)
+                self.num_hw_breakpoint_used -= 1
+                return
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/coresight/__init__.py` & `pyOCD-0.9.0/pyOCD/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,25 +1,28 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import dap
-import ap
-import rom_table
-import cortex_m
-import dwt
-import fpb
-import breakpoints
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import board
+import core
+import debug
+import flash
+import gdbserver
+import target
+import utility
+import coresight
+
+from ._version import version as __version__
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/analyzer/generate_python.py` & `pyOCD-0.9.0/pyOCD/test/conftest.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,39 +1,29 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from struct import unpack
-
-with open("main.bin", "rb") as f:
-    data = f.read()
-
-words = len(data) / 4
-str = "<L%i" % words
-print("Data length %i" % len(data))
-data = unpack("<%iL" % words, data)
-
-str = "analyzer = (\n    "
-count = 0
-for val in data:
-    if count % 8 == 7:
-        str += "0x{:08x},\n    ".format(val)
-    else:
-        str += "0x{:08x}, ".format(val)
-    count += 1
-str += "\n    )"
-data = str
-
-with open("main.py", "wb") as f:
-    f.write(data)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import pytest
+import logging
+from mockcore import MockCore
+
+@pytest.fixture(scope='module', autouse=True)
+def debuglog():
+    logging.basicConfig(level=logging.DEBUG)
+
+@pytest.fixture(scope='function')
+def mockcore():
+    return MockCore()
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/analyzer/linker_script.ld` & `pyOCD-0.9.0/src/gdb_test_program/linker_script.ld`

 * *Files 12% similar despite different names*

```diff
@@ -1,61 +1,54 @@
-/*
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-*/
-
-/* Memory regions */
-MEMORY
-{
-  /* Ram configurations are for smallest KL25 in family - 4K */
-  m_all        (rwx) : ORIGIN = 0x00000000, LENGTH = 0x600
-}
-
-/* Define output sections */
-SECTIONS
-{
-
-  .text :
-  {
-    . = ALIGN(4);
-
-    /* Entry point */
-    KEEP(*(.text.compute_crc))
-
-    *(.text)           /* .text sections (code) */
-    *(.text*)          /* .text* sections (code) */
-
-    . = ALIGN(4);
-    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
-    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
-
-  } >m_all
-
-  .data :
-  {
-    . = ALIGN(4);
-    *(.data)           /* .data sections */
-    *(.data*)          /* .data* sections */
-  } >m_all
-
-   /* Uninitialized data section */
-  .bss :
-  {
-    . = ALIGN(4);
-    *(.bss)
-    *(.bss*)
-    *(COMMON)
-  } > m_all
-
-}
+/*
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+/* Memory regions */
+MEMORY
+{
+  /* Ram configurations are for smallest KL25 in family - 4K */
+  m_all        (rwx) : ORIGIN = 0x00000000, LENGTH = 0x600
+}
+
+/* Define output sections */
+SECTIONS
+{
+
+  .text :
+  {
+    . = ALIGN(4);
+
+    /* Entry point */
+    KEEP(*(.text.main))
+
+    *(.text)           /* .text sections (code) */
+    *(.text*)          /* .text* sections (code) */
+
+    . = ALIGN(4);
+    *(.data)           /* .data sections */
+    *(.data*)          /* .data* sections */
+    
+    . = ALIGN(4);
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    
+    . = ALIGN(4);
+    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
+
+  } >m_all
+
+}
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/analyzer/main.c` & `pyOCD-0.9.0/src/analyzer/main.c`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,69 +1,69 @@
-/*
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-*/
-
-#include<stdint.h>
-
-typedef struct {
-    uint16_t size;
-    uint16_t addr;
-} sector_info_t;
-
-static uint32_t crc32_tab[256];
-
-static uint32_t crc32(uint32_t crc, const void *buf, uint32_t size) {
-	const uint8_t *p;
-
-	p = buf;
-	crc = crc ^ ~0U;
-
-	while (size--) {
-		crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
-    }
-
-	return crc ^ ~0U;
-}
-
-static void fill_table(void) {
-    int i;
-    uint32_t byte, crc, mask;
-    for (byte = 0; byte <= 255; byte++) {
-        crc = byte;
-        for (i = 7; i >= 0; i--) {    // Do eight times.
-            mask = -(crc & 1);
-            crc = (crc >> 1) ^ (0xEDB88320 & mask);
-        }
-        crc32_tab[byte] = crc;
-    }
-}
-
-int compute_crc(void * data, uint32_t num) {
-    sector_info_t * sectors = data;
-    uint32_t * crcs = data;
-    uint32_t i;
-    uint32_t crc;
-    uint32_t addr;
-    uint32_t size;
-    fill_table();
-    for (i = 0; i < num; i++) {
-        size = 1 << sectors[i].size;
-        addr = size * sectors[i].addr;
-        crc = crc32(0, (void*)addr, size);
-        crcs[i] = crc;
-    }
-    size = 1 << num;
-    return 0;
-}
+/*
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+#include<stdint.h>
+
+typedef struct {
+    uint16_t size;
+    uint16_t addr;
+} sector_info_t;
+
+static uint32_t crc32_tab[256];
+
+static uint32_t crc32(uint32_t crc, const void *buf, uint32_t size) {
+	const uint8_t *p;
+
+	p = buf;
+	crc = crc ^ ~0U;
+
+	while (size--) {
+		crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+    }
+
+	return crc ^ ~0U;
+}
+
+static void fill_table(void) {
+    int i;
+    uint32_t byte, crc, mask;
+    for (byte = 0; byte <= 255; byte++) {
+        crc = byte;
+        for (i = 7; i >= 0; i--) {    // Do eight times.
+            mask = -(crc & 1);
+            crc = (crc >> 1) ^ (0xEDB88320 & mask);
+        }
+        crc32_tab[byte] = crc;
+    }
+}
+
+int compute_crc(void * data, uint32_t num) {
+    sector_info_t * sectors = data;
+    uint32_t * crcs = data;
+    uint32_t i;
+    uint32_t crc;
+    uint32_t addr;
+    uint32_t size;
+    fill_table();
+    for (i = 0; i < num; i++) {
+        size = 1 << sectors[i].size;
+        addr = size * sectors[i].addr;
+        crc = crc32(0, (void*)addr, size);
+        crcs[i] = crc;
+    }
+    size = 1 << num;
+    return 0;
+}
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash.py` & `pyOCD-0.9.0/pyOCD/flash/flash.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,411 +1,408 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from pyOCD.target.target import Target
-import logging
-from struct import unpack
-from time import time
-from flash_builder import FlashBuilder
-
-DEFAULT_PAGE_PROGRAM_WEIGHT = 0.130
-DEFAULT_PAGE_ERASE_WEIGHT = 0.048
-DEFAULT_CHIP_ERASE_WEIGHT = 0.174
-
-# Program to compute the CRC of sectors.  This works on cortex-m processors.
-# Code is relocatable and only needs to be on a 4 byte boundary.
-# 200 bytes of executable data below + 1024 byte crc table = 1224 bytes
-# Usage requirements:
-# -In memory reserve 0x600 for code & table
-# -Make sure data buffer is big enough to hold 4 bytes for each page that could be checked (ie.  >= num pages * 4)
-analyzer = (
-    0x2180468c, 0x2600b5f0, 0x4f2c2501, 0x447f4c2c, 0x1c2b0049, 0x425b4033, 0x40230872, 0x085a4053,
-    0x425b402b, 0x40534023, 0x402b085a, 0x4023425b, 0x085a4053, 0x425b402b, 0x40534023, 0x402b085a,
-    0x4023425b, 0x085a4053, 0x425b402b, 0x40534023, 0x402b085a, 0x4023425b, 0x085a4053, 0x425b402b,
-    0x40534023, 0xc7083601, 0xd1d2428e, 0x2b004663, 0x4663d01f, 0x46b4009e, 0x24ff2701, 0x44844d11,
-    0x1c3a447d, 0x88418803, 0x4351409a, 0xd0122a00, 0x22011856, 0x780b4252, 0x40533101, 0x009b4023,
-    0x0a12595b, 0x42b1405a, 0x43d2d1f5, 0x4560c004, 0x2000d1e7, 0x2200bdf0, 0x46c0e7f8, 0x000000b6,
-    0xedb88320, 0x00000044,
-    )
-
-def _msb(n):
-    ndx = 0
-    while (1 < n):
-        n = (n >> 1)
-        ndx += 1
-    return ndx
-
-def _same(d1, d2):
-    if len(d1) != len(d2):
-        return False
-    for i in range(len(d1)):
-        if d1[i] != d2[i]:
-            return False
-    return True
-
-class PageInfo(object):
-
-    def __init__(self):
-        self.base_addr = None           # Start address of this page
-        self.erase_weight = None        # Time it takes to erase a page
-        self.program_weight = None      # Time it takes to program a page (Not including data transfer time)
-        self.size = None                # Size of page
-        self.crc_supported = None       # Is the function computeCrcs supported?
-
-class FlashInfo(object):
-
-    def __init__(self):
-        self.rom_start = None           # Starting address of ROM
-        self.erase_weight = None        # Time it takes to perform a chip erase
-
-class Flash(object):
-    """
-    This class is responsible to flash a new binary in a target
-    """
-
-    def __init__(self, target, flash_algo):
-        self.target = target
-        self.flash_algo = flash_algo
-        self.flash_algo_debug = False
-        if flash_algo is not None:
-            self.end_flash_algo = flash_algo['load_address'] + len(flash_algo) * 4
-            self.begin_stack = flash_algo['begin_stack']
-            self.begin_data = flash_algo['begin_data']
-            self.static_base = flash_algo['static_base']
-            self.min_program_length = flash_algo.get('min_program_length', 0)
-
-            # Check for double buffering support.
-            if flash_algo.has_key('page_buffers'):
-                self.page_buffers = flash_algo['page_buffers']
-            else:
-                self.page_buffers = [self.begin_data]
-
-            self.double_buffer_supported = len(self.page_buffers) > 1
-
-        else:
-            self.end_flash_algo = None
-            self.begin_stack = None
-            self.begin_data = None
-            self.static_base = None
-
-    @property
-    def minimumProgramLength(self):
-        return self.min_program_length
-
-    def init(self):
-        """
-        Download the flash algorithm in RAM
-        """
-        self.target.halt()
-        self.target.setTargetState("PROGRAM")
-
-        # update core register to execute the init subroutine
-        result = self.callFunctionAndWait(self.flash_algo['pc_init'], init=True)
-
-        # check the return code
-        if result != 0:
-            logging.error('init error: %i', result)
-
-    def computeCrcs(self, sectors):
-        data = []
-
-        # Convert address, size pairs into commands
-        # for the crc computation algorithm to preform
-        for addr, size in sectors:
-            size_val = _msb(size)
-            addr_val = addr // size
-            # Size must be a power of 2
-            assert (1 << size_val) == size
-            # Address must be a multiple of size
-            assert (addr % size) == 0
-            val = (size_val << 0) | (addr_val << 16)
-            data.append(val)
-
-        self.target.writeBlockMemoryAligned32(self.begin_data, data)
-
-        # update core register to execute the subroutine
-        result = self.callFunctionAndWait(self.flash_algo['analyzer_address'], self.begin_data, len(data))
-
-        # Read back the CRCs for each section
-        data = self.target.readBlockMemoryAligned32(self.begin_data, len(data))
-        return data
-
-    def eraseAll(self):
-        """
-        Erase all the flash
-        """
-
-        # update core register to execute the eraseAll subroutine
-        result = self.callFunctionAndWait(self.flash_algo['pc_eraseAll'])
-
-        # check the return code
-        if result != 0:
-            logging.error('eraseAll error: %i', result)
-
-    def erasePage(self, flashPtr):
-        """
-        Erase one page
-        """
-
-        # update core register to execute the erasePage subroutine
-        result = self.callFunctionAndWait(self.flash_algo['pc_erase_sector'], flashPtr)
-
-        # check the return code
-        if result != 0:
-            logging.error('erasePage(0x%x) error: %i', flashPtr, result)
-
-    def programPage(self, flashPtr, bytes):
-        """
-        Flash one page
-        """
-
-        # prevent security settings from locking the device
-        bytes = self.overrideSecurityBits(flashPtr, bytes)
-
-        # first transfer in RAM
-        self.target.writeBlockMemoryUnaligned8(self.begin_data, bytes)
-
-        # get info about this page
-        page_info = self.getPageInfo(flashPtr)
-
-        # update core register to execute the program_page subroutine
-        result = self.callFunctionAndWait(self.flash_algo['pc_program_page'], flashPtr, len(bytes), self.begin_data)
-
-        # check the return code
-        if result != 0:
-            logging.error('programPage(0x%x) error: %i', flashPtr, result)
-
-    def getPageBufferCount(self):
-        return len(self.page_buffers)
-
-    def isDoubleBufferingSupported(self):
-        return self.double_buffer_supported
-
-    def startProgramPageWithBuffer(self, bufferNumber, flashPtr):
-        """
-        Flash one page
-        """
-        assert bufferNumber < len(self.page_buffers), "Invalid buffer number"
-
-        # get info about this page
-        page_info = self.getPageInfo(flashPtr)
-
-        # update core register to execute the program_page subroutine
-        result = self.callFunction(self.flash_algo['pc_program_page'], flashPtr, page_info.size, self.page_buffers[bufferNumber])
-
-    def loadPageBuffer(self, bufferNumber, flashPtr, bytes):
-        assert bufferNumber < len(self.page_buffers), "Invalid buffer number"
-
-        # prevent security settings from locking the device
-        bytes = self.overrideSecurityBits(flashPtr, bytes)
-
-        # transfer the buffer to device RAM
-        self.target.writeBlockMemoryUnaligned8(self.page_buffers[bufferNumber], bytes)
-
-    def programPhrase(self, flashPtr, bytes):
-        """
-        Flash a portion of a page.
-        """
-
-        # Get min programming length. If one was not specified, use the page size.
-        if self.min_program_length:
-            min_len = self.min_program_length
-        else:
-            min_len = self.getPageInfo(flashPtr).size
-
-        # Require write address and length to be aligned to min write size.
-        if flashPtr % min_len:
-            raise RuntimeError("unaligned flash write address")
-        if len(bytes) % min_len:
-            raise RuntimeError("phrase length is unaligned or too small")
-
-        # prevent security settings from locking the device
-        bytes = self.overrideSecurityBits(flashPtr, bytes)
-
-        # first transfer in RAM
-        self.target.writeBlockMemoryUnaligned8(self.begin_data, bytes)
-
-        # update core register to execute the program_page subroutine
-        result = self.callFunctionAndWait(self.flash_algo['pc_program_page'], flashPtr, len(bytes), self.begin_data)
-
-        # check the return code
-        if result != 0:
-            logging.error('programPhrase(0x%x) error: %i', flashPtr, result)
-
-    def getPageInfo(self, addr):
-        """
-        Get info about the page that contains this address
-
-        Override this function if variable page sizes are supported
-        """
-        region = self.target.getMemoryMap().getRegionForAddress(addr)
-        if not region:
-            return None
-
-        info = PageInfo()
-        info.erase_weight = DEFAULT_PAGE_ERASE_WEIGHT
-        info.program_weight = DEFAULT_PAGE_PROGRAM_WEIGHT
-        info.size = region.blocksize
-        info.base_addr = addr - (addr % info.size)
-        return info
-
-    def getFlashInfo(self):
-        """
-        Get info about the flash
-
-        Override this function to return differnt values
-        """
-        boot_region = self.target.getMemoryMap().getBootMemory()
-
-        info = FlashInfo()
-        info.rom_start = boot_region.start if boot_region else 0
-        info.erase_weight = DEFAULT_CHIP_ERASE_WEIGHT
-        info.crc_supported = self.flash_algo['analyzer_supported']
-        return info
-
-    def getFlashBuilder(self):
-        return FlashBuilder(self, self.getFlashInfo().rom_start)
-
-    def flashBlock(self, addr, data, smart_flash=True, chip_erase=None, progress_cb=None, fast_verify=False):
-        """
-        Flash a block of data
-        """
-        flash_start = self.getFlashInfo().rom_start
-        fb = FlashBuilder(self, flash_start)
-        fb.addData(addr, data)
-        info = fb.program(chip_erase, progress_cb, smart_flash, fast_verify)
-        return info
-
-    def flashBinary(self, path_file, flashPtr=None, smart_flash=True, chip_erase=None, progress_cb=None, fast_verify=False):
-        """
-        Flash a binary
-        """
-        if flashPtr is None:
-            flashPtr = self.getFlashInfo().rom_start
-
-        f = open(path_file, "rb")
-
-        with open(path_file, "rb") as f:
-            data = f.read()
-        data = unpack(str(len(data)) + 'B', data)
-        self.flashBlock(flashPtr, data, smart_flash, chip_erase, progress_cb, fast_verify)
-
-    def callFunction(self, pc, r0=None, r1=None, r2=None, r3=None, init=False):
-        reg_list = []
-        data_list = []
-
-        if self.flash_algo_debug:
-            # Save vector catch state for use in waitForCompletion()
-            self._vector_catch_enabled = self.target.getVectorCatchFault()
-            self._reset_catch_enabled = self.target.getVectorCatchReset()
-            self.target.setVectorCatchFault(True)
-            self.target.setVectorCatchReset(True)
-
-        if init:
-            # download flash algo in RAM
-            self.target.writeBlockMemoryAligned32(self.flash_algo['load_address'], self.flash_algo['instructions'])
-            if self.flash_algo['analyzer_supported']:
-                self.target.writeBlockMemoryAligned32(self.flash_algo['analyzer_address'], analyzer)
-
-        reg_list.append('pc')
-        data_list.append(pc)
-        if r0 is not None:
-            reg_list.append('r0')
-            data_list.append(r0)
-        if r1 is not None:
-            reg_list.append('r1')
-            data_list.append(r1)
-        if r2 is not None:
-            reg_list.append('r2')
-            data_list.append(r2)
-        if r3 is not None:
-            reg_list.append('r3')
-            data_list.append(r3)
-        if init:
-            reg_list.append('r9')
-            data_list.append(self.static_base)
-        if init:
-            reg_list.append('sp')
-            data_list.append(self.begin_stack)
-        reg_list.append('lr')
-        data_list.append(self.flash_algo['load_address'] + 1)
-        self.target.writeCoreRegistersRaw(reg_list, data_list)
-
-        # resume target
-        self.target.resume()
-
-    ## @brief Wait until the breakpoint is hit.
-    def waitForCompletion(self):
-        while(self.target.getState() == Target.TARGET_RUNNING):
-            pass
-
-        if self.flash_algo_debug:
-            analyzer_supported = self.flash_algo['analyzer_supported']
-
-            expected_fp = self.flash_algo['static_base']
-            expected_sp = self.flash_algo['begin_stack']
-            expected_pc = self.flash_algo['load_address']
-            expected_flash_algo = self.flash_algo['instructions']
-            if analyzer_supported:
-                expected_analyzer = analyzer
-            final_fp = self.target.readCoreRegister('r9')
-            final_sp = self.target.readCoreRegister('sp')
-            final_pc = self.target.readCoreRegister('pc')
-            #TODO - uncomment if Read/write and zero init sections can be moved into a separate flash algo section
-            #final_flash_algo = self.target.readBlockMemoryAligned32(self.flash_algo['load_address'], len(self.flash_algo['instructions']))
-            #if analyzer_supported:
-            #    final_analyzer = self.target.readBlockMemoryAligned32(self.flash_algo['analyzer_address'], len(analyzer))
-
-            error = False
-            if final_fp != expected_fp:
-                # Frame pointer should not change
-                logging.error("Frame pointer should be 0x%x but is 0x%x" % (expected_fp, final_fp))
-                error = True
-            if final_sp != expected_sp:
-                # Stack pointer should return to original value after function call
-                logging.error("Stack pointer should be 0x%x but is 0x%x" % (expected_sp, final_sp))
-                error = True
-            if final_pc != expected_pc:
-                # PC should be pointing to breakpoint address
-                logging.error("PC should be 0x%x but is 0x%x" % (expected_pc, final_pc))
-                error = True
-            #TODO - uncomment if Read/write and zero init sections can be moved into a separate flash algo section
-            #if not _same(expected_flash_algo, final_flash_algo):
-            #    logging.error("Flash algorithm overwritten!")
-            #    error = True
-            #if analyzer_supported and not _same(expected_analyzer, final_analyzer):
-            #    logging.error("Analyzer overwritten!")
-            #    error = True
-            assert error == False
-            self.target.setVectorCatchFault(self._vector_catch_enabled)
-            self.target.setVectorCatchReset(self._reset_catch_enabled)
-
-        return self.target.readCoreRegister('r0')
-
-    def callFunctionAndWait(self, pc, r0=None, r1=None, r2=None, r3=None, init=False):
-        self.callFunction(pc, r0, r1, r2, r3, init)
-        return self.waitForCompletion()
-
-    def setFlashAlgoDebug(self, enable):
-        """
-        Turn on extra flash algorithm checking
-
-        When set this will greatly slow down flash algo performance
-        """
-        self.flash_algo_debug = enable
-
-    def overrideSecurityBits(self, address, data):
-        return data
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..core.target import Target
+import logging
+from struct import unpack
+from time import time
+from flash_builder import FlashBuilder
+
+DEFAULT_PAGE_PROGRAM_WEIGHT = 0.130
+DEFAULT_PAGE_ERASE_WEIGHT = 0.048
+DEFAULT_CHIP_ERASE_WEIGHT = 0.174
+
+# Program to compute the CRC of sectors.  This works on cortex-m processors.
+# Code is relocatable and only needs to be on a 4 byte boundary.
+# 200 bytes of executable data below + 1024 byte crc table = 1224 bytes
+# Usage requirements:
+# -In memory reserve 0x600 for code & table
+# -Make sure data buffer is big enough to hold 4 bytes for each page that could be checked (ie.  >= num pages * 4)
+analyzer = (
+    0x2180468c, 0x2600b5f0, 0x4f2c2501, 0x447f4c2c, 0x1c2b0049, 0x425b4033, 0x40230872, 0x085a4053,
+    0x425b402b, 0x40534023, 0x402b085a, 0x4023425b, 0x085a4053, 0x425b402b, 0x40534023, 0x402b085a,
+    0x4023425b, 0x085a4053, 0x425b402b, 0x40534023, 0x402b085a, 0x4023425b, 0x085a4053, 0x425b402b,
+    0x40534023, 0xc7083601, 0xd1d2428e, 0x2b004663, 0x4663d01f, 0x46b4009e, 0x24ff2701, 0x44844d11,
+    0x1c3a447d, 0x88418803, 0x4351409a, 0xd0122a00, 0x22011856, 0x780b4252, 0x40533101, 0x009b4023,
+    0x0a12595b, 0x42b1405a, 0x43d2d1f5, 0x4560c004, 0x2000d1e7, 0x2200bdf0, 0x46c0e7f8, 0x000000b6,
+    0xedb88320, 0x00000044,
+    )
+
+def _msb(n):
+    ndx = 0
+    while (1 < n):
+        n = (n >> 1)
+        ndx += 1
+    return ndx
+
+def _same(d1, d2):
+    if len(d1) != len(d2):
+        return False
+    for i in range(len(d1)):
+        if d1[i] != d2[i]:
+            return False
+    return True
+
+class PageInfo(object):
+
+    def __init__(self):
+        self.base_addr = None           # Start address of this page
+        self.erase_weight = None        # Time it takes to erase a page
+        self.program_weight = None      # Time it takes to program a page (Not including data transfer time)
+        self.size = None                # Size of page
+        self.crc_supported = None       # Is the function computeCrcs supported?
+
+class FlashInfo(object):
+
+    def __init__(self):
+        self.rom_start = None           # Starting address of ROM
+        self.erase_weight = None        # Time it takes to perform a chip erase
+
+class Flash(object):
+    """
+    This class is responsible to flash a new binary in a target
+    """
+
+    def __init__(self, target, flash_algo):
+        self.target = target
+        self.flash_algo = flash_algo
+        self.flash_algo_debug = False
+        if flash_algo is not None:
+            self.end_flash_algo = flash_algo['load_address'] + len(flash_algo) * 4
+            self.begin_stack = flash_algo['begin_stack']
+            self.begin_data = flash_algo['begin_data']
+            self.static_base = flash_algo['static_base']
+            self.min_program_length = flash_algo.get('min_program_length', 0)
+
+            # Check for double buffering support.
+            if flash_algo.has_key('page_buffers'):
+                self.page_buffers = flash_algo['page_buffers']
+            else:
+                self.page_buffers = [self.begin_data]
+
+            self.double_buffer_supported = len(self.page_buffers) > 1
+
+        else:
+            self.end_flash_algo = None
+            self.begin_stack = None
+            self.begin_data = None
+            self.static_base = None
+
+    @property
+    def minimumProgramLength(self):
+        return self.min_program_length
+
+    def init(self):
+        """
+        Download the flash algorithm in RAM
+        """
+        self.target.halt()
+        self.target.setTargetState("PROGRAM")
+
+        # update core register to execute the init subroutine
+        result = self.callFunctionAndWait(self.flash_algo['pc_init'], init=True)
+
+        # check the return code
+        if result != 0:
+            logging.error('init error: %i', result)
+
+    def computeCrcs(self, sectors):
+        data = []
+
+        # Convert address, size pairs into commands
+        # for the crc computation algorithm to preform
+        for addr, size in sectors:
+            size_val = _msb(size)
+            addr_val = addr // size
+            # Size must be a power of 2
+            assert (1 << size_val) == size
+            # Address must be a multiple of size
+            assert (addr % size) == 0
+            val = (size_val << 0) | (addr_val << 16)
+            data.append(val)
+
+        self.target.writeBlockMemoryAligned32(self.begin_data, data)
+
+        # update core register to execute the subroutine
+        result = self.callFunctionAndWait(self.flash_algo['analyzer_address'], self.begin_data, len(data))
+
+        # Read back the CRCs for each section
+        data = self.target.readBlockMemoryAligned32(self.begin_data, len(data))
+        return data
+
+    def eraseAll(self):
+        """
+        Erase all the flash
+        """
+
+        # update core register to execute the eraseAll subroutine
+        result = self.callFunctionAndWait(self.flash_algo['pc_eraseAll'])
+
+        # check the return code
+        if result != 0:
+            logging.error('eraseAll error: %i', result)
+
+    def erasePage(self, flashPtr):
+        """
+        Erase one page
+        """
+
+        # update core register to execute the erasePage subroutine
+        result = self.callFunctionAndWait(self.flash_algo['pc_erase_sector'], flashPtr)
+
+        # check the return code
+        if result != 0:
+            logging.error('erasePage(0x%x) error: %i', flashPtr, result)
+
+    def programPage(self, flashPtr, bytes):
+        """
+        Flash one page
+        """
+
+        # prevent security settings from locking the device
+        bytes = self.overrideSecurityBits(flashPtr, bytes)
+
+        # first transfer in RAM
+        self.target.writeBlockMemoryUnaligned8(self.begin_data, bytes)
+
+        # get info about this page
+        page_info = self.getPageInfo(flashPtr)
+
+        # update core register to execute the program_page subroutine
+        result = self.callFunctionAndWait(self.flash_algo['pc_program_page'], flashPtr, len(bytes), self.begin_data)
+
+        # check the return code
+        if result != 0:
+            logging.error('programPage(0x%x) error: %i', flashPtr, result)
+
+    def getPageBufferCount(self):
+        return len(self.page_buffers)
+
+    def isDoubleBufferingSupported(self):
+        return self.double_buffer_supported
+
+    def startProgramPageWithBuffer(self, bufferNumber, flashPtr):
+        """
+        Flash one page
+        """
+        assert bufferNumber < len(self.page_buffers), "Invalid buffer number"
+
+        # get info about this page
+        page_info = self.getPageInfo(flashPtr)
+
+        # update core register to execute the program_page subroutine
+        result = self.callFunction(self.flash_algo['pc_program_page'], flashPtr, page_info.size, self.page_buffers[bufferNumber])
+
+    def loadPageBuffer(self, bufferNumber, flashPtr, bytes):
+        assert bufferNumber < len(self.page_buffers), "Invalid buffer number"
+
+        # prevent security settings from locking the device
+        bytes = self.overrideSecurityBits(flashPtr, bytes)
+
+        # transfer the buffer to device RAM
+        self.target.writeBlockMemoryUnaligned8(self.page_buffers[bufferNumber], bytes)
+
+    def programPhrase(self, flashPtr, bytes):
+        """
+        Flash a portion of a page.
+        """
+
+        # Get min programming length. If one was not specified, use the page size.
+        if self.min_program_length:
+            min_len = self.min_program_length
+        else:
+            min_len = self.getPageInfo(flashPtr).size
+
+        # Require write address and length to be aligned to min write size.
+        if flashPtr % min_len:
+            raise RuntimeError("unaligned flash write address")
+        if len(bytes) % min_len:
+            raise RuntimeError("phrase length is unaligned or too small")
+
+        # prevent security settings from locking the device
+        bytes = self.overrideSecurityBits(flashPtr, bytes)
+
+        # first transfer in RAM
+        self.target.writeBlockMemoryUnaligned8(self.begin_data, bytes)
+
+        # update core register to execute the program_page subroutine
+        result = self.callFunctionAndWait(self.flash_algo['pc_program_page'], flashPtr, len(bytes), self.begin_data)
+
+        # check the return code
+        if result != 0:
+            logging.error('programPhrase(0x%x) error: %i', flashPtr, result)
+
+    def getPageInfo(self, addr):
+        """
+        Get info about the page that contains this address
+
+        Override this function if variable page sizes are supported
+        """
+        region = self.target.getMemoryMap().getRegionForAddress(addr)
+        if not region:
+            return None
+
+        info = PageInfo()
+        info.erase_weight = DEFAULT_PAGE_ERASE_WEIGHT
+        info.program_weight = DEFAULT_PAGE_PROGRAM_WEIGHT
+        info.size = region.blocksize
+        info.base_addr = addr - (addr % info.size)
+        return info
+
+    def getFlashInfo(self):
+        """
+        Get info about the flash
+
+        Override this function to return differnt values
+        """
+        boot_region = self.target.getMemoryMap().getBootMemory()
+
+        info = FlashInfo()
+        info.rom_start = boot_region.start if boot_region else 0
+        info.erase_weight = DEFAULT_CHIP_ERASE_WEIGHT
+        info.crc_supported = self.flash_algo['analyzer_supported']
+        return info
+
+    def getFlashBuilder(self):
+        return FlashBuilder(self, self.getFlashInfo().rom_start)
+
+    def flashBlock(self, addr, data, smart_flash=True, chip_erase=None, progress_cb=None, fast_verify=False):
+        """
+        Flash a block of data
+        """
+        flash_start = self.getFlashInfo().rom_start
+        fb = FlashBuilder(self, flash_start)
+        fb.addData(addr, data)
+        info = fb.program(chip_erase, progress_cb, smart_flash, fast_verify)
+        return info
+
+    def flashBinary(self, path_file, flashPtr=None, smart_flash=True, chip_erase=None, progress_cb=None, fast_verify=False):
+        """
+        Flash a binary
+        """
+        if flashPtr is None:
+            flashPtr = self.getFlashInfo().rom_start
+
+        f = open(path_file, "rb")
+
+        with open(path_file, "rb") as f:
+            data = f.read()
+        data = unpack(str(len(data)) + 'B', data)
+        self.flashBlock(flashPtr, data, smart_flash, chip_erase, progress_cb, fast_verify)
+
+    def callFunction(self, pc, r0=None, r1=None, r2=None, r3=None, init=False):
+        reg_list = []
+        data_list = []
+
+        if self.flash_algo_debug:
+            # Save vector catch state for use in waitForCompletion()
+            self._saved_vector_catch = self.target.getVectorCatch()
+            self.target.setVectorCatch(Target.CATCH_ALL)
+
+        if init:
+            # download flash algo in RAM
+            self.target.writeBlockMemoryAligned32(self.flash_algo['load_address'], self.flash_algo['instructions'])
+            if self.flash_algo['analyzer_supported']:
+                self.target.writeBlockMemoryAligned32(self.flash_algo['analyzer_address'], analyzer)
+
+        reg_list.append('pc')
+        data_list.append(pc)
+        if r0 is not None:
+            reg_list.append('r0')
+            data_list.append(r0)
+        if r1 is not None:
+            reg_list.append('r1')
+            data_list.append(r1)
+        if r2 is not None:
+            reg_list.append('r2')
+            data_list.append(r2)
+        if r3 is not None:
+            reg_list.append('r3')
+            data_list.append(r3)
+        if init:
+            reg_list.append('r9')
+            data_list.append(self.static_base)
+        if init:
+            reg_list.append('sp')
+            data_list.append(self.begin_stack)
+        reg_list.append('lr')
+        data_list.append(self.flash_algo['load_address'] + 1)
+        self.target.writeCoreRegistersRaw(reg_list, data_list)
+
+        # resume target
+        self.target.resume()
+
+    ## @brief Wait until the breakpoint is hit.
+    def waitForCompletion(self):
+        while(self.target.getState() == Target.TARGET_RUNNING):
+            pass
+
+        if self.flash_algo_debug:
+            analyzer_supported = self.flash_algo['analyzer_supported']
+
+            expected_fp = self.flash_algo['static_base']
+            expected_sp = self.flash_algo['begin_stack']
+            expected_pc = self.flash_algo['load_address']
+            expected_flash_algo = self.flash_algo['instructions']
+            if analyzer_supported:
+                expected_analyzer = analyzer
+            final_fp = self.target.readCoreRegister('r9')
+            final_sp = self.target.readCoreRegister('sp')
+            final_pc = self.target.readCoreRegister('pc')
+            #TODO - uncomment if Read/write and zero init sections can be moved into a separate flash algo section
+            #final_flash_algo = self.target.readBlockMemoryAligned32(self.flash_algo['load_address'], len(self.flash_algo['instructions']))
+            #if analyzer_supported:
+            #    final_analyzer = self.target.readBlockMemoryAligned32(self.flash_algo['analyzer_address'], len(analyzer))
+
+            error = False
+            if final_fp != expected_fp:
+                # Frame pointer should not change
+                logging.error("Frame pointer should be 0x%x but is 0x%x" % (expected_fp, final_fp))
+                error = True
+            if final_sp != expected_sp:
+                # Stack pointer should return to original value after function call
+                logging.error("Stack pointer should be 0x%x but is 0x%x" % (expected_sp, final_sp))
+                error = True
+            if final_pc != expected_pc:
+                # PC should be pointing to breakpoint address
+                logging.error("PC should be 0x%x but is 0x%x" % (expected_pc, final_pc))
+                error = True
+            #TODO - uncomment if Read/write and zero init sections can be moved into a separate flash algo section
+            #if not _same(expected_flash_algo, final_flash_algo):
+            #    logging.error("Flash algorithm overwritten!")
+            #    error = True
+            #if analyzer_supported and not _same(expected_analyzer, final_analyzer):
+            #    logging.error("Analyzer overwritten!")
+            #    error = True
+            assert error == False
+            self.target.setVectorCatch(self._saved_vector_catch)
+
+        return self.target.readCoreRegister('r0')
+
+    def callFunctionAndWait(self, pc, r0=None, r1=None, r2=None, r3=None, init=False):
+        self.callFunction(pc, r0, r1, r2, r3, init)
+        return self.waitForCompletion()
+
+    def setFlashAlgoDebug(self, enable):
+        """
+        Turn on extra flash algorithm checking
+
+        When set this will greatly slow down flash algo performance
+        """
+        self.flash_algo_debug = enable
+
+    def overrideSecurityBits(self, address, data):
+        return data
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_builder.py` & `pyOCD-0.9.0/pyOCD/flash/flash_builder.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,612 +1,612 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from pyOCD.target.target import Target
-import logging
-from struct import unpack
-from time import time
-from binascii import crc32
-
-# Number of bytes in a page to read to quickly determine if the page has the same data
-PAGE_ESTIMATE_SIZE = 32
-PAGE_READ_WEIGHT = 0.3
-DATA_TRANSFER_B_PER_S = 40 * 1000 # ~40KB/s, depends on clock speed, theoretical limit for HID is 56,000 B/s
-
-class ProgrammingInfo(object):
-    def __init__(self):
-        self.program_type = None                # Type of programming performed - FLASH_PAGE_ERASE or FLASH_CHIP_ERASE
-        self.program_time = None                # Total programming time
-        self.analyze_type = None                # Type of flash analysis performed - FLASH_ANALYSIS_CRC32 or FLASH_ANALYSIS_PARTIAL_PAGE_READ
-        self.analyze_time = None                # Time to analyze flash contents
-
-def _same(d1, d2):
-    assert len(d1) == len(d2)
-    for i in range(len(d1)):
-        if d1[i] != d2[i]:
-            return False
-    return True
-
-def _erased(d):
-    for i in range(len(d)):
-        if d[i] != 0xFF:
-            return False
-    return True
-
-def _stub_progress(percent):
-    pass
-
-class flash_page(object):
-    def __init__(self, addr, size, data, erase_weight, program_weight):
-        self.addr = addr
-        self.size = size
-        self.data = data
-        self.erase_weight = erase_weight
-        self.program_weight = program_weight
-        self.erased = None
-        self.same = None
-
-    def getProgramWeight(self):
-        """
-        Get time to program a page including the data transfer
-        """
-        return self.program_weight + \
-            float(len(self.data)) / float(DATA_TRANSFER_B_PER_S)
-
-    def getEraseProgramWeight(self):
-        """
-        Get time to erase and program a page including data transfer time
-        """
-        return self.erase_weight + self.program_weight + \
-            float(len(self.data)) / float(DATA_TRANSFER_B_PER_S)
-
-    def getVerifyWeight(self):
-        """
-        Get time to verify a page
-        """
-        return float(self.size) / float(DATA_TRANSFER_B_PER_S)
-
-class flash_operation(object):
-    def __init__(self, addr, data):
-        self.addr = addr
-        self.data = data
-
-class FlashBuilder(object):
-
-    # Type of flash operation
-    FLASH_PAGE_ERASE = 1
-    FLASH_CHIP_ERASE = 2
-
-    # Type of flash analysis
-    FLASH_ANALYSIS_CRC32 = "CRC32"
-    FLASH_ANALYSIS_PARTIAL_PAGE_READ = "PAGE_READ"
-
-    def __init__(self, flash, base_addr=0):
-        self.flash = flash
-        self.flash_start = base_addr
-        self.flash_operation_list = []
-        self.page_list = []
-        self.perf = ProgrammingInfo()
-        self.enable_double_buffering = True
-        self.max_errors = 10
-
-    def enableDoubleBuffer(self, enable):
-        self.enable_double_buffering = enable
-
-    def setMaxErrors(self, count):
-        self.max_errors = count
-
-    def addData(self, addr, data):
-        """
-        Add a block of data to be programmed
-
-        Note - programming does not start until the method
-        program is called.
-        """
-        # Sanity check
-        if addr < self.flash_start:
-            raise Exception("Invalid flash address 0x%x is before flash start 0x%x" % (addr, self.flash_start))
-
-        # Add operation to list
-        self.flash_operation_list.append(flash_operation(addr, data))
-
-        # Keep list sorted
-        self.flash_operation_list = sorted(self.flash_operation_list, key=lambda operation: operation.addr)
-        # Verify this does not overlap
-        prev_flash_operation = None
-        for operation in self.flash_operation_list:
-            if prev_flash_operation != None:
-                if prev_flash_operation.addr + len(prev_flash_operation.data) > operation.addr:
-                    raise ValueError("Error adding data - Data at 0x%x..0x%x overlaps with 0x%x..0x%x"
-                            % (prev_flash_operation.addr, prev_flash_operation.addr + len(prev_flash_operation.data),
-                               operation.addr, operation.addr + len(operation.data)))
-            prev_flash_operation = operation
-
-    def program(self, chip_erase=None, progress_cb=None, smart_flash=True, fast_verify=False):
-        """
-        Determine fastest method of flashing and then run flash programming.
-
-        Data must have already been added with addData
-        """
-
-        # Assumptions
-        # 1. Page erases must be on page boundaries ( page_erase_addr % page_size == 0 )
-        # 2. Page erase can have a different size depending on location
-        # 3. It is safe to program a page with less than a page of data
-
-        # Examples
-        # - lpc4330     -Non 0 base address
-        # - nRF51       -UICR location far from flash (address 0x10001000)
-        # - LPC1768     -Different sized pages
-        program_start = time()
-
-        if progress_cb is None:
-            progress_cb = _stub_progress
-
-        # There must be at least 1 flash operation
-        if len(self.flash_operation_list) == 0:
-            logging.warning("No pages were programmed")
-            return
-
-        # Convert the list of flash operations into flash pages
-        program_byte_count = 0
-        flash_addr = self.flash_operation_list[0].addr
-        info = self.flash.getPageInfo(flash_addr)
-        page_addr = flash_addr - (flash_addr % info.size)
-        current_page = flash_page(page_addr, info.size, [], info.erase_weight, info.program_weight)
-        self.page_list.append(current_page)
-        for flash_operation in self.flash_operation_list:
-            pos = 0
-            while pos < len(flash_operation.data):
-
-                # Check if operation is in next page
-                flash_addr = flash_operation.addr + pos
-                if flash_addr >= current_page.addr + current_page.size:
-                    info = self.flash.getPageInfo(flash_addr)
-                    page_addr = flash_addr - (flash_addr % info.size)
-                    current_page = flash_page(page_addr, info.size, [], info.erase_weight, info.program_weight)
-                    self.page_list.append(current_page)
-
-                # Fill the page gap if there is one
-                page_data_end = current_page.addr + len(current_page.data)
-                if flash_addr != page_data_end:
-                    old_data = self.flash.target.readBlockMemoryUnaligned8(page_data_end, flash_addr - page_data_end)
-                    current_page.data.extend(old_data)
-
-                # Copy data to page and increment pos
-                space_left_in_page = info.size - len(current_page.data)
-                space_left_in_data = len(flash_operation.data) - pos
-                amount = min(space_left_in_page, space_left_in_data)
-                current_page.data.extend(flash_operation.data[pos:pos + amount])
-                program_byte_count += current_page.size
-
-                #increment position
-                pos += amount
-
-        # If smart flash was set to false then mark all pages
-        # as requiring programming
-        if not smart_flash:
-            self._mark_all_pages_for_programming()
-
-        # If the first page being programmed is not the first page
-        # in ROM then don't use a chip erase
-        if self.page_list[0].addr > self.flash_start:
-            if chip_erase is None:
-                chip_erase = False
-            elif chip_erase is True:
-                logging.warning('Chip erase used when flash address 0x%x is not the same as flash start 0x%x', self.page_list[0].addr, self.flash_start)
-
-        self.flash.init()
-
-        chip_erase_count, chip_erase_program_time = self._compute_chip_erase_pages_and_weight()
-        page_erase_min_program_time = self._compute_page_erase_pages_weight_min()
-
-        # If chip_erase hasn't been specified determine if chip erase is faster
-        # than page erase regardless of contents
-        if (chip_erase is None) and (chip_erase_program_time < page_erase_min_program_time):
-            chip_erase = True
-
-        # If chip erase isn't True then analyze the flash
-        if chip_erase != True:
-            analyze_start = time()
-            if self.flash.getFlashInfo().crc_supported:
-                sector_erase_count, page_program_time = self._compute_page_erase_pages_and_weight_crc32(fast_verify)
-                self.perf.analyze_type = FlashBuilder.FLASH_ANALYSIS_CRC32
-            else:
-                sector_erase_count, page_program_time = self._compute_page_erase_pages_and_weight_sector_read()
-                self.perf.analyze_type = FlashBuilder.FLASH_ANALYSIS_PARTIAL_PAGE_READ
-            analyze_finish = time()
-            self.perf.analyze_time = analyze_finish - analyze_start
-            logging.debug("Analyze time: %f" % (analyze_finish - analyze_start))
-
-        # If chip erase hasn't been set then determine fastest method to program
-        if chip_erase is None:
-            logging.debug("Chip erase count %i, Page erase est count %i" % (chip_erase_count, sector_erase_count))
-            logging.debug("Chip erase weight %f, Page erase weight %f" % (chip_erase_program_time, page_program_time))
-            chip_erase = chip_erase_program_time < page_program_time
-
-        if chip_erase:
-            if self.flash.isDoubleBufferingSupported() and self.enable_double_buffering:
-                logging.debug("Using double buffer chip erase program")
-                flash_operation = self._chip_erase_program_double_buffer(progress_cb)
-            else:
-                flash_operation = self._chip_erase_program(progress_cb)
-        else:
-            if self.flash.isDoubleBufferingSupported() and self.enable_double_buffering:
-                logging.debug("Using double buffer page erase program")
-                flash_operation = self._page_erase_program_double_buffer(progress_cb)
-            else:
-                flash_operation = self._page_erase_program(progress_cb)
-
-        self.flash.target.resetStopOnReset()
-
-        program_finish = time()
-        self.perf.program_time = program_finish - program_start
-        self.perf.program_type = flash_operation
-
-        logging.info("Programmed %d bytes (%d pages) at %.02f kB/s", program_byte_count, len(self.page_list), ((program_byte_count/1024) / self.perf.program_time))
-
-        return self.perf
-
-    def getPerformance(self):
-        return self.perf
-
-    def _mark_all_pages_for_programming(self):
-        for page in self.page_list:
-            page.erased = False
-            page.same = False
-
-    def _compute_chip_erase_pages_and_weight(self):
-        """
-        Compute the number of erased pages.
-
-        Determine how many pages in the new data are already erased.
-        """
-        chip_erase_count = 0
-        chip_erase_weight = 0
-        chip_erase_weight += self.flash.getFlashInfo().erase_weight
-        for page in self.page_list:
-            if page.erased is None:
-                page.erased = _erased(page.data)
-            if not page.erased:
-                chip_erase_count += 1
-                chip_erase_weight += page.getProgramWeight()
-        self.chip_erase_count = chip_erase_count
-        self.chip_erase_weight = chip_erase_weight
-        return chip_erase_count, chip_erase_weight
-
-    def _compute_page_erase_pages_weight_min(self):
-        page_erase_min_weight = 0
-        for page in self.page_list:
-            page_erase_min_weight += page.getVerifyWeight()
-        return page_erase_min_weight
-
-    def _compute_page_erase_pages_and_weight_sector_read(self):
-        """
-        Estimate how many pages are the same.
-
-        Quickly estimate how many pages are the same.  These estimates are used
-        by page_erase_program so it is recommended to call this before beginning programming
-        This is done automatically by smart_program.
-        """
-        # Quickly estimate how many pages are the same
-        page_erase_count = 0
-        page_erase_weight = 0
-        for page in self.page_list:
-            # Analyze pages that haven't been analyzed yet
-            if page.same is None:
-                size = min(PAGE_ESTIMATE_SIZE, len(page.data))
-                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, size)
-                page_same = _same(data, page.data[0:size])
-                if page_same is False:
-                    page.same = False
-
-        # Put together page and time estimate
-        for page in self.page_list:
-            if page.same is False:
-                page_erase_count += 1
-                page_erase_weight += page.getEraseProgramWeight()
-            elif page.same is None:
-                # Page is probably the same but must be read to confirm
-                page_erase_weight += page.getVerifyWeight()
-            elif page.same is True:
-                # Page is confirmed to be the same so no programming weight
-                pass
-
-        self.page_erase_count = page_erase_count
-        self.page_erase_weight = page_erase_weight
-        return page_erase_count, page_erase_weight
-
-    def _compute_page_erase_pages_and_weight_crc32(self, assume_estimate_correct=False):
-        """
-        Estimate how many pages are the same.
-
-        Quickly estimate how many pages are the same.  These estimates are used
-        by page_erase_program so it is recommended to call this before beginning programming
-        This is done automatically by smart_program.
-
-        If assume_estimate_correct is set to True, then pages with matching CRCs
-        will be marked as the same.  There is a small chance that the CRCs match even though the
-        data is different, but the odds of this happing are low: ~1/(2^32) = ~2.33*10^-8%.
-        """
-        # Build list of all the pages that need to be analyzed
-        sector_list = []
-        page_list = []
-        for page in self.page_list:
-            if page.same is None:
-                # Add sector to computeCrcs
-                sector_list.append((page.addr, page.size))
-                page_list.append(page)
-                # Compute CRC of data (Padded with 0xFF)
-                data = list(page.data)
-                pad_size = page.size - len(page.data)
-                if pad_size > 0:
-                    data.extend([0xFF] * pad_size)
-                page.crc = crc32(bytearray(data)) & 0xFFFFFFFF
-
-        # Analyze pages
-        page_erase_count = 0
-        page_erase_weight = 0
-        if len(page_list) > 0:
-            crc_list = self.flash.computeCrcs(sector_list)
-            for page, crc in zip(page_list, crc_list):
-                page_same = page.crc == crc
-                if assume_estimate_correct:
-                    page.same = page_same
-                elif page_same is False:
-                    page.same = False
-
-        # Put together page and time estimate
-        for page in self.page_list:
-            if page.same is False:
-                page_erase_count += 1
-                page_erase_weight += page.getEraseProgramWeight()
-            elif page.same is None:
-                # Page is probably the same but must be read to confirm
-                page_erase_weight += page.getVerifyWeight()
-            elif page.same is True:
-                # Page is confirmed to be the same so no programming weight
-                pass
-
-        self.page_erase_count = page_erase_count
-        self.page_erase_weight = page_erase_weight
-        return page_erase_count, page_erase_weight
-
-    def _chip_erase_program(self, progress_cb=_stub_progress):
-        """
-        Program by first performing a chip erase.
-        """
-        logging.debug("Smart chip erase")
-        logging.debug("%i of %i pages already erased", len(self.page_list) - self.chip_erase_count, len(self.page_list))
-        progress_cb(0.0)
-        progress = 0
-        self.flash.eraseAll()
-        progress += self.flash.getFlashInfo().erase_weight
-        for page in self.page_list:
-            if not page.erased:
-                self.flash.programPage(page.addr, page.data)
-                progress += page.getProgramWeight()
-                progress_cb(float(progress) / float(self.chip_erase_weight))
-        progress_cb(1.0)
-        return FlashBuilder.FLASH_CHIP_ERASE
-
-    def _next_unerased_page(self, i):
-        if i >= len(self.page_list):
-            return None, i
-        page = self.page_list[i]
-        while page.erased:
-            i += 1
-            if i >= len(self.page_list):
-                return None, i
-            page = self.page_list[i]
-        return page, i + 1
-
-    def _chip_erase_program_double_buffer(self, progress_cb=_stub_progress):
-        """
-        Program by first performing a chip erase.
-        """
-        logging.debug("Smart chip erase")
-        logging.debug("%i of %i pages already erased", len(self.page_list) - self.chip_erase_count, len(self.page_list))
-        progress_cb(0.0)
-        progress = 0
-        self.flash.eraseAll()
-        progress += self.flash.getFlashInfo().erase_weight
-
-        # Set up page and buffer info.
-        error_count = 0
-        current_buf = 0
-        next_buf = 1
-        page, i = self._next_unerased_page(0)
-        assert page is not None
-
-        # Load first page buffer
-        self.flash.loadPageBuffer(current_buf, page.addr, page.data)
-
-        while page is not None:
-            # Kick off this page program.
-            current_addr = page.addr
-            current_weight = page.getProgramWeight()
-            self.flash.startProgramPageWithBuffer(current_buf, current_addr)
-
-            # Get next page and load it.
-            page, i = self._next_unerased_page(i)
-            if page is not None:
-                self.flash.loadPageBuffer(next_buf, page.addr, page.data)
-
-            # Wait for the program to complete.
-            result = self.flash.waitForCompletion()
-
-            # check the return code
-            if result != 0:
-                logging.error('programPage(0x%x) error: %i', current_addr, result)
-                error_count += 1
-                if error_count > self.max_errors:
-                    logging.error("Too many page programming errors, aborting program operation")
-                    break
-
-            # Swap buffers.
-            temp = current_buf
-            current_buf = next_buf
-            next_buf = temp
-
-            # Update progress.
-            progress += current_weight
-            progress_cb(float(progress) / float(self.chip_erase_weight))
-
-        progress_cb(1.0)
-        return FlashBuilder.FLASH_CHIP_ERASE
-
-    def _page_erase_program(self, progress_cb=_stub_progress):
-        """
-        Program by performing sector erases.
-        """
-        actual_page_erase_count = 0
-        actual_page_erase_weight = 0
-        progress = 0
-
-        progress_cb(0.0)
-
-        for page in self.page_list:
-
-            # If the page is not the same
-            if page.same is False:
-                progress += page.getEraseProgramWeight()
-
-            # Read page data if unknown - after this page.same will be True or False
-            if page.same is None:
-                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, len(page.data))
-                page.same = _same(page.data, data)
-                progress += page.getVerifyWeight()
-
-            # Program page if not the same
-            if page.same is False:
-                self.flash.erasePage(page.addr)
-                self.flash.programPage(page.addr, page.data)
-                actual_page_erase_count += 1
-                actual_page_erase_weight += page.getEraseProgramWeight()
-
-            # Update progress
-            if self.page_erase_weight > 0:
-                progress_cb(float(progress) / float(self.page_erase_weight))
-
-        progress_cb(1.0)
-
-        logging.debug("Estimated page erase count: %i", self.page_erase_count)
-        logging.debug("Actual page erase count: %i", actual_page_erase_count)
-
-        return FlashBuilder.FLASH_PAGE_ERASE
-
-    def _scan_pages_for_same(self, progress_cb=_stub_progress):
-        """
-        Program by performing sector erases.
-        """
-        progress = 0
-        count = 0
-        same_count = 0
-
-        for page in self.page_list:
-            # Read page data if unknown - after this page.same will be True or False
-            if page.same is None:
-                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, len(page.data))
-                page.same = _same(page.data, data)
-                progress += page.getVerifyWeight()
-                count += 1
-                if page.same:
-                    same_count += 1
-
-                # Update progress
-                progress_cb(float(progress) / float(self.page_erase_weight))
-        return progress
-
-    def _next_nonsame_page(self, i):
-        if i >= len(self.page_list):
-            return None, i
-        page = self.page_list[i]
-        while page.same:
-            i += 1
-            if i >= len(self.page_list):
-                return None, i
-            page = self.page_list[i]
-        return page, i + 1
-
-    def _page_erase_program_double_buffer(self, progress_cb=_stub_progress):
-        """
-        Program by performing sector erases.
-        """
-        actual_page_erase_count = 0
-        actual_page_erase_weight = 0
-        progress = 0
-
-        progress_cb(0.0)
-
-        # Fill in same flag for all pages. This is done up front so we're not trying
-        # to read from flash while simultaneously programming it.
-        progress = self._scan_pages_for_same(progress_cb)
-
-        # Set up page and buffer info.
-        error_count = 0
-        current_buf = 0
-        next_buf = 1
-        page, i = self._next_nonsame_page(0)
-
-        # Make sure there are actually pages to program differently from current flash contents.
-        if page is not None:
-            # Load first page buffer
-            self.flash.loadPageBuffer(current_buf, page.addr, page.data)
-
-            while page is not None:
-                assert page.same is not None
-
-                # Kick off this page program.
-                current_addr = page.addr
-                current_weight = page.getEraseProgramWeight()
-                self.flash.erasePage(current_addr)
-                self.flash.startProgramPageWithBuffer(current_buf, current_addr) #, erase_page=True)
-                actual_page_erase_count += 1
-                actual_page_erase_weight += page.getEraseProgramWeight()
-
-                # Get next page and load it.
-                page, i = self._next_nonsame_page(i)
-                if page is not None:
-                    self.flash.loadPageBuffer(next_buf, page.addr, page.data)
-
-                # Wait for the program to complete.
-                result = self.flash.waitForCompletion()
-
-                # check the return code
-                if result != 0:
-                    logging.error('programPage(0x%x) error: %i', current_addr, result)
-                    error_count += 1
-                    if error_count > self.max_errors:
-                        logging.error("Too many page programming errors, aborting program operation")
-                        break
-
-                # Swap buffers.
-                temp = current_buf
-                current_buf = next_buf
-                next_buf = temp
-
-                # Update progress
-                progress += current_weight
-                if self.page_erase_weight > 0:
-                    progress_cb(float(progress) / float(self.page_erase_weight))
-
-        progress_cb(1.0)
-
-        logging.debug("Estimated page erase count: %i", self.page_erase_count)
-        logging.debug("Actual page erase count: %i", actual_page_erase_count)
-
-        return FlashBuilder.FLASH_PAGE_ERASE
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..core.target import Target
+import logging
+from struct import unpack
+from time import time
+from binascii import crc32
+
+# Number of bytes in a page to read to quickly determine if the page has the same data
+PAGE_ESTIMATE_SIZE = 32
+PAGE_READ_WEIGHT = 0.3
+DATA_TRANSFER_B_PER_S = 40 * 1000 # ~40KB/s, depends on clock speed, theoretical limit for HID is 56,000 B/s
+
+class ProgrammingInfo(object):
+    def __init__(self):
+        self.program_type = None                # Type of programming performed - FLASH_PAGE_ERASE or FLASH_CHIP_ERASE
+        self.program_time = None                # Total programming time
+        self.analyze_type = None                # Type of flash analysis performed - FLASH_ANALYSIS_CRC32 or FLASH_ANALYSIS_PARTIAL_PAGE_READ
+        self.analyze_time = None                # Time to analyze flash contents
+
+def _same(d1, d2):
+    assert len(d1) == len(d2)
+    for i in range(len(d1)):
+        if d1[i] != d2[i]:
+            return False
+    return True
+
+def _erased(d):
+    for i in range(len(d)):
+        if d[i] != 0xFF:
+            return False
+    return True
+
+def _stub_progress(percent):
+    pass
+
+class flash_page(object):
+    def __init__(self, addr, size, data, erase_weight, program_weight):
+        self.addr = addr
+        self.size = size
+        self.data = data
+        self.erase_weight = erase_weight
+        self.program_weight = program_weight
+        self.erased = None
+        self.same = None
+
+    def getProgramWeight(self):
+        """
+        Get time to program a page including the data transfer
+        """
+        return self.program_weight + \
+            float(len(self.data)) / float(DATA_TRANSFER_B_PER_S)
+
+    def getEraseProgramWeight(self):
+        """
+        Get time to erase and program a page including data transfer time
+        """
+        return self.erase_weight + self.program_weight + \
+            float(len(self.data)) / float(DATA_TRANSFER_B_PER_S)
+
+    def getVerifyWeight(self):
+        """
+        Get time to verify a page
+        """
+        return float(self.size) / float(DATA_TRANSFER_B_PER_S)
+
+class flash_operation(object):
+    def __init__(self, addr, data):
+        self.addr = addr
+        self.data = data
+
+class FlashBuilder(object):
+
+    # Type of flash operation
+    FLASH_PAGE_ERASE = 1
+    FLASH_CHIP_ERASE = 2
+
+    # Type of flash analysis
+    FLASH_ANALYSIS_CRC32 = "CRC32"
+    FLASH_ANALYSIS_PARTIAL_PAGE_READ = "PAGE_READ"
+
+    def __init__(self, flash, base_addr=0):
+        self.flash = flash
+        self.flash_start = base_addr
+        self.flash_operation_list = []
+        self.page_list = []
+        self.perf = ProgrammingInfo()
+        self.enable_double_buffering = True
+        self.max_errors = 10
+
+    def enableDoubleBuffer(self, enable):
+        self.enable_double_buffering = enable
+
+    def setMaxErrors(self, count):
+        self.max_errors = count
+
+    def addData(self, addr, data):
+        """
+        Add a block of data to be programmed
+
+        Note - programming does not start until the method
+        program is called.
+        """
+        # Sanity check
+        if addr < self.flash_start:
+            raise Exception("Invalid flash address 0x%x is before flash start 0x%x" % (addr, self.flash_start))
+
+        # Add operation to list
+        self.flash_operation_list.append(flash_operation(addr, data))
+
+        # Keep list sorted
+        self.flash_operation_list = sorted(self.flash_operation_list, key=lambda operation: operation.addr)
+        # Verify this does not overlap
+        prev_flash_operation = None
+        for operation in self.flash_operation_list:
+            if prev_flash_operation != None:
+                if prev_flash_operation.addr + len(prev_flash_operation.data) > operation.addr:
+                    raise ValueError("Error adding data - Data at 0x%x..0x%x overlaps with 0x%x..0x%x"
+                            % (prev_flash_operation.addr, prev_flash_operation.addr + len(prev_flash_operation.data),
+                               operation.addr, operation.addr + len(operation.data)))
+            prev_flash_operation = operation
+
+    def program(self, chip_erase=None, progress_cb=None, smart_flash=True, fast_verify=False):
+        """
+        Determine fastest method of flashing and then run flash programming.
+
+        Data must have already been added with addData
+        """
+
+        # Assumptions
+        # 1. Page erases must be on page boundaries ( page_erase_addr % page_size == 0 )
+        # 2. Page erase can have a different size depending on location
+        # 3. It is safe to program a page with less than a page of data
+
+        # Examples
+        # - lpc4330     -Non 0 base address
+        # - nRF51       -UICR location far from flash (address 0x10001000)
+        # - LPC1768     -Different sized pages
+        program_start = time()
+
+        if progress_cb is None:
+            progress_cb = _stub_progress
+
+        # There must be at least 1 flash operation
+        if len(self.flash_operation_list) == 0:
+            logging.warning("No pages were programmed")
+            return
+
+        # Convert the list of flash operations into flash pages
+        program_byte_count = 0
+        flash_addr = self.flash_operation_list[0].addr
+        info = self.flash.getPageInfo(flash_addr)
+        page_addr = flash_addr - (flash_addr % info.size)
+        current_page = flash_page(page_addr, info.size, [], info.erase_weight, info.program_weight)
+        self.page_list.append(current_page)
+        for flash_operation in self.flash_operation_list:
+            pos = 0
+            while pos < len(flash_operation.data):
+
+                # Check if operation is in next page
+                flash_addr = flash_operation.addr + pos
+                if flash_addr >= current_page.addr + current_page.size:
+                    info = self.flash.getPageInfo(flash_addr)
+                    page_addr = flash_addr - (flash_addr % info.size)
+                    current_page = flash_page(page_addr, info.size, [], info.erase_weight, info.program_weight)
+                    self.page_list.append(current_page)
+
+                # Fill the page gap if there is one
+                page_data_end = current_page.addr + len(current_page.data)
+                if flash_addr != page_data_end:
+                    old_data = self.flash.target.readBlockMemoryUnaligned8(page_data_end, flash_addr - page_data_end)
+                    current_page.data.extend(old_data)
+
+                # Copy data to page and increment pos
+                space_left_in_page = info.size - len(current_page.data)
+                space_left_in_data = len(flash_operation.data) - pos
+                amount = min(space_left_in_page, space_left_in_data)
+                current_page.data.extend(flash_operation.data[pos:pos + amount])
+                program_byte_count += amount
+
+                #increment position
+                pos += amount
+
+        # If smart flash was set to false then mark all pages
+        # as requiring programming
+        if not smart_flash:
+            self._mark_all_pages_for_programming()
+
+        # If the first page being programmed is not the first page
+        # in ROM then don't use a chip erase
+        if self.page_list[0].addr > self.flash_start:
+            if chip_erase is None:
+                chip_erase = False
+            elif chip_erase is True:
+                logging.warning('Chip erase used when flash address 0x%x is not the same as flash start 0x%x', self.page_list[0].addr, self.flash_start)
+
+        self.flash.init()
+
+        chip_erase_count, chip_erase_program_time = self._compute_chip_erase_pages_and_weight()
+        page_erase_min_program_time = self._compute_page_erase_pages_weight_min()
+
+        # If chip_erase hasn't been specified determine if chip erase is faster
+        # than page erase regardless of contents
+        if (chip_erase is None) and (chip_erase_program_time < page_erase_min_program_time):
+            chip_erase = True
+
+        # If chip erase isn't True then analyze the flash
+        if chip_erase != True:
+            analyze_start = time()
+            if self.flash.getFlashInfo().crc_supported:
+                sector_erase_count, page_program_time = self._compute_page_erase_pages_and_weight_crc32(fast_verify)
+                self.perf.analyze_type = FlashBuilder.FLASH_ANALYSIS_CRC32
+            else:
+                sector_erase_count, page_program_time = self._compute_page_erase_pages_and_weight_sector_read()
+                self.perf.analyze_type = FlashBuilder.FLASH_ANALYSIS_PARTIAL_PAGE_READ
+            analyze_finish = time()
+            self.perf.analyze_time = analyze_finish - analyze_start
+            logging.debug("Analyze time: %f" % (analyze_finish - analyze_start))
+
+        # If chip erase hasn't been set then determine fastest method to program
+        if chip_erase is None:
+            logging.debug("Chip erase count %i, Page erase est count %i" % (chip_erase_count, sector_erase_count))
+            logging.debug("Chip erase weight %f, Page erase weight %f" % (chip_erase_program_time, page_program_time))
+            chip_erase = chip_erase_program_time < page_program_time
+
+        if chip_erase:
+            if self.flash.isDoubleBufferingSupported() and self.enable_double_buffering:
+                logging.debug("Using double buffer chip erase program")
+                flash_operation = self._chip_erase_program_double_buffer(progress_cb)
+            else:
+                flash_operation = self._chip_erase_program(progress_cb)
+        else:
+            if self.flash.isDoubleBufferingSupported() and self.enable_double_buffering:
+                logging.debug("Using double buffer page erase program")
+                flash_operation = self._page_erase_program_double_buffer(progress_cb)
+            else:
+                flash_operation = self._page_erase_program(progress_cb)
+
+        self.flash.target.resetStopOnReset()
+
+        program_finish = time()
+        self.perf.program_time = program_finish - program_start
+        self.perf.program_type = flash_operation
+
+        logging.info("Programmed %d bytes (%d pages) at %.02f kB/s", program_byte_count, len(self.page_list), ((program_byte_count/1024) / self.perf.program_time))
+
+        return self.perf
+
+    def getPerformance(self):
+        return self.perf
+
+    def _mark_all_pages_for_programming(self):
+        for page in self.page_list:
+            page.erased = False
+            page.same = False
+
+    def _compute_chip_erase_pages_and_weight(self):
+        """
+        Compute the number of erased pages.
+
+        Determine how many pages in the new data are already erased.
+        """
+        chip_erase_count = 0
+        chip_erase_weight = 0
+        chip_erase_weight += self.flash.getFlashInfo().erase_weight
+        for page in self.page_list:
+            if page.erased is None:
+                page.erased = _erased(page.data)
+            if not page.erased:
+                chip_erase_count += 1
+                chip_erase_weight += page.getProgramWeight()
+        self.chip_erase_count = chip_erase_count
+        self.chip_erase_weight = chip_erase_weight
+        return chip_erase_count, chip_erase_weight
+
+    def _compute_page_erase_pages_weight_min(self):
+        page_erase_min_weight = 0
+        for page in self.page_list:
+            page_erase_min_weight += page.getVerifyWeight()
+        return page_erase_min_weight
+
+    def _compute_page_erase_pages_and_weight_sector_read(self):
+        """
+        Estimate how many pages are the same.
+
+        Quickly estimate how many pages are the same.  These estimates are used
+        by page_erase_program so it is recommended to call this before beginning programming
+        This is done automatically by smart_program.
+        """
+        # Quickly estimate how many pages are the same
+        page_erase_count = 0
+        page_erase_weight = 0
+        for page in self.page_list:
+            # Analyze pages that haven't been analyzed yet
+            if page.same is None:
+                size = min(PAGE_ESTIMATE_SIZE, len(page.data))
+                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, size)
+                page_same = _same(data, page.data[0:size])
+                if page_same is False:
+                    page.same = False
+
+        # Put together page and time estimate
+        for page in self.page_list:
+            if page.same is False:
+                page_erase_count += 1
+                page_erase_weight += page.getEraseProgramWeight()
+            elif page.same is None:
+                # Page is probably the same but must be read to confirm
+                page_erase_weight += page.getVerifyWeight()
+            elif page.same is True:
+                # Page is confirmed to be the same so no programming weight
+                pass
+
+        self.page_erase_count = page_erase_count
+        self.page_erase_weight = page_erase_weight
+        return page_erase_count, page_erase_weight
+
+    def _compute_page_erase_pages_and_weight_crc32(self, assume_estimate_correct=False):
+        """
+        Estimate how many pages are the same.
+
+        Quickly estimate how many pages are the same.  These estimates are used
+        by page_erase_program so it is recommended to call this before beginning programming
+        This is done automatically by smart_program.
+
+        If assume_estimate_correct is set to True, then pages with matching CRCs
+        will be marked as the same.  There is a small chance that the CRCs match even though the
+        data is different, but the odds of this happing are low: ~1/(2^32) = ~2.33*10^-8%.
+        """
+        # Build list of all the pages that need to be analyzed
+        sector_list = []
+        page_list = []
+        for page in self.page_list:
+            if page.same is None:
+                # Add sector to computeCrcs
+                sector_list.append((page.addr, page.size))
+                page_list.append(page)
+                # Compute CRC of data (Padded with 0xFF)
+                data = list(page.data)
+                pad_size = page.size - len(page.data)
+                if pad_size > 0:
+                    data.extend([0xFF] * pad_size)
+                page.crc = crc32(bytearray(data)) & 0xFFFFFFFF
+
+        # Analyze pages
+        page_erase_count = 0
+        page_erase_weight = 0
+        if len(page_list) > 0:
+            crc_list = self.flash.computeCrcs(sector_list)
+            for page, crc in zip(page_list, crc_list):
+                page_same = page.crc == crc
+                if assume_estimate_correct:
+                    page.same = page_same
+                elif page_same is False:
+                    page.same = False
+
+        # Put together page and time estimate
+        for page in self.page_list:
+            if page.same is False:
+                page_erase_count += 1
+                page_erase_weight += page.getEraseProgramWeight()
+            elif page.same is None:
+                # Page is probably the same but must be read to confirm
+                page_erase_weight += page.getVerifyWeight()
+            elif page.same is True:
+                # Page is confirmed to be the same so no programming weight
+                pass
+
+        self.page_erase_count = page_erase_count
+        self.page_erase_weight = page_erase_weight
+        return page_erase_count, page_erase_weight
+
+    def _chip_erase_program(self, progress_cb=_stub_progress):
+        """
+        Program by first performing a chip erase.
+        """
+        logging.debug("Smart chip erase")
+        logging.debug("%i of %i pages already erased", len(self.page_list) - self.chip_erase_count, len(self.page_list))
+        progress_cb(0.0)
+        progress = 0
+        self.flash.eraseAll()
+        progress += self.flash.getFlashInfo().erase_weight
+        for page in self.page_list:
+            if not page.erased:
+                self.flash.programPage(page.addr, page.data)
+                progress += page.getProgramWeight()
+                progress_cb(float(progress) / float(self.chip_erase_weight))
+        progress_cb(1.0)
+        return FlashBuilder.FLASH_CHIP_ERASE
+
+    def _next_unerased_page(self, i):
+        if i >= len(self.page_list):
+            return None, i
+        page = self.page_list[i]
+        while page.erased:
+            i += 1
+            if i >= len(self.page_list):
+                return None, i
+            page = self.page_list[i]
+        return page, i + 1
+
+    def _chip_erase_program_double_buffer(self, progress_cb=_stub_progress):
+        """
+        Program by first performing a chip erase.
+        """
+        logging.debug("Smart chip erase")
+        logging.debug("%i of %i pages already erased", len(self.page_list) - self.chip_erase_count, len(self.page_list))
+        progress_cb(0.0)
+        progress = 0
+        self.flash.eraseAll()
+        progress += self.flash.getFlashInfo().erase_weight
+
+        # Set up page and buffer info.
+        error_count = 0
+        current_buf = 0
+        next_buf = 1
+        page, i = self._next_unerased_page(0)
+        assert page is not None
+
+        # Load first page buffer
+        self.flash.loadPageBuffer(current_buf, page.addr, page.data)
+
+        while page is not None:
+            # Kick off this page program.
+            current_addr = page.addr
+            current_weight = page.getProgramWeight()
+            self.flash.startProgramPageWithBuffer(current_buf, current_addr)
+
+            # Get next page and load it.
+            page, i = self._next_unerased_page(i)
+            if page is not None:
+                self.flash.loadPageBuffer(next_buf, page.addr, page.data)
+
+            # Wait for the program to complete.
+            result = self.flash.waitForCompletion()
+
+            # check the return code
+            if result != 0:
+                logging.error('programPage(0x%x) error: %i', current_addr, result)
+                error_count += 1
+                if error_count > self.max_errors:
+                    logging.error("Too many page programming errors, aborting program operation")
+                    break
+
+            # Swap buffers.
+            temp = current_buf
+            current_buf = next_buf
+            next_buf = temp
+
+            # Update progress.
+            progress += current_weight
+            progress_cb(float(progress) / float(self.chip_erase_weight))
+
+        progress_cb(1.0)
+        return FlashBuilder.FLASH_CHIP_ERASE
+
+    def _page_erase_program(self, progress_cb=_stub_progress):
+        """
+        Program by performing sector erases.
+        """
+        actual_page_erase_count = 0
+        actual_page_erase_weight = 0
+        progress = 0
+
+        progress_cb(0.0)
+
+        for page in self.page_list:
+
+            # If the page is not the same
+            if page.same is False:
+                progress += page.getEraseProgramWeight()
+
+            # Read page data if unknown - after this page.same will be True or False
+            if page.same is None:
+                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, len(page.data))
+                page.same = _same(page.data, data)
+                progress += page.getVerifyWeight()
+
+            # Program page if not the same
+            if page.same is False:
+                self.flash.erasePage(page.addr)
+                self.flash.programPage(page.addr, page.data)
+                actual_page_erase_count += 1
+                actual_page_erase_weight += page.getEraseProgramWeight()
+
+            # Update progress
+            if self.page_erase_weight > 0:
+                progress_cb(float(progress) / float(self.page_erase_weight))
+
+        progress_cb(1.0)
+
+        logging.debug("Estimated page erase count: %i", self.page_erase_count)
+        logging.debug("Actual page erase count: %i", actual_page_erase_count)
+
+        return FlashBuilder.FLASH_PAGE_ERASE
+
+    def _scan_pages_for_same(self, progress_cb=_stub_progress):
+        """
+        Program by performing sector erases.
+        """
+        progress = 0
+        count = 0
+        same_count = 0
+
+        for page in self.page_list:
+            # Read page data if unknown - after this page.same will be True or False
+            if page.same is None:
+                data = self.flash.target.readBlockMemoryUnaligned8(page.addr, len(page.data))
+                page.same = _same(page.data, data)
+                progress += page.getVerifyWeight()
+                count += 1
+                if page.same:
+                    same_count += 1
+
+                # Update progress
+                progress_cb(float(progress) / float(self.page_erase_weight))
+        return progress
+
+    def _next_nonsame_page(self, i):
+        if i >= len(self.page_list):
+            return None, i
+        page = self.page_list[i]
+        while page.same:
+            i += 1
+            if i >= len(self.page_list):
+                return None, i
+            page = self.page_list[i]
+        return page, i + 1
+
+    def _page_erase_program_double_buffer(self, progress_cb=_stub_progress):
+        """
+        Program by performing sector erases.
+        """
+        actual_page_erase_count = 0
+        actual_page_erase_weight = 0
+        progress = 0
+
+        progress_cb(0.0)
+
+        # Fill in same flag for all pages. This is done up front so we're not trying
+        # to read from flash while simultaneously programming it.
+        progress = self._scan_pages_for_same(progress_cb)
+
+        # Set up page and buffer info.
+        error_count = 0
+        current_buf = 0
+        next_buf = 1
+        page, i = self._next_nonsame_page(0)
+
+        # Make sure there are actually pages to program differently from current flash contents.
+        if page is not None:
+            # Load first page buffer
+            self.flash.loadPageBuffer(current_buf, page.addr, page.data)
+
+            while page is not None:
+                assert page.same is not None
+
+                # Kick off this page program.
+                current_addr = page.addr
+                current_weight = page.getEraseProgramWeight()
+                self.flash.erasePage(current_addr)
+                self.flash.startProgramPageWithBuffer(current_buf, current_addr) #, erase_page=True)
+                actual_page_erase_count += 1
+                actual_page_erase_weight += page.getEraseProgramWeight()
+
+                # Get next page and load it.
+                page, i = self._next_nonsame_page(i)
+                if page is not None:
+                    self.flash.loadPageBuffer(next_buf, page.addr, page.data)
+
+                # Wait for the program to complete.
+                result = self.flash.waitForCompletion()
+
+                # check the return code
+                if result != 0:
+                    logging.error('programPage(0x%x) error: %i', current_addr, result)
+                    error_count += 1
+                    if error_count > self.max_errors:
+                        logging.error("Too many page programming errors, aborting program operation")
+                        break
+
+                # Swap buffers.
+                temp = current_buf
+                current_buf = next_buf
+                next_buf = temp
+
+                # Update progress
+                progress += current_weight
+                if self.page_erase_weight > 0:
+                    progress_cb(float(progress) / float(self.page_erase_weight))
+
+        progress_cb(1.0)
+
+        logging.debug("Estimated page erase count: %i", self.page_erase_count)
+        logging.debug("Actual page erase count: %i", actual_page_erase_count)
+
+        return FlashBuilder.FLASH_PAGE_ERASE
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_k20d50m.py` & `pyOCD-0.9.0/pyOCD/target/target_MK64FN1M0xxx12.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,77 +1,93 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4604b570, 0x4616460d, 0x5020f24c, 0x81c84932, 0x1028f64d, 0x460881c8, 0xf0208800, 0x80080001,
-    0x4448482e, 0xf8dcf000, 0x2001b108, 0x2000bd70, 0x4601e7fc, 0x47702000, 0x4929b510, 0x44484827,
-    0xf8b8f000, 0xb92c4604, 0x48242100, 0xf0004448, 0x4604f9a3, 0xf837f000, 0xbd104620, 0x4604b570,
-    0x4448481e, 0x46214b1e, 0xf00068c2, 0x4605f85d, 0x481ab93d, 0x23004448, 0x68c24621, 0xf940f000,
-    0xf0004605, 0x4628f820, 0xb5febd70, 0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf8f8f000,
-    0xb9674607, 0x22012000, 0x2000e9cd, 0x46224633, 0x90024629, 0x44484809, 0xf97ef000, 0xf0004607,
-    0x4638f802, 0x4807bdfe, 0xf4206840, 0xf5000070, 0x49040070, 0x47706048, 0x40052000, 0x00000004,
-    0x6b65666b, 0x4001f000, 0x4a0e2070, 0x20807010, 0xbf007010, 0x7800480b, 0x280009c0, 0x4809d0fa,
-    0xf0017801, 0xb1080020, 0x47702067, 0x0010f001, 0x2068b108, 0xf001e7f9, 0xb1080001, 0xe7f42069,
-    0xe7f22000, 0x40020000, 0x4df0e92d, 0x460d4604, 0x469a4690, 0xf0004650, 0x4606f891, 0x4630b116,
-    0x8df0e8bd, 0x46422304, 0x46204629, 0xf86cf000, 0xb10e4606, 0xe7f34630, 0x0008eb05, 0x68e01e47,
-    0xf1f0fbb7, 0x7011fb00, 0x68e0b140, 0xf0f0fbb7, 0x0b01f100, 0xfb0068e0, 0x1e47f00b, 0x480be011,
-    0x68004478, 0x20096005, 0x71c84909, 0xffacf7ff, 0x69a04606, 0x69a0b108, 0xb1064780, 0x68e0e003,
-    0x42bd4405, 0xbf00d9eb, 0xe7c94630, 0x000002e0, 0x40020000, 0x4604b570, 0x4628460d, 0xf84ef000,
-    0xb10e4606, 0xbd704630, 0x2004b90c, 0x2044e7fb, 0x71c84902, 0xff88f7ff, 0x0000e7f5, 0x40020000,
-    0xb9094601, 0x47702004, 0x6cc04826, 0x6003f3c0, 0x447b4b25, 0x0010f833, 0xb90a0302, 0xe7f22064,
-    0x60082000, 0x2001604a, 0x02806088, 0x200060c8, 0x61486108, 0xbf006188, 0x4602e7e5, 0x2004b90a,
-    0x61914770, 0xe7fb2000, 0x4604b530, 0x2004b90c, 0x1e58bd30, 0xb9104008, 0x40101e58, 0x2065b108,
-    0x6820e7f6, 0xd8054288, 0x0500e9d4, 0x188d4428, 0xd20142a8, 0xe7eb2066, 0xe7e92000, 0x480b4601,
-    0xd0014281, 0x4770206b, 0xe7fc2000, 0xb90b4603, 0x47702004, 0xd801290f, 0xd0012a04, 0xe7f82004,
-    0xe7f62000, 0x40048000, 0x0000024e, 0x6b65666b, 0x41f0e92d, 0x46884607, 0x461d4614, 0x2004b914,
-    0x81f0e8bd, 0x462a2304, 0x46384641, 0xffbcf7ff, 0xb10e4606, 0xe7f34630, 0x480fe019, 0x68004478,
-    0x8000f8c0, 0x490ccc01, 0x390c4479, 0x60486809, 0x490a2006, 0xf7ff71c8, 0x4606ff07, 0xb10869b8,
-    0x478069b8, 0xe004b106, 0x0804f108, 0x2d001f2d, 0xbf00d1e3, 0xe7d34630, 0x000001a4, 0x40020000,
-    0x4dffe92d, 0x4682b082, 0x2304460c, 0x46504621, 0xf7ff9a04, 0x4683ff89, 0x0f00f1bb, 0x4658d003,
-    0xe8bdb006, 0xe9da8df0, 0xfbb00101, 0x4260f7f1, 0x40084279, 0x42a54245, 0x443dd100, 0xe0229e04,
-    0x0804eba5, 0xd90045b0, 0xea4f46b0, 0x90010098, 0x4478480f, 0x60046800, 0x490e2001, 0x980171c8,
-    0x72c80a00, 0x72889801, 0x72489805, 0xfebcf7ff, 0xf1bb4683, 0xd0010f00, 0xe7d14658, 0x0608eba6,
-    0x443d4444, 0x2e00bf00, 0x2000d1da, 0x0000e7c8, 0x0000010e, 0x40020000, 0x4604b570, 0xb90c460d,
-    0xbd702004, 0x49032040, 0x460871c8, 0xf7ff7185, 0xe7f6fe9b, 0x40020000, 0x4dffe92d, 0x4617460c,
-    0xe9dd461d, 0xf8ddb80c, 0xb91da038, 0xb0042004, 0x8df0e8bd, 0x463a2304, 0x98004621, 0xff24f7ff,
-    0xb10e4606, 0xe7f24630, 0x4814e022, 0x68004478, 0x20026004, 0x71c84912, 0xf8804608, 0x490fb00b,
-    0x39144479, 0x68096828, 0xf7ff6088, 0x4606fe6d, 0xf1b8b15e, 0xd0010f00, 0x4000f8c8, 0x0f00f1ba,
-    0x2000d002, 0x0000f8ca, 0x1f3fe004, 0x1d241d2d, 0xd1da2f00, 0x4630bf00, 0x0000e7c9, 0x00000074,
-    0x40020000, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000,
-    0x01000000, 0x40020004, 0x00000000,
-                                ],
-               'pc_init' : 0x20000021,
-               'pc_eraseAll' : 0x20000059,
-               'pc_erase_sector' : 0x2000007D,
-               'pc_program_page' : 0x200000AB,
-               'begin_stack' : 0x20000c00,
-               'begin_data' : 0x20001c00,       # Analyzer uses a max of 512 B data (128 pages * 4 bytes / page)
-               'page_buffers' : [0x20001800, 0x20001c00],   # Enable double buffering
-               'static_base' : 0x20000000 + 0x20 + 0x468,
-               'min_program_length' : 8,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x1fffe000  # Analyzer 0x1fffe000..0x1fffe600
-              };
-
-class Flash_k20d50m(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_k20d50m, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4604b570, 0x4616460d, 0x5020f24c, 0x81c84932, 0x1028f64d, 0x460881c8, 0xf0208800, 0x80080001,
+    0x4448482e, 0xf8dcf000, 0x2001b108, 0x2000bd70, 0x4601e7fc, 0x47702000, 0x4929b510, 0x44484827,
+    0xf8b8f000, 0xb92c4604, 0x48242100, 0xf0004448, 0x4604f9a9, 0xf837f000, 0xbd104620, 0x4604b570,
+    0x4448481e, 0x46214b1e, 0xf00068c2, 0x4605f85d, 0x481ab93d, 0x23004448, 0x68c24621, 0xf946f000,
+    0xf0004605, 0x4628f820, 0xb5febd70, 0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf8f8f000,
+    0xb9674607, 0x22012000, 0x2000e9cd, 0x46224633, 0x90024629, 0x44484809, 0xf984f000, 0xf0004607,
+    0x4638f802, 0x4807bdfe, 0xf4206840, 0xf5000070, 0x49040070, 0x47706048, 0x40052000, 0x00000004,
+    0x6b65666b, 0x4001f000, 0x4a0e2070, 0x20807010, 0xbf007010, 0x7800480b, 0x280009c0, 0x4809d0fa,
+    0xf0017801, 0xb1080020, 0x47702067, 0x0010f001, 0x2068b108, 0xf001e7f9, 0xb1080001, 0xe7f42069,
+    0xe7f22000, 0x40020000, 0x4df0e92d, 0x460d4604, 0x469a4690, 0xf0004650, 0x4606f891, 0x4630b116,
+    0x8df0e8bd, 0x46422310, 0x46204629, 0xf86cf000, 0xb10e4606, 0xe7f34630, 0x0008eb05, 0x68e01e47,
+    0xf1f0fbb7, 0x7011fb00, 0x68e0b140, 0xf0f0fbb7, 0x0b01f100, 0xfb0068e0, 0x1e47f00b, 0x480be011,
+    0x68004478, 0x20096005, 0x71c84909, 0xffacf7ff, 0x69a04606, 0x69a0b108, 0xb1064780, 0x68e0e003,
+    0x42bd4405, 0xbf00d9eb, 0xe7c94630, 0x000002ec, 0x40020000, 0x4604b570, 0x4628460d, 0xf84ef000,
+    0xb10e4606, 0xbd704630, 0x2004b90c, 0x2044e7fb, 0x71c84902, 0xff88f7ff, 0x0000e7f5, 0x40020000,
+    0xb9094601, 0x47702004, 0x6cc04826, 0x6003f3c0, 0x447b4b25, 0x0010f833, 0xb90a0302, 0xe7f22064,
+    0x60082000, 0x2002604a, 0x02c06088, 0x200060c8, 0x61486108, 0xbf006188, 0x4602e7e5, 0x2004b90a,
+    0x61914770, 0xe7fb2000, 0x4604b530, 0x2004b90c, 0x1e58bd30, 0xb9104008, 0x40101e58, 0x2065b108,
+    0x6820e7f6, 0xd8054288, 0x0500e9d4, 0x188d4428, 0xd20142a8, 0xe7eb2066, 0xe7e92000, 0x480b4601,
+    0xd0014281, 0x4770206b, 0xe7fc2000, 0xb90b4603, 0x47702004, 0xd801290f, 0xd0012a04, 0xe7f82004,
+    0xe7f62000, 0x40048000, 0x0000025a, 0x6b65666b, 0x41f0e92d, 0x46884607, 0x461d4614, 0x2004b914,
+    0x81f0e8bd, 0x462a2308, 0x46384641, 0xffbcf7ff, 0xb10e4606, 0xe7f34630, 0x4812e01f, 0x68004478,
+    0x8000f8c0, 0x490fcc01, 0x390c4479, 0x60486809, 0x490ccc01, 0x39184479, 0x60886809, 0x490a2007,
+    0xf7ff71c8, 0x4606ff01, 0xb10869b8, 0x478069b8, 0xe004b106, 0x0808f108, 0x2d003d08, 0xbf00d1dd,
+    0xe7cd4630, 0x000001b0, 0x40020000, 0x4dffe92d, 0x4682b082, 0x2310460c, 0x46504621, 0xf7ff9a04,
+    0x4683ff83, 0x0f00f1bb, 0x4658d003, 0xe8bdb006, 0xe9da8df0, 0xfbb00101, 0x4260f7f1, 0x40084279,
+    0x42a54245, 0x443dd100, 0xe0229e04, 0x0804eba5, 0xd90045b0, 0xea4f46b0, 0x90011018, 0x4478480f,
+    0x60046800, 0x490e2001, 0x980171c8, 0x72c80a00, 0x72889801, 0x72489805, 0xfeb6f7ff, 0xf1bb4683,
+    0xd0010f00, 0xe7d14658, 0x0608eba6, 0x443d4444, 0x2e00bf00, 0x2000d1da, 0x0000e7c8, 0x0000010e,
+    0x40020000, 0x4604b570, 0xb90c460d, 0xbd702004, 0x49032040, 0x460871c8, 0xf7ff7185, 0xe7f6fe95,
+    0x40020000, 0x4dffe92d, 0x4617460c, 0xe9dd461d, 0xf8ddb80c, 0xb91da038, 0xb0042004, 0x8df0e8bd,
+    0x463a2304, 0x98004621, 0xff1ef7ff, 0xb10e4606, 0xe7f24630, 0x4814e022, 0x68004478, 0x20026004,
+    0x71c84912, 0xf8804608, 0x490fb00b, 0x39144479, 0x68096828, 0xf7ff6088, 0x4606fe67, 0xf1b8b15e,
+    0xd0010f00, 0x4000f8c8, 0x0f00f1ba, 0x2000d002, 0x0000f8ca, 0x1f3fe004, 0x1d241d2d, 0xd1da2f00,
+    0x4630bf00, 0x0000e7c9, 0x00000074, 0x40020000, 0x00000000, 0x00080000, 0x00100000, 0x00200000,
+    0x00400000, 0x00800000, 0x01000000, 0x01000000, 0x40020004, 0x00000000,
+                                ],
+               'pc_init' : 0x20000021,
+               'pc_eraseAll' : 0x20000059,
+               'pc_erase_sector' : 0x2000007D,
+               'pc_program_page' : 0x200000AB,
+               'begin_stack' : 0x20001000,
+               'begin_data' : 0x20003000,       # Analyzer uses a max of 1024 B data (256 pages * 4 bytes / page)
+               'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
+               'static_base' : 0x20000000 + 0x20 + 0x474,
+               'min_program_length' : 8,
+               'analyzer_supported' : True,
+               'analyzer_address' : 0x1ffff000  # Analyzer 0x1ffff000..0x1ffff600
+              };
+
+class Flash_k64f(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_k64f, self).__init__(target, flash_algo)
+
+class K64F(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x100000,     blocksize=0x1000, isBootMemory=True),
+        RamRegion(      start=0x1fff0000,  length=0x40000)
+        )
+
+    def __init__(self, link):
+        super(K64F, self).__init__(link, self.memoryMap)
+        self.mdm_idr = 0x001c0000
+        self._svd_location = SVDFile(vendor="Freescale", filename="MK64F12.svd", is_local=False)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_k22f.py` & `pyOCD-0.9.0/pyOCD/target/target_MKE18F256xxx16.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,78 +1,109 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4604b570, 0x4616460d, 0x5020f24c, 0x81c84932, 0x1028f64d, 0x460881c8, 0xf0208800, 0x80080001,
-    0x4448482e, 0xf8dcf000, 0x2001b108, 0x2000bd70, 0x4601e7fc, 0x47702000, 0x4929b510, 0x44484827,
-    0xf8b8f000, 0xb92c4604, 0x48242100, 0xf0004448, 0x4604f9b5, 0xf837f000, 0xbd104620, 0x4604b570,
-    0x4448481e, 0x46214b1e, 0xf00068c2, 0x4605f85d, 0x481ab93d, 0x23004448, 0x68c24621, 0xf952f000,
-    0xf0004605, 0x4628f820, 0xb5febd70, 0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf90af000,
-    0xb9674607, 0x22012000, 0x2000e9cd, 0x46224633, 0x90024629, 0x44484809, 0xf990f000, 0xf0004607,
-    0x4638f802, 0x4807bdfe, 0xf4206840, 0xf5000070, 0x49040070, 0x47706048, 0x40052000, 0x00000004,
-    0x6b65666b, 0x4001f000, 0x4a0e2070, 0x20807010, 0xbf007010, 0x7800480b, 0x280009c0, 0x4809d0fa,
-    0xf0017801, 0xb1080020, 0x47702067, 0x0010f001, 0x2068b108, 0xf001e7f9, 0xb1080001, 0xe7f42069,
-    0xe7f22000, 0x40020000, 0x4df0e92d, 0x460d4604, 0x469a4690, 0xf0004650, 0x4606f899, 0x4630b116,
-    0x8df0e8bd, 0x46422308, 0x46204629, 0xf874f000, 0xb10e4606, 0xe7f34630, 0x0008eb05, 0x68e01e47,
-    0xf1f0fbb7, 0x7011fb00, 0x68e0b140, 0xf0f0fbb7, 0x0b01f100, 0xfb0068e0, 0x1e47f00b, 0x480be011,
-    0x68004478, 0x20096005, 0x71c84909, 0xffacf7ff, 0x69a04606, 0x69a0b108, 0xb1064780, 0x68e0e003,
-    0x42bd4405, 0xbf00d9eb, 0xe7c94630, 0x00000304, 0x40020000, 0x4604b570, 0x4628460d, 0xf856f000,
-    0xb10e4606, 0xbd704630, 0x2004b90c, 0x2044e7fb, 0x71c84902, 0xff88f7ff, 0x0000e7f5, 0x40020000,
-    0xb9094601, 0x47702004, 0x6cc0482e, 0x6003f3c0, 0x447b4b2d, 0x0010f833, 0xb90a0302, 0xe7f22064,
-    0x60082000, 0x2002604a, 0x02806088, 0x482760c8, 0x15807803, 0x61084098, 0x38284824, 0x002bf890,
-    0x20006148, 0xbf006188, 0x4602e7dd, 0x2004b90a, 0x61914770, 0xe7fb2000, 0x4604b530, 0x2004b90c,
-    0x1e58bd30, 0xb9104008, 0x40101e58, 0x2065b108, 0x6820e7f6, 0xd8054288, 0x0500e9d4, 0x188d4428,
-    0xd20142a8, 0xe7eb2066, 0xe7e92000, 0x48104601, 0xd0014281, 0x4770206b, 0xe7fc2000, 0xb90b4603,
-    0x47702004, 0xd803290f, 0xd0092a04, 0xe7f82004, 0xd8032913, 0xd0032a08, 0xe7f22004, 0xe7f02004,
-    0xe7ee2000, 0x40048000, 0x00000272, 0x40020028, 0x6b65666b, 0x41f0e92d, 0x46884607, 0x461d4614,
-    0x2004b914, 0x81f0e8bd, 0x462a2304, 0x46384641, 0xffb2f7ff, 0xb10e4606, 0xe7f34630, 0x480fe019,
-    0x68004478, 0x8000f8c0, 0x490ccc01, 0x390c4479, 0x60486809, 0x490a2006, 0xf7ff71c8, 0x4606fef5,
-    0xb10869b8, 0x478069b8, 0xe004b106, 0x0804f108, 0x2d001f2d, 0xbf00d1e3, 0xe7d34630, 0x000001a4,
-    0x40020000, 0x4dffe92d, 0x4682b082, 0x2308460c, 0x46504621, 0xf7ff9a04, 0x4683ff7f, 0x0f00f1bb,
-    0x4658d003, 0xe8bdb006, 0xe9da8df0, 0xfbb00101, 0x4260f7f1, 0x40084279, 0x42a54245, 0x443dd100,
-    0xe0229e04, 0x0804eba5, 0xd90045b0, 0xea4f46b0, 0x900100d8, 0x4478480f, 0x60046800, 0x490e2001,
-    0x980171c8, 0x72c80a00, 0x72889801, 0x72489805, 0xfeaaf7ff, 0xf1bb4683, 0xd0010f00, 0xe7d14658,
-    0x0608eba6, 0x443d4444, 0x2e00bf00, 0x2000d1da, 0x0000e7c8, 0x0000010e, 0x40020000, 0x4604b570,
-    0xb90c460d, 0xbd702004, 0x49032040, 0x460871c8, 0xf7ff7185, 0xe7f6fe89, 0x40020000, 0x4dffe92d,
-    0x4617460c, 0xe9dd461d, 0xf8ddb80c, 0xb91da038, 0xb0042004, 0x8df0e8bd, 0x463a2304, 0x98004621,
-    0xff1af7ff, 0xb10e4606, 0xe7f24630, 0x4814e022, 0x68004478, 0x20026004, 0x71c84912, 0xf8804608,
-    0x490fb00b, 0x39144479, 0x68096828, 0xf7ff6088, 0x4606fe5b, 0xf1b8b15e, 0xd0010f00, 0x4000f8c8,
-    0x0f00f1ba, 0x2000d002, 0x0000f8ca, 0x1f3fe004, 0x1d241d2d, 0xd1da2f00, 0x4630bf00, 0x0000e7c9,
-    0x00000074, 0x40020000, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
-    0x01000000, 0x01000000, 0x40020004, 0x00000000,
-                                ],
-               'pc_init' : 0x20000021,
-               'pc_eraseAll' : 0x20000059,
-               'pc_erase_sector' : 0x2000007D,
-               'pc_program_page' : 0x200000AB,
-               'begin_stack' : 0x20000800,
-               'begin_data' : 0x20001000,       # Analyzer uses a max of 1024 B data (256 pages * 4 bytes / page)
-               'page_buffers' : [0x20001000, 0x20001800],   # Enable double buffering
-               'static_base' : 0x20000000 + 0x20 + 0x48c,
-               'min_program_length' : 8,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x1ffff000  # Analyzer 0x1ffff000..0x1ffff600
-              };
-
-class Flash_k22f(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_k22f, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 Freescale Semiconductor, Inc.
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+RCM_MR = 0x4007f010
+RCM_MR_BOOTROM_MASK = 0x6
+
+flash_algo = {
+    'load_address' : 0x20000000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0xb510482d, 0x6041492b, 0x71fff64f, 0x68016081, 0x0180f021, 0x0120f041, 0x48286001, 0xf0004448,
+    0x2800f851, 0x2001bf18, 0x2000bd10, 0x48234770, 0x4923b510, 0xf0004448, 0x2800f89d, 0xbd10bf18,
+    0x481e2100, 0x4010e8bd, 0xf0004448, 0xb570b962, 0x46054c1a, 0x4601444c, 0x46204b19, 0xf00068e2,
+    0x2800f8c2, 0xbd70bf18, 0x46292300, 0xe8bd68e2, 0x48124070, 0xf0004448, 0xb570b956, 0x460b460c,
+    0x46014606, 0xb084480d, 0x44484615, 0xf8f5f000, 0xbf1c2800, 0xbd70b004, 0x21012000, 0x1000e9cd,
+    0x48069002, 0x4622462b, 0x44484631, 0xf989f000, 0xbd70b004, 0xd928c520, 0x40052000, 0x00000004,
+    0x6b65666b, 0xbf042800, 0x47702004, 0x6cc949f0, 0x6103f3c1, 0xbf08290f, 0x2100f44f, 0x4aedbf1f,
+    0xf832447a, 0x02891011, 0x2200b410, 0x2100e9c0, 0x60812101, 0x03094be8, 0xf89360c1, 0x110cc000,
+    0xfc0cfa04, 0xc014f8c0, 0x618378db, 0xf04f6102, 0xe9c052a0, 0xbc102108, 0x47702000, 0xbf0e2800,
+    0x61012004, 0x47702000, 0x48dc4602, 0x49db6800, 0x0020f040, 0x46086008, 0xf0406800, 0x60080010,
+    0x48d74770, 0x70012170, 0x70012180, 0xf0117801, 0xd0fb0f80, 0xf0107800, 0xbf1c0f20, 0x47702067,
+    0x0f10f010, 0x2068bf1c, 0xf0104770, 0xbf180001, 0x47702069, 0xbf042800, 0x47702004, 0x4604b510,
+    0xf06f4ac7, 0x6050403b, 0x428148c6, 0x206bbf14, 0x28002000, 0xbd10bf18, 0xf7ff4620, 0x4603ffd2,
+    0xf7ff4620, 0x4618ffc1, 0x2800bd10, 0x2004bf04, 0x23004770, 0x60936053, 0x611360d3, 0x61936153,
+    0x601161d3, 0x605168c1, 0x1001e9d0, 0xf0f0fbb1, 0x20086090, 0xe9c22110, 0xe9c20103, 0x20041005,
+    0x200061d0, 0xe92d4770, 0xb0884df0, 0x46984615, 0x4682460c, 0xf7ff466a, 0x462affd8, 0x46504621,
+    0xf0009b04, 0x0007f92f, 0xb008bf1c, 0x8df0e8bd, 0x4600e9dd, 0x1e451960, 0xf0f6fbb5, 0x5110fb06,
+    0x1c40b111, 0x1e454370, 0xbf9842ac, 0xb270f8df, 0xf024d81c, 0xf040407f, 0xf8cb6010, 0x48990004,
+    0xbf144580, 0x2000206b, 0xbf1c2800, 0xe8bdb008, 0x46508df0, 0xff75f7ff, 0xf8da4607, 0x28000010,
+    0x4780bf18, 0x4434b917, 0xd9e242ac, 0xf7ff4650, 0xb008ff5b, 0xe8bd4638, 0x2a008df0, 0x2004bf04,
+    0xe92d4770, 0xb08945f0, 0x461e4614, 0x4680460d, 0xf7ff466a, 0x4632ff8a, 0x46404629, 0xf0009b03,
+    0x0007f8e1, 0xb009bf1c, 0x85f0e8bd, 0x2e009d00, 0xf8dfbf18, 0xd025a1ec, 0x0b04f854, 0x0008f8ca,
+    0x28049803, 0xf025bf04, 0xf040407f, 0xd00960c0, 0xd1092808, 0x0b04f854, 0x000cf8ca, 0x407ff025,
+    0x60e0f040, 0x0004f8ca, 0xf7ff4640, 0xf8d8ff2a, 0x46071010, 0xbf182900, 0xb91f4788, 0x44059803,
+    0xd1d91a36, 0xf7ff4640, 0xb009ff0f, 0xe8bd4638, 0x280085f0, 0x2004bf04, 0x4a634770, 0x4101ea42,
+    0x60514a5f, 0xe92de70d, 0xb0884dff, 0x469a4614, 0x466a460d, 0xf7ff9808, 0x4622ff38, 0x9b054629,
+    0xf0009808, 0x2800f88f, 0xb00cbf1c, 0x8df0e8bd, 0x4629466a, 0xf7ff9808, 0x9e00ff28, 0x8008f8dd,
+    0xf1c84270, 0x40080100, 0x42b74247, 0x4447bf08, 0xbf182c00, 0xb128f8df, 0x1bbdd01f, 0xbf8842a5,
+    0x98054625, 0x417ff026, 0xf0f0fbb5, 0x7180f041, 0x1004f8cb, 0xea400400, 0xf040200a, 0xf8cb00ff,
+    0x98080008, 0xfecdf7ff, 0xbf1c2800, 0xe8bdb00c, 0x1b648df0, 0x4447442e, 0xb00cd1df, 0xe8bd2000,
+    0x2b008df0, 0x2004bf04, 0xe92d4770, 0xb0884dff, 0xe9dd4616, 0x461d7a14, 0x466a460c, 0x8058f8dd,
+    0xf7ff9808, 0xe9ddfee2, 0x46323007, 0xf0004621, 0x2800f839, 0xb00cbf1c, 0x8df0e8bd, 0x2e009c00,
+    0xb00cbf04, 0x8df0e8bd, 0xb094f8df, 0x407ff06f, 0x6707ea40, 0x407ff024, 0x7000f040, 0x0004f8cb,
+    0x7008f8cb, 0xf8cb6828, 0x9808000c, 0xfe89f7ff, 0xf1bab168, 0xbf180f00, 0x4000f8ca, 0x0f00f1b8,
+    0x2100bf1c, 0x1000f8c8, 0xe8bdb00c, 0x99078df0, 0xf0211a76, 0x440d0103, 0x440c9907, 0xb00cd1da,
+    0x8df0e8bd, 0xbf042800, 0x47702004, 0x42191e5b, 0x421abf0e, 0x47702065, 0x428b6803, 0x6840d806,
+    0x44184411, 0xbf244288, 0x47702000, 0x47702066, 0x40048000, 0x000003d0, 0x40020028, 0x40001400,
+    0x40020000, 0x6b65666b, 0x4000ffff, 0x40020004, 0x40020010, 0x00100008, 0x00200018, 0x00400030,
+    0x00800060, 0x010000c0, 0x02000180, 0x04000300, 0x00000600, 0x00000000,
+    ],
+
+    'pc_init' : 0x20000021,
+    'pc_unInit': 0x2000004B,
+    'pc_program_page': 0x2000009B,
+    'pc_erase_sector': 0x2000006F,
+    'pc_eraseAll' : 0x2000004F,
+
+    'static_base' : 0x20000000 + 0x00000020 + 0x000004d4,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'page_size' : 0x00001000,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
+    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
+    'min_program_length' : 8,
+};
+
+class Flash_ke18f16(Flash_Kinetis):
+    def __init__(self, target):
+        super(Flash_ke18f16, self).__init__(target, flash_algo)
+
+class KE18F16(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x80000,       blocksize=0x1000, isBootMemory=True),
+        RamRegion(      start=0x1fff8000,  length=0x10000)
+        )
+
+    def __init__(self, link):
+        super(KE18F16, self).__init__(link, self.memoryMap)
+        self.mdm_idr = 0x001c0000
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKE18F16.svd")
+
+    def init(self):
+        super(KE18F16, self).init()
+
+        # Disable ROM vector table remapping.
+        self.write32(RCM_MR, RCM_MR_BOOTROM_MASK)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_k64f.py` & `pyOCD-0.9.0/pyOCD/target/target_MK20DX128xxx5.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,93 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4604b570, 0x4616460d, 0x5020f24c, 0x81c84932, 0x1028f64d, 0x460881c8, 0xf0208800, 0x80080001,
-    0x4448482e, 0xf8dcf000, 0x2001b108, 0x2000bd70, 0x4601e7fc, 0x47702000, 0x4929b510, 0x44484827,
-    0xf8b8f000, 0xb92c4604, 0x48242100, 0xf0004448, 0x4604f9a9, 0xf837f000, 0xbd104620, 0x4604b570,
-    0x4448481e, 0x46214b1e, 0xf00068c2, 0x4605f85d, 0x481ab93d, 0x23004448, 0x68c24621, 0xf946f000,
-    0xf0004605, 0x4628f820, 0xb5febd70, 0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf8f8f000,
-    0xb9674607, 0x22012000, 0x2000e9cd, 0x46224633, 0x90024629, 0x44484809, 0xf984f000, 0xf0004607,
-    0x4638f802, 0x4807bdfe, 0xf4206840, 0xf5000070, 0x49040070, 0x47706048, 0x40052000, 0x00000004,
-    0x6b65666b, 0x4001f000, 0x4a0e2070, 0x20807010, 0xbf007010, 0x7800480b, 0x280009c0, 0x4809d0fa,
-    0xf0017801, 0xb1080020, 0x47702067, 0x0010f001, 0x2068b108, 0xf001e7f9, 0xb1080001, 0xe7f42069,
-    0xe7f22000, 0x40020000, 0x4df0e92d, 0x460d4604, 0x469a4690, 0xf0004650, 0x4606f891, 0x4630b116,
-    0x8df0e8bd, 0x46422310, 0x46204629, 0xf86cf000, 0xb10e4606, 0xe7f34630, 0x0008eb05, 0x68e01e47,
-    0xf1f0fbb7, 0x7011fb00, 0x68e0b140, 0xf0f0fbb7, 0x0b01f100, 0xfb0068e0, 0x1e47f00b, 0x480be011,
-    0x68004478, 0x20096005, 0x71c84909, 0xffacf7ff, 0x69a04606, 0x69a0b108, 0xb1064780, 0x68e0e003,
-    0x42bd4405, 0xbf00d9eb, 0xe7c94630, 0x000002ec, 0x40020000, 0x4604b570, 0x4628460d, 0xf84ef000,
-    0xb10e4606, 0xbd704630, 0x2004b90c, 0x2044e7fb, 0x71c84902, 0xff88f7ff, 0x0000e7f5, 0x40020000,
-    0xb9094601, 0x47702004, 0x6cc04826, 0x6003f3c0, 0x447b4b25, 0x0010f833, 0xb90a0302, 0xe7f22064,
-    0x60082000, 0x2002604a, 0x02c06088, 0x200060c8, 0x61486108, 0xbf006188, 0x4602e7e5, 0x2004b90a,
-    0x61914770, 0xe7fb2000, 0x4604b530, 0x2004b90c, 0x1e58bd30, 0xb9104008, 0x40101e58, 0x2065b108,
-    0x6820e7f6, 0xd8054288, 0x0500e9d4, 0x188d4428, 0xd20142a8, 0xe7eb2066, 0xe7e92000, 0x480b4601,
-    0xd0014281, 0x4770206b, 0xe7fc2000, 0xb90b4603, 0x47702004, 0xd801290f, 0xd0012a04, 0xe7f82004,
-    0xe7f62000, 0x40048000, 0x0000025a, 0x6b65666b, 0x41f0e92d, 0x46884607, 0x461d4614, 0x2004b914,
-    0x81f0e8bd, 0x462a2308, 0x46384641, 0xffbcf7ff, 0xb10e4606, 0xe7f34630, 0x4812e01f, 0x68004478,
-    0x8000f8c0, 0x490fcc01, 0x390c4479, 0x60486809, 0x490ccc01, 0x39184479, 0x60886809, 0x490a2007,
-    0xf7ff71c8, 0x4606ff01, 0xb10869b8, 0x478069b8, 0xe004b106, 0x0808f108, 0x2d003d08, 0xbf00d1dd,
-    0xe7cd4630, 0x000001b0, 0x40020000, 0x4dffe92d, 0x4682b082, 0x2310460c, 0x46504621, 0xf7ff9a04,
-    0x4683ff83, 0x0f00f1bb, 0x4658d003, 0xe8bdb006, 0xe9da8df0, 0xfbb00101, 0x4260f7f1, 0x40084279,
-    0x42a54245, 0x443dd100, 0xe0229e04, 0x0804eba5, 0xd90045b0, 0xea4f46b0, 0x90011018, 0x4478480f,
-    0x60046800, 0x490e2001, 0x980171c8, 0x72c80a00, 0x72889801, 0x72489805, 0xfeb6f7ff, 0xf1bb4683,
-    0xd0010f00, 0xe7d14658, 0x0608eba6, 0x443d4444, 0x2e00bf00, 0x2000d1da, 0x0000e7c8, 0x0000010e,
-    0x40020000, 0x4604b570, 0xb90c460d, 0xbd702004, 0x49032040, 0x460871c8, 0xf7ff7185, 0xe7f6fe95,
-    0x40020000, 0x4dffe92d, 0x4617460c, 0xe9dd461d, 0xf8ddb80c, 0xb91da038, 0xb0042004, 0x8df0e8bd,
-    0x463a2304, 0x98004621, 0xff1ef7ff, 0xb10e4606, 0xe7f24630, 0x4814e022, 0x68004478, 0x20026004,
-    0x71c84912, 0xf8804608, 0x490fb00b, 0x39144479, 0x68096828, 0xf7ff6088, 0x4606fe67, 0xf1b8b15e,
-    0xd0010f00, 0x4000f8c8, 0x0f00f1ba, 0x2000d002, 0x0000f8ca, 0x1f3fe004, 0x1d241d2d, 0xd1da2f00,
-    0x4630bf00, 0x0000e7c9, 0x00000074, 0x40020000, 0x00000000, 0x00080000, 0x00100000, 0x00200000,
-    0x00400000, 0x00800000, 0x01000000, 0x01000000, 0x40020004, 0x00000000,
-                                ],
-               'pc_init' : 0x20000021,
-               'pc_eraseAll' : 0x20000059,
-               'pc_erase_sector' : 0x2000007D,
-               'pc_program_page' : 0x200000AB,
-               'begin_stack' : 0x20001000,
-               'begin_data' : 0x20003000,       # Analyzer uses a max of 1024 B data (256 pages * 4 bytes / page)
-               'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
-               'static_base' : 0x20000000 + 0x20 + 0x474,
-               'min_program_length' : 8,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x1ffff000  # Analyzer 0x1ffff000..0x1ffff600
-              };
-
-class Flash_k64f(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_k64f, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2017 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4604b570, 0x4616460d, 0x5020f24c, 0x81c84932, 0x1028f64d, 0x460881c8, 0xf0208800, 0x80080001,
+    0x4448482e, 0xf8dcf000, 0x2001b108, 0x2000bd70, 0x4601e7fc, 0x47702000, 0x4929b510, 0x44484827,
+    0xf8b8f000, 0xb92c4604, 0x48242100, 0xf0004448, 0x4604f9a3, 0xf837f000, 0xbd104620, 0x4604b570,
+    0x4448481e, 0x46214b1e, 0xf00068c2, 0x4605f85d, 0x481ab93d, 0x23004448, 0x68c24621, 0xf940f000,
+    0xf0004605, 0x4628f820, 0xb5febd70, 0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf8f8f000,
+    0xb9674607, 0x22012000, 0x2000e9cd, 0x46224633, 0x90024629, 0x44484809, 0xf97ef000, 0xf0004607,
+    0x4638f802, 0x4807bdfe, 0xf4206840, 0xf5000070, 0x49040070, 0x47706048, 0x40052000, 0x00000004,
+    0x6b65666b, 0x4001f000, 0x4a0e2070, 0x20807010, 0xbf007010, 0x7800480b, 0x280009c0, 0x4809d0fa,
+    0xf0017801, 0xb1080020, 0x47702067, 0x0010f001, 0x2068b108, 0xf001e7f9, 0xb1080001, 0xe7f42069,
+    0xe7f22000, 0x40020000, 0x4df0e92d, 0x460d4604, 0x469a4690, 0xf0004650, 0x4606f891, 0x4630b116,
+    0x8df0e8bd, 0x46422304, 0x46204629, 0xf86cf000, 0xb10e4606, 0xe7f34630, 0x0008eb05, 0x68e01e47,
+    0xf1f0fbb7, 0x7011fb00, 0x68e0b140, 0xf0f0fbb7, 0x0b01f100, 0xfb0068e0, 0x1e47f00b, 0x480be011,
+    0x68004478, 0x20096005, 0x71c84909, 0xffacf7ff, 0x69a04606, 0x69a0b108, 0xb1064780, 0x68e0e003,
+    0x42bd4405, 0xbf00d9eb, 0xe7c94630, 0x000002e0, 0x40020000, 0x4604b570, 0x4628460d, 0xf84ef000,
+    0xb10e4606, 0xbd704630, 0x2004b90c, 0x2044e7fb, 0x71c84902, 0xff88f7ff, 0x0000e7f5, 0x40020000,
+    0xb9094601, 0x47702004, 0x6cc04826, 0x6003f3c0, 0x447b4b25, 0x0010f833, 0xb90a0302, 0xe7f22064,
+    0x60082000, 0x2001604a, 0x02806088, 0x200060c8, 0x61486108, 0xbf006188, 0x4602e7e5, 0x2004b90a,
+    0x61914770, 0xe7fb2000, 0x4604b530, 0x2004b90c, 0x1e58bd30, 0xb9104008, 0x40101e58, 0x2065b108,
+    0x6820e7f6, 0xd8054288, 0x0500e9d4, 0x188d4428, 0xd20142a8, 0xe7eb2066, 0xe7e92000, 0x480b4601,
+    0xd0014281, 0x4770206b, 0xe7fc2000, 0xb90b4603, 0x47702004, 0xd801290f, 0xd0012a04, 0xe7f82004,
+    0xe7f62000, 0x40048000, 0x0000024e, 0x6b65666b, 0x41f0e92d, 0x46884607, 0x461d4614, 0x2004b914,
+    0x81f0e8bd, 0x462a2304, 0x46384641, 0xffbcf7ff, 0xb10e4606, 0xe7f34630, 0x480fe019, 0x68004478,
+    0x8000f8c0, 0x490ccc01, 0x390c4479, 0x60486809, 0x490a2006, 0xf7ff71c8, 0x4606ff07, 0xb10869b8,
+    0x478069b8, 0xe004b106, 0x0804f108, 0x2d001f2d, 0xbf00d1e3, 0xe7d34630, 0x000001a4, 0x40020000,
+    0x4dffe92d, 0x4682b082, 0x2304460c, 0x46504621, 0xf7ff9a04, 0x4683ff89, 0x0f00f1bb, 0x4658d003,
+    0xe8bdb006, 0xe9da8df0, 0xfbb00101, 0x4260f7f1, 0x40084279, 0x42a54245, 0x443dd100, 0xe0229e04,
+    0x0804eba5, 0xd90045b0, 0xea4f46b0, 0x90010098, 0x4478480f, 0x60046800, 0x490e2001, 0x980171c8,
+    0x72c80a00, 0x72889801, 0x72489805, 0xfebcf7ff, 0xf1bb4683, 0xd0010f00, 0xe7d14658, 0x0608eba6,
+    0x443d4444, 0x2e00bf00, 0x2000d1da, 0x0000e7c8, 0x0000010e, 0x40020000, 0x4604b570, 0xb90c460d,
+    0xbd702004, 0x49032040, 0x460871c8, 0xf7ff7185, 0xe7f6fe9b, 0x40020000, 0x4dffe92d, 0x4617460c,
+    0xe9dd461d, 0xf8ddb80c, 0xb91da038, 0xb0042004, 0x8df0e8bd, 0x463a2304, 0x98004621, 0xff24f7ff,
+    0xb10e4606, 0xe7f24630, 0x4814e022, 0x68004478, 0x20026004, 0x71c84912, 0xf8804608, 0x490fb00b,
+    0x39144479, 0x68096828, 0xf7ff6088, 0x4606fe6d, 0xf1b8b15e, 0xd0010f00, 0x4000f8c8, 0x0f00f1ba,
+    0x2000d002, 0x0000f8ca, 0x1f3fe004, 0x1d241d2d, 0xd1da2f00, 0x4630bf00, 0x0000e7c9, 0x00000074,
+    0x40020000, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000,
+    0x01000000, 0x40020004, 0x00000000,
+                                ],
+               'pc_init' : 0x20000021,
+               'pc_eraseAll' : 0x20000059,
+               'pc_erase_sector' : 0x2000007D,
+               'pc_program_page' : 0x200000AB,
+               'begin_stack' : 0x20000c00,
+               'begin_data' : 0x20001c00,       # Analyzer uses a max of 512 B data (128 pages * 4 bytes / page)
+               'page_buffers' : [0x20001800, 0x20001c00],   # Enable double buffering
+               'static_base' : 0x20000000 + 0x20 + 0x468,
+               'min_program_length' : 8,
+               'analyzer_supported' : True,
+               'analyzer_address' : 0x1fffe000  # Analyzer 0x1fffe000..0x1fffe600
+              };
+
+class Flash_k20d50m(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_k20d50m, self).__init__(target, flash_algo)
+
+class K20D50M(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x20000,     blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1fffe000,  length=0x4000)
+        )
+
+    def __init__(self, link):
+        super(K20D50M, self).__init__(link, self.memoryMap)
+        self.mdm_idr = 0x001c0000
+        self._svd_location = SVDFile(vendor="Freescale", filename="MK20D5.svd", is_local=False)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_k66f18.py` & `pyOCD-0.9.0/pyOCD/target/target_MK66FN2M0xxx18.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,78 +1,95 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0xb510482e, 0x5120f24c, 0xf64d81c1, 0x81c11128, 0xf0218801, 0x80010101, 0x44484829, 0xf856f000,
-    0xbf182800, 0xbd102001, 0x47702000, 0xb5104824, 0x44484924, 0xf926f000, 0x4821b920, 0x44482100,
-    0xf9daf000, 0x684a4920, 0x0270f442, 0xbd10604a, 0x4c1bb570, 0x444c4605, 0x4b1a4601, 0x68e24620,
-    0xf88ef000, 0x2300b928, 0x46204629, 0xf00068e2, 0x4915f91f, 0xf442684a, 0x604a0270, 0xb570bd70,
-    0x460b460c, 0x46014606, 0xb084480d, 0x44484615, 0xf8b8f000, 0x2000b958, 0xe9cd2101, 0x90021000,
-    0x462b4807, 0x46314622, 0xf0004448, 0x4906f963, 0xf442684a, 0x604a0270, 0xbd70b004, 0x40052000,
-    0x00000004, 0x6b65666b, 0x4001f000, 0xbf042800, 0x47702004, 0x6cc94926, 0x0e094a26, 0xf832447a,
-    0x03091011, 0x2064bf04, 0x22004770, 0x2100e9c0, 0x60812104, 0x60c10289, 0x780b491f, 0x7c80f44f,
-    0xf303fa0c, 0x78c96103, 0x1205e9c0, 0x47704610, 0xbf0e2800, 0x61812004, 0x47702000, 0xbf042800,
-    0x47702004, 0x42191e5b, 0x421abf0e, 0x47702065, 0x428b6803, 0x6840d806, 0x44184411, 0xbf244288,
-    0x47702000, 0x47702066, 0x4288490c, 0x206bbf14, 0x47702000, 0x290fb140, 0x2a04d802, 0xe005d104,
-    0xbf982913, 0xd0012a08, 0x47702004, 0x47702000, 0x40048000, 0x0000036c, 0x40020028, 0x6b65666b,
-    0x4df0e92d, 0x46154606, 0x4618460c, 0xffdcf7ff, 0xbf182800, 0x8df0e8bd, 0x462a2310, 0x46304621,
-    0xffbcf7ff, 0xbf180007, 0x8df0e8bd, 0x1e451960, 0xfbb568f0, 0xfb00f1f0, 0xb1125211, 0x43481c49,
-    0x42ac1e45, 0xf8dfd817, 0x44f88034, 0xb030f8df, 0x0a09f04f, 0x0000f8d8, 0xf88b6004, 0xf000a007,
-    0x4607f917, 0x280069b0, 0x4780bf18, 0x68f0b91f, 0x42ac4404, 0x4638d9ee, 0x8df0e8bd, 0x0000027a,
-    0x40020000, 0xbf042a00, 0x47702004, 0x4df0e92d, 0x4614461d, 0x4607460e, 0x462a2308, 0xff7ef7ff,
-    0x0b00ea5f, 0xe8bdbf18, 0x2d008df0, 0xf8dfbf1e, 0x44f8804c, 0x0a07f04f, 0xf8d8d01c, 0x60060000,
-    0x1000f8d8, 0x0b04f854, 0xf8d86048, 0xf8541000, 0x60880b04, 0xf880480a, 0xf000a007, 0x4683f8d9,
-    0x280069b8, 0x4780bf18, 0x0f00f1bb, 0x3608d102, 0xd1e23d08, 0xe8bd4658, 0x00008df0, 0x00000212,
-    0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff5d, 0xbd10bf18, 0xbf042c00, 0xbd102004, 0x49032044,
-    0xe8bd71c8, 0xf0004010, 0x0000b8b3, 0x40020000, 0x4df0e92d, 0x4614469a, 0x4605460e, 0xf7ff2310,
-    0x2800ff2d, 0xe8bdbf18, 0xe9d58df0, 0xfbb00101, 0x4270f8f1, 0x0100f1c8, 0x42474008, 0xbf0842b7,
-    0x2c004447, 0xf8dfbf18, 0xd01cb044, 0x42a51bbd, 0x4625bf88, 0x490e0928, 0x68094479, 0x2101600e,
-    0x1007f88b, 0xf88b0a01, 0xf88b100b, 0xf88b000a, 0xf000a009, 0x2800f87d, 0xe8bdbf18, 0x1b648df0,
-    0x4447442e, 0x2000d1e2, 0x8df0e8bd, 0x40020000, 0x0000014c, 0xbf122800, 0x20042a00, 0x29084770,
-    0xe8dfd215, 0x0604f001, 0x0c0a0806, 0x68c0100e, 0x6840e00a, 0x6880e008, 0x6800e006, 0x2001e004,
-    0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xbf042b00, 0x47702004, 0x4df0e92d,
-    0xe9dd461c, 0x46158709, 0x2304460e, 0xa020f8dd, 0xfec4f7ff, 0xbf182800, 0x8df0e8bd, 0xbf1a2d00,
-    0xb04cf8df, 0xe8bd44fb, 0xf8db8df0, 0x60060000, 0x21024810, 0xf88071c1, 0xf8dba00b, 0x68201000,
-    0xf0006088, 0xb150f825, 0x0f00f1b8, 0xf8c8bf18, 0x2f006000, 0x2100bf1c, 0xe8bd6039, 0x1f2d8df0,
-    0x0404f104, 0x0604f106, 0xe8bdd1df, 0x00008df0, 0x000000a0, 0x40020000, 0xbf042800, 0x47702004,
-    0x48022240, 0x718171c2, 0xb802f000, 0x40020000, 0x2170480c, 0x21807001, 0x78017001, 0x0f80f011,
-    0x7800d0fb, 0x0f20f010, 0x2067bf1c, 0xf0104770, 0xbf1c0f10, 0x47702068, 0x0001f010, 0x2069bf18,
-    0x00004770, 0x40020000, 0x40020004, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000,
-    0x00800000, 0x01000000, 0x02000000, 0x00000000,
-                                ],
-    'pc_init' : 0x20000021,
-    'pc_unInit': 0x20000049,
-    'pc_program_page': 0x2000009F,
-    'pc_erase_sector': 0x20000071,
-    'pc_eraseAll' : 0x2000004D,
-    'static_base' : 0x20000000 + 0x00000020 + 0x0000046c,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
-    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
-    'min_program_length' : 8,
-  };
-
-class Flash_k66f18(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_k66f18, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0xb510482e, 0x5120f24c, 0xf64d81c1, 0x81c11128, 0xf0218801, 0x80010101, 0x44484829, 0xf856f000,
+    0xbf182800, 0xbd102001, 0x47702000, 0xb5104824, 0x44484924, 0xf926f000, 0x4821b920, 0x44482100,
+    0xf9daf000, 0x684a4920, 0x0270f442, 0xbd10604a, 0x4c1bb570, 0x444c4605, 0x4b1a4601, 0x68e24620,
+    0xf88ef000, 0x2300b928, 0x46204629, 0xf00068e2, 0x4915f91f, 0xf442684a, 0x604a0270, 0xb570bd70,
+    0x460b460c, 0x46014606, 0xb084480d, 0x44484615, 0xf8b8f000, 0x2000b958, 0xe9cd2101, 0x90021000,
+    0x462b4807, 0x46314622, 0xf0004448, 0x4906f963, 0xf442684a, 0x604a0270, 0xbd70b004, 0x40052000,
+    0x00000004, 0x6b65666b, 0x4001f000, 0xbf042800, 0x47702004, 0x6cc94926, 0x0e094a26, 0xf832447a,
+    0x03091011, 0x2064bf04, 0x22004770, 0x2100e9c0, 0x60812104, 0x60c10289, 0x780b491f, 0x7c80f44f,
+    0xf303fa0c, 0x78c96103, 0x1205e9c0, 0x47704610, 0xbf0e2800, 0x61812004, 0x47702000, 0xbf042800,
+    0x47702004, 0x42191e5b, 0x421abf0e, 0x47702065, 0x428b6803, 0x6840d806, 0x44184411, 0xbf244288,
+    0x47702000, 0x47702066, 0x4288490c, 0x206bbf14, 0x47702000, 0x290fb140, 0x2a04d802, 0xe005d104,
+    0xbf982913, 0xd0012a08, 0x47702004, 0x47702000, 0x40048000, 0x0000036c, 0x40020028, 0x6b65666b,
+    0x4df0e92d, 0x46154606, 0x4618460c, 0xffdcf7ff, 0xbf182800, 0x8df0e8bd, 0x462a2310, 0x46304621,
+    0xffbcf7ff, 0xbf180007, 0x8df0e8bd, 0x1e451960, 0xfbb568f0, 0xfb00f1f0, 0xb1125211, 0x43481c49,
+    0x42ac1e45, 0xf8dfd817, 0x44f88034, 0xb030f8df, 0x0a09f04f, 0x0000f8d8, 0xf88b6004, 0xf000a007,
+    0x4607f917, 0x280069b0, 0x4780bf18, 0x68f0b91f, 0x42ac4404, 0x4638d9ee, 0x8df0e8bd, 0x0000027a,
+    0x40020000, 0xbf042a00, 0x47702004, 0x4df0e92d, 0x4614461d, 0x4607460e, 0x462a2308, 0xff7ef7ff,
+    0x0b00ea5f, 0xe8bdbf18, 0x2d008df0, 0xf8dfbf1e, 0x44f8804c, 0x0a07f04f, 0xf8d8d01c, 0x60060000,
+    0x1000f8d8, 0x0b04f854, 0xf8d86048, 0xf8541000, 0x60880b04, 0xf880480a, 0xf000a007, 0x4683f8d9,
+    0x280069b8, 0x4780bf18, 0x0f00f1bb, 0x3608d102, 0xd1e23d08, 0xe8bd4658, 0x00008df0, 0x00000212,
+    0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff5d, 0xbd10bf18, 0xbf042c00, 0xbd102004, 0x49032044,
+    0xe8bd71c8, 0xf0004010, 0x0000b8b3, 0x40020000, 0x4df0e92d, 0x4614469a, 0x4605460e, 0xf7ff2310,
+    0x2800ff2d, 0xe8bdbf18, 0xe9d58df0, 0xfbb00101, 0x4270f8f1, 0x0100f1c8, 0x42474008, 0xbf0842b7,
+    0x2c004447, 0xf8dfbf18, 0xd01cb044, 0x42a51bbd, 0x4625bf88, 0x490e0928, 0x68094479, 0x2101600e,
+    0x1007f88b, 0xf88b0a01, 0xf88b100b, 0xf88b000a, 0xf000a009, 0x2800f87d, 0xe8bdbf18, 0x1b648df0,
+    0x4447442e, 0x2000d1e2, 0x8df0e8bd, 0x40020000, 0x0000014c, 0xbf122800, 0x20042a00, 0x29084770,
+    0xe8dfd215, 0x0604f001, 0x0c0a0806, 0x68c0100e, 0x6840e00a, 0x6880e008, 0x6800e006, 0x2001e004,
+    0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xbf042b00, 0x47702004, 0x4df0e92d,
+    0xe9dd461c, 0x46158709, 0x2304460e, 0xa020f8dd, 0xfec4f7ff, 0xbf182800, 0x8df0e8bd, 0xbf1a2d00,
+    0xb04cf8df, 0xe8bd44fb, 0xf8db8df0, 0x60060000, 0x21024810, 0xf88071c1, 0xf8dba00b, 0x68201000,
+    0xf0006088, 0xb150f825, 0x0f00f1b8, 0xf8c8bf18, 0x2f006000, 0x2100bf1c, 0xe8bd6039, 0x1f2d8df0,
+    0x0404f104, 0x0604f106, 0xe8bdd1df, 0x00008df0, 0x000000a0, 0x40020000, 0xbf042800, 0x47702004,
+    0x48022240, 0x718171c2, 0xb802f000, 0x40020000, 0x2170480c, 0x21807001, 0x78017001, 0x0f80f011,
+    0x7800d0fb, 0x0f20f010, 0x2067bf1c, 0xf0104770, 0xbf1c0f10, 0x47702068, 0x0001f010, 0x2069bf18,
+    0x00004770, 0x40020000, 0x40020004, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000,
+    0x00800000, 0x01000000, 0x02000000, 0x00000000,
+                                ],
+    'pc_init' : 0x20000021,
+    'pc_unInit': 0x20000049,
+    'pc_program_page': 0x2000009F,
+    'pc_erase_sector': 0x20000071,
+    'pc_eraseAll' : 0x2000004D,
+    'static_base' : 0x20000000 + 0x00000020 + 0x0000046c,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
+    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
+    'min_program_length' : 8,
+  };
+
+class Flash_k66f18(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_k66f18, self).__init__(target, flash_algo)
+
+class K66F18(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x200000,     blocksize=0x1000, isBootMemory=True),
+        RamRegion(      start=0x1fff0000,  length=0x40000),
+        RamRegion(      start=0x14000000,  length=0x1000)
+        )
+
+    def __init__(self, transport):
+        super(K66F18, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0000
+        self._svd_location = SVDFile(vendor="Freescale", filename="MK66F18.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_ke15z7.py` & `pyOCD-0.9.0/pyOCD/target/target_MK28FN2M0xxx15.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,82 +1,96 @@
-"""
- Flash OS Routines (Automagically Generated)
- Copyright (c) 2009-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = {
-    'load_address' : 0x20000000,
-    'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4829b510, 0x60414927, 0x60814928, 0x22806801, 0x22204391, 0x60014311, 0x44484825, 0xf84cf000,
-    0xd0002800, 0xbd102001, 0x47702000, 0xb5104820, 0x44484920, 0xf88ef000, 0xd1042800, 0x2100481c,
-    0xf0004448, 0xbd10f948, 0x4c19b570, 0x444c4605, 0x4b184601, 0x68e24620, 0xf8b5f000, 0xd1052800,
-    0x46292300, 0x68e24620, 0xf93ff000, 0xb570bd70, 0x460b460c, 0x46014606, 0xb084480d, 0x44484615,
-    0xf8e4f000, 0xd10a2800, 0x90029001, 0x48082101, 0x462b9100, 0x46314622, 0xf0004448, 0xb004f96d,
-    0x0000bd70, 0xd928c520, 0x40052000, 0x0000ffff, 0x00000004, 0x6b65666b, 0xd00b2800, 0x68c949dd,
-    0x0f090109, 0xd007290f, 0x00494adb, 0x5a51447a, 0xe0030289, 0x47702004, 0x04892101, 0x2300b430,
-    0x60416003, 0x02cc2101, 0x608160c4, 0x7a0d49d3, 0x40aa158a, 0x7ac96142, 0x61816103, 0x06892105,
-    0x62016244, 0x2000bc30, 0x28004770, 0x6101d002, 0x47702000, 0x47702004, 0x48c94602, 0x210168c0,
-    0x43080289, 0x60c849c6, 0x48c64770, 0x70012170, 0x70012180, 0x06097801, 0x7800d5fc, 0xd5010681,
-    0x47702067, 0xd50106c1, 0x47702068, 0xd0fc07c0, 0x47702069, 0xd1012800, 0x47702004, 0x4604b510,
-    0x48b94ab8, 0x48b96050, 0xd0014281, 0xe000206b, 0x28002000, 0x4620d107, 0xffd7f7ff, 0x46204603,
-    0xffcaf7ff, 0xbd104618, 0xd1012800, 0x47702004, 0x4614b510, 0x60622200, 0x60e260a2, 0x61626122,
-    0x61e261a2, 0x68c16021, 0x68816061, 0xf0006840, 0x60a0f953, 0x60e02008, 0x61606120, 0x200461a0,
-    0x200061e0, 0xb5ffbd10, 0x4615b089, 0x466a460c, 0xf7ff9809, 0x462affd9, 0x9b044621, 0xf0009809,
-    0x0007f90c, 0x9c00d130, 0x19659e01, 0x46311e6d, 0xf0004628, 0x2900f931, 0x1c40d002, 0x1e454370,
-    0xd81d42ac, 0x20090221, 0x06000a09, 0x488d1809, 0x498e6041, 0x4288980c, 0x206bd001, 0x2000e000,
-    0xd1112800, 0xf7ff9809, 0x4607ff80, 0x69009809, 0xd0002800, 0x2f004780, 0x19a4d102, 0xd9e142ac,
-    0xf7ff9809, 0x4638ff69, 0xbdf0b00d, 0xd1012a00, 0x47702004, 0xb089b5ff, 0x461e4614, 0x466a460d,
-    0xf7ff9809, 0x4632ff91, 0x9b034629, 0xf0009809, 0x0007f8c4, 0x9d00d12d, 0xd0262e00, 0x4871cc02,
-    0x99036081, 0xd0022904, 0xd0072908, 0x022ae00e, 0x0a122103, 0x18510649, 0xe0076041, 0x60c1cc02,
-    0x2107022a, 0x06090a12, 0x60411851, 0xf7ff9809, 0x4607ff3c, 0x69009809, 0xd0002800, 0x2f004780,
-    0x9803d103, 0x1a361945, 0x9809d1d8, 0xff24f7ff, 0xb00d4638, 0x2800bdf0, 0x4a5dd005, 0x18890409,
-    0x60514a58, 0x2004e721, 0xb5ff4770, 0x4614b08b, 0x460d461e, 0x980b466a, 0xff46f7ff, 0x46294622,
-    0x980b9b05, 0xf879f000, 0xd1332800, 0x4629466a, 0xf7ff980b, 0x9d00ff39, 0x90089802, 0x42404269,
-    0x424f4001, 0xd10142af, 0x183f9808, 0xd0202c00, 0x90090230, 0x42a61b7e, 0x4626d900, 0x99054630,
-    0xf88af000, 0x2101022a, 0x06090a12, 0x493d1852, 0x9a09604a, 0x43100400, 0x608830ff, 0xf7ff980b,
-    0x2800fee4, 0x9808d106, 0x19ad1ba4, 0x2c00183f, 0x2000d1e0, 0xbdf0b00f, 0xd1012b00, 0x47702004,
-    0xb089b5ff, 0x461d4616, 0x466a460c, 0x98099f12, 0xfefaf7ff, 0x46214632, 0x98099b07, 0xf82df000,
-    0xd11d2800, 0x2e009c00, 0x492ad01a, 0x18470638, 0x20010221, 0x06400a09, 0x48221809, 0x60876041,
-    0x60c16829, 0xf7ff9809, 0x2800feb0, 0x9913d00a, 0xd0002900, 0x9914600c, 0xd0012900, 0x600a2200,
-    0xbdf0b00d, 0x1a769907, 0x00890889, 0x9907194d, 0x2e00190c, 0xb00dd1dc, 0x2800bdf0, 0x2004d101,
-    0xb4104770, 0x460c1e5b, 0xd101421c, 0xd002421a, 0x2065bc10, 0x68034770, 0xd804428b, 0x18896840,
-    0x42881818, 0xbc10d202, 0x47702066, 0x2000bc10, 0x00004770, 0x40048040, 0x000003bc, 0x40020020,
-    0xf0003000, 0x40020000, 0x44ffffff, 0x6b65666b, 0x4000ffff, 0x00ffffff, 0x460bb530, 0x20004601,
-    0x24012220, 0x460de009, 0x429d40d5, 0x461dd305, 0x1b494095, 0x40954625, 0x46151940, 0x2d001e52,
-    0xbd30dcf1, 0x40020004, 0x40020010, 0x00100008, 0x00200018, 0x00400030, 0x00800060, 0x010000c0,
-    0x02000180, 0x04000300, 0x00000600, 0x00000000,
-    ],
-
-    'pc_init' : 0x20000021,
-    'pc_unInit': 0x20000049,
-    'pc_program_page': 0x2000008F,
-    'pc_erase_sector': 0x20000069,
-    'pc_eraseAll' : 0x2000004D,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x000004ac,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_size' : 0x00000800,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
-    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
-    'min_program_length' : 8,
-};
-
-class Flash_ke15z7(Flash_Kinetis):
-    def __init__(self, target):
-        super(Flash_ke15z7, self).__init__(target, flash_algo)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0xb510482e, 0x5120f24c, 0xf64d81c1, 0x81c11128, 0xf0218801, 0x80010101, 0x44484829, 0xf856f000,
+    0xbf182800, 0xbd102001, 0x47702000, 0xb5104824, 0x44484924, 0xf926f000, 0x4821b920, 0x44482100,
+    0xf9daf000, 0x684a4920, 0x0270f442, 0xbd10604a, 0x4c1bb570, 0x444c4605, 0x4b1a4601, 0x68e24620,
+    0xf88ef000, 0x2300b928, 0x46204629, 0xf00068e2, 0x4915f91f, 0xf442684a, 0x604a0270, 0xb570bd70,
+    0x460b460c, 0x46014606, 0xb084480d, 0x44484615, 0xf8b8f000, 0x2000b958, 0xe9cd2101, 0x90021000,
+    0x462b4807, 0x46314622, 0xf0004448, 0x4906f963, 0xf442684a, 0x604a0270, 0xbd70b004, 0x40052000,
+    0x00000004, 0x6b65666b, 0x4001f000, 0xbf042800, 0x47702004, 0x6cc94926, 0x0e094a26, 0xf832447a,
+    0x03091011, 0x2064bf04, 0x22004770, 0x2100e9c0, 0x60812104, 0x60c10289, 0x780b491f, 0x7c80f44f,
+    0xf303fa0c, 0x78c96103, 0x1205e9c0, 0x47704610, 0xbf0e2800, 0x61812004, 0x47702000, 0xbf042800,
+    0x47702004, 0x42191e5b, 0x421abf0e, 0x47702065, 0x428b6803, 0x6840d806, 0x44184411, 0xbf244288,
+    0x47702000, 0x47702066, 0x4288490c, 0x206bbf14, 0x47702000, 0x290fb140, 0x2a04d802, 0xe005d104,
+    0xbf982913, 0xd0012a08, 0x47702004, 0x47702000, 0x40048000, 0x0000036c, 0x40020028, 0x6b65666b,
+    0x4df0e92d, 0x46154606, 0x4618460c, 0xffdcf7ff, 0xbf182800, 0x8df0e8bd, 0x462a2310, 0x46304621,
+    0xffbcf7ff, 0xbf180007, 0x8df0e8bd, 0x1e451960, 0xfbb568f0, 0xfb00f1f0, 0xb1125211, 0x43481c49,
+    0x42ac1e45, 0xf8dfd817, 0x44f88034, 0xb030f8df, 0x0a09f04f, 0x0000f8d8, 0xf88b6004, 0xf000a007,
+    0x4607f917, 0x280069b0, 0x4780bf18, 0x68f0b91f, 0x42ac4404, 0x4638d9ee, 0x8df0e8bd, 0x0000027a,
+    0x40020000, 0xbf042a00, 0x47702004, 0x4df0e92d, 0x4614461d, 0x4607460e, 0x462a2308, 0xff7ef7ff,
+    0x0b00ea5f, 0xe8bdbf18, 0x2d008df0, 0xf8dfbf1e, 0x44f8804c, 0x0a07f04f, 0xf8d8d01c, 0x60060000,
+    0x1000f8d8, 0x0b04f854, 0xf8d86048, 0xf8541000, 0x60880b04, 0xf880480a, 0xf000a007, 0x4683f8d9,
+    0x280069b8, 0x4780bf18, 0x0f00f1bb, 0x3608d102, 0xd1e23d08, 0xe8bd4658, 0x00008df0, 0x00000212,
+    0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff5d, 0xbd10bf18, 0xbf042c00, 0xbd102004, 0x49032044,
+    0xe8bd71c8, 0xf0004010, 0x0000b8b3, 0x40020000, 0x4df0e92d, 0x4614469a, 0x4605460e, 0xf7ff2310,
+    0x2800ff2d, 0xe8bdbf18, 0xe9d58df0, 0xfbb00101, 0x4270f8f1, 0x0100f1c8, 0x42474008, 0xbf0842b7,
+    0x2c004447, 0xf8dfbf18, 0xd01cb044, 0x42a51bbd, 0x4625bf88, 0x490e0928, 0x68094479, 0x2101600e,
+    0x1007f88b, 0xf88b0a01, 0xf88b100b, 0xf88b000a, 0xf000a009, 0x2800f87d, 0xe8bdbf18, 0x1b648df0,
+    0x4447442e, 0x2000d1e2, 0x8df0e8bd, 0x40020000, 0x0000014c, 0xbf122800, 0x20042a00, 0x29084770,
+    0xe8dfd215, 0x0604f001, 0x0c0a0806, 0x68c0100e, 0x6840e00a, 0x6880e008, 0x6800e006, 0x2001e004,
+    0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xbf042b00, 0x47702004, 0x4df0e92d,
+    0xe9dd461c, 0x46158709, 0x2304460e, 0xa020f8dd, 0xfec4f7ff, 0xbf182800, 0x8df0e8bd, 0xbf1a2d00,
+    0xb04cf8df, 0xe8bd44fb, 0xf8db8df0, 0x60060000, 0x21024810, 0xf88071c1, 0xf8dba00b, 0x68201000,
+    0xf0006088, 0xb150f825, 0x0f00f1b8, 0xf8c8bf18, 0x2f006000, 0x2100bf1c, 0xe8bd6039, 0x1f2d8df0,
+    0x0404f104, 0x0604f106, 0xe8bdd1df, 0x00008df0, 0x000000a0, 0x40020000, 0xbf042800, 0x47702004,
+    0x48022240, 0x718171c2, 0xb802f000, 0x40020000, 0x2170480c, 0x21807001, 0x78017001, 0x0f80f011,
+    0x7800d0fb, 0x0f20f010, 0x2067bf1c, 0xf0104770, 0xbf1c0f10, 0x47702068, 0x0001f010, 0x2069bf18,
+    0x00004770, 0x40020000, 0x40020004, 0x00000000, 0x00080000, 0x00100000, 0x00200000, 0x00400000,
+    0x00800000, 0x01000000, 0x02000000, 0x00000000,
+                                ],
+    'pc_init' : 0x20000021,
+    'pc_unInit': 0x20000049,
+    'pc_program_page': 0x2000009F,
+    'pc_erase_sector': 0x20000071,
+    'pc_eraseAll' : 0x2000004D,
+    'static_base' : 0x20000000 + 0x00000020 + 0x0000046c,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
+    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
+    'min_program_length' : 8,
+  };
+
+class Flash_k28f15(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_k28f15, self).__init__(target, flash_algo)
+
+class K28F15(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x200000,     blocksize=0x1000, isBootMemory=True),
+        RamRegion(      start=0x1ffC0000,  length=0x80000),
+        RamRegion(      start=0x34000000,  length=0x80000),
+        RamRegion(      start=0x14000000,  length=0x1000)
+        )
+
+    def __init__(self, transport):
+        super(K28F15, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0000
+        self._svd_location = SVDFile(vendor="Freescale", filename="MK28F15.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_ke18f16.py` & `pyOCD-0.9.0/pyOCD/target/target_ncs36510.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,83 +1,97 @@
-"""
- Flash OS Routines (Automagically Generated)
- Copyright (c) 2009-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = {
-    'load_address' : 0x20000000,
-    'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0xb510482d, 0x6041492b, 0x71fff64f, 0x68016081, 0x0180f021, 0x0120f041, 0x48286001, 0xf0004448,
-    0x2800f851, 0x2001bf18, 0x2000bd10, 0x48234770, 0x4923b510, 0xf0004448, 0x2800f89d, 0xbd10bf18,
-    0x481e2100, 0x4010e8bd, 0xf0004448, 0xb570b962, 0x46054c1a, 0x4601444c, 0x46204b19, 0xf00068e2,
-    0x2800f8c2, 0xbd70bf18, 0x46292300, 0xe8bd68e2, 0x48124070, 0xf0004448, 0xb570b956, 0x460b460c,
-    0x46014606, 0xb084480d, 0x44484615, 0xf8f5f000, 0xbf1c2800, 0xbd70b004, 0x21012000, 0x1000e9cd,
-    0x48069002, 0x4622462b, 0x44484631, 0xf989f000, 0xbd70b004, 0xd928c520, 0x40052000, 0x00000004,
-    0x6b65666b, 0xbf042800, 0x47702004, 0x6cc949f0, 0x6103f3c1, 0xbf08290f, 0x2100f44f, 0x4aedbf1f,
-    0xf832447a, 0x02891011, 0x2200b410, 0x2100e9c0, 0x60812101, 0x03094be8, 0xf89360c1, 0x110cc000,
-    0xfc0cfa04, 0xc014f8c0, 0x618378db, 0xf04f6102, 0xe9c052a0, 0xbc102108, 0x47702000, 0xbf0e2800,
-    0x61012004, 0x47702000, 0x48dc4602, 0x49db6800, 0x0020f040, 0x46086008, 0xf0406800, 0x60080010,
-    0x48d74770, 0x70012170, 0x70012180, 0xf0117801, 0xd0fb0f80, 0xf0107800, 0xbf1c0f20, 0x47702067,
-    0x0f10f010, 0x2068bf1c, 0xf0104770, 0xbf180001, 0x47702069, 0xbf042800, 0x47702004, 0x4604b510,
-    0xf06f4ac7, 0x6050403b, 0x428148c6, 0x206bbf14, 0x28002000, 0xbd10bf18, 0xf7ff4620, 0x4603ffd2,
-    0xf7ff4620, 0x4618ffc1, 0x2800bd10, 0x2004bf04, 0x23004770, 0x60936053, 0x611360d3, 0x61936153,
-    0x601161d3, 0x605168c1, 0x1001e9d0, 0xf0f0fbb1, 0x20086090, 0xe9c22110, 0xe9c20103, 0x20041005,
-    0x200061d0, 0xe92d4770, 0xb0884df0, 0x46984615, 0x4682460c, 0xf7ff466a, 0x462affd8, 0x46504621,
-    0xf0009b04, 0x0007f92f, 0xb008bf1c, 0x8df0e8bd, 0x4600e9dd, 0x1e451960, 0xf0f6fbb5, 0x5110fb06,
-    0x1c40b111, 0x1e454370, 0xbf9842ac, 0xb270f8df, 0xf024d81c, 0xf040407f, 0xf8cb6010, 0x48990004,
-    0xbf144580, 0x2000206b, 0xbf1c2800, 0xe8bdb008, 0x46508df0, 0xff75f7ff, 0xf8da4607, 0x28000010,
-    0x4780bf18, 0x4434b917, 0xd9e242ac, 0xf7ff4650, 0xb008ff5b, 0xe8bd4638, 0x2a008df0, 0x2004bf04,
-    0xe92d4770, 0xb08945f0, 0x461e4614, 0x4680460d, 0xf7ff466a, 0x4632ff8a, 0x46404629, 0xf0009b03,
-    0x0007f8e1, 0xb009bf1c, 0x85f0e8bd, 0x2e009d00, 0xf8dfbf18, 0xd025a1ec, 0x0b04f854, 0x0008f8ca,
-    0x28049803, 0xf025bf04, 0xf040407f, 0xd00960c0, 0xd1092808, 0x0b04f854, 0x000cf8ca, 0x407ff025,
-    0x60e0f040, 0x0004f8ca, 0xf7ff4640, 0xf8d8ff2a, 0x46071010, 0xbf182900, 0xb91f4788, 0x44059803,
-    0xd1d91a36, 0xf7ff4640, 0xb009ff0f, 0xe8bd4638, 0x280085f0, 0x2004bf04, 0x4a634770, 0x4101ea42,
-    0x60514a5f, 0xe92de70d, 0xb0884dff, 0x469a4614, 0x466a460d, 0xf7ff9808, 0x4622ff38, 0x9b054629,
-    0xf0009808, 0x2800f88f, 0xb00cbf1c, 0x8df0e8bd, 0x4629466a, 0xf7ff9808, 0x9e00ff28, 0x8008f8dd,
-    0xf1c84270, 0x40080100, 0x42b74247, 0x4447bf08, 0xbf182c00, 0xb128f8df, 0x1bbdd01f, 0xbf8842a5,
-    0x98054625, 0x417ff026, 0xf0f0fbb5, 0x7180f041, 0x1004f8cb, 0xea400400, 0xf040200a, 0xf8cb00ff,
-    0x98080008, 0xfecdf7ff, 0xbf1c2800, 0xe8bdb00c, 0x1b648df0, 0x4447442e, 0xb00cd1df, 0xe8bd2000,
-    0x2b008df0, 0x2004bf04, 0xe92d4770, 0xb0884dff, 0xe9dd4616, 0x461d7a14, 0x466a460c, 0x8058f8dd,
-    0xf7ff9808, 0xe9ddfee2, 0x46323007, 0xf0004621, 0x2800f839, 0xb00cbf1c, 0x8df0e8bd, 0x2e009c00,
-    0xb00cbf04, 0x8df0e8bd, 0xb094f8df, 0x407ff06f, 0x6707ea40, 0x407ff024, 0x7000f040, 0x0004f8cb,
-    0x7008f8cb, 0xf8cb6828, 0x9808000c, 0xfe89f7ff, 0xf1bab168, 0xbf180f00, 0x4000f8ca, 0x0f00f1b8,
-    0x2100bf1c, 0x1000f8c8, 0xe8bdb00c, 0x99078df0, 0xf0211a76, 0x440d0103, 0x440c9907, 0xb00cd1da,
-    0x8df0e8bd, 0xbf042800, 0x47702004, 0x42191e5b, 0x421abf0e, 0x47702065, 0x428b6803, 0x6840d806,
-    0x44184411, 0xbf244288, 0x47702000, 0x47702066, 0x40048000, 0x000003d0, 0x40020028, 0x40001400,
-    0x40020000, 0x6b65666b, 0x4000ffff, 0x40020004, 0x40020010, 0x00100008, 0x00200018, 0x00400030,
-    0x00800060, 0x010000c0, 0x02000180, 0x04000300, 0x00000600, 0x00000000,
-    ],
-
-    'pc_init' : 0x20000021,
-    'pc_unInit': 0x2000004B,
-    'pc_program_page': 0x2000009B,
-    'pc_erase_sector': 0x2000006F,
-    'pc_eraseAll' : 0x2000004F,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x000004d4,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_size' : 0x00001000,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x1ffff000,  # Analyzer 0x1ffff000..0x1ffff600
-    'page_buffers' : [0x20003000, 0x20004000],   # Enable double buffering
-    'min_program_length' : 8,
-};
-
-class Flash_ke18f16(Flash_Kinetis):
-    def __init__(self, target):
-        super(Flash_ke18f16, self).__init__(target, flash_algo)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.coresight_target import CoreSightTarget
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+import logging
+
+flash_algo = {
+    'load_address' : 0x3fff4000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4770ba40, 0x4770bac0, 0x4770ba40, 0x4770bac0, 0xf2402a03, 0xf0108030, 0xf0000c03, 0xf8118015,
+    0xf1bc3b01, 0x44620f02, 0xf811bf98, 0xf800cb01, 0xbf383b01, 0x3b01f811, 0x0204f1a2, 0xf800bf98,
+    0xbf38cb01, 0x3b01f800, 0x0303f011, 0x8025f000, 0xf0c03a08, 0xf8518008, 0x3a083b04, 0xcb04f851,
+    0x1008e8a0, 0x1d12e7f5, 0xf851bf5c, 0xf8403b04, 0xf3af3b04, 0x07d28000, 0xf811bf24, 0xf8113b01,
+    0xbf48cb01, 0x2b01f811, 0xf800bf24, 0xf8003b01, 0xbf48cb01, 0x2b01f800, 0xb5104770, 0xf0c03a20,
+    0xe8b1800b, 0x3a205018, 0x5018e8a0, 0x5018e8b1, 0x5018e8a0, 0xaff5f4bf, 0x7c02ea5f, 0xe8b1bf24,
+    0xe8a05018, 0xbf445018, 0xc018c918, 0x4010e8bd, 0x7c82ea5f, 0xf851bf24, 0xf8403b04, 0xbf083b04,
+    0x07d24770, 0xf831bf28, 0xbf483b02, 0x2b01f811, 0xf820bf28, 0xbf483b02, 0x2b01f800, 0x20004770,
+    0x00004770, 0xb5104803, 0xf0004478, 0x2000f8b5, 0x0000bd10, 0x00000390, 0x9800b501, 0x5f00f5b0,
+    0x2001bf3c, 0xf410bd08, 0x466a1f80, 0x0102f04f, 0x4804bf1c, 0xbf044478, 0x44784803, 0xf80ef000,
+    0xbd082000, 0x00000370, 0x0000035e, 0x69c14770, 0x0f01f011, 0x69c0bf18, 0x00004770, 0x4c44b410,
+    0xc110f8df, 0xd27f2906, 0xf001e8df, 0x562a037e, 0x6801704a, 0x1f80f411, 0xf44fbf14, 0xf44f1181,
+    0x68425100, 0x684160d1, 0x6801610c, 0x1f80f411, 0xbf146841, 0xc018f8c1, 0xc014f8c1, 0x68422102,
+    0x68016091, 0xf4116840, 0xd0041f80, 0xf0116801, 0xd1fb0f02, 0x6801e058, 0x0f01f011, 0xe053d1fb,
+    0x68426811, 0x68026114, 0x1f80f412, 0xbf146842, 0xc018f8c2, 0xc014f8c2, 0x60d16842, 0x21016842,
+    0x68016091, 0xf4116840, 0xd0041f80, 0xf0116801, 0xd1fb0f02, 0x6801e038, 0x0f01f011, 0xe033d1fb,
+    0x68406801, 0x1f80f411, 0xbf146841, 0x0101f041, 0x0102f041, 0xe0276041, 0xf4116801, 0x68411f80,
+    0xbf14684a, 0x0201f022, 0x0202f022, 0x6801604a, 0xf4116840, 0xd0041f80, 0xf0116801, 0xd1fb0f02,
+    0x6801e012, 0x0f01f011, 0xe00dd1fb, 0x68406801, 0x1f80f411, 0x6801d004, 0x0f02f011, 0xe003d1fb,
+    0xf0116801, 0xd1fb0f01, 0x2001bc10, 0x00004770, 0xbb781ae9, 0xb56d9099, 0xf4116801, 0x68411f80,
+    0xf44fbf14, 0xf44f1281, 0x60ca5200, 0x49076842, 0x68016111, 0xf4116842, 0x49051f80, 0x6191bf14,
+    0x21026151, 0x60816840, 0x00004770, 0xbb781ae9, 0xb56d9099, 0x4a086843, 0x6802611a, 0xf4126843,
+    0x4a061f80, 0x619abf14, 0x6842615a, 0x684060d1, 0x60812101, 0x00004770, 0xbb781ae9, 0xb56d9099,
+    0x68406801, 0x1f80f411, 0xbf146841, 0x0101f041, 0x0102f041, 0x47706041, 0x68406801, 0x1f80f411,
+    0xbf146841, 0x0101f021, 0x0102f021, 0x47706041, 0x1e5b6808, 0xf810d305, 0xf802cb01, 0x1e5bcb01,
+    0x6008d2f9, 0x47702001, 0x68406801, 0x1f80f411, 0x6801d004, 0x0f02f011, 0x4770d1fb, 0xf0116801,
+    0xd1fb0f01, 0x00004770, 0x49056842, 0x68016111, 0xf4116840, 0x49031f80, 0x6181bf14, 0x47706141,
+    0xbb781ae9, 0xb56d9099, 0x4614b510, 0x68084602, 0x5f00f5b0, 0x010af3c0, 0xb131d20b, 0x0c0af3c0,
+    0x6100f5cc, 0xd905428b, 0xf5b3e00a, 0xd8076f00, 0xb139e00b, 0x0c0af3c0, 0x6100f5cc, 0xd904428b,
+    0xbd102000, 0x6f00f5b3, 0xf8d2d8fa, 0xf8dcc004, 0xf0411004, 0xf8cc0140, 0xf8d21004, 0x4908c004,
+    0x1010f8cc, 0x68526811, 0x1f80f411, 0xbf144905, 0x61516191, 0x4621461a, 0xfe1af7ff, 0xbd102001,
+    0xbb781ae9, 0xb56d9099, 0xb5104916, 0xf422690a, 0x610a0200, 0x22e0f04f, 0xf8c2211f, 0xf8c21180,
+    0x4a111280, 0x6120f04f, 0xf4106011, 0xf04f1f80, 0xf04f0200, 0xd0080103, 0x4478480c, 0xfe9ef7ff,
+    0x2200480b, 0x44782104, 0x480ae007, 0xf7ff4478, 0x4808fe95, 0x21042200, 0xf7ff4478, 0x2000fe8f,
+    0x0000bd10, 0x4001b000, 0xe000ed04, 0x0000008a, 0x00000072, 0x0000006c, 0x9800b507, 0x5f00f5b0,
+    0x460bd310, 0x1f80f410, 0xbf1c4669, 0x44784807, 0x4807bf04, 0xf7ff4478, 0x2801ff77, 0x2000bf02,
+    0xbd00b003, 0xb0032001, 0x0000bd00, 0x00000036, 0x00000024, 0x47702000, 0x47702000, 0x00000000,
+    0x40017000, 0x00000008, 0x00100000, 0x40017000, 0x00000008, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000,
+    ],
+
+    'pc_init' : 0x3FFF4409,
+    'pc_verify' : 0x3FFF44B9,
+    'pc_uninit' : 0x3FFF44B5,
+    'pc_eraseAll' : 0x3FFF4125,
+    'pc_program_page' : 0x3FFF4479,
+    'pc_erase_sector' : 0x3FFF4139,
+
+    'static_base' : 0x3fff4000 + 0x00000020 + 0x000004b4,
+    'begin_data' : 0x3fff4000 + 0x00000A00,
+    'begin_stack' : 0x3fff4800,
+    'page_size' : 0x00000800,
+    'min_program_length' : 0x00000800,
+    'analyzer_supported' : False,
+}
+
+
+class Flash_ncs36510(Flash):
+
+    def __init__(self, target):
+        super(Flash_ncs36510, self).__init__(target, flash_algo)
+
+class NCS36510(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0x2000,           length=0x50000,      blocksize=0x800, isBootMemory=True),
+        RamRegion(      start=0x3FFF4000,  length=0xC000)
+        )
+
+    def __init__(self, link):
+        super(NCS36510, self).__init__(link, self.memoryMap)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kinetis.py` & `pyOCD-0.9.0/pyOCD/target/family/flash_kinetis.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,99 +1,99 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash
-import logging
-
-# Kinetis security values and addresses
-SECURITY_START = 0x400
-SECURITY_SIZE = 16
-FPROT_ADDR = 0x408
-FPROT_ADDR_END = 0x40c
-FPROT_SIZE = 4
-FSEC_ADDR = 0x40c
-FSEC_VAL = 0xFE
-FOPT_ADDR = 0x40d
-FOPT_VAL = 0xFF
-FEPROT_ADDR = 0x40e
-FEPROT_VAL = 0xFF
-FDPROT_ADDR = 0x40f
-FDPROT_VAL = 0xFF
-
-# @brief Base flash algorithm class for Freescale Kinetis devices.
-class Flash_Kinetis(Flash):
-
-    # @brief Check security bytes.
-    #
-    # Override Flash Configuration Field bytes at address 0x400-0x40f to ensure that flash security
-    # won't be enabled. If flash security is enabled, then the chip is inaccessible via SWD.
-    #
-    # FCF bytes:
-    # [0x0-0x7]=backdoor key
-    # [0x8-0xb]=flash protection bytes
-    # [0xc]=FSEC:
-    #      [7:6]=KEYEN (2'b10 is backdoor key enabled, all others backdoor key disabled)
-    #      [5:4]=MEEN (2'b10 mass erase disabled, all other mass erase enabled)
-    #      [3:2]=FSLACC (2'b00 and 2'b11 factory access enabled, 2'b01 and 2'b10 factory access disabled)
-    #      [1:0]=SEC (2'b10 flash security disabled, all other flash security enabled)
-    # [0xd]=FOPT
-    # [0xe]=EEPROM protection bytes (FlexNVM devices only)
-    # [0xf]=data flash protection bytes (FlexNVM devices only)
-    #
-    # This function enforces that:
-    # - 0x8-0xb==0xff
-    # - 0xe-0xf==0xff
-    # - FSEC=0xfe
-    #
-    # FOPT can be set to any value except 0x00.
-    #
-    # @retval Data with modified security bits
-    def overrideSecurityBits(self, address, data):
-        # Check if the data passed in contains the security bits
-        if (address <= SECURITY_START and address + len(data) >= SECURITY_START + SECURITY_SIZE):
-
-            # convert data to a list so it can be modified
-            data = list(data)
-
-            # FPROT must be 0xff (erase protection disabled)
-            for i in range(FPROT_ADDR, FPROT_ADDR_END):
-                if (data[i - address] != 0xff):
-                    data[i - address] = 0xff
-                    logging.debug("FCF[%d] at addr 0x%X changed to 0x%X", i - FPROT_ADDR, i, data[i - address])
-
-            # FSEC must be 0xff
-            if data[FSEC_ADDR - address] != FSEC_VAL:
-                data[FSEC_ADDR - address] = FSEC_VAL
-                logging.debug("FSEC at addr 0x%X changed to 0x%X", FSEC_ADDR, FSEC_VAL)
-
-            # FOPT must not be 0x00, any other value is acceptable.
-            if data[FOPT_ADDR - address] == 0x00:
-                logging.debug("FOPT is restricted value 0x00")
-
-            # FEPROT must be 0xff
-            if data[FEPROT_ADDR - address] != FEPROT_VAL:
-                data[FEPROT_ADDR - address] = FEPROT_VAL
-                logging.debug("FEPROT at addr 0x%X changed to 0x%X", FEPROT_ADDR, FEPROT_VAL)
-
-            # FDPROT must be 0xff
-            if data[FDPROT_ADDR - address] != FDPROT_VAL:
-                data[FDPROT_ADDR - address] = FDPROT_VAL
-                logging.debug("FDPROT at addr 0x%X changed to 0x%X", FDPROT_ADDR, FDPROT_VAL)
-
-            # convert back to tuple
-            data = tuple(data)
-
-        return data
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ...flash.flash import Flash
+import logging
+
+# Kinetis security values and addresses
+SECURITY_START = 0x400
+SECURITY_SIZE = 16
+FPROT_ADDR = 0x408
+FPROT_ADDR_END = 0x40c
+FPROT_SIZE = 4
+FSEC_ADDR = 0x40c
+FSEC_VAL = 0xFE
+FOPT_ADDR = 0x40d
+FOPT_VAL = 0xFF
+FEPROT_ADDR = 0x40e
+FEPROT_VAL = 0xFF
+FDPROT_ADDR = 0x40f
+FDPROT_VAL = 0xFF
+
+# @brief Base flash algorithm class for Freescale Kinetis devices.
+class Flash_Kinetis(Flash):
+
+    # @brief Check security bytes.
+    #
+    # Override Flash Configuration Field bytes at address 0x400-0x40f to ensure that flash security
+    # won't be enabled. If flash security is enabled, then the chip is inaccessible via SWD.
+    #
+    # FCF bytes:
+    # [0x0-0x7]=backdoor key
+    # [0x8-0xb]=flash protection bytes
+    # [0xc]=FSEC:
+    #      [7:6]=KEYEN (2'b10 is backdoor key enabled, all others backdoor key disabled)
+    #      [5:4]=MEEN (2'b10 mass erase disabled, all other mass erase enabled)
+    #      [3:2]=FSLACC (2'b00 and 2'b11 factory access enabled, 2'b01 and 2'b10 factory access disabled)
+    #      [1:0]=SEC (2'b10 flash security disabled, all other flash security enabled)
+    # [0xd]=FOPT
+    # [0xe]=EEPROM protection bytes (FlexNVM devices only)
+    # [0xf]=data flash protection bytes (FlexNVM devices only)
+    #
+    # This function enforces that:
+    # - 0x8-0xb==0xff
+    # - 0xe-0xf==0xff
+    # - FSEC=0xfe
+    #
+    # FOPT can be set to any value except 0x00.
+    #
+    # @retval Data with modified security bits
+    def overrideSecurityBits(self, address, data):
+        # Check if the data passed in contains the security bits
+        if (address <= SECURITY_START and address + len(data) >= SECURITY_START + SECURITY_SIZE):
+
+            # convert data to a list so it can be modified
+            data = list(data)
+
+            # FPROT must be 0xff (erase protection disabled)
+            for i in range(FPROT_ADDR, FPROT_ADDR_END):
+                if (data[i - address] != 0xff):
+                    data[i - address] = 0xff
+                    logging.debug("FCF[%d] at addr 0x%X changed to 0x%X", i - FPROT_ADDR, i, data[i - address])
+
+            # FSEC must be 0xff
+            if data[FSEC_ADDR - address] != FSEC_VAL:
+                data[FSEC_ADDR - address] = FSEC_VAL
+                logging.debug("FSEC at addr 0x%X changed to 0x%X", FSEC_ADDR, FSEC_VAL)
+
+            # FOPT must not be 0x00, any other value is acceptable.
+            if data[FOPT_ADDR - address] == 0x00:
+                logging.debug("FOPT is restricted value 0x00")
+
+            # FEPROT must be 0xff
+            if data[FEPROT_ADDR - address] != FEPROT_VAL:
+                data[FEPROT_ADDR - address] = FEPROT_VAL
+                logging.debug("FEPROT at addr 0x%X changed to 0x%X", FEPROT_ADDR, FEPROT_VAL)
+
+            # FDPROT must be 0xff
+            if data[FDPROT_ADDR - address] != FDPROT_VAL:
+                data[FDPROT_ADDR - address] = FDPROT_VAL
+                logging.debug("FDPROT at addr 0x%X changed to 0x%X", FDPROT_ADDR, FDPROT_VAL)
+
+            # convert back to tuple
+            data = tuple(data)
+
+        return data
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kl27z4.py` & `pyOCD-0.9.0/pyOCD/target/target_MKW40Z160xxx4.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,93 +1,111 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
-    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
-    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
-    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
-    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
-    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
-    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
-    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
-    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
-    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
-    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
-    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
-    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
-    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
-    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
-    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8ecf000, 0xd1042800, 0x21004806, 0xf0004448,
-    0x4a05f9b1, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
-    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf894f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf956f000,
-    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
-    0x60082000, 0x44484804, 0xf8e8f000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
-    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807,
-    0x4622462b, 0x44484631, 0xf96af000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
-    0xf0003000, 0x47702000, 0xd0032800, 0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800,
-    0x47702004, 0x1e5bb410, 0x421c460c, 0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804,
-    0x18181889, 0xd2024288, 0x2066bc10, 0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770,
-    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
-    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
-    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76,
-    0x91004630, 0xfe3cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
-    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
-    0xbdf84638, 0x0000026a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
-    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
-    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
-    0x6800e006, 0x2000e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800,
-    0x68c9490c, 0x0e094a0c, 0x447a0049, 0x03095a51, 0x2200d00d, 0x60416002, 0x60812102, 0x61426102,
-    0x61820249, 0x461060c1, 0x20044770, 0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00,
-    0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00,
-    0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980,
-    0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800,
-    0x20006181, 0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800,
-    0x686868a9, 0xfd7cf7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a,
-    0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804,
-    0xfef2f7ff, 0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da,
-    0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000,
-    0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00,
-    0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800,
-    0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8,
-    0x00000062, 0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000,
-    0x00000000, 0x00100000, 0x40020004, 0x00000000,
-                                ],
-    'pc_init' : 0x2000027D,
-    'pc_unInit': 0x200002E5,
-    'pc_program_page': 0x2000029D,
-    'pc_erase_sector': 0x2000023D,
-    'pc_eraseAll' : 0x20000209,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x0000060c,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
-    'min_program_length' : 4,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x20002000
-  };
-
-# @brief Flash algorithm for Kinetis KL27Z4 device.
-class Flash_kl27z4(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_kl27z4, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
+    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
+    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
+    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
+    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
+    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
+    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
+    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
+    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
+    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
+    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
+    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
+    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8f2f000, 0xd1042800, 0x21004806, 0xf0004448,
+    0x4a05f9bf, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
+    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf89af000, 0xd1052800, 0x46292300, 0x68e24620, 0xf964f000,
+    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
+    0x60082000, 0x44484804, 0xf8eef000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
+    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f903, 0x9001d10a, 0x21019002, 0x91004807,
+    0x4622462b, 0x44484631, 0xf978f000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
+    0xf0003000, 0x47702000, 0xd0082800, 0xd802290f, 0xd1042a04, 0x2913e005, 0x2a08d801, 0x2004d001,
+    0x20004770, 0x28004770, 0x2004d101, 0xb4104770, 0x460c1e5b, 0xd101421c, 0xd002421a, 0x2065bc10,
+    0x68034770, 0xd804428b, 0x18896840, 0x42881818, 0xbc10d202, 0x47702066, 0x2000bc10, 0x00004770,
+    0x42884903, 0x206bd001, 0x20004770, 0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001,
+    0xd5fc0609, 0x06817800, 0x2067d501, 0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770,
+    0x40020000, 0x4605b5f8, 0x460c4616, 0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628,
+    0x0007ffb2, 0x19a6d123, 0x68e91e76, 0x91004630, 0xfe36f7ff, 0xd0032900, 0x1c409e00, 0x1e764346,
+    0xd81342b4, 0x4478480a, 0x60046800, 0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000,
+    0xd1032f00, 0x190468e8, 0xd9eb42b4, 0xbdf84638, 0x0000027a, 0x40020000, 0x4604b510, 0xf7ff4608,
+    0x2800ff9f, 0x2c00d106, 0x4904d005, 0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000,
+    0xd00c2800, 0xd00a2a00, 0xd21a2908, 0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f,
+    0x68c04770, 0x6840e00a, 0x6880e008, 0x6800e006, 0x2001e004, 0x6900e002, 0x6940e000, 0x20006010,
+    0x206a4770, 0x00004770, 0xd00a2800, 0x68c9490f, 0x0e094a0f, 0x447a0049, 0x03095a51, 0x2064d103,
+    0x20044770, 0xb4104770, 0x60032300, 0x21026041, 0x02496081, 0x490760c1, 0x158a7a0c, 0x610240a2,
+    0x61837ac9, 0xbc106141, 0x47704618, 0x40048040, 0x000001aa, 0x40020020, 0xd1012a00, 0x47702004,
+    0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff19f7ff, 0xd1190007, 0xd0162c00, 0x4478480c,
+    0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff30f7ff, 0x98014607, 0x28006980, 0x4780d000,
+    0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800, 0x20006181,
+    0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfee7f7ff, 0xd12a2800, 0x686868a9,
+    0xfd6ef7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a, 0xd90042a5,
+    0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804, 0xfeeaf7ff,
+    0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da, 0x40020000,
+    0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fecf, 0x40020000, 0xd1012b00,
+    0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfe99f7ff, 0xd1192800, 0xd0172d00, 0x447a4a0f,
+    0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeaef7ff, 0xd0082800, 0x29009907,
+    0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8, 0x00000062,
+    0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000, 0x00000000,
+    0x00200000, 0x40020004, 0x00000000,
+    ],
+
+    'pc_init' : 0x2000027D,
+    'pc_unInit': 0x200002E5,
+    'pc_program_page': 0x2000029D,
+    'pc_erase_sector': 0x2000023D,
+    'pc_eraseAll' : 0x20000209,
+
+    'static_base' : 0x20000000 + 0x00000020 + 0x00000628,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
+    'min_program_length' : 4,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff800
+  };
+
+# @brief Flash algorithm for Kinetis KW40Z4 device.
+class Flash_kw40z4(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kw40z4, self).__init__(target, flash_algo)
+
+class KW40Z4(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x28000,      blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1ffff000,  length=0x5000)
+        )
+
+    def __init__(self, transport):
+        super(KW40Z4, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKW40Z4.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kl28z.py` & `pyOCD-0.9.0/pyOCD/target/target_MKW01Z128xxx4.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,133 +1,110 @@
-"""
- Flash OS Routines (Automagically Generated...but manually tweaked. See below)
- Copyright (c) 2009-2015 ARM Limited
- 
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- 
-     http://www.apache.org/licenses/LICENSE-2.0
- 
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-""" 
-
-from flash_kinetis import Flash_Kinetis
-import logging
-
-flash_algo = { 
-    'load_address' : 0x20000000,
-    'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4832b510, 0x60414930, 0x60814931, 0x22806801, 0x22204391, 0x60014311, 0x4448482e, 0xf860f000, 
-    0xd0002800, 0xbd102001, 0x47702000, 0xb5104829, 0x44484929, 0xf922f000, 0xd1042800, 0x21004825, 
-    0xf0004448, 0x4a25f9c3, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x4c1fb570, 0x444c4605, 0x4b1e4601, 
-    0x68e24620, 0xf89ef000, 0xd1052800, 0x46292300, 0x68e24620, 0xf916f000, 0x68ca4918, 0x029b2301, 
-    0x60ca431a, 0xb570bd70, 0x460b460c, 0x46014606, 0xb0844810, 0x44484615, 0xf8bef000, 0xd10a2800, 
-    0x90029001, 0x480b2101, 0x462b9100, 0x46314622, 0xf0004448, 0x4909f957, 0x230168ca, 0x431a029b, 
-    0xb00460ca, 0x0000bd70, 0xd928c520, 0x40076000, 0x0000ffff, 0x00000004, 0x6b65666b, 0xf0003000, 
-    0xd00a2800, 0x68c9492b, 0x0e094a2b, 0x447a0049, 0x03095a51, 0x2064d103, 0x20044770, 0xb4104770, 
-    0x60032300, 0x21026041, 0x02896081, 0x492360c1, 0x158a7a0c, 0x610240a2, 0x61837ac9, 0xbc106141, 
-    0x47704618, 0xd0022800, 0x20006181, 0x20044770, 0x28004770, 0x2004d101, 0xb4104770, 0x42191e5b, 
-    0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804, 0x18181889, 0xd2024288, 0x2066bc10, 
-    0xbc104770, 0x47702000, 0x4288490d, 0x206bd001, 0x20004770, 0x28004770, 0x290fd008, 0x2a04d802, 
-    0xe005d104, 0xd8012913, 0xd0012a08, 0x47702004, 0x47702000, 0x40075040, 0x00000512, 0x40020020, 
-    0x6b65666b, 0x4605b5f8, 0x460c4616, 0xf7ff4618, 0x2800ffdb, 0x2308d12b, 0x46214632, 0xf7ff4628, 
-    0x0007ffb8, 0x19a6d123, 0x1e7668e9, 0x91004630, 0xf922f000, 0xd0032900, 0x1c409e00, 0x1e764346, 
-    0xd81342b4, 0x4478480a, 0x60046800, 0x20094909, 0xf00071c8, 0x4607f8f9, 0x280069a8, 0x4780d000, 
-    0xd1032f00, 0x190468e8, 0xd9eb42b4, 0xbdf84638, 0x00000416, 0x40020000, 0xd1012a00, 0x47702004, 
-    0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff7ff7ff, 0xd11a0007, 0xd0172c00, 0x4478480d, 
-    0x600e6801, 0x6800cd02, 0x490b6041, 0x71c82006, 0xf8caf000, 0x98014607, 0x28006980, 0x4780d000, 
-    0xd1032f00, 0x1d361f24, 0xd1e72c00, 0xb0054638, 0x0000bdf0, 0x000003be, 0x40020000, 0x4604b510, 
-    0xf7ff4608, 0x2800ff71, 0x2c00d106, 0x4904d005, 0x71c82044, 0xf8a8f000, 0x2004bd10, 0x0000bd10, 
-    0x40020000, 0xb081b5ff, 0x460e4614, 0x23084605, 0xff3ff7ff, 0xd12a2800, 0x686868a9, 0xf8acf000, 
-    0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a, 0xd90042a5, 0x490d4625, 
-    0x447908e8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804, 0xf876f000, 0xd1062800, 
-    0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x0000031a, 0x40020000, 0xd00c2800, 
-    0xd00a2a00, 0xd21a2908, 0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 
-    0x6840e00a, 0x6880e008, 0x6800e006, 0x2001e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 
-    0x00004770, 0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfedbf7ff, 0xd1192800, 
-    0xd0172d00, 0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xf824f000, 
-    0xd0082800, 0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1d24bdf8, 0x1d361f2d, 0xd1e12d00, 
-    0x0000bdf8, 0x00000276, 0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf0007181, 
-    0xbd10f803, 0x40020000, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501, 
-    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x09032200, 0xd373428b, 
-    0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603, 0x2200d47f, 0x428b0843, 
-    0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03, 0x22ffd30d, 0xba120209, 
-    0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09, 0xd301428b, 0x1ac003cb, 
-    0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b, 0x0b034152, 0xd301428b, 
-    0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b, 0x1ac0028b, 0x0a434152, 
-    0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152, 0x428b09c3, 0x01cbd301, 
-    0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301, 0x41521ac0, 0x428b0903, 
-    0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883, 0x008bd301, 0x41521ac0, 
-    0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610, 0x0fcae05d, 0x4249d000, 
-    0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b, 0x018922fc, 0x0a03ba12, 
-    0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189, 0xe0001192, 0x09c30989, 
-    0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152, 0xd301428b, 0x1ac0014b, 
-    0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb, 0x08834152, 0xd301428b, 
-    0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x46634601, 0x105b4152, 
-    0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240, 0x46c02000, 0xbd0246c0, 
-    0x40020004, 0x00000000, 0x00000000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x00000000, 
-    0x00800000, 0x00000000, 
-    ],
-    
-    'pc_init' : 0x20000021,
-    'pc_unInit': 0x20000049,
-    'pc_program_page': 0x200000A7,
-    'pc_erase_sector': 0x20000075,
-    'pc_eraseAll' : 0x2000004D,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x00000624,
-    'begin_stack' : 0x20000000 + 0x00000800,            
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_size' : 0x00000200,
-
-    # All keys above are auto-generated. The following are added or modified.
-    'analyzer_supported' : True,                 # [modified] default is False
-    'analyzer_address' : 0x1fffa000,             # [modified] default is zero. Use 8K block before flash algo. Can be any unused SRAM.
-    'page_buffers' : [0x20000a00, 0x20001200],   # [added] Use areas above algo. Note 'begin_data' is unused if double buffering. Can be any unused SRAM.
-    'min_program_length' : 4                     # [added] See FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE in KSDK features header file
-};
-
-
-SCG_CSR = 0x4007B010
-
-SCG_RCCR = 0x4007B014
-SCS_MASK = 0x0F000000
-SCS_SHIFT = 24
-DIVCORE_MASK = 0x000F0000
-DIVCORE_SHIFT = 16
-DIVSLOW_MASK = 0x0000000F
-DIVSLOW_SHIFT = 0
-
-SCG_FIRCCSR = 0x4007B300
-FIRCEN_MASK = 1
-
-SCG_FIRCCFG = 0x4007B308
-
-class Flash_kl28z(Flash_Kinetis): 
-    def __init__(self, target):
-        super(Flash_kl28z, self).__init__(target, flash_algo)
-
-    ##
-    # This function sets up target clocks to ensure that flash is clocked at the maximum
-    # of 24MHz. Doing so gets the best flash programming performance. The FIRC clock source
-    # is used so that there is no dependency on an external crystal frequency.
-    def init(self):
-        super(Flash_kl28z, self).init()
-
-        # Enable FIRC.
-        value = self.target.read32(SCG_FIRCCSR)
-        value |= FIRCEN_MASK
-        self.target.write32(SCG_FIRCCSR, value)
-
-        # Switch system to FIRC, core=48MHz (/1), slow=24MHz (/2).
-        # Flash and the bus are clocked from the slow clock, and its max is 24MHz,
-        # so there is no benefit from raising the core clock further.
-        self.target.write32(SCG_RCCR, (0x3 << SCS_SHIFT) | (1 << DIVSLOW_SHIFT))
-
-        csr = self.target.read32(SCG_CSR)
-        logging.debug("SCG_CSR = 0x%08x", csr)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
+    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
+    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
+    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
+    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
+    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
+    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
+    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
+    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
+    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
+    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
+    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
+    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8ecf000, 0xd1042800, 0x21004806, 0xf0004448,
+    0x4a05f9b1, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
+    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf894f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf956f000,
+    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
+    0x60082000, 0x44484804, 0xf8e8f000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
+    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807,
+    0x4622462b, 0x44484631, 0xf96af000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
+    0xf0003000, 0x47702000, 0xd0032800, 0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800,
+    0x47702004, 0x1e5bb410, 0x421c460c, 0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804,
+    0x18181889, 0xd2024288, 0x2066bc10, 0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770,
+    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
+    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
+    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76,
+    0x91004630, 0xfe3cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
+    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
+    0xbdf84638, 0x0000026a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
+    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
+    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
+    0x6800e006, 0x2000e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800,
+    0x68c9490c, 0x0e094a0c, 0x447a0049, 0x03095a51, 0x2200d00d, 0x60416002, 0x60812102, 0x61426102,
+    0x61820249, 0x461060c1, 0x20044770, 0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00,
+    0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00,
+    0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980,
+    0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800,
+    0x20006181, 0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800,
+    0x686868a9, 0xfd7cf7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a,
+    0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804,
+    0xfef2f7ff, 0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da,
+    0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000,
+    0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00,
+    0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800,
+    0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8,
+    0x00000062, 0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000,
+    0x00000000, 0x00200000, 0x40020004, 0x00000000,
+    ],
+
+    'pc_init' : 0x2000027D,
+    'pc_unInit': 0x200002E5,
+    'pc_program_page': 0x2000029D,
+    'pc_erase_sector': 0x2000023D,
+    'pc_eraseAll' : 0x20000209,
+
+    'static_base' : 0x20000000 + 0x00000020 + 0x0000060c,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
+    'min_program_length' : 4,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff800
+  };
+
+# @brief Flash algorithm for Kinetis KW01Z4 device.
+class Flash_kw01z4(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kw01z4, self).__init__(target, flash_algo)
+
+class KW01Z4(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x20000,      blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1ffff000,  length=0x4000)
+        )
+
+    def __init__(self, transport):
+        super(KW01Z4, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKW01Z4.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kl43z4.py` & `pyOCD-0.9.0/pyOCD/target/target_MKL26Z256xxx4.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,94 +1,107 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
-    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
-    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
-    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
-    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
-    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
-    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
-    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
-    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
-    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
-    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
-    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
-    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
-    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
-    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
-    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8ecf000, 0xd1042800, 0x21004806, 0xf0004448,
-    0x4a05f9b1, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
-    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf894f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf956f000,
-    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
-    0x60082000, 0x44484804, 0xf8e8f000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
-    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807,
-    0x4622462b, 0x44484631, 0xf96af000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
-    0xf0003000, 0x47702000, 0xd0032800, 0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800,
-    0x47702004, 0x1e5bb410, 0x421c460c, 0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804,
-    0x18181889, 0xd2024288, 0x2066bc10, 0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770,
-    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
-    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
-    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76,
-    0x91004630, 0xfe3cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
-    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
-    0xbdf84638, 0x0000026a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
-    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
-    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
-    0x6800e006, 0x2000e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800,
-    0x68c9490c, 0x0e094a0c, 0x447a0049, 0x03095a51, 0x2200d00d, 0x60416002, 0x60812102, 0x61426102,
-    0x61820249, 0x461060c1, 0x20044770, 0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00,
-    0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00,
-    0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980,
-    0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800,
-    0x20006181, 0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800,
-    0x686868a9, 0xfd7cf7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a,
-    0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804,
-    0xfef2f7ff, 0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da,
-    0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000,
-    0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00,
-    0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800,
-    0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8,
-    0x00000062, 0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000,
-    0x00000000, 0x00400000, 0x40020004, 0x00000000,
-    ],
-
-    'pc_init' : 0x2000027D,
-    'pc_unInit': 0x200002E5,
-    'pc_program_page': 0x2000029D,
-    'pc_erase_sector': 0x2000023D,
-    'pc_eraseAll' : 0x20000209,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x0000060c,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
-    'min_program_length' : 4,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x20002000
-  };
-
-# @brief Flash algorithm for Kinetis KL43Z4 device.
-class Flash_kl43z4(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_kl43z4, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4604b570, 0x4616460d, 0x49302000, 0x48306008, 0xf0004448, 0x2800f8e9, 0x2001d001, 0x2000bd70,
+    0x4601e7fc, 0x47702000, 0x492ab510, 0x44484828, 0xf8c2f000, 0x2c004604, 0x2100d105, 0x44484824,
+    0xf9bef000, 0xf0004604, 0x4620f838, 0xb570bd10, 0x481f4604, 0x4b1f4448, 0x68c24621, 0xf862f000,
+    0x2d004605, 0x481ad107, 0x23004448, 0x68c24621, 0xf956f000, 0xf0004605, 0x4628f820, 0xb5febd70,
+    0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf90af000, 0x2f004607, 0x2201d10b, 0x46339001,
+    0x90029200, 0x46294622, 0x44484809, 0xf99af000, 0xf0004607, 0x4638f802, 0x4807bdfe, 0x210168c0,
+    0x43880289, 0x49041840, 0x477060c8, 0x40048100, 0x00000004, 0x6b65666b, 0xf0003000, 0x4a102070,
+    0x20807010, 0xbf007010, 0x7800480d, 0x280009c0, 0x480bd0fa, 0x20207801, 0x28004008, 0x2067d001,
+    0x20104770, 0x28004008, 0x2068d001, 0x07c8e7f8, 0x28000fc0, 0x2069d001, 0x2000e7f2, 0x0000e7f0,
+    0x40020000, 0xb081b5ff, 0x460d4604, 0xf0009804, 0x4606f89f, 0xd0022e00, 0xb0054630, 0x2304bdf0,
+    0x46204629, 0xf0009a03, 0x4606f876, 0xd0012e00, 0xe7f24630, 0x18289803, 0x46381e47, 0xf00068e1,
+    0x2900f983, 0x4638d009, 0xf00068e1, 0x1c40f97d, 0x68e19000, 0x43489800, 0xe0131e47, 0x4478480c,
+    0x60056800, 0x490b2009, 0xf7ff71c8, 0x4606ffa7, 0x280069a0, 0x69a0d001, 0x2e004780, 0xe003d000,
+    0x194568e0, 0xd9e942bd, 0x4630bf00, 0x0000e7c5, 0x00000462, 0x40020000, 0x4604b570, 0x4628460d,
+    0xf856f000, 0x2e004606, 0x4630d001, 0x2c00bd70, 0x2004d101, 0x2044e7fa, 0x71c84902, 0xff7ef7ff,
+    0x0000e7f4, 0x40020000, 0x29004601, 0x2004d101, 0x482a4770, 0x010068c0, 0x00400f00, 0x447b4b28,
+    0x03025a18, 0xd1012a00, 0xe7f12064, 0x60082000, 0x2001604a, 0x02806088, 0x200060c8, 0x61486108,
+    0xbf006188, 0x4602e7e4, 0xd1012a00, 0x47702004, 0x20006191, 0xb530e7fb, 0x2c004604, 0x2004d101,
+    0x1e58bd30, 0x28004008, 0x1e58d103, 0x28004010, 0x2065d001, 0x6820e7f4, 0xd8054288, 0x68206865,
+    0x188d1940, 0xd20142a8, 0xe7e92066, 0xe7e72000, 0x480c4601, 0xd0014281, 0x4770206b, 0xe7fc2000,
+    0x2b004603, 0x2004d101, 0x290f4770, 0x2a04d801, 0x2004d001, 0x2000e7f8, 0x0000e7f6, 0x40048040,
+    0x000003c0, 0x6b65666b, 0xb081b5ff, 0x46144607, 0x2c00461d, 0x2004d102, 0xbdf0b005, 0x462a2304,
+    0x99024638, 0xffb7f7ff, 0x2e004606, 0x4630d001, 0xe01ce7f2, 0x44794910, 0x68099802, 0xcc016008,
+    0x4479490d, 0x6809390c, 0x20066048, 0x71c8490b, 0xfef4f7ff, 0x69b84606, 0xd0012800, 0x478069b8,
+    0xd0002e00, 0x9802e005, 0x90021d00, 0x2d001f2d, 0xbf00d1e0, 0xe7cf4630, 0x0000030a, 0x40020000,
+    0xb083b5ff, 0x2304460c, 0x9a054621, 0xf7ff9803, 0x9002ff82, 0x28009802, 0x9802d002, 0xbdf0b007,
+    0x68919a03, 0xf0006850, 0x4605f88f, 0x42684261, 0x424e4001, 0xd10042a6, 0x9f051976, 0x1b30e027,
+    0x98019001, 0xd90042b8, 0x98019701, 0x90000880, 0x44784811, 0x60046800, 0x49102001, 0x980071c8,
+    0x0e010400, 0x72c1480d, 0x9800490c, 0x98067288, 0xf7ff7248, 0x9002fea3, 0x28009802, 0x9802d001,
+    0x9801e7cc, 0x98011a3f, 0x19761824, 0x2f00bf00, 0x2000d1d5, 0x0000e7c2, 0x0000026e, 0x40020000,
+    0x4604b570, 0x2c00460d, 0x2004d101, 0x2040bd70, 0x71c84903, 0x71854608, 0xfe80f7ff, 0x0000e7f6,
+    0x40020000, 0xb081b5ff, 0x4617460c, 0x2d00461d, 0x2004d102, 0xbdf0b005, 0x463a2304, 0x98014621,
+    0xff19f7ff, 0x2e004606, 0x4630d001, 0xe022e7f2, 0x44784813, 0x60046800, 0x49122002, 0x980a71c8,
+    0x490f72c8, 0x39124479, 0x68096828, 0xf7ff6088, 0x4606fe55, 0xd00b2e00, 0x2800980b, 0x980bd001,
+    0x980c6004, 0xd0022800, 0x980c2100, 0xe0046001, 0x1d2d1f3f, 0x2f001d24, 0xbf00d1da, 0xe7c94630,
+    0x000001ce, 0x40020000, 0x09032200, 0xd32c428b, 0x428b0a03, 0x2300d311, 0xe04e469c, 0x430b4603,
+    0x2200d43c, 0x428b0843, 0x0903d331, 0xd31c428b, 0x428b0a03, 0x4694d301, 0x09c3e03f, 0xd301428b,
+    0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152, 0xd301428b, 0x1ac0014b, 0x09034152,
+    0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb, 0x08834152, 0xd301428b, 0x1ac0008b,
+    0x08434152, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x46104152, 0xe05d4770, 0xd0000fca,
+    0x10034249, 0x4240d300, 0x22004053, 0x0903469c, 0xd32d428b, 0x428b0a03, 0x22fcd312, 0xba120189,
+    0x428b0a03, 0x0189d30c, 0x428b1192, 0x0189d308, 0x428b1192, 0x0189d304, 0x1192d03a, 0x0989e000,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x0843d2d9, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x41524663,
+    0x4610105b, 0x4240d301, 0xd5002b00, 0x47704249, 0x105b4663, 0x4240d300, 0x2000b501, 0x46c046c0,
+    0x0002bd02, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000000, 0x00000000,
+    0x00000020, 0x40020004, 0x00000000,
+                                ],
+               'pc_init' : 0x20000021,
+               'pc_eraseAll' : 0x20000049,
+               'pc_erase_sector' : 0x2000006F,
+               'pc_program_page' : 0x2000009F,
+               'begin_stack' : 0x20000800,
+               'begin_data' : 0x20000800,       # Analyzer uses a max of 1 KB data (256 pages * 4 bytes / page)
+                                                # Note: 128 pages on KL25 and KL26, 256 pages on KL46
+               'static_base' : 0x20000000 + 0x20 + 0x5E8,
+               'min_program_length' : 4,
+               'page_buffers' : [0x20000800, 0x20000c00], # Enable double buffering
+               'analyzer_supported' : True,
+               'analyzer_address' : 0x1ffff000  # Analyzer 0x1ffff000..0x1ffff600
+              };
+
+# @brief Flash algorithm for Kinetis L-series devices.
+class Flash_kl26z(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kl26z, self).__init__(target, flash_algo)
+
+class KL26Z(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x20000,      blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1ffff000,  length=0x4000)
+        )
+
+    def __init__(self, link):
+        super(KL26Z, self).__init__(link, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKL26Z4.svd", is_local=False)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_klxx.py` & `pyOCD-0.9.0/pyOCD/target/target_MKL02Z32xxx4.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,98 +1,105 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-from pyOCD.target.target_kl25z import KL25Z
-from pyOCD.target.target_kl26z import KL26Z
-from pyOCD.target.target_kl46z import KL46Z
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x4604b570, 0x4616460d, 0x49302000, 0x48306008, 0xf0004448, 0x2800f8e9, 0x2001d001, 0x2000bd70,
-    0x4601e7fc, 0x47702000, 0x492ab510, 0x44484828, 0xf8c2f000, 0x2c004604, 0x2100d105, 0x44484824,
-    0xf9bef000, 0xf0004604, 0x4620f838, 0xb570bd10, 0x481f4604, 0x4b1f4448, 0x68c24621, 0xf862f000,
-    0x2d004605, 0x481ad107, 0x23004448, 0x68c24621, 0xf956f000, 0xf0004605, 0x4628f820, 0xb5febd70,
-    0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf90af000, 0x2f004607, 0x2201d10b, 0x46339001,
-    0x90029200, 0x46294622, 0x44484809, 0xf99af000, 0xf0004607, 0x4638f802, 0x4807bdfe, 0x210168c0,
-    0x43880289, 0x49041840, 0x477060c8, 0x40048100, 0x00000004, 0x6b65666b, 0xf0003000, 0x4a102070,
-    0x20807010, 0xbf007010, 0x7800480d, 0x280009c0, 0x480bd0fa, 0x20207801, 0x28004008, 0x2067d001,
-    0x20104770, 0x28004008, 0x2068d001, 0x07c8e7f8, 0x28000fc0, 0x2069d001, 0x2000e7f2, 0x0000e7f0,
-    0x40020000, 0xb081b5ff, 0x460d4604, 0xf0009804, 0x4606f89f, 0xd0022e00, 0xb0054630, 0x2304bdf0,
-    0x46204629, 0xf0009a03, 0x4606f876, 0xd0012e00, 0xe7f24630, 0x18289803, 0x46381e47, 0xf00068e1,
-    0x2900f983, 0x4638d009, 0xf00068e1, 0x1c40f97d, 0x68e19000, 0x43489800, 0xe0131e47, 0x4478480c,
-    0x60056800, 0x490b2009, 0xf7ff71c8, 0x4606ffa7, 0x280069a0, 0x69a0d001, 0x2e004780, 0xe003d000,
-    0x194568e0, 0xd9e942bd, 0x4630bf00, 0x0000e7c5, 0x00000462, 0x40020000, 0x4604b570, 0x4628460d,
-    0xf856f000, 0x2e004606, 0x4630d001, 0x2c00bd70, 0x2004d101, 0x2044e7fa, 0x71c84902, 0xff7ef7ff,
-    0x0000e7f4, 0x40020000, 0x29004601, 0x2004d101, 0x482a4770, 0x010068c0, 0x00400f00, 0x447b4b28,
-    0x03025a18, 0xd1012a00, 0xe7f12064, 0x60082000, 0x2001604a, 0x02806088, 0x200060c8, 0x61486108,
-    0xbf006188, 0x4602e7e4, 0xd1012a00, 0x47702004, 0x20006191, 0xb530e7fb, 0x2c004604, 0x2004d101,
-    0x1e58bd30, 0x28004008, 0x1e58d103, 0x28004010, 0x2065d001, 0x6820e7f4, 0xd8054288, 0x68206865,
-    0x188d1940, 0xd20142a8, 0xe7e92066, 0xe7e72000, 0x480c4601, 0xd0014281, 0x4770206b, 0xe7fc2000,
-    0x2b004603, 0x2004d101, 0x290f4770, 0x2a04d801, 0x2004d001, 0x2000e7f8, 0x0000e7f6, 0x40048040,
-    0x000003c0, 0x6b65666b, 0xb081b5ff, 0x46144607, 0x2c00461d, 0x2004d102, 0xbdf0b005, 0x462a2304,
-    0x99024638, 0xffb7f7ff, 0x2e004606, 0x4630d001, 0xe01ce7f2, 0x44794910, 0x68099802, 0xcc016008,
-    0x4479490d, 0x6809390c, 0x20066048, 0x71c8490b, 0xfef4f7ff, 0x69b84606, 0xd0012800, 0x478069b8,
-    0xd0002e00, 0x9802e005, 0x90021d00, 0x2d001f2d, 0xbf00d1e0, 0xe7cf4630, 0x0000030a, 0x40020000,
-    0xb083b5ff, 0x2304460c, 0x9a054621, 0xf7ff9803, 0x9002ff82, 0x28009802, 0x9802d002, 0xbdf0b007,
-    0x68919a03, 0xf0006850, 0x4605f88f, 0x42684261, 0x424e4001, 0xd10042a6, 0x9f051976, 0x1b30e027,
-    0x98019001, 0xd90042b8, 0x98019701, 0x90000880, 0x44784811, 0x60046800, 0x49102001, 0x980071c8,
-    0x0e010400, 0x72c1480d, 0x9800490c, 0x98067288, 0xf7ff7248, 0x9002fea3, 0x28009802, 0x9802d001,
-    0x9801e7cc, 0x98011a3f, 0x19761824, 0x2f00bf00, 0x2000d1d5, 0x0000e7c2, 0x0000026e, 0x40020000,
-    0x4604b570, 0x2c00460d, 0x2004d101, 0x2040bd70, 0x71c84903, 0x71854608, 0xfe80f7ff, 0x0000e7f6,
-    0x40020000, 0xb081b5ff, 0x4617460c, 0x2d00461d, 0x2004d102, 0xbdf0b005, 0x463a2304, 0x98014621,
-    0xff19f7ff, 0x2e004606, 0x4630d001, 0xe022e7f2, 0x44784813, 0x60046800, 0x49122002, 0x980a71c8,
-    0x490f72c8, 0x39124479, 0x68096828, 0xf7ff6088, 0x4606fe55, 0xd00b2e00, 0x2800980b, 0x980bd001,
-    0x980c6004, 0xd0022800, 0x980c2100, 0xe0046001, 0x1d2d1f3f, 0x2f001d24, 0xbf00d1da, 0xe7c94630,
-    0x000001ce, 0x40020000, 0x09032200, 0xd32c428b, 0x428b0a03, 0x2300d311, 0xe04e469c, 0x430b4603,
-    0x2200d43c, 0x428b0843, 0x0903d331, 0xd31c428b, 0x428b0a03, 0x4694d301, 0x09c3e03f, 0xd301428b,
-    0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152, 0xd301428b, 0x1ac0014b, 0x09034152,
-    0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb, 0x08834152, 0xd301428b, 0x1ac0008b,
-    0x08434152, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x46104152, 0xe05d4770, 0xd0000fca,
-    0x10034249, 0x4240d300, 0x22004053, 0x0903469c, 0xd32d428b, 0x428b0a03, 0x22fcd312, 0xba120189,
-    0x428b0a03, 0x0189d30c, 0x428b1192, 0x0189d308, 0x428b1192, 0x0189d304, 0x1192d03a, 0x0989e000,
-    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
-    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
-    0x008bd301, 0x41521ac0, 0x0843d2d9, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x41524663,
-    0x4610105b, 0x4240d301, 0xd5002b00, 0x47704249, 0x105b4663, 0x4240d300, 0x2000b501, 0x46c046c0,
-    0x0002bd02, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000000, 0x00000000,
-    0x00000020, 0x40020004, 0x00000000,
-                                ],
-               'pc_init' : 0x20000021,
-               'pc_eraseAll' : 0x20000049,
-               'pc_erase_sector' : 0x2000006F,
-               'pc_program_page' : 0x2000009F,
-               'begin_stack' : 0x20000800,
-               'begin_data' : 0x20000800,       # Analyzer uses a max of 1 KB data (256 pages * 4 bytes / page)
-                                                # Note: 128 pages on KL25 and KL26, 256 pages on KL46
-               'static_base' : 0x20000000 + 0x20 + 0x5E8,
-               'min_program_length' : 4,
-               'analyzer_supported' : False     # Not enough space on KL02 and KL05
-              };
-
-# @brief Flash algorithm for Kinetis L-series devices.
-class Flash_klxx(Flash_Kinetis):
-
-    def __init__(self, target):
-        algo = flash_algo
-        if isinstance(target, KL25Z) or isinstance(target, KL26Z) or isinstance(target, KL46Z):
-            algo = dict(algo)
-            algo['page_buffers'] = [0x20000800, 0x20000c00] # Enable double buffering
-            algo['analyzer_supported'] = True
-            algo['analyzer_address'] = 0x1ffff000  # Analyzer 0x1ffff000..0x1ffff600
-        super(Flash_klxx, self).__init__(target, algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4604b570, 0x4616460d, 0x49302000, 0x48306008, 0xf0004448, 0x2800f8e9, 0x2001d001, 0x2000bd70,
+    0x4601e7fc, 0x47702000, 0x492ab510, 0x44484828, 0xf8c2f000, 0x2c004604, 0x2100d105, 0x44484824,
+    0xf9bef000, 0xf0004604, 0x4620f838, 0xb570bd10, 0x481f4604, 0x4b1f4448, 0x68c24621, 0xf862f000,
+    0x2d004605, 0x481ad107, 0x23004448, 0x68c24621, 0xf956f000, 0xf0004605, 0x4628f820, 0xb5febd70,
+    0x460c4605, 0x46234616, 0x46294632, 0x44484810, 0xf90af000, 0x2f004607, 0x2201d10b, 0x46339001,
+    0x90029200, 0x46294622, 0x44484809, 0xf99af000, 0xf0004607, 0x4638f802, 0x4807bdfe, 0x210168c0,
+    0x43880289, 0x49041840, 0x477060c8, 0x40048100, 0x00000004, 0x6b65666b, 0xf0003000, 0x4a102070,
+    0x20807010, 0xbf007010, 0x7800480d, 0x280009c0, 0x480bd0fa, 0x20207801, 0x28004008, 0x2067d001,
+    0x20104770, 0x28004008, 0x2068d001, 0x07c8e7f8, 0x28000fc0, 0x2069d001, 0x2000e7f2, 0x0000e7f0,
+    0x40020000, 0xb081b5ff, 0x460d4604, 0xf0009804, 0x4606f89f, 0xd0022e00, 0xb0054630, 0x2304bdf0,
+    0x46204629, 0xf0009a03, 0x4606f876, 0xd0012e00, 0xe7f24630, 0x18289803, 0x46381e47, 0xf00068e1,
+    0x2900f983, 0x4638d009, 0xf00068e1, 0x1c40f97d, 0x68e19000, 0x43489800, 0xe0131e47, 0x4478480c,
+    0x60056800, 0x490b2009, 0xf7ff71c8, 0x4606ffa7, 0x280069a0, 0x69a0d001, 0x2e004780, 0xe003d000,
+    0x194568e0, 0xd9e942bd, 0x4630bf00, 0x0000e7c5, 0x00000462, 0x40020000, 0x4604b570, 0x4628460d,
+    0xf856f000, 0x2e004606, 0x4630d001, 0x2c00bd70, 0x2004d101, 0x2044e7fa, 0x71c84902, 0xff7ef7ff,
+    0x0000e7f4, 0x40020000, 0x29004601, 0x2004d101, 0x482a4770, 0x010068c0, 0x00400f00, 0x447b4b28,
+    0x03025a18, 0xd1012a00, 0xe7f12064, 0x60082000, 0x2001604a, 0x02806088, 0x200060c8, 0x61486108,
+    0xbf006188, 0x4602e7e4, 0xd1012a00, 0x47702004, 0x20006191, 0xb530e7fb, 0x2c004604, 0x2004d101,
+    0x1e58bd30, 0x28004008, 0x1e58d103, 0x28004010, 0x2065d001, 0x6820e7f4, 0xd8054288, 0x68206865,
+    0x188d1940, 0xd20142a8, 0xe7e92066, 0xe7e72000, 0x480c4601, 0xd0014281, 0x4770206b, 0xe7fc2000,
+    0x2b004603, 0x2004d101, 0x290f4770, 0x2a04d801, 0x2004d001, 0x2000e7f8, 0x0000e7f6, 0x40048040,
+    0x000003c0, 0x6b65666b, 0xb081b5ff, 0x46144607, 0x2c00461d, 0x2004d102, 0xbdf0b005, 0x462a2304,
+    0x99024638, 0xffb7f7ff, 0x2e004606, 0x4630d001, 0xe01ce7f2, 0x44794910, 0x68099802, 0xcc016008,
+    0x4479490d, 0x6809390c, 0x20066048, 0x71c8490b, 0xfef4f7ff, 0x69b84606, 0xd0012800, 0x478069b8,
+    0xd0002e00, 0x9802e005, 0x90021d00, 0x2d001f2d, 0xbf00d1e0, 0xe7cf4630, 0x0000030a, 0x40020000,
+    0xb083b5ff, 0x2304460c, 0x9a054621, 0xf7ff9803, 0x9002ff82, 0x28009802, 0x9802d002, 0xbdf0b007,
+    0x68919a03, 0xf0006850, 0x4605f88f, 0x42684261, 0x424e4001, 0xd10042a6, 0x9f051976, 0x1b30e027,
+    0x98019001, 0xd90042b8, 0x98019701, 0x90000880, 0x44784811, 0x60046800, 0x49102001, 0x980071c8,
+    0x0e010400, 0x72c1480d, 0x9800490c, 0x98067288, 0xf7ff7248, 0x9002fea3, 0x28009802, 0x9802d001,
+    0x9801e7cc, 0x98011a3f, 0x19761824, 0x2f00bf00, 0x2000d1d5, 0x0000e7c2, 0x0000026e, 0x40020000,
+    0x4604b570, 0x2c00460d, 0x2004d101, 0x2040bd70, 0x71c84903, 0x71854608, 0xfe80f7ff, 0x0000e7f6,
+    0x40020000, 0xb081b5ff, 0x4617460c, 0x2d00461d, 0x2004d102, 0xbdf0b005, 0x463a2304, 0x98014621,
+    0xff19f7ff, 0x2e004606, 0x4630d001, 0xe022e7f2, 0x44784813, 0x60046800, 0x49122002, 0x980a71c8,
+    0x490f72c8, 0x39124479, 0x68096828, 0xf7ff6088, 0x4606fe55, 0xd00b2e00, 0x2800980b, 0x980bd001,
+    0x980c6004, 0xd0022800, 0x980c2100, 0xe0046001, 0x1d2d1f3f, 0x2f001d24, 0xbf00d1da, 0xe7c94630,
+    0x000001ce, 0x40020000, 0x09032200, 0xd32c428b, 0x428b0a03, 0x2300d311, 0xe04e469c, 0x430b4603,
+    0x2200d43c, 0x428b0843, 0x0903d331, 0xd31c428b, 0x428b0a03, 0x4694d301, 0x09c3e03f, 0xd301428b,
+    0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152, 0xd301428b, 0x1ac0014b, 0x09034152,
+    0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb, 0x08834152, 0xd301428b, 0x1ac0008b,
+    0x08434152, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x46104152, 0xe05d4770, 0xd0000fca,
+    0x10034249, 0x4240d300, 0x22004053, 0x0903469c, 0xd32d428b, 0x428b0a03, 0x22fcd312, 0xba120189,
+    0x428b0a03, 0x0189d30c, 0x428b1192, 0x0189d308, 0x428b1192, 0x0189d304, 0x1192d03a, 0x0989e000,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x0843d2d9, 0xd301428b, 0x1ac0004b, 0x1a414152, 0x4601d200, 0x41524663,
+    0x4610105b, 0x4240d301, 0xd5002b00, 0x47704249, 0x105b4663, 0x4240d300, 0x2000b501, 0x46c046c0,
+    0x0002bd02, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000000, 0x00000000,
+    0x00000020, 0x40020004, 0x00000000,
+                                ],
+               'pc_init' : 0x20000021,
+               'pc_eraseAll' : 0x20000049,
+               'pc_erase_sector' : 0x2000006F,
+               'pc_program_page' : 0x2000009F,
+               'begin_stack' : 0x20000800,
+               'begin_data' : 0x20000800,       # Analyzer uses a max of 1 KB data (256 pages * 4 bytes / page)
+                                                # Note: 128 pages on KL25 and KL26, 256 pages on KL46
+               'static_base' : 0x20000000 + 0x20 + 0x5E8,
+               'min_program_length' : 4,
+               'analyzer_supported' : False     # Not enough space on KL02 and KL05
+              };
+
+# @brief Flash algorithm for Kinetis L-series devices.
+class Flash_kl02z(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kl02z, self).__init__(target, flash_algo)
+
+class KL02Z(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x8000,       blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1ffffc00,  length=0x1000)
+        )
+
+    def __init__(self, link):
+        super(KL02Z, self).__init__(link, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKL02Z4.svd", is_local=False)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kv10z7.py` & `pyOCD-0.9.0/pyOCD/target/target_MKV11Z128xxx7.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,95 +1,112 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
-    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
-    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
-    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
-    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
-    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
-    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
-    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
-    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
-    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
-    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
-    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
-    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
-    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
-    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
-    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8f6f000, 0xd1042800, 0x21004806, 0xf0004448,
-    0x4a05f9bb, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
-    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf89ef000, 0xd1052800, 0x46292300, 0x68e24620, 0xf960f000,
-    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4809b510,
-    0x81c14907, 0x81c14908, 0x08498801, 0x80010049, 0x44484806, 0xf8ecf000, 0xd0002800, 0xbd102001,
-    0x0000c520, 0x40052000, 0x0000d928, 0x00000004, 0x460cb570, 0x4606460b, 0x480d4601, 0x4615b084,
-    0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807, 0x4622462b, 0x44484631, 0xf96af000,
-    0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004, 0xf0003000, 0x47702000, 0xd0032800,
-    0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800, 0x47702004, 0x1e5bb410, 0x421c460c,
-    0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804, 0x18181889, 0xd2024288, 0x2066bc10,
-    0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770, 0x00004770, 0x6b65666b, 0x2170480a,
-    0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501, 0x06c14770, 0x2068d501, 0x07c04770,
-    0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616, 0xf7ff4618, 0x2800ffd7, 0x2304d12b,
-    0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76, 0x91004630, 0xfe32f7ff, 0xd0032900,
-    0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800, 0x20094909, 0xf7ff71c8, 0x4607ffbf,
-    0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4, 0xbdf84638, 0x0000026a, 0x40020000,
-    0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005, 0x71c82044, 0xffa0f7ff, 0x2004bd10,
-    0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908, 0x447b000b, 0x18db791b, 0x0705449f,
-    0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008, 0x6800e006, 0x2000e004, 0x6900e002,
-    0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800, 0x68c9490c, 0x0e094a0c, 0x447a0049,
-    0x03095a51, 0x2200d00d, 0x60416002, 0x60812101, 0x61426102, 0x61820289, 0x461060c1, 0x20044770,
-    0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00, 0x47702004, 0x461cb5ff, 0x4615b081,
-    0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00, 0x4478480c, 0x600e6801, 0x6800cd02,
-    0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980, 0x4780d000, 0xd1022f00, 0x1f241d36,
-    0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800, 0x20006181, 0x20044770, 0x00004770,
-    0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800, 0x686868a9, 0xfd72f7ff, 0x42719000,
-    0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a, 0xd90042a5, 0x490d4625, 0x447908a8,
-    0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804, 0xfef2f7ff, 0xd1062800, 0x1b649800,
-    0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da, 0x40020000, 0xd1012800, 0x47702004,
-    0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000, 0xd1012b00, 0x47702004, 0x461cb5f8,
-    0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00, 0x447a4a0f, 0x60066810, 0x2102480e,
-    0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800, 0x29009907, 0x600ed000, 0xd0012f00,
-    0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8, 0x00000062, 0x40020000, 0x00040002,
-    0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000, 0x00000000, 0x00200000, 0x40020004,
-    0x00000000,
-    ],
-
-    'pc_init' : 0x2000027D,
-    'pc_unInit': 0x200002F9,
-    'pc_program_page': 0x200002B1,
-    'pc_erase_sector': 0x2000023D,
-    'pc_eraseAll' : 0x20000209,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x00000620,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
-    'min_program_length' : 4,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x1ffff800
-  };
-
-# @brief Flash algorithm for Kinetis KV10Z7 device.
-class Flash_kv10z7(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_kv10z7, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
+    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
+    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
+    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
+    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
+    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
+    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
+    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
+    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
+    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
+    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
+    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
+    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8fcf000, 0xd1042800, 0x21004806, 0xf0004448,
+    0x4a05f9c9, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
+    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf8a4f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf96ef000,
+    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4809b510,
+    0x81c14907, 0x81c14908, 0x08498801, 0x80010049, 0x44484806, 0xf8f2f000, 0xd0002800, 0xbd102001,
+    0x0000c520, 0x40052000, 0x0000d928, 0x00000004, 0x460cb570, 0x4606460b, 0x480d4601, 0x4615b084,
+    0xf0004448, 0x2800f903, 0x9001d10a, 0x21019002, 0x91004807, 0x4622462b, 0x44484631, 0xf978f000,
+    0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004, 0xf0003000, 0x47702000, 0xd0082800,
+    0xd802290f, 0xd1042a04, 0x2913e005, 0x2a08d801, 0x2004d001, 0x20004770, 0x28004770, 0x2004d101,
+    0xb4104770, 0x460c1e5b, 0xd101421c, 0xd002421a, 0x2065bc10, 0x68034770, 0xd804428b, 0x18896840,
+    0x42881818, 0xbc10d202, 0x47702066, 0x2000bc10, 0x00004770, 0x42884903, 0x206bd001, 0x20004770,
+    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
+    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
+    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb2, 0x19a6d123, 0x68e91e76,
+    0x91004630, 0xfe2cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
+    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
+    0xbdf84638, 0x0000027a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
+    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
+    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
+    0x6800e006, 0x2001e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd00a2800,
+    0x68c9490f, 0x0e094a0f, 0x447a0049, 0x03095a51, 0x2064d103, 0x20044770, 0xb4104770, 0x60032300,
+    0x21016041, 0x02896081, 0x490760c1, 0x158a7a0c, 0x610240a2, 0x61837ac9, 0xbc106141, 0x47704618,
+    0x40048040, 0x000001aa, 0x40020020, 0xd1012a00, 0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e,
+    0x98014622, 0xff19f7ff, 0xd1190007, 0xd0162c00, 0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041,
+    0x71c82006, 0xff30f7ff, 0x98014607, 0x28006980, 0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8,
+    0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800, 0x20006181, 0x20044770, 0x00004770, 0xb081b5ff,
+    0x460e4614, 0x23044605, 0xfee7f7ff, 0xd12a2800, 0x686868a9, 0xfd64f7ff, 0x42719000, 0x40014240,
+    0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a, 0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809,
+    0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804, 0xfeeaf7ff, 0xd1062800, 0x1b649800, 0x183f1976,
+    0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da, 0x40020000, 0xd1012800, 0x47702004, 0x4803b510,
+    0x71c22240, 0xf7ff7181, 0xbd10fecf, 0x40020000, 0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615,
+    0x9f082304, 0xfe99f7ff, 0xd1192800, 0xd0172d00, 0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1,
+    0x681172c1, 0x60886820, 0xfeaef7ff, 0xd0082800, 0x29009907, 0x600ed000, 0xd0012f00, 0x60392100,
+    0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8, 0x00000062, 0x40020000, 0x00040002, 0x00080000,
+    0x00100000, 0x00200000, 0x00400000, 0x00000000, 0x00000000, 0x00200000, 0x40020004, 0x00000000,
+
+    ],
+
+    'pc_init' : 0x2000027D,
+    'pc_unInit': 0x200002F9,
+    'pc_program_page': 0x200002B1,
+    'pc_erase_sector': 0x2000023D,
+    'pc_eraseAll' : 0x20000209,
+
+    'static_base' : 0x20000000 + 0x00000020 + 0x0000063c,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
+    'min_program_length' : 4,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x1ffff800
+  };
+
+# @brief Flash algorithm for Kinetis KV11Z7 device.
+class Flash_kv11z7(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kv11z7, self).__init__(target, flash_algo)
+
+class KV11Z7(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x20000,      blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1ffff000,  length=0x4000)
+        )
+
+    def __init__(self, transport):
+        super(KV11Z7, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKV11Z7.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_kw01z4.py` & `pyOCD-0.9.0/pyOCD/target/target_MKL43Z256xxx4.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,94 +1,110 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash_kinetis import Flash_Kinetis
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
-    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
-    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
-    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
-    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
-    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
-    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
-    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
-    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
-    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
-    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
-    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
-    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
-    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
-    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
-    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8ecf000, 0xd1042800, 0x21004806, 0xf0004448,
-    0x4a05f9b1, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
-    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf894f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf956f000,
-    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
-    0x60082000, 0x44484804, 0xf8e8f000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
-    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807,
-    0x4622462b, 0x44484631, 0xf96af000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
-    0xf0003000, 0x47702000, 0xd0032800, 0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800,
-    0x47702004, 0x1e5bb410, 0x421c460c, 0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804,
-    0x18181889, 0xd2024288, 0x2066bc10, 0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770,
-    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
-    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
-    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76,
-    0x91004630, 0xfe3cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
-    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
-    0xbdf84638, 0x0000026a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
-    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
-    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
-    0x6800e006, 0x2000e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800,
-    0x68c9490c, 0x0e094a0c, 0x447a0049, 0x03095a51, 0x2200d00d, 0x60416002, 0x60812102, 0x61426102,
-    0x61820249, 0x461060c1, 0x20044770, 0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00,
-    0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00,
-    0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980,
-    0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800,
-    0x20006181, 0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800,
-    0x686868a9, 0xfd7cf7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a,
-    0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804,
-    0xfef2f7ff, 0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da,
-    0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000,
-    0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00,
-    0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800,
-    0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8,
-    0x00000062, 0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000,
-    0x00000000, 0x00200000, 0x40020004, 0x00000000,
-    ],
-
-    'pc_init' : 0x2000027D,
-    'pc_unInit': 0x200002E5,
-    'pc_program_page': 0x2000029D,
-    'pc_erase_sector': 0x2000023D,
-    'pc_eraseAll' : 0x20000209,
-
-    'static_base' : 0x20000000 + 0x00000020 + 0x0000060c,
-    'begin_stack' : 0x20000000 + 0x00000800,
-    'begin_data' : 0x20000000 + 0x00000A00,
-    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
-    'min_program_length' : 4,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x1ffff800
-  };
-
-# @brief Flash algorithm for Kinetis KW01Z4 device.
-class Flash_kw01z4(Flash_Kinetis):
-
-    def __init__(self, target):
-        super(Flash_kw01z4, self).__init__(target, flash_algo)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .family.target_kinetis import Kinetis
+from .family.flash_kinetis import Flash_Kinetis
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from ..debug.svd import SVDFile
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x09032200, 0xd373428b, 0x428b0a03, 0x0b03d358, 0xd33c428b, 0x428b0c03, 0xe012d321, 0x430b4603,
+    0x2200d47f, 0x428b0843, 0x0903d374, 0xd35f428b, 0x428b0a03, 0x0b03d344, 0xd328428b, 0x428b0c03,
+    0x22ffd30d, 0xba120209, 0x428b0c03, 0x1212d302, 0xd0650209, 0x428b0b03, 0xe000d319, 0x0bc30a09,
+    0xd301428b, 0x1ac003cb, 0x0b834152, 0xd301428b, 0x1ac0038b, 0x0b434152, 0xd301428b, 0x1ac0034b,
+    0x0b034152, 0xd301428b, 0x1ac0030b, 0x0ac34152, 0xd301428b, 0x1ac002cb, 0x0a834152, 0xd301428b,
+    0x1ac0028b, 0x0a434152, 0xd301428b, 0x1ac0024b, 0x0a034152, 0xd301428b, 0x1ac0020b, 0xd2cd4152,
+    0x428b09c3, 0x01cbd301, 0x41521ac0, 0x428b0983, 0x018bd301, 0x41521ac0, 0x428b0943, 0x014bd301,
+    0x41521ac0, 0x428b0903, 0x010bd301, 0x41521ac0, 0x428b08c3, 0x00cbd301, 0x41521ac0, 0x428b0883,
+    0x008bd301, 0x41521ac0, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41, 0x41524601, 0x47704610,
+    0x0fcae05d, 0x4249d000, 0xd3001003, 0x40534240, 0x469c2200, 0x428b0903, 0x0a03d32d, 0xd312428b,
+    0x018922fc, 0x0a03ba12, 0xd30c428b, 0x11920189, 0xd308428b, 0x11920189, 0xd304428b, 0xd03a0189,
+    0xe0001192, 0x09c30989, 0xd301428b, 0x1ac001cb, 0x09834152, 0xd301428b, 0x1ac0018b, 0x09434152,
+    0xd301428b, 0x1ac0014b, 0x09034152, 0xd301428b, 0x1ac0010b, 0x08c34152, 0xd301428b, 0x1ac000cb,
+    0x08834152, 0xd301428b, 0x1ac0008b, 0xd2d94152, 0x428b0843, 0x004bd301, 0x41521ac0, 0xd2001a41,
+    0x46634601, 0x105b4152, 0xd3014610, 0x2b004240, 0x4249d500, 0x46634770, 0xd300105b, 0xb5014240,
+    0x46c02000, 0xbd0246c0, 0xb510480a, 0x44484908, 0xf8ecf000, 0xd1042800, 0x21004806, 0xf0004448,
+    0x4a05f9b1, 0x230168d1, 0x4319029b, 0xbd1060d1, 0x6b65666b, 0x00000004, 0xf0003000, 0x4c0cb570,
+    0x444c4605, 0x4b0b4601, 0x68e24620, 0xf894f000, 0xd1052800, 0x46292300, 0x68e24620, 0xf956f000,
+    0x68ca4905, 0x029b2301, 0x60ca431a, 0x0000bd70, 0x00000004, 0x6b65666b, 0xf0003000, 0x4905b510,
+    0x60082000, 0x44484804, 0xf8e8f000, 0xd0002800, 0xbd102001, 0x40048100, 0x00000004, 0x460cb570,
+    0x4606460b, 0x480d4601, 0x4615b084, 0xf0004448, 0x2800f8f5, 0x9001d10a, 0x21019002, 0x91004807,
+    0x4622462b, 0x44484631, 0xf96af000, 0x68ca4904, 0x029b2301, 0x60ca431a, 0xbd70b004, 0x00000004,
+    0xf0003000, 0x47702000, 0xd0032800, 0xd801290f, 0xd0012a04, 0x47702004, 0x47702000, 0xd1012800,
+    0x47702004, 0x1e5bb410, 0x421c460c, 0x421ad101, 0xbc10d002, 0x47702065, 0x428b6803, 0x6840d804,
+    0x18181889, 0xd2024288, 0x2066bc10, 0xbc104770, 0x47702000, 0x42884903, 0x206bd001, 0x20004770,
+    0x00004770, 0x6b65666b, 0x2170480a, 0x21807001, 0x78017001, 0xd5fc0609, 0x06817800, 0x2067d501,
+    0x06c14770, 0x2068d501, 0x07c04770, 0x2069d0fc, 0x00004770, 0x40020000, 0x4605b5f8, 0x460c4616,
+    0xf7ff4618, 0x2800ffd7, 0x2304d12b, 0x46214632, 0xf7ff4628, 0x0007ffb3, 0x19a6d123, 0x68e91e76,
+    0x91004630, 0xfe3cf7ff, 0xd0032900, 0x1c409e00, 0x1e764346, 0xd81342b4, 0x4478480a, 0x60046800,
+    0x20094909, 0xf7ff71c8, 0x4607ffbf, 0x280069a8, 0x4780d000, 0xd1032f00, 0x190468e8, 0xd9eb42b4,
+    0xbdf84638, 0x0000026a, 0x40020000, 0x4604b510, 0xf7ff4608, 0x2800ff9f, 0x2c00d106, 0x4904d005,
+    0x71c82044, 0xffa0f7ff, 0x2004bd10, 0x0000bd10, 0x40020000, 0xd00c2800, 0xd00a2a00, 0xd21a2908,
+    0x447b000b, 0x18db791b, 0x0705449f, 0x0d0b0907, 0x2004110f, 0x68c04770, 0x6840e00a, 0x6880e008,
+    0x6800e006, 0x2000e004, 0x6900e002, 0x6940e000, 0x20006010, 0x206a4770, 0x00004770, 0xd0142800,
+    0x68c9490c, 0x0e094a0c, 0x447a0049, 0x03095a51, 0x2200d00d, 0x60416002, 0x60812102, 0x61426102,
+    0x61820249, 0x461060c1, 0x20044770, 0x20644770, 0x00004770, 0x40048040, 0x0000019a, 0xd1012a00,
+    0x47702004, 0x461cb5ff, 0x4615b081, 0x2304460e, 0x98014622, 0xff22f7ff, 0xd1190007, 0xd0162c00,
+    0x4478480c, 0x600e6801, 0x6800cd02, 0x490a6041, 0x71c82006, 0xff38f7ff, 0x98014607, 0x28006980,
+    0x4780d000, 0xd1022f00, 0x1f241d36, 0x4638d1e8, 0xbdf0b005, 0x00000162, 0x40020000, 0xd0022800,
+    0x20006181, 0x20044770, 0x00004770, 0xb081b5ff, 0x460e4614, 0x23044605, 0xfef0f7ff, 0xd12a2800,
+    0x686868a9, 0xfd7cf7ff, 0x42719000, 0x40014240, 0x42b7424f, 0x9800d101, 0x2c00183f, 0x1bbdd01a,
+    0xd90042a5, 0x490d4625, 0x447908a8, 0x600e6809, 0x2201490b, 0x0a0271ca, 0x728872ca, 0x72489804,
+    0xfef2f7ff, 0xd1062800, 0x1b649800, 0x183f1976, 0xd1e42c00, 0xb0052000, 0x0000bdf0, 0x000000da,
+    0x40020000, 0xd1012800, 0x47702004, 0x4803b510, 0x71c22240, 0xf7ff7181, 0xbd10fed7, 0x40020000,
+    0xd1012b00, 0x47702004, 0x461cb5f8, 0x460e4615, 0x9f082304, 0xfea2f7ff, 0xd1192800, 0xd0172d00,
+    0x447a4a0f, 0x60066810, 0x2102480e, 0x990671c1, 0x681172c1, 0x60886820, 0xfeb6f7ff, 0xd0082800,
+    0x29009907, 0x600ed000, 0xd0012f00, 0x60392100, 0x1f2dbdf8, 0x1d361d24, 0xd1e12d00, 0x0000bdf8,
+    0x00000062, 0x40020000, 0x00040002, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00000000,
+    0x00000000, 0x00400000, 0x40020004, 0x00000000,
+    ],
+
+    'pc_init' : 0x2000027D,
+    'pc_unInit': 0x200002E5,
+    'pc_program_page': 0x2000029D,
+    'pc_erase_sector': 0x2000023D,
+    'pc_eraseAll' : 0x20000209,
+
+    'static_base' : 0x20000000 + 0x00000020 + 0x0000060c,
+    'begin_stack' : 0x20000000 + 0x00000800,
+    'begin_data' : 0x20000000 + 0x00000A00,
+    'page_buffers' : [0x20000a00, 0x20001200],   # Enable double buffering
+    'min_program_length' : 4,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x20002000
+  };
+
+# @brief Flash algorithm for Kinetis KL43Z4 device.
+class Flash_kl43z4(Flash_Kinetis):
+
+    def __init__(self, target):
+        super(Flash_kl43z4, self).__init__(target, flash_algo)
+
+class KL43Z4(Kinetis):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x40000,      blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x1fffe000,  length=0x8000)
+        )
+
+    def __init__(self, transport):
+        super(KL43Z4, self).__init__(transport, self.memoryMap)
+        self.mdm_idr = 0x001c0020
+        self._svd_location = SVDFile(vendor="Freescale", filename="MKL43Z4.svd")
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_lpc11u24.py` & `pyOCD-0.9.0/pyOCD/target/target_LPC1114FN28_102.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,59 +1,87 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash
-
-flash_algo = { 'load_address' : 0x10000000,
-               'instructions' : [
-                                0xe00abe00, 0x062d780d, 0x24084068, 0xd3000040, 0x1e644058, 0x1c49d1fa, 0x2a001e52, 0x4770d1f2,
-                                0x7803e005, 0x42931c40, 0x2001d001, 0x1e494770, 0x2000d2f7, 0x00004770, 0x47700b00, 0x484e494f,
-                                0x60084449, 0x2100484e, 0x22016301, 0x63416342, 0x6b416342, 0xd0fc07c9, 0x49496382, 0x39402002,
-                                0x20007008, 0x20004770, 0xb5f84770, 0x20324c45, 0x2500444c, 0x46222607, 0x4621c261, 0x4f423114,
-                                0x91004620, 0x696047b8, 0xd10c2800, 0x46212034, 0x483ac161, 0x68004448, 0x462060e0, 0x47b89900,
-                                0x28006960, 0x2001d000, 0xb5f8bdf8, 0x0b044d35, 0x2032444d, 0x4629606c, 0x311460ac, 0x4e326028,
-                                0x4628460f, 0x696847b0, 0xd10d2800, 0x2034606c, 0x602860ac, 0x46394829, 0x68004448, 0x462860e8,
-                                0x696847b0, 0xd0002800, 0xbdf82001, 0x0006b5f8, 0xd11e4614, 0x0180200b, 0x6bc11820, 0x42814823,
-                                0x4823d038, 0xd0354281, 0x42814822, 0x4822d032, 0xd02f4281, 0x68206861, 0x184068e2, 0x188968a1,
-                                0x69211840, 0x69611840, 0x69a11840, 0x42401840, 0x4d1461e0, 0x444d0b30, 0x60682132, 0x60a86029,
-                                0x31144629, 0x46284f10, 0x47b89100, 0x28006968, 0x606ed110, 0x60ac2033, 0x20016028, 0x60e80280,
-                                0x44484806, 0x61286800, 0x99004628, 0x696847b8, 0xd0002800, 0xbdf82001, 0x00002ee0, 0x00000004,
-                                0x40048040, 0x00000008, 0x1fff1ff1, 0x4e697370, 0x12345678, 0x87654321, 0x43218765, 0x00000000,
-                                0x00000000
-                                ],
-               'pc_init' : 0x1000003d,
-               'pc_eraseAll' : 0x1000006b,
-               'pc_erase_sector' : 0x100000ab,
-               'pc_program_page' : 0x100000ed,
-               'begin_data' : 0x100001c4,
-               # Double buffering is not supported since there is not enough ram
-               'begin_stack' : 0x10001000,
-               'static_base' : 0x1000019c,
-               'min_program_length' : 256,
-               'analyzer_supported' : False
-              };
-
-class Flash_lpc11u24(Flash):
-
-    def __init__(self, target):
-        super(Flash_lpc11u24, self).__init__(target, flash_algo)
-
-    # TODO - temporary until flash algo is rebuilt with 4K page program size
-    def programPage(self, flashPtr, bytes):
-        write_size = 1024
-        for i in range(0, 4):
-            data = bytes[i * write_size : (i + 1) * write_size]
-            Flash.programPage(self, flashPtr + i * write_size, data)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.coresight_target import CoreSightTarget
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+
+WRITE_SIZE = 256
+
+flash_algo = {
+    'load_address' : 0x10000000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4c0fb5f8, 0x25002032, 0x2607444c, 0x490d60a6, 0x60206065, 0x4f0c4449, 0x91004620, 0x696047b8,
+    0xd10b2800, 0x203460a6, 0x60206065, 0x60e04807, 0x99004620, 0x696047b8, 0xd0002800, 0xbdf82001,
+    0x00000004, 0x00000018, 0x1fff1ff1, 0x00002ee0, 0x4d0fb5f8, 0x444d0b04, 0x490e606c, 0x60ac2032,
+    0x60284449, 0x460f4e0c, 0x47b04628, 0x28006968, 0x606cd10b, 0x60ac2034, 0x48086028, 0x463960e8,
+    0x47b04628, 0x28006968, 0x2001d000, 0x0000bdf8, 0x00000004, 0x00000018, 0x1fff1ff1, 0x00002ee0,
+    0x47700b00, 0x21004807, 0x22016301, 0x63416342, 0x6b416342, 0xd0fc07c9, 0x49036382, 0x60082002,
+    0x47702000, 0x40048040, 0x40048000, 0x4614b5f8, 0xd10e0005, 0x68206861, 0x184068e2, 0x188968a1,
+    0x69211840, 0x69611840, 0x69a11840, 0x42401840, 0x4e1061e0, 0x444e0b28, 0x60702132, 0x490e6031,
+    0x444960b0, 0x46304f0d, 0x47b89100, 0x28006970, 0x6075d10e, 0x60b42033, 0x20ff6030, 0x60f03001,
+    0x61304807, 0x99004630, 0x697047b8, 0xd0002800, 0xbdf82001, 0x00000004, 0x00000018, 0x1fff1ff1,
+    0x00002ee0, 0x47702000, 0x00000000,
+    ],
+
+    'pc_eraseAll' : 0x10000021,
+    'pc_init' : 0x100000C5,
+    #'pc_UnInit' : 0x10000165,
+    'pc_program_page' : 0x100000ED,
+    'pc_erase_sector' : 0x10000071,
+
+    'static_base' : 0x10000000 + 0x00000020 + 0x00000148,
+    'begin_data' : 0x10000000 + 0x00000A00,
+    # Double buffering is not supported since there is not enough ram
+    'begin_stack' : 0x10000800,
+    'page_size' : 0x00001000,
+    'min_program_length' : 1024,
+    'analyzer_supported' : False,
+};
+
+class Flash_lpc11xx_32(Flash):
+    def __init__(self, target):
+        super(Flash_lpc11xx_32, self).__init__(target, flash_algo)
+
+    # Override programPage and break the operation into 4 1KB writes
+    # since there isn't enough ram to do a 4K sector write directly
+    def programPage(self, flashPtr, bytes):
+        pages = (len(bytes) + WRITE_SIZE - 1) // WRITE_SIZE
+        for i in range(0, pages):
+            data = bytes[i * WRITE_SIZE : (i + 1) * WRITE_SIZE]
+            Flash.programPage(self, flashPtr + i * WRITE_SIZE, data)
+
+class LPC11XX_32(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x8000,       blocksize=0x1000, isBootMemory=True),
+        RamRegion(      start=0x10000000,  length=0x1000)
+        )
+
+    def __init__(self, link):
+        super(LPC11XX_32, self).__init__(link, self.memoryMap)
+
+    def resetStopOnReset(self, software_reset=None, map_to_user=True):
+        super(LPC11XX_32, self).resetStopOnReset(software_reset)
+
+        # Remap to use flash and set SP and SP accordingly
+        if map_to_user:
+            self.writeMemory(0x40048000, 0x2, 32)
+            sp = self.readMemory(0x0)
+            pc = self.readMemory(0x4)
+            self.writeCoreRegisterRaw('sp', sp)
+            self.writeCoreRegisterRaw('pc', pc)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_lpc1768.py` & `pyOCD-0.9.0/pyOCD/target/target_lpc4088qsb.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,90 +1,99 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash, PageInfo, DEFAULT_PAGE_PROGRAM_WEIGHT, DEFAULT_PAGE_ERASE_WEIGHT
-
-LARGE_PAGE_START_ADDR = 0x10000
-SMALL_PAGE_SIZE = 0x1000
-LARGE_PAGE_SIZE = 0x8000
-LARGE_TO_SMALL_RATIO = LARGE_PAGE_SIZE / SMALL_PAGE_SIZE
-WRITE_SIZE = 1024
-
-flash_algo = { 'load_address' : 0x10000000,
-               'instructions' : [
-                                0xe00abe00, 0x062d780d, 0x24084068, 0xd3000040, 0x1e644058, 0x1c49d1fa, 0x2a001e52, 0x4770d1f2,
-                                0x7803e005, 0x42931c40, 0x2001d001, 0x1e494770, 0x2000d2f7, 0x00004770, 0x28100b00, 0x210ed302,
-                                0x00d0eb01, 0x486c4770, 0x7801b510, 0x0102f021, 0x22aa7001, 0x23557302, 0x78017303, 0x0101f021,
-                                0x73027001, 0xf8d07303, 0xf0411120, 0xf8c00120, 0xf1a01120, 0xf8d00080, 0x064911a0, 0xf100d5fb,
-                                0x24010080, 0x408cf880, 0x0113f04f, 0x73026041, 0x78017303, 0x0101f041, 0x73027001, 0xf1a07303,
-                                0xf8d00080, 0x01491088, 0xf100d5fb, 0x2107006d, 0x1097f880, 0x0109f04f, 0x109bf880, 0xf0417cc1,
-                                0x74c10102, 0x77c377c2, 0x4c2df800, 0xf64e494b, 0x44492060, 0xf04f6008, 0xbd100000, 0x47702000,
-                                0x41f0e92d, 0x20324c46, 0x2500444c, 0xe884271d, 0xf10400a1, 0x4e430114, 0x46204688, 0x696047b0,
-                                0x2034b960, 0x00a1e884, 0x4641483c, 0x68004448, 0x462060e0, 0x696047b0, 0xd0002800, 0xe8bd2001,
-                                0xe92d81f0, 0xf7ff41f0, 0x4d35ff87, 0x444d4604, 0xe9c52032, 0xf1050400, 0x4e320114, 0x4628460f,
-                                0x47b060ac, 0xb9686968, 0xe9c52034, 0x482b0400, 0x444860ac, 0x68004639, 0x462860e8, 0x696847b0,
-                                0xd0dc2800, 0xe7da2001, 0x41f0e92d, 0x46140006, 0x4925d11d, 0x02fcf8d4, 0xd03a4288, 0x42884923,
-                                0x4923d037, 0xd0344288, 0x4131ea4f, 0xd0304288, 0x0100e9d4, 0xe9d44408, 0x44111202, 0x69214408,
-                                0x69614408, 0x69a14408, 0x42404408, 0x463061e0, 0xff42f7ff, 0x21324d12, 0x4f12444d, 0x1000e9c5,
-                                0x0114f105, 0x468860a8, 0x47b84628, 0xb9806968, 0xe9c52033, 0xf44f0600, 0xe9c56080, 0x48074002,
-                                0x44484641, 0x61286800, 0x47b84628, 0x28006968, 0x2001d095, 0x0000e793, 0x400fc080, 0x00000004,
-                                0x00000008, 0x1fff1ff1, 0x4e697370, 0x12345678, 0x87654321, 0x00000000, 0x00000000
-                                ],
-               'pc_init' : 0x10000047,
-               'pc_eraseAll' : 0x100000e1,
-               'pc_erase_sector' : 0x10000123,
-               'pc_program_page' : 0x10000169,
-               'begin_data' : 0x2007c000,       # Analyzer uses a max of 120 B data (30 pages * 4 bytes / page)
-               # Double buffering is not supported since there is not enough ram
-               'begin_stack' : 0x10001000,
-               'static_base' : 0x10000214,
-               'min_program_length' : 256,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x10002000  # Analyzer 0x10002000..0x10002600
-              };
-
-class Flash_lpc1768(Flash):
-
-    def __init__(self, target):
-        super(Flash_lpc1768, self).__init__(target, flash_algo)
-
-    def erasePage(self, flashPtr):
-        Flash.erasePage(self, flashPtr)
-
-    def programPage(self, flashPtr, bytes):
-        if flashPtr < LARGE_PAGE_START_ADDR:
-            assert len(bytes) <= SMALL_PAGE_SIZE
-        else:
-            assert len(bytes) <= LARGE_PAGE_SIZE
-
-        pages = (len(bytes) + WRITE_SIZE - 1) // WRITE_SIZE
-
-        for i in range(0, pages):
-            data = bytes[i * WRITE_SIZE : (i + 1) * WRITE_SIZE]
-            Flash.programPage(self, flashPtr + i * WRITE_SIZE, data)
-
-    def getPageInfo(self, addr):
-        info = PageInfo()
-        if addr < LARGE_PAGE_START_ADDR:
-            info.erase_weight = DEFAULT_PAGE_ERASE_WEIGHT
-            info.program_weight = DEFAULT_PAGE_PROGRAM_WEIGHT
-            info.size = SMALL_PAGE_SIZE
-        else:
-            info.erase_weight = DEFAULT_PAGE_ERASE_WEIGHT * LARGE_TO_SMALL_RATIO
-            info.program_weight = DEFAULT_PAGE_PROGRAM_WEIGHT * LARGE_TO_SMALL_RATIO
-            info.size = LARGE_PAGE_SIZE
-        info.base_addr = addr - (addr % info.size)
-        return info
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from .target_LPC4088FBD144 import (Flash_lpc4088, LPC4088)
+
+SPIFI_START = 0x28000000
+SPIFI_SIZE = 16 * 1024 * 1024
+SPIFI_SECTOR_SIZE = 4 * 1024
+
+flash_algo = {
+    'load_address' : 0x10000000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x28100b00, 0x210ebf24, 0x00d0eb01, 0xe92d4770, 0xf8df4df0, 0x4606831c, 0x460c44c8, 0x0000f8d8,
+    0x1c402500, 0x0000f8c8, 0x0f01f010, 0x461749c1, 0x2080f44f, 0x63c8bf14, 0x05306388, 0xa2f8f8df,
+    0xf04f0d00, 0x44ca0b00, 0xf8cad111, 0xf44fb010, 0xf8ca5080, 0xe9ca6000, 0xf8ca0b01, 0xf8d8b00c,
+    0x4651000c, 0xf1a16882, 0x47900080, 0x2018b9c0, 0xb008f8ca, 0xb003e9ca, 0xf5b4b1cc, 0xbf8c7f80,
+    0x7b80f44f, 0x197046a3, 0x0b00e9ca, 0x000cf8d8, 0x19794aa9, 0x6843444a, 0x0080f1a2, 0xb1104798,
+    0xe8bd2001, 0x445d8df0, 0x040bebb4, 0x2000d1e5, 0x8df0e8bd, 0x41f0e92d, 0x8274f8df, 0x60e0f642,
+    0x4d9e44c8, 0x0008f8c8, 0x70282000, 0x732820aa, 0x73282055, 0xf8052001, 0x22000c40, 0xf0002112,
+    0x2200f91a, 0x4610210d, 0xf915f000, 0x210d2200, 0xf0002001, 0x2200f910, 0x20022113, 0xf90bf000,
+    0x68204c8c, 0x5000f440, 0x6a206020, 0x2084f440, 0x6c206220, 0x2000f440, 0xf44f6420, 0x63e72780,
+    0x61a6117e, 0xf4406c68, 0x64683080, 0xf8c52002, 0x22050134, 0xf0002107, 0x2205f8ee, 0x20002116,
+    0xf8e9f000, 0x210f2205, 0xf0002000, 0x2205f8e4, 0x20002110, 0xf8dff000, 0x21112205, 0xf0002000,
+    0x2205f8da, 0x20002112, 0xf8d5f000, 0xf44f4874, 0x6800727a, 0xf8c86940, 0xf8d8000c, 0xfbb11008,
+    0xf8d5f1f2, 0xf8d02134, 0xf002c000, 0xfbb1021f, 0x496cf3f2, 0xfba1486c, 0x08892103, 0x444822c0,
+    0x280047e0, 0x61e6bf04, 0x81f0e8bd, 0x61e663a7, 0xe8bd2001, 0x200081f0, 0xe92d4770, 0x4c6341f0,
+    0x444c2032, 0x251d2700, 0xe9c460a5, 0x4e600700, 0x0114f104, 0x47b04620, 0xb9806960, 0x60a52034,
+    0x0700e9c4, 0xf1044852, 0x44480114, 0x60e06880, 0x47b04620, 0x28006960, 0xe8bdbf08, 0x200181f0,
+    0x81f0e8bd, 0x5f20f1b0, 0xf5b0bf32, 0x20002f00, 0xb5704770, 0x2c100b04, 0x200ebf24, 0x04d4eb00,
+    0x4d4a2032, 0x444d4e4a, 0x0114f105, 0x0400e9c5, 0x60ac4628, 0x696847b0, 0x2034b978, 0x0400e9c5,
+    0x60ac483b, 0xf1054448, 0x68800114, 0x462860e8, 0x696847b0, 0xbf082800, 0x2001bd70, 0xe92dbd70,
+    0x4f3341f0, 0x444f4605, 0x68784614, 0x1c404a31, 0xf0106078, 0xf44f0f01, 0xbf145000, 0x619061d0,
+    0x5f20f1b5, 0x4622d305, 0x5020f1a5, 0x41f0e8bd, 0xf5b5e6bd, 0xd3052f00, 0xf5a54622, 0xe8bd2000,
+    0xe6b441f0, 0xe9d4b975, 0x44080100, 0x1202e9d4, 0x44084411, 0x44086921, 0x44086961, 0x440869a1,
+    0x61e04240, 0x28100b28, 0x210ebf24, 0x00d0eb01, 0x4e1e2132, 0x8078f8df, 0xe9c6444e, 0x60b01000,
+    0x0114f106, 0x47c04630, 0xb9886970, 0xe9c62033, 0xf44f0500, 0xe9c67000, 0x68b84002, 0xf1066130,
+    0x46300114, 0x697047c0, 0xbf082800, 0x81f0e8bd, 0xe8bd2001, 0xeb0181f0, 0x490e1040, 0x0080eb01,
+    0xf0216801, 0x60010107, 0x43116801, 0x47706001, 0x00000004, 0x20098000, 0x000000b4, 0x400fc080,
+    0x1fff1ff8, 0xcccccccd, 0x00000034, 0x00000014, 0x1fff1ff1, 0x4002c000, 0x00000000, 0x00000001,
+    0x00000000, 0x00000000, 0x00000000,
+    ],
+
+    'pc_init' : 0x100000D5,
+    'pc_unInit': 0x100001D7,
+    'pc_program_page': 0x1000027F,
+    'pc_erase_sector': 0x10000225,
+    'pc_eraseAll' : 0x100001DB,
+
+    'static_base' : 0x10000000 + 0x00000020 + 0x00000400,
+    'begin_stack' : 0x10000000 + 0x00000800,
+    # Double buffering is not supported since there is not enough ram
+    'begin_data' : 0x10000000 + 0x00000A00,  # Analyzer uses a max of 120 B data (30 pages * 4 bytes / page)
+    'page_size' : 0x00000200,
+    'analyzer_supported' : False,
+    'min_program_length' : 512,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x10002000  # Analyzer 0x10002000..0x10002600
+}
+
+
+class Flash_lpc4088qsb_dm(Flash_lpc4088):
+    def __init__(self, target):
+        super(Flash_lpc4088qsb_dm, self).__init__(target, flash_algo)
+
+    def programPage(self, flashPtr, bytes):
+        if SPIFI_START <= flashPtr < SPIFI_START + SPIFI_SIZE:
+            assert len(bytes) <= SPIFI_SECTOR_SIZE
+            Flash.programPage(self, flashPtr, bytes)
+        else:
+            super(Flash_lpc4088qsb_dm, self).programPage(flashPtr, bytes)
+
+class LPC4088qsb(LPC4088):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x10000,      blocksize=0x1000, isBootMemory=True),
+        FlashRegion(    start=0x10000,     length=0x70000,      blocksize=0x8000),
+        FlashRegion(    start=0x28000000,  length=0x800000,     blocksize=0x400),
+        RamRegion(      start=0x10000000,  length=0x10000),
+        )
+
+    def __init__(self, link):
+        super(LPC4088qsb, self).__init__(link, self.memoryMap)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4088.py` & `pyOCD-0.9.0/pyOCD/target/target_LPC824M201JHI33.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,78 +1,82 @@
-"""
- Flash OS Routines (Automagically Generated)
- Copyright (c) 2009-2015 ARM Limited
- 
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- 
-     http://www.apache.org/licenses/LICENSE-2.0
- 
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-""" 
-
-from flash import Flash, PageInfo, DEFAULT_PAGE_PROGRAM_WEIGHT, DEFAULT_PAGE_ERASE_WEIGHT
-
-LARGE_PAGE_START_ADDR = 0x10000
-SMALL_PAGE_SIZE = 0x1000
-LARGE_PAGE_SIZE = 0x8000
-LARGE_TO_SMALL_RATIO = LARGE_PAGE_SIZE / SMALL_PAGE_SIZE
-WRITE_SIZE = 512
-
-flash_algo = {
-    'load_address' : 0x10000000,
-    'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x28100b00, 0x210ebf24, 0x00d0eb01, 0xf6424770, 0x494d60e0, 0x60084449, 0x2100484c, 0x21aa7001, 
-    0x21557301, 0x21017301, 0x1c40f800, 0x47702000, 0x47702000, 0x41f0e92d, 0x20324c45, 0x2700444c, 
-    0x60a5251d, 0x0700e9c4, 0xf1044e42, 0x46200114, 0x696047b0, 0x2034b980, 0xe9c460a5, 0x483a0700, 
-    0x0114f104, 0x68004448, 0x462060e0, 0x696047b0, 0xbf082800, 0x81f0e8bd, 0xe8bd2001, 0xb57081f0, 
-    0x2c100b04, 0x200ebf24, 0x04d4eb00, 0x4d302032, 0x444d4e30, 0x0114f105, 0x0400e9c5, 0x60ac4628, 
-    0x696847b0, 0x2034b978, 0x0400e9c5, 0x60ac4826, 0xf1054448, 0x68000114, 0x462860e8, 0x696847b0, 
-    0xbf082800, 0x2001bd70, 0xe92dbd70, 0x461441f0, 0xd10e0005, 0x0100e9d4, 0xe9d44408, 0x44111202, 
-    0x69214408, 0x69614408, 0x69a14408, 0x42404408, 0x0b2961e0, 0xbf242910, 0xeb00200e, 0x203201d1, 
-    0x4f144e13, 0xe9c6444e, 0x60b10100, 0x0114f106, 0x47b84630, 0xb9986970, 0xe9c62033, 0xf44f0500, 
-    0xe9c67000, 0x48084002, 0x0114f106, 0x68004448, 0x46306130, 0x697047b8, 0xbf082800, 0x81f0e8bd, 
-    0xe8bd2001, 0x000081f0, 0x00000004, 0x400fc080, 0x00000008, 0x1fff1ff1, 0x00000000, 0x00000000, 
-    
-    ],
-    
-    'pc_init' : 0x1000002F,
-    'pc_unInit': 0x10000051,
-    'pc_program_page': 0x100000EB,
-    'pc_erase_sector': 0x1000009F,
-    'pc_eraseAll' : 0x10000055,
-
-    'static_base' : 0x10000000 + 0x00000020 + 0x00000200,
-    'begin_stack' : 0x10000000 + 0x00000800,            
-    # Double buffering is not supported since there is not enough ram
-    'begin_data' : 0x10000000 + 0x00000A00, # Analyzer uses a max of 120 B data (30 pages * 4 bytes / page)
-    'page_size' : 0x00001000,
-    'min_program_length' : 512,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x10002000  # Analyzer 0x10002000..0x10002600
-}
-
-
-class Flash_lpc4088(Flash):
-    def __init__(self, target, algo=None):
-        if algo is None:
-            algo = flash_algo
-        super(Flash_lpc4088, self).__init__(target, algo)
-
-    def programPage(self, flashPtr, bytes):
-        if flashPtr < LARGE_PAGE_START_ADDR:
-            assert len(bytes) <= SMALL_PAGE_SIZE
-        else:
-            assert len(bytes) <= LARGE_PAGE_SIZE
-
-        pages = (len(bytes) + WRITE_SIZE - 1) // WRITE_SIZE
-
-        for i in range(0, pages):
-            data = bytes[i * WRITE_SIZE: (i + 1) * WRITE_SIZE]
-            Flash.programPage(self, flashPtr + i * WRITE_SIZE, data)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.coresight_target import (SVDFile, CoreSightTarget)
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+
+flash_algo = {
+    'load_address' : 0x10000000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x47700a80, 0x21004842, 0x22016301, 0x63416342, 0x6b416342, 0xd0fc07c9, 0x493e6382, 0x70082002,
+    0x47702000, 0x47702000, 0x4c3bb5f8, 0x25002032, 0x261f444c, 0x493960a6, 0x60206065, 0x4f384449,
+    0x91004620, 0x696047b8, 0xd10b2800, 0x203460a6, 0x60206065, 0x60e04833, 0x99004620, 0x696047b8,
+    0xd0002800, 0xbdf82001, 0x4d2bb5f8, 0x444d0a84, 0x492a606c, 0x60ac2032, 0x60284449, 0x460f4e28,
+    0x47b04628, 0x28006968, 0x606cd10b, 0x60ac2034, 0x48246028, 0x463960e8, 0x47b04628, 0x28006968,
+    0x2001d000, 0xb5f8bdf8, 0x00054614, 0x6861d10e, 0x68e26820, 0x68a11840, 0x18401889, 0x18406921,
+    0x18406961, 0x184069a1, 0x61e04240, 0x0aa84e12, 0x2132444e, 0x60316070, 0x60b04910, 0x4f104449,
+    0x91004630, 0x697047b8, 0xd10e2800, 0x20336075, 0x603060b4, 0x02402001, 0x480a60f0, 0x46306130,
+    0x47b89900, 0x28006970, 0x2001d000, 0x0000bdf8, 0x40048040, 0x40048000, 0x00000004, 0x00000018,
+    0x1fff1ff1, 0x00002ee0, 0x00000000,
+    ],
+
+    'pc_init' : 0x10000025,
+    'pc_erase_sector' : 0x10000089,
+    'pc_program_page' : 0x100000C7,
+    'pc_eraseAll' : 0x10000049,
+    # Double buffering is not supported since sector size differs from page size
+    'static_base' : 0x10000000 + 0x00000020 + 0x00000128,
+    'begin_data' : 0x10000000 + 0x00000800, # Analyzer uses a max of 128 B data (32 pages * 4 bytes / page)
+    'begin_stack' : 0x10000800,
+    'min_program_length' : 1024,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x10001000  # Analyzer 0x10001000..0x10000600
+}
+
+
+class Flash_lpc824(Flash):
+    def __init__(self, target):
+        super(Flash_lpc824, self).__init__(target, flash_algo)
+
+    # TODO - temporary until flash algo is rebuilt with 1K page program size
+    def programPage(self, flashPtr, bytes):
+        write_size = 512
+        for i in range(0, 2):
+            data = bytes[i * write_size : (i + 1) * write_size]
+            Flash.programPage(self, flashPtr + i * write_size, data)
+
+class LPC824(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x8000,       blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x10000000,  length=0x2000)
+        )
+
+    def __init__(self, link):
+        super(LPC824, self).__init__(link, self.memoryMap)
+
+    def resetStopOnReset(self, software_reset=None, map_to_user=True):
+        super(LPC824, self).resetStopOnReset(software_reset)
+
+        # Remap to use flash and set SP and SP accordingly
+        if map_to_user:
+            self.writeMemory(0x40048000, 0x2, 32)
+            sp = self.readMemory(0x0)
+            pc = self.readMemory(0x4)
+            self.writeCoreRegisterRaw('sp', sp)
+            self.writeCoreRegisterRaw('pc', pc)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4088qsb_dm.py` & `pyOCD-0.9.0/pyOCD/target/target_lpc4088dm.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,87 +1,99 @@
-"""
- Flash OS Routines (Automagically Generated)
- Copyright (c) 2009-2015 ARM Limited
- 
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- 
-     http://www.apache.org/licenses/LICENSE-2.0
- 
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-""" 
-
-from flash_lpc4088 import Flash_lpc4088
-from flash import Flash
-
-SPIFI_START = 0x28000000
-SPIFI_SIZE = 16 * 1024 * 1024
-SPIFI_SECTOR_SIZE = 4 * 1024
-
-flash_algo = { 
-    'load_address' : 0x10000000,
-    'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x28100b00, 0x210ebf24, 0x00d0eb01, 0xe92d4770, 0xf8df4df0, 0x4606831c, 0x460c44c8, 0x0000f8d8, 
-    0x1c402500, 0x0000f8c8, 0x0f01f010, 0x461749c1, 0x2080f44f, 0x63c8bf14, 0x05306388, 0xa2f8f8df, 
-    0xf04f0d00, 0x44ca0b00, 0xf8cad111, 0xf44fb010, 0xf8ca5080, 0xe9ca6000, 0xf8ca0b01, 0xf8d8b00c, 
-    0x4651000c, 0xf1a16882, 0x47900080, 0x2018b9c0, 0xb008f8ca, 0xb003e9ca, 0xf5b4b1cc, 0xbf8c7f80, 
-    0x7b80f44f, 0x197046a3, 0x0b00e9ca, 0x000cf8d8, 0x19794aa9, 0x6843444a, 0x0080f1a2, 0xb1104798, 
-    0xe8bd2001, 0x445d8df0, 0x040bebb4, 0x2000d1e5, 0x8df0e8bd, 0x41f0e92d, 0x8274f8df, 0x60e0f642, 
-    0x4d9e44c8, 0x0008f8c8, 0x70282000, 0x732820aa, 0x73282055, 0xf8052001, 0x22000c40, 0xf0002112, 
-    0x2200f91a, 0x4610210d, 0xf915f000, 0x210d2200, 0xf0002001, 0x2200f910, 0x20022113, 0xf90bf000, 
-    0x68204c8c, 0x5000f440, 0x6a206020, 0x2084f440, 0x6c206220, 0x2000f440, 0xf44f6420, 0x63e72780, 
-    0x61a6117e, 0xf4406c68, 0x64683080, 0xf8c52002, 0x22050134, 0xf0002107, 0x2205f8ee, 0x20002116, 
-    0xf8e9f000, 0x210f2205, 0xf0002000, 0x2205f8e4, 0x20002110, 0xf8dff000, 0x21112205, 0xf0002000, 
-    0x2205f8da, 0x20002112, 0xf8d5f000, 0xf44f4874, 0x6800727a, 0xf8c86940, 0xf8d8000c, 0xfbb11008, 
-    0xf8d5f1f2, 0xf8d02134, 0xf002c000, 0xfbb1021f, 0x496cf3f2, 0xfba1486c, 0x08892103, 0x444822c0, 
-    0x280047e0, 0x61e6bf04, 0x81f0e8bd, 0x61e663a7, 0xe8bd2001, 0x200081f0, 0xe92d4770, 0x4c6341f0, 
-    0x444c2032, 0x251d2700, 0xe9c460a5, 0x4e600700, 0x0114f104, 0x47b04620, 0xb9806960, 0x60a52034, 
-    0x0700e9c4, 0xf1044852, 0x44480114, 0x60e06880, 0x47b04620, 0x28006960, 0xe8bdbf08, 0x200181f0, 
-    0x81f0e8bd, 0x5f20f1b0, 0xf5b0bf32, 0x20002f00, 0xb5704770, 0x2c100b04, 0x200ebf24, 0x04d4eb00, 
-    0x4d4a2032, 0x444d4e4a, 0x0114f105, 0x0400e9c5, 0x60ac4628, 0x696847b0, 0x2034b978, 0x0400e9c5, 
-    0x60ac483b, 0xf1054448, 0x68800114, 0x462860e8, 0x696847b0, 0xbf082800, 0x2001bd70, 0xe92dbd70, 
-    0x4f3341f0, 0x444f4605, 0x68784614, 0x1c404a31, 0xf0106078, 0xf44f0f01, 0xbf145000, 0x619061d0, 
-    0x5f20f1b5, 0x4622d305, 0x5020f1a5, 0x41f0e8bd, 0xf5b5e6bd, 0xd3052f00, 0xf5a54622, 0xe8bd2000, 
-    0xe6b441f0, 0xe9d4b975, 0x44080100, 0x1202e9d4, 0x44084411, 0x44086921, 0x44086961, 0x440869a1, 
-    0x61e04240, 0x28100b28, 0x210ebf24, 0x00d0eb01, 0x4e1e2132, 0x8078f8df, 0xe9c6444e, 0x60b01000, 
-    0x0114f106, 0x47c04630, 0xb9886970, 0xe9c62033, 0xf44f0500, 0xe9c67000, 0x68b84002, 0xf1066130, 
-    0x46300114, 0x697047c0, 0xbf082800, 0x81f0e8bd, 0xe8bd2001, 0xeb0181f0, 0x490e1040, 0x0080eb01, 
-    0xf0216801, 0x60010107, 0x43116801, 0x47706001, 0x00000004, 0x20098000, 0x000000b4, 0x400fc080, 
-    0x1fff1ff8, 0xcccccccd, 0x00000034, 0x00000014, 0x1fff1ff1, 0x4002c000, 0x00000000, 0x00000001, 
-    0x00000000, 0x00000000, 0x00000000, 
-    ],
-    
-    'pc_init' : 0x100000D5,
-    'pc_unInit': 0x100001D7,
-    'pc_program_page': 0x1000027F,
-    'pc_erase_sector': 0x10000225,
-    'pc_eraseAll' : 0x100001DB,
-
-    'static_base' : 0x10000000 + 0x00000020 + 0x00000400,
-    'begin_stack' : 0x10000000 + 0x00000800,
-    # Double buffering is not supported since there is not enough ram
-    'begin_data' : 0x10000000 + 0x00000A00,  # Analyzer uses a max of 120 B data (30 pages * 4 bytes / page)
-    'page_size' : 0x00000200,
-    'analyzer_supported' : False,
-    'min_program_length' : 512,
-    'analyzer_supported' : True,
-    'analyzer_address' : 0x10002000  # Analyzer 0x10002000..0x10002600
-}
-
-
-class Flash_lpc4088qsb_dm(Flash_lpc4088):
-    def __init__(self, target):
-        super(Flash_lpc4088qsb_dm, self).__init__(target, flash_algo)
-
-    def programPage(self, flashPtr, bytes):
-        if SPIFI_START <= flashPtr < SPIFI_START + SPIFI_SIZE:
-            assert len(bytes) <= SPIFI_SECTOR_SIZE
-            Flash.programPage(self, flashPtr, bytes)
-        else:
-            super(Flash_lpc4088qsb_dm, self).programPage(flashPtr, bytes)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+from .target_LPC4088FBD144 import (Flash_lpc4088, LPC4088)
+
+SPIFI_START = 0x28000000
+SPIFI_SIZE = 16 * 1024 * 1024
+SPIFI_SECTOR_SIZE = 4 * 1024
+
+flash_algo = {
+    'load_address' : 0x10000000,
+    'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x28100b00, 0x210ebf24, 0x00d0eb01, 0xe92d4770, 0xf8df4df0, 0x4606831c, 0x460c44c8, 0x0000f8d8,
+    0x1c402500, 0x0000f8c8, 0x0f01f010, 0x461749c1, 0x2080f44f, 0x63c8bf14, 0x05306388, 0xa2f8f8df,
+    0xf04f0d00, 0x44ca0b00, 0xf8cad111, 0xf44fb010, 0xf8ca5080, 0xe9ca6000, 0xf8ca0b01, 0xf8d8b00c,
+    0x4651000c, 0xf1a16882, 0x47900080, 0x2018b9c0, 0xb008f8ca, 0xb003e9ca, 0xf5b4b1cc, 0xbf8c7f80,
+    0x7b80f44f, 0x197046a3, 0x0b00e9ca, 0x000cf8d8, 0x19794aa9, 0x6843444a, 0x0080f1a2, 0xb1104798,
+    0xe8bd2001, 0x445d8df0, 0x040bebb4, 0x2000d1e5, 0x8df0e8bd, 0x41f0e92d, 0x8274f8df, 0x60e0f642,
+    0x4d9e44c8, 0x0008f8c8, 0x70282000, 0x732820aa, 0x73282055, 0xf8052001, 0x22000c40, 0xf0002112,
+    0x2200f91a, 0x4610210d, 0xf915f000, 0x210d2200, 0xf0002001, 0x2200f910, 0x20022113, 0xf90bf000,
+    0x68204c8c, 0x5000f440, 0x6a206020, 0x2084f440, 0x6c206220, 0x2000f440, 0xf44f6420, 0x63e72780,
+    0x61a6117e, 0xf4406c68, 0x64683080, 0xf8c52002, 0x22050134, 0xf0002107, 0x2205f8ee, 0x20002116,
+    0xf8e9f000, 0x210f2205, 0xf0002000, 0x2205f8e4, 0x20002110, 0xf8dff000, 0x21112205, 0xf0002000,
+    0x2205f8da, 0x20002112, 0xf8d5f000, 0xf44f4874, 0x6800727a, 0xf8c86940, 0xf8d8000c, 0xfbb11008,
+    0xf8d5f1f2, 0xf8d02134, 0xf002c000, 0xfbb1021f, 0x496cf3f2, 0xfba1486c, 0x08892103, 0x444822c0,
+    0x280047e0, 0x61e6bf04, 0x81f0e8bd, 0x61e663a7, 0xe8bd2001, 0x200081f0, 0xe92d4770, 0x4c6341f0,
+    0x444c2032, 0x251d2700, 0xe9c460a5, 0x4e600700, 0x0114f104, 0x47b04620, 0xb9806960, 0x60a52034,
+    0x0700e9c4, 0xf1044852, 0x44480114, 0x60e06880, 0x47b04620, 0x28006960, 0xe8bdbf08, 0x200181f0,
+    0x81f0e8bd, 0x5f20f1b0, 0xf5b0bf32, 0x20002f00, 0xb5704770, 0x2c100b04, 0x200ebf24, 0x04d4eb00,
+    0x4d4a2032, 0x444d4e4a, 0x0114f105, 0x0400e9c5, 0x60ac4628, 0x696847b0, 0x2034b978, 0x0400e9c5,
+    0x60ac483b, 0xf1054448, 0x68800114, 0x462860e8, 0x696847b0, 0xbf082800, 0x2001bd70, 0xe92dbd70,
+    0x4f3341f0, 0x444f4605, 0x68784614, 0x1c404a31, 0xf0106078, 0xf44f0f01, 0xbf145000, 0x619061d0,
+    0x5f20f1b5, 0x4622d305, 0x5020f1a5, 0x41f0e8bd, 0xf5b5e6bd, 0xd3052f00, 0xf5a54622, 0xe8bd2000,
+    0xe6b441f0, 0xe9d4b975, 0x44080100, 0x1202e9d4, 0x44084411, 0x44086921, 0x44086961, 0x440869a1,
+    0x61e04240, 0x28100b28, 0x210ebf24, 0x00d0eb01, 0x4e1e2132, 0x8078f8df, 0xe9c6444e, 0x60b01000,
+    0x0114f106, 0x47c04630, 0xb9886970, 0xe9c62033, 0xf44f0500, 0xe9c67000, 0x68b84002, 0xf1066130,
+    0x46300114, 0x697047c0, 0xbf082800, 0x81f0e8bd, 0xe8bd2001, 0xeb0181f0, 0x490e1040, 0x0080eb01,
+    0xf0216801, 0x60010107, 0x43116801, 0x47706001, 0x00000004, 0x20098000, 0x000000b4, 0x400fc080,
+    0x1fff1ff8, 0xcccccccd, 0x00000034, 0x00000014, 0x1fff1ff1, 0x4002c000, 0x00000000, 0x00000001,
+    0x00000000, 0x00000000, 0x00000000,
+    ],
+
+    'pc_init' : 0x100000D5,
+    'pc_unInit': 0x100001D7,
+    'pc_program_page': 0x1000027F,
+    'pc_erase_sector': 0x10000225,
+    'pc_eraseAll' : 0x100001DB,
+
+    'static_base' : 0x10000000 + 0x00000020 + 0x00000400,
+    'begin_stack' : 0x10000000 + 0x00000800,
+    # Double buffering is not supported since there is not enough ram
+    'begin_data' : 0x10000000 + 0x00000A00,  # Analyzer uses a max of 120 B data (30 pages * 4 bytes / page)
+    'page_size' : 0x00000200,
+    'analyzer_supported' : False,
+    'min_program_length' : 512,
+    'analyzer_supported' : True,
+    'analyzer_address' : 0x10002000  # Analyzer 0x10002000..0x10002600
+}
+
+
+class Flash_lpc4088qsb_dm(Flash_lpc4088):
+    def __init__(self, target):
+        super(Flash_lpc4088qsb_dm, self).__init__(target, flash_algo)
+
+    def programPage(self, flashPtr, bytes):
+        if SPIFI_START <= flashPtr < SPIFI_START + SPIFI_SIZE:
+            assert len(bytes) <= SPIFI_SECTOR_SIZE
+            Flash.programPage(self, flashPtr, bytes)
+        else:
+            super(Flash_lpc4088qsb_dm, self).programPage(flashPtr, bytes)
+
+class LPC4088dm(LPC4088):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x10000,      blocksize=0x1000, isBootMemory=True),
+        FlashRegion(    start=0x10000,     length=0x70000,      blocksize=0x8000),
+        FlashRegion(    start=0x28000000,  length=0x1000000,    blocksize=0x400),
+        RamRegion(      start=0x10000000,  length=0x10000),
+        )
+
+    def __init__(self, link):
+        super(LPC4088dm, self).__init__(link, self.memoryMap)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_lpc4330.py` & `pyOCD-0.9.0/pyOCD/target/target_LPC4330.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,325 +1,377 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash, DEFAULT_CHIP_ERASE_WEIGHT, FlashInfo
-
-flash_algo = { 'load_address' : 0x10000000,
-               'instructions' : [
-                        0xe00abe00, 0x062d780d, 0x24084068, 0xd3000040, 0x1e644058, 0x1c49d1fa, 0x2a001e52, 0x4770d1f2,
-                        0x4770ba40, 0x4770bac0, 0xb5104935, 0x22004449, 0x604a600a, 0x608a4a33, 0x32fff04f, 0x220860ca,
-                        0x4931610a, 0x60084449, 0x48304931, 0x49316708, 0x600820f3, 0x610820d3, 0x608860c8, 0x20136048,
-                        0x48276148, 0x4448230c, 0x210322c0, 0xf0003880, 0x2800fb23, 0x2001d000, 0x2000bd10, 0x48204770,
-                        0x44482100, 0xf1a06001, 0x68890180, 0x491d6041, 0x21046081, 0x46016101, 0xf0013880, 0x491ab890,
-                        0x4449b510, 0x1a416809, 0x44484815, 0xf44f6001, 0x60415180, 0x60814913, 0x61012120, 0x38804601,
-                        0xf87df001, 0xd0002800, 0xbd102001, 0x4a0e4613, 0x444ab510, 0x1a826812, 0x44484809, 0x2100e9c0,
-                        0x60814908, 0x60c12100, 0x61012108, 0x46194602, 0xf0003880, 0x2800ff3e, 0x2001d000, 0xbd10,
-                        0x88, 0x10080000, 0x4, 0x1000800, 0x40050000, 0x4008618c, 0x604849f9, 0xc800480,
-                        0x2801d006, 0x2802d008, 0x2803d008, 0x6948d008, 0x79269ca, 0x4770d4fc, 0xe7f97d08, 0xe7f78a88,
-                        0x7d0a8a88, 0x4002ea40, 0xb510e7f2, 0x1400f44f, 0x5141eb04, 0x6000ea41, 0x4002ea40, 0xbd104318,
-                        0x3406a80, 0xf44fd502, 0x477010c0, 0x47702000, 0x4604b510, 0x46084613, 0x46112200, 0xffe5f7ff,
-                        0x46204601, 0xffecf7ff, 0x4010e8bd, 0xe7c34308, 0xb5004bdb, 0xf7ff609a, 0x4308ffe3, 0xeb04f85d,
-                        0xb530e7ba, 0x46054cd6, 0x46114608, 0x230060a3, 0xf7ff461a, 0x4601ffca, 0xf7ff4628, 0x4301ffd1,
-                        0x69e06061, 0xd4fc0780, 0x2200bd30, 0xe7cf2106, 0x460db5f0, 0x461f4616, 0xf7ff4604, 0x463bfff6,
-                        0x46294632, 0xe8bd4620, 0xe7da40f0, 0x460db5f0, 0x461c4616, 0xf7ff4607, 0x49c1ffe8, 0x4638608e,
-                        0xffaef7ff, 0xf4404328, 0x60484000, 0xc8004a8, 0x2801d007, 0xb2a2d00b, 0xd00a2802, 0xd0042803,
-                        0x69c8614c, 0xd4fc0780, 0x828abdf0, 0x750c0c24, 0x828ae7f7, 0x49b2e7f5, 0xf01369cb, 0xd0190f06,
-                        0x61ca2210, 0xf01269ca, 0xd1fb0f16, 0xd511075a, 0xf40269c2, 0xf5b20260, 0xd30b0f40, 0x730a22ff,
-                        0xf36f69c0, 0xf100000f, 0x60480001, 0x69c87d08, 0xd4fc0780, 0xe92d4770, 0x460541f0, 0x46882400,
-                        0x21017cea, 0xf102fa01, 0x46204f9d, 0x69f9b2ce, 0xd4fc0789, 0x6c20f644, 0x45641c64, 0x2201d207,
-                        0x46282105, 0xff64f7ff, 0x4230b2c0, 0x4230d0f4, 0x75284e94, 0xea5fd00a, 0xd00c0008, 0xd00c2801,
-                        0xd0062802, 0xf03f1b8, 0xe008d10b, 0xe8bd4630, 0x4c8d81f0, 0x4c8de005, 0x4c8de003, 0xf04fe001,
-                        0x462834ff, 0xff3cf7ff, 0x4308498a, 0x43087ce9, 0x69f86078, 0xd5020780, 0xd1fa1e64, 0xb1ece01e,
-                        0x75287d38, 0xf00f1b8, 0x6ae8d01e, 0xb2c1b1e0, 0xd0172905, 0x46282201, 0xff2af7ff, 0x7568b2c0,
-                        0xea106ae9, 0xd00f2f11, 0x4107f3c1, 0x2200b119, 0xf7ff4628, 0x4873ff1d, 0xe7c81c80, 0xf7ff4628,
-                        0xe7c3ff7a, 0xe7eb7d28, 0xe7c02000, 0x4615b530, 0x460b4604, 0x46112200, 0xf7ff2001, 0x4601fef6,
-                        0x2200462b, 0xf7ff4620, 0x6aa0ff41, 0xd5010480, 0xbd302000, 0xe8bd4620, 0x21004030, 0xb5f0e77b,
-                        0x69c44605, 0x26a66a80, 0xd50b0581, 0x120f404, 0xf00f5b1, 0xf444d106, 0x61ec1400, 0xf4416a29,
-                        0x62291100, 0xd5180681, 0xd5010540, 0xe0002702, 0x1d3f2701, 0x21852201, 0xf7ff4628, 0xf000fed9,
-                        0x69e80307, 0x110f1c7, 0x20e0f400, 0x430340c8, 0x21812201, 0xf7ff4628, 0x6aa8fefb, 0xd00707c0,
-                        0x22032300, 0x462821a3, 0xfedbf7ff, 0xd1fd1e76, 0x5142f3c4, 0x29064842, 0x21a5d304, 0xf4247301,
-                        0xe0010440, 0x730121ff, 0xbdf06184, 0x4604b510, 0x6006a80, 0x2201d511, 0x4620212b, 0xfea8f7ff,
-                        0x6aa17560, 0xf4210600, 0xd5023170, 0x3080f44f, 0xf44fe001, 0x43014080, 0xbd1062a1, 0x2300b530,
-                        0x84836381, 0x84c32307, 0x8c83e010, 0x442388cc, 0x790b8483, 0x88cd8cc4, 0xd00107db, 0xe0002302,
-                        0xfb052301, 0x31084303, 0x3a0884c3, 0xd2ec2a08, 0x1ccf3c3, 0xbd3084c1, 0xb1226b82, 0x8c82b109,
-                        0x8cc0800a, 0xb1114770, 0xc126882, 0x6880800a, 0x47700cc0, 0x4604b510, 0x33cf100, 0xf7ff2100,
-                        0x1ffeb, 0x6aa0d01f, 0x7080f440, 0x462062a0, 0xfe56f7ff, 0x201ea40, 0x43024817, 0x60424810,
-                        0x7d02e002, 0x2b01f803, 0xf1a1000a, 0xb2890101, 0x2100d1f7, 0x42a33480, 0xf803d202, 0xe7fa1b01,
-                        0x78969c1, 0xbd10d4fc, 0x22011c49, 0xf04f408a, 0x60826100, 0xd900428a, 0x60c2460a, 0x4770,
-                        0x40003000, 0x20003, 0x38270, 0x419ce0, 0xa408300, 0x5204000, 0x72200000, 0x41f0e92d,
-                        0x460d4604, 0x49fe69c0, 0x46984616, 0xd06e4288, 0x62a54620, 0xff6af7ff, 0xf1b068a0, 0xd9197f80,
-                        0xf4406aa0, 0x62a07000, 0x28017c20, 0x2820d006, 0x28c2d00b, 0xf04fd009, 0xe6b81002, 0x22012380,
-                        0x46202117, 0xfe1df7ff, 0x2200e004, 0x462021b7, 0xfdfef7ff, 0xd5040568, 0x680148ea, 0x5180f041,
-                        0x4fe96001, 0xd5240768, 0x21352201, 0xf7ff4620, 0xb2c0fdef, 0x7817560, 0x7c0d455, 0x2201d135,
-                        0x46202105, 0xfde4f7ff, 0xf0417d61, 0xea400102, 0xb2822001, 0x46202102, 0xfec8f7ff, 0xd1cc2800,
-                        0x21352201, 0xf7ff4620, 0x7560fdd3, 0x7080ea4f, 0x4e8e019, 0x2201d51c, 0x46202105, 0xfdc8f7ff,
-                        0x7520b2c0, 0xd42e0641, 0x240f040, 0x46202101, 0xfeacf7ff, 0xd1b02800, 0x21052201, 0xf7ff4620,
-                        0x7520fdb7, 0x28000640, 0x4638db1d, 0xe04ee65f, 0xd5180728, 0x213f2201, 0xf7ff4620, 0xb2c0fda9,
-                        0x6017560, 0xf040d40f, 0x22010380, 0x4620213e, 0xfdcef7ff, 0x213f2201, 0xf7ff4620, 0x7560fd99,
-                        0x6000ea4f, 0x7a8e7df, 0x2200d505, 0x46202138, 0xfd8ef7ff, 0x6e8e017, 0x568d515, 0x2740d501,
-                        0x2780e000, 0x21652201, 0xf7ff4620, 0xb2c0fd81, 0x42387560, 0xf040d007, 0x43bb03c8, 0x21612201,
-                        0xf7ff4620, 0xf3c6fda5, 0x280340c1, 0xd0106aa0, 0x2080f420, 0x52862a0, 0xf3c6d507, 0x1e5b4302,
-                        0x21c02201, 0xf7ff4620, 0xe9c4fd7c, 0x20006807, 0xf440e60d, 0xe7ed2080, 0x41f0e92d, 0x46044e99,
-                        0x69b0460f, 0x46984615, 0xf40f410, 0x4601d04d, 0x40c1f3c0, 0x280361e1, 0x2000d04a, 0x462062a0,
-                        0xfda9f7ff, 0x21ff2200, 0xf7ff4620, 0x2200fd41, 0x46112301, 0xf7ff2065, 0xf440fd28, 0xf7ff10c0,
-                        0xf1a0fd0b, 0x29800140, 0x681d208, 0xf040d406, 0x220103c0, 0x46202161, 0xfd5af7ff, 0x46202180,
-                        0xfcbff001, 0xc1f005, 0xd02428c1, 0x2170f44f, 0x4107ea01, 0x50c0ea41, 0x71fff64f, 0x60304408,
-                        0x219f2203, 0xf7ff4620, 0xf04ffd13, 0x61204100, 0x1600e9c4, 0xf06fb130, 0x4288417f, 0x4973d002,
-                        0xd10b4288, 0x1d404870, 0xf440e5b1, 0xe7af0140, 0x2080f44f, 0x486ce7b2, 0xe5a81e40, 0x4080f44f,
-                        0x201c62a0, 0x209c8360, 0x4f658320, 0xd50107a8, 0xe0004638, 0xf8444866, 0x48660f1c, 0x20206060,
-                        0x200c7620, 0x20d87520, 0x201076a0, 0xf81475a0, 0xf1a40c0c, 0x287f041c, 0xdc0cd029, 0xd01d281f,
-                        0x2801dc04, 0x281cd014, 0xe014d139, 0xd0182820, 0xd1342837, 0x28c2e018, 0xdc04d022, 0xd019288c,
-                        0xd12c28bf, 0x28c8e019, 0x28efd01d, 0xe01dd127, 0x447b4b51, 0x4b51e01c, 0xe019447b, 0x447b4b50,
-                        0x4b50e016, 0xe013447b, 0x447b4b4f, 0x4b4fe010, 0xe00d447b, 0x447b4b4e, 0x4b4ee00a, 0xe007447b,
-                        0x447b4b4d, 0x4b4de004, 0xe001447b, 0x447b4b4c, 0x4642b12b, 0x46204629, 0x46064798, 0x4e3ae001,
-                        0xb3061d36, 0x61e72500, 0xf0014628, 0x2103fb1a, 0x22002301, 0xf7ff4608, 0x4601fc78, 0x46202200,
-                        0xfc96f7ff, 0xb10d4601, 0xe00020ff, 0x42812000, 0x1c6dd102, 0xdbe72d02, 0xd10a2d02, 0xf4406aa0,
-                        0x62a07000, 0x6aa0e005, 0xd5020400, 0xf7ff4620, 0x4620fe01, 0xfd73f7ff, 0xe5184630, 0x4dffe92d,
-                        0x4683b08a, 0x90032000, 0x68c6980b, 0xf7ff4658, 0x4658fcc2, 0xfdaaf7ff, 0x8028f8db, 0x4048ea5f,
-                        0xf8bbd576, 0xf0080018, 0xf4000104, 0x4308407f, 0x2001d000, 0x22014682, 0x46582105, 0xfc48f7ff,
-                        0x14f88b, 0xaea5f, 0x2201d004, 0x46582135, 0xfc3ef7ff, 0x15f88b, 0x4014f8bb, 0xd0311c70,
-                        0xf8bbb16e, 0xea240018, 0x40300200, 0xf10a4302, 0xb2c10001, 0xf7ff4658, 0x9003fd19, 0xe02ce067,
-                        0x3803fff, 0x40003000, 0x20005, 0xcccccc, 0xb813fff, 0x2808000, 0x13e1, 0xe51,
-                        0xc57, 0x1243, 0xbab, 0xd5d, 0xeef, 0x1461, 0x104f, 0xf99,
-                        0x1529, 0x7800980c, 0x980db310, 0xf8bb8802, 0x4002001a, 0x43224384, 0xf8bbe7c9, 0x4220001a,
-                        0x990cd037, 0x25002001, 0x980d7008, 0xf10a8004, 0xb2c70001, 0x1af8bb, 0xea244639, 0x46580200,
-                        0xfcd4f7ff, 0xb1209003, 0x2d031c6d, 0xe189dbf2, 0x20a6e01f, 0xd1fd1e40, 0x21052201, 0xf7ff4658,
-                        0xf88bfbd7, 0xea5f0014, 0xd004000a, 0x21352201, 0xf7ff4658, 0xf88bfbcd, 0xf8bb0015, 0xf8bb0014,
-                        0x4208101a, 0x48f9d002, 0xe16b9003, 0x28009803, 0xf418d1dd, 0xd0da3f60, 0xf8db2000, 0x46045038,
-                        0x20019006, 0xb10e9008, 0xe00020ff, 0x90092000, 0x90002000, 0xf44f980b, 0xe9d03780, 0x44081000,
-                        0xf10b9002, 0x4682003c, 0xf8db9005, 0xa907001c, 0x5040f3c0, 0x90011cc0, 0xf7ff4658, 0x9004fd1d,
-                        0xf8bdb915, 0x9006001c, 0x4008ea5f, 0xea5fd505, 0xd40250c8, 0xf7ff4658, 0x1c70fd1d, 0xb1b6d001,
-                        0x980ce104, 0xb1587800, 0x4008ea5f, 0xe9ddd5f8, 0x990d2004, 0xfa9ef001, 0xf8ad2000, 0xe0f5001c,
-                        0xf7ff4658, 0x2000fc7c, 0xe8bdb00e, 0x990c8df0, 0x70082000, 0x4008ea5f, 0xe9ddd5e2, 0x980d2104,
-                        0xfa88f001, 0x9806e0e2, 0x88e8bb28, 0x68289006, 0xf9959000, 0x28000005, 0x4240da00, 0x40872701,
-                        0x7c07928, 0x1b0d021, 0x1006ea40, 0x86ea40, 0xb2c04330, 0x20029009, 0x2c409008, 0x2c10d00c,
-                        0x2c04d00a, 0x2c01d008, 0x2c20d006, 0x2c08d00a, 0x2c02d008, 0xe017d006, 0xf7ff4658, 0xf04ffc40,
-                        0xe7c11002, 0x454ea44, 0xb10ee00e, 0xe00020ff, 0x90092000, 0x90082001, 0xd0032c30, 0xd0012c0c,
-                        0xd1012c03, 0x444ea04, 0xb125b934, 0x7c07928, 0x24c0d001, 0x2480e000, 0x6801980b, 0x44389800,
-                        0xd2784281, 0x98029900, 0xd9744288, 0x3f40f418, 0x1c70d063, 0x2e00d00b, 0xea5fdd1b, 0xd50b30c8,
-                        0x2136460b, 0x9a014658, 0xfb32f7ff, 0xf89ae04e, 0x42200000, 0xe049d1f1, 0x22002301, 0x990120e5,
-                        0xfae3f7ff, 0x23014601, 0x9a004658, 0xfb2ef7ff, 0xd13be03c, 0x30c8ea5f, 0x203cd501, 0x20e8e000,
-                        0x22002301, 0xf7ff9901, 0x4601fad0, 0x9a004658, 0xfaeef7ff, 0xea5fb2c0, 0xd5023188, 0x78943c1,
-                        0x7c0d00b, 0xea5fd025, 0xd50b30c8, 0x3200e9dd, 0x46582139, 0xfafcf7ff, 0x4658e010, 0xfbcff7ff,
-                        0xe751487a, 0x22002301, 0x990120e5, 0xfaadf7ff, 0x23004601, 0x9a004658, 0xfaf8f7ff, 0x2001990c,
-                        0xf89a7008, 0x43200000, 0xf88a, 0xbbe89803, 0xf89ae011, 0x43a00000, 0xf89ae7f6, 0x99092000,
-                        0x4ea22, 0x43084021, 0xd0044282, 0xf88a, 0x2001990c, 0x98087008, 0xd10140c4, 0xa01f10a,
-                        0xf995b135, 0x28000005, 0xf1c7da02, 0xe0000000, 0x99004638, 0x90004408, 0xf1a09806, 0x4000001,
-                        0x90060c00, 0xb10dd102, 0x508f105, 0x1cf8bd, 0x101f1a0, 0x101cf8ad, 0xf47f2800, 0x980caf14,
-                        0xb1187800, 0x4008ea5f, 0xe000d51c, 0x4658e01a, 0xfa9bf7ff, 0x99054658, 0xfa62f7ff, 0x43109a04,
-                        0x43104a4b, 0x60504a4b, 0xf811e002, 0x75100b01, 0xf1a09804, 0xb29b0301, 0x28009304, 0x69d0d1f5,
-                        0xd4fc0780, 0xf7ff4658, 0x9803fb5a, 0xb570e6dc, 0x6886680a, 0x6803b1ce, 0xd8064293, 0x684d68c4,
-                        0x4415441c, 0xd30042ac, 0x42961ad2, 0x684bd910, 0x42b34413, 0x690cd80c, 0xf30f014, 0x68c0d002,
-                        0xd8054283, 0x600a2000, 0x4830bd70, 0xbd701c80, 0x1e40482e, 0xb570bd70, 0x4615460c, 0xf7ff4606,
-                        0x4630fa8a, 0xfa51f7ff, 0x608d492a, 0xf7ff4630, 0x6a32fa17, 0x260f402, 0x6204ea42, 0x60484310,
-                        0xd0072cc7, 0xd0052c60, 0x46302101, 0x4070e8bd, 0xba91f7ff, 0xe7f82103, 0x460db570, 0x46044616,
-                        0xfa33f7ff, 0x6085481b, 0x43316a21, 0xbd706041, 0x4df0e92d, 0x460e4683, 0x46984617, 0xf8df681c,
-                        0x6855a054, 0x693be067, 0xb2d0683a, 0x7480f5c0, 0x42a5b113, 0x462cd200, 0xe0024621, 0x1e6d1c76,
-                        0x7b01e64, 0x7830d009, 0xd11828ff, 0x2c00b1f5, 0xe01bd1f4, 0x1f2d1d36, 0x68301f24, 0xd10e1c40,
-                        0xd30c2d04, 0xd2f52c04, 0xe00a, 0x20005, 0x42208000, 0x40003000, 0x1e6d1c76, 0xb12d1e64,
-                        0x2c04b124, 0x7830d202, 0xd0f528ff, 0x44101b08, 0xb3956038, 0xd0c72c00, 0x46224601, 0xf7ff4658,
-                        0x6838ffab, 0x60384420, 0x2c00e001, 0x4650d0bb, 0xd00b07b1, 0xb14cb1c5, 0x1b01f816, 0x1e6d7501,
-                        0xe7f51e64, 0x6141ce02, 0x1f241f2d, 0xd3072d04, 0xd2f72c04, 0xf816e005, 0x75011b01, 0x1e641e6d,
-                        0x2c00b115, 0xe000d1f7, 0x2102b92c, 0xf7ff4658, 0x2800fa12, 0x2d00d104, 0x2000d1d7, 0x4000f8c8,
-                        0x6800e613, 0xe0044408, 0x1c496801, 0x1d00d104, 0x2a001f12, 0x2000d1f8, 0x68134770, 0x44186800,
-                        0x40486010, 0xd0010780, 0x47702000, 0x47702001, 0x460cb53f, 0xaa02461d, 0xffeff7ff, 0xb948b335,
-                        0x9802e022, 0x1b01f814, 0x42917802, 0x1c40d11f, 0x90021e6d, 0xd00b07a0, 0xd1f22d00, 0x9802e016,
-                        0x68026821, 0xd1124291, 0x1d241d00, 0x90021f2d, 0xd2f42d04, 0x9802e008, 0x1b01f814, 0x42917802,
-                        0x1c40d105, 0x90021e6d, 0xd1f42d00, 0xb0042000, 0xb5f8bd30, 0x6811460c, 0x68559100, 0x43de469c,
-                        0x4621466a, 0xffb9f7ff, 0xf00cb385, 0xb1e803ff, 0x7a0b2f1, 0xb34dd018, 0xf8149f00, 0xf8170b01,
-                        0x40582b01, 0x4210404a, 0xd11b9700, 0xe7f01e6d, 0x68209a00, 0xea806811, 0x4071000c, 0xd1114208,
-                        0x1d241d12, 0x92001f2d, 0xd2f12d04, 0xb16db2f1, 0xf8149e00, 0xf8160b01, 0x40582b01, 0x4210404a,
-                        0xd0019600, 0xbdf82001, 0xe7f01e6d, 0x2000e7ff, 0xe92dbdf8, 0x46174df7, 0x468bb09d, 0x46392214,
-                        0xf001a802, 0x2500f85c, 0x5068f88d, 0x687ca902, 0xf7ff981d, 0x6fe9c, 0x9802d138, 0x4420901b,
-                        0x46289018, 0x69389005, 0xd4070580, 0xaa1aab07, 0x981da902, 0xfc72f7ff, 0xd1270006, 0x981de0b1,
-                        0xa01f04f, 0x1030f890, 0xf001fa0a, 0x1e429902, 0xeb004391, 0x91010801, 0xeba89902, 0x42ac0501,
-                        0x4625d200, 0x69389503, 0xd4060740, 0xaa022300, 0x981d4659, 0xff7df7ff, 0x2001b100, 0x91199902,
-                        0xd07d2800, 0x7006938, 0x48ead502, 0xe53cb020, 0xb30868b8, 0x1201e9dd, 0xa01eba2, 0x46429918,
-                        0xd2034541, 0x9a184611, 0xe0001a89, 0x46882100, 0x10aea5f, 0x460ad005, 0xf0009901, 0x9801ffbb,
-                        0xf1b89002, 0xd00a0f00, 0x464268b9, 0xaeb01, 0xf0009918, 0xe002ffaf, 0x800f04f, 0x981d46c2,
-                        0xf8909a01, 0xf7ff1034, 0x6fe56, 0x981dd003, 0xf985f7ff, 0x6938e066, 0xd5100680, 0xf7ff981d,
-                        0x981df97e, 0x99012201, 0x30f890, 0x981d4082, 0xfee7f7ff, 0xd1b92800, 0xf7ff981d, 0x2000f8cc,
-                        0x90069000, 0xa00cf8cd, 0xaa02466b, 0x981d68b9, 0xfe5ef7ff, 0x95034606, 0xf00f1b8, 0x2000d003,
-                        0xb1169006, 0x2001e008, 0x466be7fa, 0x4659aa02, 0xf7ff981d, 0x4606fe4d, 0xf8cd2001, 0x9006800c,
-                        0x68b9b966, 0x4451466b, 0x981daa02, 0xfe40f7ff, 0xd1030006, 0xb1089800, 0x1602f04f, 0xe000981d,
-                        0xf7ffe056, 0xb9eef93c, 0x6c06938, 0x462bd507, 0x9a194659, 0xf7ff981d, 0x6febb, 0x44abd112,
-                        0x2c001b64, 0xaf4bf47f, 0xb15868f8, 0x981b9005, 0x68789002, 0xab079003, 0xa902aa1a, 0xf7ff981d,
-                        0x4606fbad, 0xe7614630, 0xfff041, 0x1c6d1a45, 0xd20042ac, 0xf04f4625, 0xaa0233ff, 0x95034659,
-                        0xf7ff981d, 0xb1f0fec6, 0xf7ff981d, 0x2000f864, 0x466b9000, 0x4659aa02, 0xa018f8cd, 0xf7ff981d,
-                        0x4606fdf7, 0xf7ff981d, 0x2e00f8fa, 0x6938d1da, 0xd50b06c0, 0x4659462b, 0x981d9a19, 0xfe78f7ff,
-                        0xd1cf0006, 0x9802e002, 0x90024428, 0x1b6444ab, 0xd0b92c00, 0x45419902, 0xaf01f4bf, 0xe92de7c4,
-                        0xb09e4df3, 0x2214460c, 0xf000a802, 0x2600ff38, 0x606cf88d, 0x90016860, 0xf890981e, 0x20011030,
-                        0x901a4088, 0x9618a902, 0xf7ff981e, 0x5fd70, 0x9605d17e, 0x5806920, 0xab07d407, 0xa902aa1b,
-                        0xf7ff981e, 0x5fb4b, 0xe9ddd172, 0x44080101, 0x9000911c, 0xd16c2900, 0x6881981e, 0x42819801,
-                        0x981ed867, 0x6406a80, 0x981ed463, 0xf803f7ff, 0x461a2300, 0x981e21c7, 0xffcaf7fe, 0x981e2103,
-                        0xf819f7ff, 0x981e4605, 0xf899f7ff, 0x2703e09f, 0x4438981e, 0xf890901d, 0x28000030, 0x2101d07e,
-                        0xf800fa01, 0xf1a89802, 0xea200101, 0xeba00b01, 0xeb0b060b, 0x90190008, 0x42819900, 0x1a40d201,
-                        0x2000e000, 0x981a4682, 0xd2794286, 0xd2774582, 0xb16868a0, 0x4632b11e, 0xf0004659, 0xf1bafe8b,
-                        0xd0050f00, 0x465268a0, 0x99004430, 0xfe82f000, 0x465a981e, 0xf8904438, 0x981e1034, 0xfd2bf7ff,
-                        0x981e4605, 0xf85bf7ff, 0xd1702d00, 0x6806920, 0x981dd50a, 0x46592201, 0x30f890, 0x981e4082,
-                        0xfdbff7ff, 0xd1030005, 0xb3c068a0, 0xe0012001, 0xe048e05e, 0xb1fe9006, 0xf7fe981e, 0xe9cdff9c,
-                        0xab18b602, 0x68a1aa02, 0xf7ff981e, 0x4605fd31, 0xf7ff981e, 0xb925f834, 0xb1109818, 0x1502f04f,
-                        0x6920e045, 0xd50606c0, 0x465a4633, 0x981e68a1, 0xfdaef7ff, 0xbbd54605, 0xf00f1ba, 0x981ed017,
-                        0xff79f7fe, 0xe9cd9800, 0x68a00a02, 0x1981ab18, 0x981eaa02, 0xfd0cf7ff, 0xe0014605, 0xe006e010,
-                        0xf7ff981e, 0xbb15f80c, 0x28009818, 0x9819d1d6, 0x98019002, 0xd90b4540, 0x8eba0, 0xe0029001,
-                        0xf57f1e7f, 0x9801af65, 0xf47f2800, 0xb975af60, 0xb16068e0, 0x9002981c, 0x90036860, 0x900568e0,
-                        0xaa1bab07, 0x981ea902, 0xfa78f7ff, 0x46284605, 0xe62c, 0x2000b, 0x41f0e92d, 0x7c847c46,
-                        0x460f4605, 0xd0042e30, 0xd0072e40, 0xe8bd481c, 0xf1a481f0, 0x28070010, 0xe009d211, 0x15f1a4,
-                        0xd20c2802, 0x401cf244, 0xf2448368, 0x832850fc, 0x46281e61, 0xf878f7ff, 0xd1052e40, 0x4810e002,
-                        0xe7e41e40, 0xd50805f8, 0xf44f480e, 0x2c164188, 0x4b0dd301, 0x6a2be005, 0x480ce003, 0xf2444b0c,
-                        0x2c160104, 0x2206d301, 0x2204e000, 0x5242ea40, 0x43024808, 0xe8bd4628, 0xf7ff41f0, 0xb86f,
-                        0x20008, 0xbb010000, 0xa2888000, 0xeb030000, 0x32888000, 0x103fff, 0x41f0e92d, 0x7c404605,
-                        0xf44f460f, 0x7ca94680, 0x343f1a0, 0xb24c3a, 0x800f04f, 0xd8252b05, 0xd140094b, 0x432f1a0,
-                        0x28444616, 0x2845d006, 0x2846d00b, 0xf444d33d, 0xe03a7480, 0x22204931, 0x46284479, 0xffcef7fe,
-                        0x2901e033, 0x492dd131, 0x44792220, 0x4628310e, 0xffc4f7fe, 0x219f2204, 0xf7fe4628, 0xe00fe59,
-                        0xe022d1e5, 0xd0092865, 0xd0072866, 0xd0142886, 0xd0122887, 0x1c404820, 0x81f0e8bd, 0x456f1a0,
-                        0xd0082865, 0x8368206c, 0x80f040, 0x20008328, 0x32f885, 0x2004e009, 0x949e7f5, 0x4620d001,
-                        0x3872e7ea, 0x7440f440, 0x20524616, 0x35f885, 0xf885200f, 0xf2420031, 0x62e80005, 0x11ff004,
-                        0xf7fe4628, 0xf414ffe1, 0xd0127f40, 0x7f40f5b4, 0x5f8d301, 0xf446d504, 0x4a096180, 0xe0034b09,
-                        0x4b0a4a09, 0x108f046, 0xe8bd4628, 0xf7fe41f0, 0x4640bfe5, 0xe7bf62ae, 0x20007, 0xc54,
-                        0x3b893fff, 0xa2888000, 0x6b893fff, 0x32888000, 0x4605b570, 0x7cac7c40, 0x289d460e, 0x482dd001,
-                        0xf1a4bd70, 0x28010013, 0x380cd918, 0xd8032803, 0xf4443c11, 0xe0117480, 0xd0072c2f, 0x44f1a4,
-                        0xd8062802, 0xf4443c31, 0xe0077440, 0x7487f44f, 0xf1a4e004, 0x2802007c, 0x3c6cd820, 0x11ff004,
-                        0xd8022910, 0xf885200f, 0xf5b40032, 0xd3037f45, 0x8368203c, 0x832820bc, 0xf7fe4628, 0xf414ff85,
-                        0xd0cd7040, 0x7040f44f, 0xd3014284, 0xd50d05f1, 0x4188f44f, 0xd9044284, 0xe0034a0f, 0x1e40480d,
-                        0x4a0ebd70, 0x431a4b0e, 0xe0036a2b, 0x4b0e4a0d, 0x41a0f44f, 0xd9014284, 0xe0002006, 0xea422004,
-                        0xf6435240, 0x430270ff, 0xe8bd4628, 0xf7fe4070, 0xbf75, 0x20008, 0xbb100000, 0x3b080000,
-                        0x13fff, 0xeb133fff, 0x32888000, 0x41f0e92d, 0x7c867c45, 0x460f4604, 0xd0082d20, 0xbef005,
-                        0xd0042830, 0xd0022d38, 0xe8bd4824, 0xf1a681f0, 0x28090010, 0x4821d302, 0xe7f61e40, 0xd8032e11,
-                        0xf884200f, 0xe00c0032, 0xd10a2d20, 0xd1082e17, 0xf8042010, 0x20d80f30, 0x20007120, 0xf1a470a0,
-                        0x1e710430, 0xf7fe4620, 0x2e16ff1f, 0x2d30d006, 0x2d70d002, 0xe005d002, 0xd3032e16, 0x8360203c,
-                        0x832020bc, 0xbff005, 0xd0012830, 0xe7cc2000, 0x6a238b60, 0xc0f040, 0x5f88320, 0xf44fd503,
-                        0x4a074188, 0x4a07e004, 0x102f244, 0x13c0f443, 0xe8bd4620, 0xf7fe41f0, 0xbf11, 0x20008,
-                        0xbb913fff, 0xebdb3fff, 0x41f0e92d, 0x7c857c44, 0x460f4606, 0xd00a2c20, 0xd0082c21, 0xd0062c30,
-                        0xd0042c40, 0xd0022c41, 0xe8bd4820, 0xf1a581f0, 0x28050013, 0x481dd302, 0xe7f61e40, 0xd0012c30,
-                        0xd1052c41, 0x833020bc, 0xd1012c41, 0x8370203c, 0x46301e69, 0xfec8f7fe, 0xd5010660, 0xd50a05f8,
-                        0x4188f44f, 0xd5010660, 0xe0004a11, 0x48124a11, 0x43026a33, 0x2d16e007, 0xf44fd009, 0x4a0f5080,
-                        0xf4404b0f, 0xf0144180, 0xd0020f9f, 0x2004e005, 0x2d16e7f5, 0xf441d101, 0x6605100, 0xf442d501,
-                        0x46300280, 0x41f0e8bd, 0xbeb8f7fe, 0x20008, 0xbb100000, 0x3b080000, 0x813fff, 0xeb933fff,
-                        0x32888000, 0x41f0e92d, 0x6a064604, 0x7ca57c40, 0x2840460f, 0x4822d002, 0x81f0e8bd, 0x10f1a5,
-                        0xd83a2807, 0xf8842052, 0x200f0035, 0x31f884, 0xd00b2d10, 0xd3052d14, 0xf88420d2, 0x20110037,
-                        0x33f884, 0xd2052d16, 0xe005201c, 0xf8842000, 0xe7f90032, 0x1cf244, 0x2d168360, 0xf44fd202,
-                        0xe00170fe, 0x50fcf244, 0x1e698320, 0xf7fe4620, 0x5f8fe5b, 0xf244d503, 0x4a0a4101, 0x4a0ae005,
-                        0x105f244, 0xd3002d16, 0x48094e08, 0x43024633, 0xe8bd4620, 0xf7fe41f0, 0x4801be61, 0xe7bb1e40,
-                        0x20008, 0xbb110000, 0xeb130000, 0x32888000, 0xc03fff, 0x4ff7e92d, 0x7c847c45, 0xf04f4606,
-                        0xf44f0b00, 0x2d204a80, 0x2d24d008, 0x2d25d006, 0x2d5ed004, 0x485ad002, 0x8ffee8bd, 0x81ff004,
-                        0x10f1a8, 0xd8722809, 0x101f1a8, 0xf7fe4630, 0x4954fe1b, 0xff004, 0x2c104479, 0x83705c08,
-                        0x80f040, 0xd1028330, 0xf8862000, 0x22010032, 0x46302105, 0xfc4cf7fe, 0x7530b2c0, 0x740f010,
-                        0xf040d119, 0xf0800040, 0x21010204, 0xf7fe4630, 0xea5ffd2d, 0xd1cf0b00, 0x21052201, 0xf7fe4630,
-                        0xf080fc37, 0xb2c20004, 0xf0027532, 0x21010740, 0xf7fe4630, 0x2d20fd1b, 0x2d25d002, 0xe00fd004,
-                        0xd3122c16, 0xe010b937, 0x33f1a4, 0xd9012806, 0xd30e2c53, 0xf8862052, 0x200f0035, 0x31f886,
-                        0xd0022d20, 0xd0042d25, 0x2c17e01b, 0xb917d319, 0x2c34e034, 0xf1a8d315, 0x28060014, 0xe8dfd20f,
-                        0x703f000, 0x26211c17, 0x22104927, 0xe0034479, 0x22104925, 0x31084479, 0xf7fe4630, 0xf04ffd5f,
-                        0xb1cf0a80, 0xf4109801, 0xd1197f80, 0xe033e02b, 0x2210491d, 0x39084479, 0x491be7ee, 0x44792218,
-                        0xe7e91e89, 0x22184918, 0x310c4479, 0x4916e7e4, 0x44792218, 0xe7df311a, 0xd11b2d20, 0xd3192c15,
-                        0x2d20b137, 0x2c18d101, 0x20bbd902, 0xe0012102, 0x2101203b, 0xea400600, 0x480c42c1, 0x6180f44a,
-                        0x6a334302, 0x4b0ae002, 0x46514a0a, 0xf7fe4630, 0x4683fd95, 0xe74f4658, 0x1e404801, 0xe74c,
-                        0x20008, 0x8ec, 0x7c0, 0x813fff, 0x38908000, 0xebd33fff, 0x4602b50c, 0xe9d0a053,
-                        0xe9cd3000, 0x5c83000, 0x2a4bd505, 0x2001d801, 0x2002bd0c, 0x2000bd0c, 0x5c0b4669, 0xd2024293,
-                        0x28051c40, 0x1c40d3f9, 0xe92dbd0c, 0x46044df0, 0x468b4610, 0x7ca67c65, 0xffdef7ff, 0xf44fb2c7,
-                        0xf04f4880, 0x2d200a0c, 0x2dbad00e, 0x2dbbd00c, 0x20dbd00a, 0x2d802108, 0x2d40d01a, 0x2d71d024,
-                        0x483cd028, 0x8df0e8bd, 0xf88420d8, 0x2e110034, 0x200fd801, 0x2d20e006, 0x2e18d103, 0x2012d301,
-                        0x2010e000, 0x30f884, 0xf8842000, 0xe0110032, 0x430f104, 0x70217120, 0x20f04f, 0xf8847160,
-                        0xf1a4a001, 0xe0050430, 0x34f884, 0x1030f884, 0x840f04f, 0x10f1a6, 0xd302280a, 0x1e404825,
-                        0x1e71e7d0, 0xf7fe4620, 0x2e13fcff, 0xf8a4d202, 0xe006a01a, 0xd3042dba, 0xd3042e17, 0x8360205c,
-                        0x2d71e001, 0x2dbad011, 0x2dbbd00f, 0x2000d00d, 0xf0408b61, 0x43080080, 0x2d718320, 0xd106d322,
-                        0x3111f44f, 0x4b154a14, 0x2020e017, 0x4814e7f0, 0xea5f62e0, 0xd50650cb, 0xf2444812, 0xea404130,
-                        0x4b114207, 0x4811e005, 0xf2444b11, 0xea400130, 0x2e184207, 0xf441d301, 0x46203100, 0x4df0e8bd,
-                        0xbcdcf7fe, 0xf8c42000, 0xe78b8028, 0x5f4e3b27, 0x6c, 0x20008, 0x3b893fff, 0xa2888000,
-                        0x503070, 0xbbd83fff, 0xd2988000, 0xebd83fff, 0x12988000, 0x4604b510, 0x219f2205, 0xfae8f7fe,
-                        0x28030e00, 0x4930d001, 0x493062e1, 0xb1197d09, 0xd0052901, 0xbd10482e, 0xf8842012, 0xe0030030,
-                        0xd1012803, 0x8360203c, 0x46207ca1, 0xf7fe1e49, 0x2000fc8b, 0xb570bd10, 0x460d4604, 0x7ca17c40,
-                        0xf88422d8, 0x22102034, 0x2030f884, 0xf8842200, 0x4a1f2032, 0x28021c52, 0x2820d003, 0x1c50d013,
-                        0xf1a1bd70, 0x28020012, 0x4620d803, 0xfc6cf7fe, 0xf1a1e013, 0x28010015, 0x4813d802, 0xe7f462e0,
-                        0xd0042919, 0x2918e001, 0x4610d001, 0x4620bd70, 0xffb0f7ff, 0xfff010, 0x6ae0d1f8, 0xd0f52800,
-                        0xf4408b60, 0x83205036, 0xd50405e8, 0x4188f44f, 0x6a234a08, 0x4a08e003, 0xf2444b08, 0x46200104,
-                        0x4070e8bd, 0xbc5af7fe, 0x306005, 0x40003000, 0x20006, 0xbbd13fff, 0xebd33fff, 0x32888000,
-                        0x4604b570, 0x7c807c41, 0x29264a26, 0x2925d003, 0x1c50d02d, 0xf000bd70, 0x290301df, 0x2107d829,
-                        0x210074e1, 0x507f000, 0x1032f884, 0x113f105, 0xf7fe4620, 0x2d01fc19, 0x2d02d004, 0x2d03d006,
-                        0xe00fd10b, 0x22284918, 0xe0034479, 0x22284916, 0x31204479, 0xf7fe4620, 0x4b14fbb1, 0xf2484a14,
-                        0xe01a0102, 0x22284910, 0x31304479, 0x284be7f2, 0x4610d001, 0x2116bd70, 0xf7fe4620, 0x203cfbf5,
-                        0x20bc8360, 0x20528320, 0x35f884, 0x4b09200f, 0xf8844a09, 0xf44f0031, 0x462041c8, 0x4070e8bd,
-                        0xbbfcf7fe, 0x20007, 0x4e8, 0x2988000, 0xb993fff, 0xa2888000, 0xbb913fff, 0x4602b508,
-                        0x4669a039, 0x90006800, 0x5c0b2000, 0xd2024293, 0x28031c40, 0x1c40d3f9, 0xe92dbd08, 0x469041f0,
-                        0x460b7c47, 0x4a317c86, 0xf44f4604, 0xf44f4580, 0x2f304188, 0xf017d003, 0xd0090f8f, 0xf1a6e029,
-                        0x28040010, 0x8b20d20a, 0x20f040, 0xe0108320, 0xd01e2f70, 0x12f1a6, 0xd3022808, 0xe8bd4610,
-                        0xf24481f0, 0x8360001c, 0x10fcf244, 0x5d88320, 0x460dd500, 0x46201e71, 0xfb96f7fe, 0xf8842052,
-                        0x200f0035, 0x31f884, 0xd5050568, 0x6a234a18, 0x4816e011, 0xe7e21c40, 0xd00f2f60, 0x21022203,
-                        0x504f244, 0x4122001, 0x42c1ea42, 0x430a4911, 0xea414911, 0x2f4043c0, 0xe00ed009, 0x504f644,
-                        0xf7ff4640, 0xb2c2ff9b, 0x46012003, 0x2e14e7eb, 0x2e16d303, 0xf045d801, 0x46290501, 0xe8bd4620,
-                        0xf7fe41f0, 0xbb7b, 0x50321e, 0x20007, 0xbbd13fff, 0xebc03fff, 0x32808000, 0x49514a52,
-                        0x4a526011, 0x112f04f, 0xf1026011, 0xf04f0204, 0x60110142, 0xf04f494e, 0xfb000280, 0xf44ff001,
-                        0xfbb011e1, 0x484bf1f1, 0xb2ca60c2, 0xea4f6002, 0x60412111, 0x107f04f, 0xf04f60c1, 0x60810147,
-                        0xb1284770, 0xd0052801, 0x494320d3, 0x47706008, 0xe7fa20db, 0xe7f820c3, 0x20f34940, 0xf04f6008,
-                        0x610800d3, 0x608860c8, 0xf04f6048, 0x61480013, 0xb5f04770, 0x4c34460f, 0x3ca02100, 0x4b3861a1,
-                        0x6163e005, 0x2116962, 0xf3c2d4fc, 0x3978214d, 0xd2f62929, 0xd90128a0, 0xe00220a0, 0xd200280a,
-                        0xf44f200a, 0xfbb171a0, 0x4358f3f0, 0xfbb0210c, 0x4a2cf0f1, 0xea421e41, 0x6c624501, 0x40164e2a,
-                        0xd01342ae, 0xf3c66ee6, 0x2e0c6604, 0x4e27d101, 0x7d666e6, 0xf042d106, 0x64620201, 0x1c522200,
-                        0xd9fc2aff, 0x6c216465, 0xd0fc07c9, 0x140eb00, 0x7296f44f, 0xf81ebb2, 0x2103d201, 0x2296e006,
-                        0xf81ebb2, 0x2102d201, 0x2101e000, 0x1f12008a, 0x6210f042, 0x9a64a2, 0xf0421f12, 0x65a26210,
-                        0x66e24a08, 0x67224a12, 0x40eb00, 0xfbb50085, 0x4620f4f1, 0xff62f7ff, 0x603cb107, 0xf0f3fbb5,
-                        0xbdf0, 0xc000800, 0x400500a0, 0x40086634, 0xf4240, 0x40082000, 0x40086198, 0x4008618c,
-                        0x6800078, 0x6000080, 0xfff33c3, 0x1000800, 0x10000800, 0xf2402a03, 0xf0108030, 0xf0000c03,
-                        0xf8118015, 0xf1bc3b01, 0x44620f02, 0xf811bf98, 0xf800cb01, 0xbf383b01, 0x3b01f811, 0x204f1a2,
-                        0xf800bf98, 0xbf38cb01, 0x3b01f800, 0x303f011, 0x8025f000, 0xf0c03a08, 0xf8518008, 0x3a083b04,
-                        0xcb04f851, 0x1008e8a0, 0x1d12e7f5, 0xf851bf5c, 0xf8403b04, 0xf3af3b04, 0x7d28000, 0xf811bf24,
-                        0xf8113b01, 0xbf48cb01, 0x2b01f811, 0xf800bf24, 0xf8003b01, 0xbf48cb01, 0x2b01f800, 0xb5104770,
-                        0xf0c03a20, 0xe8b1800b, 0x3a205018, 0x5018e8a0, 0x5018e8b1, 0x5018e8a0, 0xaff5f4bf, 0x7c02ea5f,
-                        0xe8b1bf24, 0xe8a05018, 0xbf445018, 0xc018c918, 0x4010e8bd, 0x7c82ea5f, 0xf851bf24, 0xf8403b04,
-                        0xbf083b04, 0x7d24770, 0xf831bf28, 0xbf483b02, 0x2b01f811, 0xf820bf28, 0xbf483b02, 0x2b01f800,
-                        0xf04f4770, 0xb5000200, 0x46944613, 0x39204696, 0xe8a0bf22, 0xe8a0500c, 0xf1b1500c, 0xf4bf0120,
-                        0x709aff7, 0xe8a0bf28, 0xbf48500c, 0xf85dc00c, 0x89eb04, 0xf840bf28, 0xbf082b04, 0xbf484770,
-                        0x2b02f820, 0x4f80f011, 0xf800bf18, 0x47702b01, 0x0, 0x71000, 0x70000, 0x10f00,
-                        0x78000, 0x20d00, 0x7c000, 0x10e00, 0x0, 0xf1000, 0xf0000, 0x10e00,
-                        0xf4000, 0x20d00, 0xf8000, 0x10f00, 0x0, 0x100c00, 0x10000, 0xf1000,
-                        0x0, 0x100c00, 0x10000, 0x1f1000, 0x0, 0x100c00, 0x10000, 0x3f1000,
-                        0x0, 0x100c00, 0x10000, 0x7e1000, 0x7f000, 0x100c00, 0x0, 0x100c00,
-                        0x10000, 0xfe1000, 0xff000, 0x100c00, 0x0, 0x100c00, 0x10000, 0x1fe1000,
-                        0x1ff000, 0x100c00, 0x3c7c0c0c, 0x3c3c3c3c, 0x3c3c, 0x1fe000, 0x4f301, 0x6000,
-                        0x4f301, 0x1f0000, 0x1f100, 0x8000, 0x1f100, 0x1e0000, 0x1ef000, 0x3fe000,
-                        0x4f301, 0x6000, 0x4f301, 0x3f0000, 0x1f100, 0x8000, 0x1f100, 0x3e0000,
-                        0x3ef000, 0x7fe000, 0x4f301, 0x6000, 0x4f301, 0x7f0000, 0x1f100, 0x8000,
-                        0x1f100, 0x7e0000, 0x7ef000, 0x0,
-                        0x00000000,
-                        0x06802005, # movs r0, #5      ; Call pc_init routine with r0 forced to start of FLASH.
-                                    # lsls r0, r0, #26 ; start of FLASH = 5 << 26 = 0x14000000
-                        0xbef6f7fd, # b 0x10000028
-                        0x00000000
-                                ],
-               'pc_init'         : 0x10002234, # Call through thunk added to force r0 to 0x14000000
-               'pc_eraseAll'     : 0x1000007F,
-               'pc_erase_sector' : 0x1000009F,
-               'pc_program_page' : 0x100000CD,
-               'begin_data'      : 0x10004000,  # Analyzer uses a max of 128 KB data (32,768 pages * 4 bytes / page)
-               'page_buffers'    : [0x10004000, 0x10004800],   # Enable double buffering
-               'begin_stack'     : 0x10008000,
-               'static_base'     : 0x10002240,
-               'min_program_length' : 512,
-               'analyzer_supported' : False,    # Analyzer works, but would fail if a full ROM analysis was performed since there is not enough ram
-               'analyzer_address' : 0x10005000  # Analyzer 0x10005000..0x10005600
-              };
-
-class Flash_lpc4330(Flash):
-
-    def __init__(self, target):
-        super(Flash_lpc4330, self).__init__(target, flash_algo)
-        self.target.setFlash(self)
-
-    def getFlashInfo(self):
-        info = FlashInfo()
-        info.rom_start = 0x14000000
-        info.erase_weight = DEFAULT_CHIP_ERASE_WEIGHT
-        return info
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash, DEFAULT_CHIP_ERASE_WEIGHT, FlashInfo
+from ..core.coresight_target import (SVDFile, CoreSightTarget)
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+
+flash_algo = { 'load_address' : 0x10000000,
+               'instructions' : [
+                        0xe00abe00, 0x062d780d, 0x24084068, 0xd3000040, 0x1e644058, 0x1c49d1fa, 0x2a001e52, 0x4770d1f2,
+                        0x4770ba40, 0x4770bac0, 0xb5104935, 0x22004449, 0x604a600a, 0x608a4a33, 0x32fff04f, 0x220860ca,
+                        0x4931610a, 0x60084449, 0x48304931, 0x49316708, 0x600820f3, 0x610820d3, 0x608860c8, 0x20136048,
+                        0x48276148, 0x4448230c, 0x210322c0, 0xf0003880, 0x2800fb23, 0x2001d000, 0x2000bd10, 0x48204770,
+                        0x44482100, 0xf1a06001, 0x68890180, 0x491d6041, 0x21046081, 0x46016101, 0xf0013880, 0x491ab890,
+                        0x4449b510, 0x1a416809, 0x44484815, 0xf44f6001, 0x60415180, 0x60814913, 0x61012120, 0x38804601,
+                        0xf87df001, 0xd0002800, 0xbd102001, 0x4a0e4613, 0x444ab510, 0x1a826812, 0x44484809, 0x2100e9c0,
+                        0x60814908, 0x60c12100, 0x61012108, 0x46194602, 0xf0003880, 0x2800ff3e, 0x2001d000, 0xbd10,
+                        0x88, 0x10080000, 0x4, 0x1000800, 0x40050000, 0x4008618c, 0x604849f9, 0xc800480,
+                        0x2801d006, 0x2802d008, 0x2803d008, 0x6948d008, 0x79269ca, 0x4770d4fc, 0xe7f97d08, 0xe7f78a88,
+                        0x7d0a8a88, 0x4002ea40, 0xb510e7f2, 0x1400f44f, 0x5141eb04, 0x6000ea41, 0x4002ea40, 0xbd104318,
+                        0x3406a80, 0xf44fd502, 0x477010c0, 0x47702000, 0x4604b510, 0x46084613, 0x46112200, 0xffe5f7ff,
+                        0x46204601, 0xffecf7ff, 0x4010e8bd, 0xe7c34308, 0xb5004bdb, 0xf7ff609a, 0x4308ffe3, 0xeb04f85d,
+                        0xb530e7ba, 0x46054cd6, 0x46114608, 0x230060a3, 0xf7ff461a, 0x4601ffca, 0xf7ff4628, 0x4301ffd1,
+                        0x69e06061, 0xd4fc0780, 0x2200bd30, 0xe7cf2106, 0x460db5f0, 0x461f4616, 0xf7ff4604, 0x463bfff6,
+                        0x46294632, 0xe8bd4620, 0xe7da40f0, 0x460db5f0, 0x461c4616, 0xf7ff4607, 0x49c1ffe8, 0x4638608e,
+                        0xffaef7ff, 0xf4404328, 0x60484000, 0xc8004a8, 0x2801d007, 0xb2a2d00b, 0xd00a2802, 0xd0042803,
+                        0x69c8614c, 0xd4fc0780, 0x828abdf0, 0x750c0c24, 0x828ae7f7, 0x49b2e7f5, 0xf01369cb, 0xd0190f06,
+                        0x61ca2210, 0xf01269ca, 0xd1fb0f16, 0xd511075a, 0xf40269c2, 0xf5b20260, 0xd30b0f40, 0x730a22ff,
+                        0xf36f69c0, 0xf100000f, 0x60480001, 0x69c87d08, 0xd4fc0780, 0xe92d4770, 0x460541f0, 0x46882400,
+                        0x21017cea, 0xf102fa01, 0x46204f9d, 0x69f9b2ce, 0xd4fc0789, 0x6c20f644, 0x45641c64, 0x2201d207,
+                        0x46282105, 0xff64f7ff, 0x4230b2c0, 0x4230d0f4, 0x75284e94, 0xea5fd00a, 0xd00c0008, 0xd00c2801,
+                        0xd0062802, 0xf03f1b8, 0xe008d10b, 0xe8bd4630, 0x4c8d81f0, 0x4c8de005, 0x4c8de003, 0xf04fe001,
+                        0x462834ff, 0xff3cf7ff, 0x4308498a, 0x43087ce9, 0x69f86078, 0xd5020780, 0xd1fa1e64, 0xb1ece01e,
+                        0x75287d38, 0xf00f1b8, 0x6ae8d01e, 0xb2c1b1e0, 0xd0172905, 0x46282201, 0xff2af7ff, 0x7568b2c0,
+                        0xea106ae9, 0xd00f2f11, 0x4107f3c1, 0x2200b119, 0xf7ff4628, 0x4873ff1d, 0xe7c81c80, 0xf7ff4628,
+                        0xe7c3ff7a, 0xe7eb7d28, 0xe7c02000, 0x4615b530, 0x460b4604, 0x46112200, 0xf7ff2001, 0x4601fef6,
+                        0x2200462b, 0xf7ff4620, 0x6aa0ff41, 0xd5010480, 0xbd302000, 0xe8bd4620, 0x21004030, 0xb5f0e77b,
+                        0x69c44605, 0x26a66a80, 0xd50b0581, 0x120f404, 0xf00f5b1, 0xf444d106, 0x61ec1400, 0xf4416a29,
+                        0x62291100, 0xd5180681, 0xd5010540, 0xe0002702, 0x1d3f2701, 0x21852201, 0xf7ff4628, 0xf000fed9,
+                        0x69e80307, 0x110f1c7, 0x20e0f400, 0x430340c8, 0x21812201, 0xf7ff4628, 0x6aa8fefb, 0xd00707c0,
+                        0x22032300, 0x462821a3, 0xfedbf7ff, 0xd1fd1e76, 0x5142f3c4, 0x29064842, 0x21a5d304, 0xf4247301,
+                        0xe0010440, 0x730121ff, 0xbdf06184, 0x4604b510, 0x6006a80, 0x2201d511, 0x4620212b, 0xfea8f7ff,
+                        0x6aa17560, 0xf4210600, 0xd5023170, 0x3080f44f, 0xf44fe001, 0x43014080, 0xbd1062a1, 0x2300b530,
+                        0x84836381, 0x84c32307, 0x8c83e010, 0x442388cc, 0x790b8483, 0x88cd8cc4, 0xd00107db, 0xe0002302,
+                        0xfb052301, 0x31084303, 0x3a0884c3, 0xd2ec2a08, 0x1ccf3c3, 0xbd3084c1, 0xb1226b82, 0x8c82b109,
+                        0x8cc0800a, 0xb1114770, 0xc126882, 0x6880800a, 0x47700cc0, 0x4604b510, 0x33cf100, 0xf7ff2100,
+                        0x1ffeb, 0x6aa0d01f, 0x7080f440, 0x462062a0, 0xfe56f7ff, 0x201ea40, 0x43024817, 0x60424810,
+                        0x7d02e002, 0x2b01f803, 0xf1a1000a, 0xb2890101, 0x2100d1f7, 0x42a33480, 0xf803d202, 0xe7fa1b01,
+                        0x78969c1, 0xbd10d4fc, 0x22011c49, 0xf04f408a, 0x60826100, 0xd900428a, 0x60c2460a, 0x4770,
+                        0x40003000, 0x20003, 0x38270, 0x419ce0, 0xa408300, 0x5204000, 0x72200000, 0x41f0e92d,
+                        0x460d4604, 0x49fe69c0, 0x46984616, 0xd06e4288, 0x62a54620, 0xff6af7ff, 0xf1b068a0, 0xd9197f80,
+                        0xf4406aa0, 0x62a07000, 0x28017c20, 0x2820d006, 0x28c2d00b, 0xf04fd009, 0xe6b81002, 0x22012380,
+                        0x46202117, 0xfe1df7ff, 0x2200e004, 0x462021b7, 0xfdfef7ff, 0xd5040568, 0x680148ea, 0x5180f041,
+                        0x4fe96001, 0xd5240768, 0x21352201, 0xf7ff4620, 0xb2c0fdef, 0x7817560, 0x7c0d455, 0x2201d135,
+                        0x46202105, 0xfde4f7ff, 0xf0417d61, 0xea400102, 0xb2822001, 0x46202102, 0xfec8f7ff, 0xd1cc2800,
+                        0x21352201, 0xf7ff4620, 0x7560fdd3, 0x7080ea4f, 0x4e8e019, 0x2201d51c, 0x46202105, 0xfdc8f7ff,
+                        0x7520b2c0, 0xd42e0641, 0x240f040, 0x46202101, 0xfeacf7ff, 0xd1b02800, 0x21052201, 0xf7ff4620,
+                        0x7520fdb7, 0x28000640, 0x4638db1d, 0xe04ee65f, 0xd5180728, 0x213f2201, 0xf7ff4620, 0xb2c0fda9,
+                        0x6017560, 0xf040d40f, 0x22010380, 0x4620213e, 0xfdcef7ff, 0x213f2201, 0xf7ff4620, 0x7560fd99,
+                        0x6000ea4f, 0x7a8e7df, 0x2200d505, 0x46202138, 0xfd8ef7ff, 0x6e8e017, 0x568d515, 0x2740d501,
+                        0x2780e000, 0x21652201, 0xf7ff4620, 0xb2c0fd81, 0x42387560, 0xf040d007, 0x43bb03c8, 0x21612201,
+                        0xf7ff4620, 0xf3c6fda5, 0x280340c1, 0xd0106aa0, 0x2080f420, 0x52862a0, 0xf3c6d507, 0x1e5b4302,
+                        0x21c02201, 0xf7ff4620, 0xe9c4fd7c, 0x20006807, 0xf440e60d, 0xe7ed2080, 0x41f0e92d, 0x46044e99,
+                        0x69b0460f, 0x46984615, 0xf40f410, 0x4601d04d, 0x40c1f3c0, 0x280361e1, 0x2000d04a, 0x462062a0,
+                        0xfda9f7ff, 0x21ff2200, 0xf7ff4620, 0x2200fd41, 0x46112301, 0xf7ff2065, 0xf440fd28, 0xf7ff10c0,
+                        0xf1a0fd0b, 0x29800140, 0x681d208, 0xf040d406, 0x220103c0, 0x46202161, 0xfd5af7ff, 0x46202180,
+                        0xfcbff001, 0xc1f005, 0xd02428c1, 0x2170f44f, 0x4107ea01, 0x50c0ea41, 0x71fff64f, 0x60304408,
+                        0x219f2203, 0xf7ff4620, 0xf04ffd13, 0x61204100, 0x1600e9c4, 0xf06fb130, 0x4288417f, 0x4973d002,
+                        0xd10b4288, 0x1d404870, 0xf440e5b1, 0xe7af0140, 0x2080f44f, 0x486ce7b2, 0xe5a81e40, 0x4080f44f,
+                        0x201c62a0, 0x209c8360, 0x4f658320, 0xd50107a8, 0xe0004638, 0xf8444866, 0x48660f1c, 0x20206060,
+                        0x200c7620, 0x20d87520, 0x201076a0, 0xf81475a0, 0xf1a40c0c, 0x287f041c, 0xdc0cd029, 0xd01d281f,
+                        0x2801dc04, 0x281cd014, 0xe014d139, 0xd0182820, 0xd1342837, 0x28c2e018, 0xdc04d022, 0xd019288c,
+                        0xd12c28bf, 0x28c8e019, 0x28efd01d, 0xe01dd127, 0x447b4b51, 0x4b51e01c, 0xe019447b, 0x447b4b50,
+                        0x4b50e016, 0xe013447b, 0x447b4b4f, 0x4b4fe010, 0xe00d447b, 0x447b4b4e, 0x4b4ee00a, 0xe007447b,
+                        0x447b4b4d, 0x4b4de004, 0xe001447b, 0x447b4b4c, 0x4642b12b, 0x46204629, 0x46064798, 0x4e3ae001,
+                        0xb3061d36, 0x61e72500, 0xf0014628, 0x2103fb1a, 0x22002301, 0xf7ff4608, 0x4601fc78, 0x46202200,
+                        0xfc96f7ff, 0xb10d4601, 0xe00020ff, 0x42812000, 0x1c6dd102, 0xdbe72d02, 0xd10a2d02, 0xf4406aa0,
+                        0x62a07000, 0x6aa0e005, 0xd5020400, 0xf7ff4620, 0x4620fe01, 0xfd73f7ff, 0xe5184630, 0x4dffe92d,
+                        0x4683b08a, 0x90032000, 0x68c6980b, 0xf7ff4658, 0x4658fcc2, 0xfdaaf7ff, 0x8028f8db, 0x4048ea5f,
+                        0xf8bbd576, 0xf0080018, 0xf4000104, 0x4308407f, 0x2001d000, 0x22014682, 0x46582105, 0xfc48f7ff,
+                        0x14f88b, 0xaea5f, 0x2201d004, 0x46582135, 0xfc3ef7ff, 0x15f88b, 0x4014f8bb, 0xd0311c70,
+                        0xf8bbb16e, 0xea240018, 0x40300200, 0xf10a4302, 0xb2c10001, 0xf7ff4658, 0x9003fd19, 0xe02ce067,
+                        0x3803fff, 0x40003000, 0x20005, 0xcccccc, 0xb813fff, 0x2808000, 0x13e1, 0xe51,
+                        0xc57, 0x1243, 0xbab, 0xd5d, 0xeef, 0x1461, 0x104f, 0xf99,
+                        0x1529, 0x7800980c, 0x980db310, 0xf8bb8802, 0x4002001a, 0x43224384, 0xf8bbe7c9, 0x4220001a,
+                        0x990cd037, 0x25002001, 0x980d7008, 0xf10a8004, 0xb2c70001, 0x1af8bb, 0xea244639, 0x46580200,
+                        0xfcd4f7ff, 0xb1209003, 0x2d031c6d, 0xe189dbf2, 0x20a6e01f, 0xd1fd1e40, 0x21052201, 0xf7ff4658,
+                        0xf88bfbd7, 0xea5f0014, 0xd004000a, 0x21352201, 0xf7ff4658, 0xf88bfbcd, 0xf8bb0015, 0xf8bb0014,
+                        0x4208101a, 0x48f9d002, 0xe16b9003, 0x28009803, 0xf418d1dd, 0xd0da3f60, 0xf8db2000, 0x46045038,
+                        0x20019006, 0xb10e9008, 0xe00020ff, 0x90092000, 0x90002000, 0xf44f980b, 0xe9d03780, 0x44081000,
+                        0xf10b9002, 0x4682003c, 0xf8db9005, 0xa907001c, 0x5040f3c0, 0x90011cc0, 0xf7ff4658, 0x9004fd1d,
+                        0xf8bdb915, 0x9006001c, 0x4008ea5f, 0xea5fd505, 0xd40250c8, 0xf7ff4658, 0x1c70fd1d, 0xb1b6d001,
+                        0x980ce104, 0xb1587800, 0x4008ea5f, 0xe9ddd5f8, 0x990d2004, 0xfa9ef001, 0xf8ad2000, 0xe0f5001c,
+                        0xf7ff4658, 0x2000fc7c, 0xe8bdb00e, 0x990c8df0, 0x70082000, 0x4008ea5f, 0xe9ddd5e2, 0x980d2104,
+                        0xfa88f001, 0x9806e0e2, 0x88e8bb28, 0x68289006, 0xf9959000, 0x28000005, 0x4240da00, 0x40872701,
+                        0x7c07928, 0x1b0d021, 0x1006ea40, 0x86ea40, 0xb2c04330, 0x20029009, 0x2c409008, 0x2c10d00c,
+                        0x2c04d00a, 0x2c01d008, 0x2c20d006, 0x2c08d00a, 0x2c02d008, 0xe017d006, 0xf7ff4658, 0xf04ffc40,
+                        0xe7c11002, 0x454ea44, 0xb10ee00e, 0xe00020ff, 0x90092000, 0x90082001, 0xd0032c30, 0xd0012c0c,
+                        0xd1012c03, 0x444ea04, 0xb125b934, 0x7c07928, 0x24c0d001, 0x2480e000, 0x6801980b, 0x44389800,
+                        0xd2784281, 0x98029900, 0xd9744288, 0x3f40f418, 0x1c70d063, 0x2e00d00b, 0xea5fdd1b, 0xd50b30c8,
+                        0x2136460b, 0x9a014658, 0xfb32f7ff, 0xf89ae04e, 0x42200000, 0xe049d1f1, 0x22002301, 0x990120e5,
+                        0xfae3f7ff, 0x23014601, 0x9a004658, 0xfb2ef7ff, 0xd13be03c, 0x30c8ea5f, 0x203cd501, 0x20e8e000,
+                        0x22002301, 0xf7ff9901, 0x4601fad0, 0x9a004658, 0xfaeef7ff, 0xea5fb2c0, 0xd5023188, 0x78943c1,
+                        0x7c0d00b, 0xea5fd025, 0xd50b30c8, 0x3200e9dd, 0x46582139, 0xfafcf7ff, 0x4658e010, 0xfbcff7ff,
+                        0xe751487a, 0x22002301, 0x990120e5, 0xfaadf7ff, 0x23004601, 0x9a004658, 0xfaf8f7ff, 0x2001990c,
+                        0xf89a7008, 0x43200000, 0xf88a, 0xbbe89803, 0xf89ae011, 0x43a00000, 0xf89ae7f6, 0x99092000,
+                        0x4ea22, 0x43084021, 0xd0044282, 0xf88a, 0x2001990c, 0x98087008, 0xd10140c4, 0xa01f10a,
+                        0xf995b135, 0x28000005, 0xf1c7da02, 0xe0000000, 0x99004638, 0x90004408, 0xf1a09806, 0x4000001,
+                        0x90060c00, 0xb10dd102, 0x508f105, 0x1cf8bd, 0x101f1a0, 0x101cf8ad, 0xf47f2800, 0x980caf14,
+                        0xb1187800, 0x4008ea5f, 0xe000d51c, 0x4658e01a, 0xfa9bf7ff, 0x99054658, 0xfa62f7ff, 0x43109a04,
+                        0x43104a4b, 0x60504a4b, 0xf811e002, 0x75100b01, 0xf1a09804, 0xb29b0301, 0x28009304, 0x69d0d1f5,
+                        0xd4fc0780, 0xf7ff4658, 0x9803fb5a, 0xb570e6dc, 0x6886680a, 0x6803b1ce, 0xd8064293, 0x684d68c4,
+                        0x4415441c, 0xd30042ac, 0x42961ad2, 0x684bd910, 0x42b34413, 0x690cd80c, 0xf30f014, 0x68c0d002,
+                        0xd8054283, 0x600a2000, 0x4830bd70, 0xbd701c80, 0x1e40482e, 0xb570bd70, 0x4615460c, 0xf7ff4606,
+                        0x4630fa8a, 0xfa51f7ff, 0x608d492a, 0xf7ff4630, 0x6a32fa17, 0x260f402, 0x6204ea42, 0x60484310,
+                        0xd0072cc7, 0xd0052c60, 0x46302101, 0x4070e8bd, 0xba91f7ff, 0xe7f82103, 0x460db570, 0x46044616,
+                        0xfa33f7ff, 0x6085481b, 0x43316a21, 0xbd706041, 0x4df0e92d, 0x460e4683, 0x46984617, 0xf8df681c,
+                        0x6855a054, 0x693be067, 0xb2d0683a, 0x7480f5c0, 0x42a5b113, 0x462cd200, 0xe0024621, 0x1e6d1c76,
+                        0x7b01e64, 0x7830d009, 0xd11828ff, 0x2c00b1f5, 0xe01bd1f4, 0x1f2d1d36, 0x68301f24, 0xd10e1c40,
+                        0xd30c2d04, 0xd2f52c04, 0xe00a, 0x20005, 0x42208000, 0x40003000, 0x1e6d1c76, 0xb12d1e64,
+                        0x2c04b124, 0x7830d202, 0xd0f528ff, 0x44101b08, 0xb3956038, 0xd0c72c00, 0x46224601, 0xf7ff4658,
+                        0x6838ffab, 0x60384420, 0x2c00e001, 0x4650d0bb, 0xd00b07b1, 0xb14cb1c5, 0x1b01f816, 0x1e6d7501,
+                        0xe7f51e64, 0x6141ce02, 0x1f241f2d, 0xd3072d04, 0xd2f72c04, 0xf816e005, 0x75011b01, 0x1e641e6d,
+                        0x2c00b115, 0xe000d1f7, 0x2102b92c, 0xf7ff4658, 0x2800fa12, 0x2d00d104, 0x2000d1d7, 0x4000f8c8,
+                        0x6800e613, 0xe0044408, 0x1c496801, 0x1d00d104, 0x2a001f12, 0x2000d1f8, 0x68134770, 0x44186800,
+                        0x40486010, 0xd0010780, 0x47702000, 0x47702001, 0x460cb53f, 0xaa02461d, 0xffeff7ff, 0xb948b335,
+                        0x9802e022, 0x1b01f814, 0x42917802, 0x1c40d11f, 0x90021e6d, 0xd00b07a0, 0xd1f22d00, 0x9802e016,
+                        0x68026821, 0xd1124291, 0x1d241d00, 0x90021f2d, 0xd2f42d04, 0x9802e008, 0x1b01f814, 0x42917802,
+                        0x1c40d105, 0x90021e6d, 0xd1f42d00, 0xb0042000, 0xb5f8bd30, 0x6811460c, 0x68559100, 0x43de469c,
+                        0x4621466a, 0xffb9f7ff, 0xf00cb385, 0xb1e803ff, 0x7a0b2f1, 0xb34dd018, 0xf8149f00, 0xf8170b01,
+                        0x40582b01, 0x4210404a, 0xd11b9700, 0xe7f01e6d, 0x68209a00, 0xea806811, 0x4071000c, 0xd1114208,
+                        0x1d241d12, 0x92001f2d, 0xd2f12d04, 0xb16db2f1, 0xf8149e00, 0xf8160b01, 0x40582b01, 0x4210404a,
+                        0xd0019600, 0xbdf82001, 0xe7f01e6d, 0x2000e7ff, 0xe92dbdf8, 0x46174df7, 0x468bb09d, 0x46392214,
+                        0xf001a802, 0x2500f85c, 0x5068f88d, 0x687ca902, 0xf7ff981d, 0x6fe9c, 0x9802d138, 0x4420901b,
+                        0x46289018, 0x69389005, 0xd4070580, 0xaa1aab07, 0x981da902, 0xfc72f7ff, 0xd1270006, 0x981de0b1,
+                        0xa01f04f, 0x1030f890, 0xf001fa0a, 0x1e429902, 0xeb004391, 0x91010801, 0xeba89902, 0x42ac0501,
+                        0x4625d200, 0x69389503, 0xd4060740, 0xaa022300, 0x981d4659, 0xff7df7ff, 0x2001b100, 0x91199902,
+                        0xd07d2800, 0x7006938, 0x48ead502, 0xe53cb020, 0xb30868b8, 0x1201e9dd, 0xa01eba2, 0x46429918,
+                        0xd2034541, 0x9a184611, 0xe0001a89, 0x46882100, 0x10aea5f, 0x460ad005, 0xf0009901, 0x9801ffbb,
+                        0xf1b89002, 0xd00a0f00, 0x464268b9, 0xaeb01, 0xf0009918, 0xe002ffaf, 0x800f04f, 0x981d46c2,
+                        0xf8909a01, 0xf7ff1034, 0x6fe56, 0x981dd003, 0xf985f7ff, 0x6938e066, 0xd5100680, 0xf7ff981d,
+                        0x981df97e, 0x99012201, 0x30f890, 0x981d4082, 0xfee7f7ff, 0xd1b92800, 0xf7ff981d, 0x2000f8cc,
+                        0x90069000, 0xa00cf8cd, 0xaa02466b, 0x981d68b9, 0xfe5ef7ff, 0x95034606, 0xf00f1b8, 0x2000d003,
+                        0xb1169006, 0x2001e008, 0x466be7fa, 0x4659aa02, 0xf7ff981d, 0x4606fe4d, 0xf8cd2001, 0x9006800c,
+                        0x68b9b966, 0x4451466b, 0x981daa02, 0xfe40f7ff, 0xd1030006, 0xb1089800, 0x1602f04f, 0xe000981d,
+                        0xf7ffe056, 0xb9eef93c, 0x6c06938, 0x462bd507, 0x9a194659, 0xf7ff981d, 0x6febb, 0x44abd112,
+                        0x2c001b64, 0xaf4bf47f, 0xb15868f8, 0x981b9005, 0x68789002, 0xab079003, 0xa902aa1a, 0xf7ff981d,
+                        0x4606fbad, 0xe7614630, 0xfff041, 0x1c6d1a45, 0xd20042ac, 0xf04f4625, 0xaa0233ff, 0x95034659,
+                        0xf7ff981d, 0xb1f0fec6, 0xf7ff981d, 0x2000f864, 0x466b9000, 0x4659aa02, 0xa018f8cd, 0xf7ff981d,
+                        0x4606fdf7, 0xf7ff981d, 0x2e00f8fa, 0x6938d1da, 0xd50b06c0, 0x4659462b, 0x981d9a19, 0xfe78f7ff,
+                        0xd1cf0006, 0x9802e002, 0x90024428, 0x1b6444ab, 0xd0b92c00, 0x45419902, 0xaf01f4bf, 0xe92de7c4,
+                        0xb09e4df3, 0x2214460c, 0xf000a802, 0x2600ff38, 0x606cf88d, 0x90016860, 0xf890981e, 0x20011030,
+                        0x901a4088, 0x9618a902, 0xf7ff981e, 0x5fd70, 0x9605d17e, 0x5806920, 0xab07d407, 0xa902aa1b,
+                        0xf7ff981e, 0x5fb4b, 0xe9ddd172, 0x44080101, 0x9000911c, 0xd16c2900, 0x6881981e, 0x42819801,
+                        0x981ed867, 0x6406a80, 0x981ed463, 0xf803f7ff, 0x461a2300, 0x981e21c7, 0xffcaf7fe, 0x981e2103,
+                        0xf819f7ff, 0x981e4605, 0xf899f7ff, 0x2703e09f, 0x4438981e, 0xf890901d, 0x28000030, 0x2101d07e,
+                        0xf800fa01, 0xf1a89802, 0xea200101, 0xeba00b01, 0xeb0b060b, 0x90190008, 0x42819900, 0x1a40d201,
+                        0x2000e000, 0x981a4682, 0xd2794286, 0xd2774582, 0xb16868a0, 0x4632b11e, 0xf0004659, 0xf1bafe8b,
+                        0xd0050f00, 0x465268a0, 0x99004430, 0xfe82f000, 0x465a981e, 0xf8904438, 0x981e1034, 0xfd2bf7ff,
+                        0x981e4605, 0xf85bf7ff, 0xd1702d00, 0x6806920, 0x981dd50a, 0x46592201, 0x30f890, 0x981e4082,
+                        0xfdbff7ff, 0xd1030005, 0xb3c068a0, 0xe0012001, 0xe048e05e, 0xb1fe9006, 0xf7fe981e, 0xe9cdff9c,
+                        0xab18b602, 0x68a1aa02, 0xf7ff981e, 0x4605fd31, 0xf7ff981e, 0xb925f834, 0xb1109818, 0x1502f04f,
+                        0x6920e045, 0xd50606c0, 0x465a4633, 0x981e68a1, 0xfdaef7ff, 0xbbd54605, 0xf00f1ba, 0x981ed017,
+                        0xff79f7fe, 0xe9cd9800, 0x68a00a02, 0x1981ab18, 0x981eaa02, 0xfd0cf7ff, 0xe0014605, 0xe006e010,
+                        0xf7ff981e, 0xbb15f80c, 0x28009818, 0x9819d1d6, 0x98019002, 0xd90b4540, 0x8eba0, 0xe0029001,
+                        0xf57f1e7f, 0x9801af65, 0xf47f2800, 0xb975af60, 0xb16068e0, 0x9002981c, 0x90036860, 0x900568e0,
+                        0xaa1bab07, 0x981ea902, 0xfa78f7ff, 0x46284605, 0xe62c, 0x2000b, 0x41f0e92d, 0x7c847c46,
+                        0x460f4605, 0xd0042e30, 0xd0072e40, 0xe8bd481c, 0xf1a481f0, 0x28070010, 0xe009d211, 0x15f1a4,
+                        0xd20c2802, 0x401cf244, 0xf2448368, 0x832850fc, 0x46281e61, 0xf878f7ff, 0xd1052e40, 0x4810e002,
+                        0xe7e41e40, 0xd50805f8, 0xf44f480e, 0x2c164188, 0x4b0dd301, 0x6a2be005, 0x480ce003, 0xf2444b0c,
+                        0x2c160104, 0x2206d301, 0x2204e000, 0x5242ea40, 0x43024808, 0xe8bd4628, 0xf7ff41f0, 0xb86f,
+                        0x20008, 0xbb010000, 0xa2888000, 0xeb030000, 0x32888000, 0x103fff, 0x41f0e92d, 0x7c404605,
+                        0xf44f460f, 0x7ca94680, 0x343f1a0, 0xb24c3a, 0x800f04f, 0xd8252b05, 0xd140094b, 0x432f1a0,
+                        0x28444616, 0x2845d006, 0x2846d00b, 0xf444d33d, 0xe03a7480, 0x22204931, 0x46284479, 0xffcef7fe,
+                        0x2901e033, 0x492dd131, 0x44792220, 0x4628310e, 0xffc4f7fe, 0x219f2204, 0xf7fe4628, 0xe00fe59,
+                        0xe022d1e5, 0xd0092865, 0xd0072866, 0xd0142886, 0xd0122887, 0x1c404820, 0x81f0e8bd, 0x456f1a0,
+                        0xd0082865, 0x8368206c, 0x80f040, 0x20008328, 0x32f885, 0x2004e009, 0x949e7f5, 0x4620d001,
+                        0x3872e7ea, 0x7440f440, 0x20524616, 0x35f885, 0xf885200f, 0xf2420031, 0x62e80005, 0x11ff004,
+                        0xf7fe4628, 0xf414ffe1, 0xd0127f40, 0x7f40f5b4, 0x5f8d301, 0xf446d504, 0x4a096180, 0xe0034b09,
+                        0x4b0a4a09, 0x108f046, 0xe8bd4628, 0xf7fe41f0, 0x4640bfe5, 0xe7bf62ae, 0x20007, 0xc54,
+                        0x3b893fff, 0xa2888000, 0x6b893fff, 0x32888000, 0x4605b570, 0x7cac7c40, 0x289d460e, 0x482dd001,
+                        0xf1a4bd70, 0x28010013, 0x380cd918, 0xd8032803, 0xf4443c11, 0xe0117480, 0xd0072c2f, 0x44f1a4,
+                        0xd8062802, 0xf4443c31, 0xe0077440, 0x7487f44f, 0xf1a4e004, 0x2802007c, 0x3c6cd820, 0x11ff004,
+                        0xd8022910, 0xf885200f, 0xf5b40032, 0xd3037f45, 0x8368203c, 0x832820bc, 0xf7fe4628, 0xf414ff85,
+                        0xd0cd7040, 0x7040f44f, 0xd3014284, 0xd50d05f1, 0x4188f44f, 0xd9044284, 0xe0034a0f, 0x1e40480d,
+                        0x4a0ebd70, 0x431a4b0e, 0xe0036a2b, 0x4b0e4a0d, 0x41a0f44f, 0xd9014284, 0xe0002006, 0xea422004,
+                        0xf6435240, 0x430270ff, 0xe8bd4628, 0xf7fe4070, 0xbf75, 0x20008, 0xbb100000, 0x3b080000,
+                        0x13fff, 0xeb133fff, 0x32888000, 0x41f0e92d, 0x7c867c45, 0x460f4604, 0xd0082d20, 0xbef005,
+                        0xd0042830, 0xd0022d38, 0xe8bd4824, 0xf1a681f0, 0x28090010, 0x4821d302, 0xe7f61e40, 0xd8032e11,
+                        0xf884200f, 0xe00c0032, 0xd10a2d20, 0xd1082e17, 0xf8042010, 0x20d80f30, 0x20007120, 0xf1a470a0,
+                        0x1e710430, 0xf7fe4620, 0x2e16ff1f, 0x2d30d006, 0x2d70d002, 0xe005d002, 0xd3032e16, 0x8360203c,
+                        0x832020bc, 0xbff005, 0xd0012830, 0xe7cc2000, 0x6a238b60, 0xc0f040, 0x5f88320, 0xf44fd503,
+                        0x4a074188, 0x4a07e004, 0x102f244, 0x13c0f443, 0xe8bd4620, 0xf7fe41f0, 0xbf11, 0x20008,
+                        0xbb913fff, 0xebdb3fff, 0x41f0e92d, 0x7c857c44, 0x460f4606, 0xd00a2c20, 0xd0082c21, 0xd0062c30,
+                        0xd0042c40, 0xd0022c41, 0xe8bd4820, 0xf1a581f0, 0x28050013, 0x481dd302, 0xe7f61e40, 0xd0012c30,
+                        0xd1052c41, 0x833020bc, 0xd1012c41, 0x8370203c, 0x46301e69, 0xfec8f7fe, 0xd5010660, 0xd50a05f8,
+                        0x4188f44f, 0xd5010660, 0xe0004a11, 0x48124a11, 0x43026a33, 0x2d16e007, 0xf44fd009, 0x4a0f5080,
+                        0xf4404b0f, 0xf0144180, 0xd0020f9f, 0x2004e005, 0x2d16e7f5, 0xf441d101, 0x6605100, 0xf442d501,
+                        0x46300280, 0x41f0e8bd, 0xbeb8f7fe, 0x20008, 0xbb100000, 0x3b080000, 0x813fff, 0xeb933fff,
+                        0x32888000, 0x41f0e92d, 0x6a064604, 0x7ca57c40, 0x2840460f, 0x4822d002, 0x81f0e8bd, 0x10f1a5,
+                        0xd83a2807, 0xf8842052, 0x200f0035, 0x31f884, 0xd00b2d10, 0xd3052d14, 0xf88420d2, 0x20110037,
+                        0x33f884, 0xd2052d16, 0xe005201c, 0xf8842000, 0xe7f90032, 0x1cf244, 0x2d168360, 0xf44fd202,
+                        0xe00170fe, 0x50fcf244, 0x1e698320, 0xf7fe4620, 0x5f8fe5b, 0xf244d503, 0x4a0a4101, 0x4a0ae005,
+                        0x105f244, 0xd3002d16, 0x48094e08, 0x43024633, 0xe8bd4620, 0xf7fe41f0, 0x4801be61, 0xe7bb1e40,
+                        0x20008, 0xbb110000, 0xeb130000, 0x32888000, 0xc03fff, 0x4ff7e92d, 0x7c847c45, 0xf04f4606,
+                        0xf44f0b00, 0x2d204a80, 0x2d24d008, 0x2d25d006, 0x2d5ed004, 0x485ad002, 0x8ffee8bd, 0x81ff004,
+                        0x10f1a8, 0xd8722809, 0x101f1a8, 0xf7fe4630, 0x4954fe1b, 0xff004, 0x2c104479, 0x83705c08,
+                        0x80f040, 0xd1028330, 0xf8862000, 0x22010032, 0x46302105, 0xfc4cf7fe, 0x7530b2c0, 0x740f010,
+                        0xf040d119, 0xf0800040, 0x21010204, 0xf7fe4630, 0xea5ffd2d, 0xd1cf0b00, 0x21052201, 0xf7fe4630,
+                        0xf080fc37, 0xb2c20004, 0xf0027532, 0x21010740, 0xf7fe4630, 0x2d20fd1b, 0x2d25d002, 0xe00fd004,
+                        0xd3122c16, 0xe010b937, 0x33f1a4, 0xd9012806, 0xd30e2c53, 0xf8862052, 0x200f0035, 0x31f886,
+                        0xd0022d20, 0xd0042d25, 0x2c17e01b, 0xb917d319, 0x2c34e034, 0xf1a8d315, 0x28060014, 0xe8dfd20f,
+                        0x703f000, 0x26211c17, 0x22104927, 0xe0034479, 0x22104925, 0x31084479, 0xf7fe4630, 0xf04ffd5f,
+                        0xb1cf0a80, 0xf4109801, 0xd1197f80, 0xe033e02b, 0x2210491d, 0x39084479, 0x491be7ee, 0x44792218,
+                        0xe7e91e89, 0x22184918, 0x310c4479, 0x4916e7e4, 0x44792218, 0xe7df311a, 0xd11b2d20, 0xd3192c15,
+                        0x2d20b137, 0x2c18d101, 0x20bbd902, 0xe0012102, 0x2101203b, 0xea400600, 0x480c42c1, 0x6180f44a,
+                        0x6a334302, 0x4b0ae002, 0x46514a0a, 0xf7fe4630, 0x4683fd95, 0xe74f4658, 0x1e404801, 0xe74c,
+                        0x20008, 0x8ec, 0x7c0, 0x813fff, 0x38908000, 0xebd33fff, 0x4602b50c, 0xe9d0a053,
+                        0xe9cd3000, 0x5c83000, 0x2a4bd505, 0x2001d801, 0x2002bd0c, 0x2000bd0c, 0x5c0b4669, 0xd2024293,
+                        0x28051c40, 0x1c40d3f9, 0xe92dbd0c, 0x46044df0, 0x468b4610, 0x7ca67c65, 0xffdef7ff, 0xf44fb2c7,
+                        0xf04f4880, 0x2d200a0c, 0x2dbad00e, 0x2dbbd00c, 0x20dbd00a, 0x2d802108, 0x2d40d01a, 0x2d71d024,
+                        0x483cd028, 0x8df0e8bd, 0xf88420d8, 0x2e110034, 0x200fd801, 0x2d20e006, 0x2e18d103, 0x2012d301,
+                        0x2010e000, 0x30f884, 0xf8842000, 0xe0110032, 0x430f104, 0x70217120, 0x20f04f, 0xf8847160,
+                        0xf1a4a001, 0xe0050430, 0x34f884, 0x1030f884, 0x840f04f, 0x10f1a6, 0xd302280a, 0x1e404825,
+                        0x1e71e7d0, 0xf7fe4620, 0x2e13fcff, 0xf8a4d202, 0xe006a01a, 0xd3042dba, 0xd3042e17, 0x8360205c,
+                        0x2d71e001, 0x2dbad011, 0x2dbbd00f, 0x2000d00d, 0xf0408b61, 0x43080080, 0x2d718320, 0xd106d322,
+                        0x3111f44f, 0x4b154a14, 0x2020e017, 0x4814e7f0, 0xea5f62e0, 0xd50650cb, 0xf2444812, 0xea404130,
+                        0x4b114207, 0x4811e005, 0xf2444b11, 0xea400130, 0x2e184207, 0xf441d301, 0x46203100, 0x4df0e8bd,
+                        0xbcdcf7fe, 0xf8c42000, 0xe78b8028, 0x5f4e3b27, 0x6c, 0x20008, 0x3b893fff, 0xa2888000,
+                        0x503070, 0xbbd83fff, 0xd2988000, 0xebd83fff, 0x12988000, 0x4604b510, 0x219f2205, 0xfae8f7fe,
+                        0x28030e00, 0x4930d001, 0x493062e1, 0xb1197d09, 0xd0052901, 0xbd10482e, 0xf8842012, 0xe0030030,
+                        0xd1012803, 0x8360203c, 0x46207ca1, 0xf7fe1e49, 0x2000fc8b, 0xb570bd10, 0x460d4604, 0x7ca17c40,
+                        0xf88422d8, 0x22102034, 0x2030f884, 0xf8842200, 0x4a1f2032, 0x28021c52, 0x2820d003, 0x1c50d013,
+                        0xf1a1bd70, 0x28020012, 0x4620d803, 0xfc6cf7fe, 0xf1a1e013, 0x28010015, 0x4813d802, 0xe7f462e0,
+                        0xd0042919, 0x2918e001, 0x4610d001, 0x4620bd70, 0xffb0f7ff, 0xfff010, 0x6ae0d1f8, 0xd0f52800,
+                        0xf4408b60, 0x83205036, 0xd50405e8, 0x4188f44f, 0x6a234a08, 0x4a08e003, 0xf2444b08, 0x46200104,
+                        0x4070e8bd, 0xbc5af7fe, 0x306005, 0x40003000, 0x20006, 0xbbd13fff, 0xebd33fff, 0x32888000,
+                        0x4604b570, 0x7c807c41, 0x29264a26, 0x2925d003, 0x1c50d02d, 0xf000bd70, 0x290301df, 0x2107d829,
+                        0x210074e1, 0x507f000, 0x1032f884, 0x113f105, 0xf7fe4620, 0x2d01fc19, 0x2d02d004, 0x2d03d006,
+                        0xe00fd10b, 0x22284918, 0xe0034479, 0x22284916, 0x31204479, 0xf7fe4620, 0x4b14fbb1, 0xf2484a14,
+                        0xe01a0102, 0x22284910, 0x31304479, 0x284be7f2, 0x4610d001, 0x2116bd70, 0xf7fe4620, 0x203cfbf5,
+                        0x20bc8360, 0x20528320, 0x35f884, 0x4b09200f, 0xf8844a09, 0xf44f0031, 0x462041c8, 0x4070e8bd,
+                        0xbbfcf7fe, 0x20007, 0x4e8, 0x2988000, 0xb993fff, 0xa2888000, 0xbb913fff, 0x4602b508,
+                        0x4669a039, 0x90006800, 0x5c0b2000, 0xd2024293, 0x28031c40, 0x1c40d3f9, 0xe92dbd08, 0x469041f0,
+                        0x460b7c47, 0x4a317c86, 0xf44f4604, 0xf44f4580, 0x2f304188, 0xf017d003, 0xd0090f8f, 0xf1a6e029,
+                        0x28040010, 0x8b20d20a, 0x20f040, 0xe0108320, 0xd01e2f70, 0x12f1a6, 0xd3022808, 0xe8bd4610,
+                        0xf24481f0, 0x8360001c, 0x10fcf244, 0x5d88320, 0x460dd500, 0x46201e71, 0xfb96f7fe, 0xf8842052,
+                        0x200f0035, 0x31f884, 0xd5050568, 0x6a234a18, 0x4816e011, 0xe7e21c40, 0xd00f2f60, 0x21022203,
+                        0x504f244, 0x4122001, 0x42c1ea42, 0x430a4911, 0xea414911, 0x2f4043c0, 0xe00ed009, 0x504f644,
+                        0xf7ff4640, 0xb2c2ff9b, 0x46012003, 0x2e14e7eb, 0x2e16d303, 0xf045d801, 0x46290501, 0xe8bd4620,
+                        0xf7fe41f0, 0xbb7b, 0x50321e, 0x20007, 0xbbd13fff, 0xebc03fff, 0x32808000, 0x49514a52,
+                        0x4a526011, 0x112f04f, 0xf1026011, 0xf04f0204, 0x60110142, 0xf04f494e, 0xfb000280, 0xf44ff001,
+                        0xfbb011e1, 0x484bf1f1, 0xb2ca60c2, 0xea4f6002, 0x60412111, 0x107f04f, 0xf04f60c1, 0x60810147,
+                        0xb1284770, 0xd0052801, 0x494320d3, 0x47706008, 0xe7fa20db, 0xe7f820c3, 0x20f34940, 0xf04f6008,
+                        0x610800d3, 0x608860c8, 0xf04f6048, 0x61480013, 0xb5f04770, 0x4c34460f, 0x3ca02100, 0x4b3861a1,
+                        0x6163e005, 0x2116962, 0xf3c2d4fc, 0x3978214d, 0xd2f62929, 0xd90128a0, 0xe00220a0, 0xd200280a,
+                        0xf44f200a, 0xfbb171a0, 0x4358f3f0, 0xfbb0210c, 0x4a2cf0f1, 0xea421e41, 0x6c624501, 0x40164e2a,
+                        0xd01342ae, 0xf3c66ee6, 0x2e0c6604, 0x4e27d101, 0x7d666e6, 0xf042d106, 0x64620201, 0x1c522200,
+                        0xd9fc2aff, 0x6c216465, 0xd0fc07c9, 0x140eb00, 0x7296f44f, 0xf81ebb2, 0x2103d201, 0x2296e006,
+                        0xf81ebb2, 0x2102d201, 0x2101e000, 0x1f12008a, 0x6210f042, 0x9a64a2, 0xf0421f12, 0x65a26210,
+                        0x66e24a08, 0x67224a12, 0x40eb00, 0xfbb50085, 0x4620f4f1, 0xff62f7ff, 0x603cb107, 0xf0f3fbb5,
+                        0xbdf0, 0xc000800, 0x400500a0, 0x40086634, 0xf4240, 0x40082000, 0x40086198, 0x4008618c,
+                        0x6800078, 0x6000080, 0xfff33c3, 0x1000800, 0x10000800, 0xf2402a03, 0xf0108030, 0xf0000c03,
+                        0xf8118015, 0xf1bc3b01, 0x44620f02, 0xf811bf98, 0xf800cb01, 0xbf383b01, 0x3b01f811, 0x204f1a2,
+                        0xf800bf98, 0xbf38cb01, 0x3b01f800, 0x303f011, 0x8025f000, 0xf0c03a08, 0xf8518008, 0x3a083b04,
+                        0xcb04f851, 0x1008e8a0, 0x1d12e7f5, 0xf851bf5c, 0xf8403b04, 0xf3af3b04, 0x7d28000, 0xf811bf24,
+                        0xf8113b01, 0xbf48cb01, 0x2b01f811, 0xf800bf24, 0xf8003b01, 0xbf48cb01, 0x2b01f800, 0xb5104770,
+                        0xf0c03a20, 0xe8b1800b, 0x3a205018, 0x5018e8a0, 0x5018e8b1, 0x5018e8a0, 0xaff5f4bf, 0x7c02ea5f,
+                        0xe8b1bf24, 0xe8a05018, 0xbf445018, 0xc018c918, 0x4010e8bd, 0x7c82ea5f, 0xf851bf24, 0xf8403b04,
+                        0xbf083b04, 0x7d24770, 0xf831bf28, 0xbf483b02, 0x2b01f811, 0xf820bf28, 0xbf483b02, 0x2b01f800,
+                        0xf04f4770, 0xb5000200, 0x46944613, 0x39204696, 0xe8a0bf22, 0xe8a0500c, 0xf1b1500c, 0xf4bf0120,
+                        0x709aff7, 0xe8a0bf28, 0xbf48500c, 0xf85dc00c, 0x89eb04, 0xf840bf28, 0xbf082b04, 0xbf484770,
+                        0x2b02f820, 0x4f80f011, 0xf800bf18, 0x47702b01, 0x0, 0x71000, 0x70000, 0x10f00,
+                        0x78000, 0x20d00, 0x7c000, 0x10e00, 0x0, 0xf1000, 0xf0000, 0x10e00,
+                        0xf4000, 0x20d00, 0xf8000, 0x10f00, 0x0, 0x100c00, 0x10000, 0xf1000,
+                        0x0, 0x100c00, 0x10000, 0x1f1000, 0x0, 0x100c00, 0x10000, 0x3f1000,
+                        0x0, 0x100c00, 0x10000, 0x7e1000, 0x7f000, 0x100c00, 0x0, 0x100c00,
+                        0x10000, 0xfe1000, 0xff000, 0x100c00, 0x0, 0x100c00, 0x10000, 0x1fe1000,
+                        0x1ff000, 0x100c00, 0x3c7c0c0c, 0x3c3c3c3c, 0x3c3c, 0x1fe000, 0x4f301, 0x6000,
+                        0x4f301, 0x1f0000, 0x1f100, 0x8000, 0x1f100, 0x1e0000, 0x1ef000, 0x3fe000,
+                        0x4f301, 0x6000, 0x4f301, 0x3f0000, 0x1f100, 0x8000, 0x1f100, 0x3e0000,
+                        0x3ef000, 0x7fe000, 0x4f301, 0x6000, 0x4f301, 0x7f0000, 0x1f100, 0x8000,
+                        0x1f100, 0x7e0000, 0x7ef000, 0x0,
+                        0x00000000,
+                        0x06802005, # movs r0, #5      ; Call pc_init routine with r0 forced to start of FLASH.
+                                    # lsls r0, r0, #26 ; start of FLASH = 5 << 26 = 0x14000000
+                        0xbef6f7fd, # b 0x10000028
+                        0x00000000
+                                ],
+               'pc_init'         : 0x10002234, # Call through thunk added to force r0 to 0x14000000
+               'pc_eraseAll'     : 0x1000007F,
+               'pc_erase_sector' : 0x1000009F,
+               'pc_program_page' : 0x100000CD,
+               'begin_data'      : 0x10004000,  # Analyzer uses a max of 128 KB data (32,768 pages * 4 bytes / page)
+               'page_buffers'    : [0x10004000, 0x10004800],   # Enable double buffering
+               'begin_stack'     : 0x10008000,
+               'static_base'     : 0x10002240,
+               'min_program_length' : 512,
+               'analyzer_supported' : False,    # Analyzer works, but would fail if a full ROM analysis was performed since there is not enough ram
+               'analyzer_address' : 0x10005000  # Analyzer 0x10005000..0x10005600
+              };
+
+class Flash_lpc4330(Flash):
+
+    def __init__(self, target):
+        super(Flash_lpc4330, self).__init__(target, flash_algo)
+        self.target.setFlash(self)
+
+    def getFlashInfo(self):
+        info = FlashInfo()
+        info.rom_start = 0x14000000
+        info.erase_weight = DEFAULT_CHIP_ERASE_WEIGHT
+        return info
+
+class LPC4330(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0x14000000,  length=0x4000000,    blocksize=0x400, isBootMemory=True),
+        RamRegion(      start=0x10000000,  length=0x20000),
+        RamRegion(      start=0x10080000,  length=0x12000),
+        RamRegion(      start=0x20000000,  length=0x8000),
+        RamRegion(      start=0x20008000,  length=0x8000)
+        )
+
+    def __init__(self, link):
+        super(LPC4330, self).__init__(link, self.memoryMap)
+        self.ignoreReset = False
+        self._svd_location = SVDFile(vendor="NXP", filename="LPC43xx_svd_v5.svd", is_local=False)
+
+    def reset(self, software_reset=False):
+        # Always use software reset for LPC4330 since the hardware version
+        # will reset the DAP.
+        super(LPC4330, self).reset(True)
+
+    def resetStopOnReset(self, software_reset=False):
+        if self.ignoreReset:
+            return
+
+        # Set core up to run some code in RAM that is guaranteed to be valid
+        # since FLASH could be corrupted and that is what user is trying to fix.
+        self.writeMemory(0x10000000, 0x10087ff0)    # Initial SP
+        self.writeMemory(0x10000004, 0x1000000d)    # Reset Handler
+        self.writeMemory(0x10000008, 0x1000000d)    # Hard Fault Handler
+        self.writeMemory(0x1000000c, 0xe7fee7fe)    # Infinite loop
+        self.writeMemory(0x40043100, 0x10000000)    # Shadow 0x0 to RAM
+
+        # Always use software reset for LPC4330 since the hardware version
+        # will reset the DAP.
+        super(LPC4330, self).resetStopOnReset(True)
+
+        # Map shadow memory to SPIFI FLASH
+        self.writeMemory(0x40043100, 0x80000000)
+
+        # The LPC4330 flash init routine can be used to remount FLASH.
+        self.ignoreReset = True
+        self.flash.init()
+        self.ignoreReset = False
+
+        # Set SP and PC based on interrupt vector in SPIFI_FLASH
+        sp = self.readMemory(0x14000000)
+        pc = self.readMemory(0x14000004)
+        self.writeCoreRegisterRaw('sp', sp)
+        self.writeCoreRegisterRaw('pc', pc)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_max32600mbed.py` & `pyOCD-0.9.0/pyOCD/target/target_nRF51822_xxAA.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,56 +1,78 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-    0x68884972, 0x7f80f010, 0x2001d001, 0x200c4770, 0x20006048, 0x496de7fa, 0xf0106888, 0xd0017f80,
-    0x47702001, 0xb1486a48, 0x62482000, 0xb1286a48, 0x62482002, 0xb1086a48, 0xe7f22001, 0xf0206888,
-    0xf0404070, 0x60885000, 0xe7ea2000, 0x4c5fb510, 0xffe1f7ff, 0x2001b108, 0x68a0bd10, 0x407ff420,
-    0x402af440, 0x68a060a0, 0x0002f040, 0xbf0060a0, 0xf01068a0, 0xd1fb7f80, 0xf02068a0, 0x60a04070,
-    0xf0106a60, 0xd0010f02, 0xe7e52001, 0xe7e32000, 0x4605b570, 0xf7ff4c4d, 0xb108ffbe, 0xbd702001,
-    0xf42068a0, 0xf440407f, 0x60a040aa, 0x68a06025, 0x0004f040, 0xbf0060a0, 0xf01068a0, 0xd1fb7f80,
-    0xf02068a0, 0x60a04070, 0xf0106a60, 0xd0010f02, 0xe7e42001, 0xe7e22000, 0x47f0e92d, 0x468a4606,
-    0x4c3a4690, 0x46474655, 0x0f03f018, 0x2001d002, 0x87f0e8bd, 0xf7ff4647, 0xb108ff8e, 0xe7f72002,
-    0xf02068a0, 0x60a06000, 0xf04068a0, 0x60a00010, 0x6026e00d, 0x6320cf01, 0xf04068a0, 0x60a00001,
-    0x68a0bf00, 0x7f80f010, 0x1d36d1fb, 0x2d041f2d, 0xf016d302, 0xd1ec0f1f, 0x2d04bf00, 0x68a0d318,
-    0x6000f020, 0x68a060a0, 0x0010f040, 0xe00d60a0, 0xcf016026, 0x68a06320, 0x0001f040, 0xbf0060a0,
-    0xf01068a0, 0xd1fb7f80, 0x1f2d1d36, 0xd2ef2d04, 0x68a2b1fd, 0x6200f022, 0x68a260a2, 0x0210f042,
-    0xf04f60a2, 0x21ff30ff, 0x683ae005, 0x0201ea62, 0x02094010, 0x2d001e6d, 0x6026d1f7, 0x68a26320,
-    0x0201f042, 0xbf0060a2, 0xf01268a2, 0xd1fb7f80, 0x68a0bf00, 0x4070f020, 0x6a6060a0, 0x0f02f010,
-    0x2003d001, 0x2000e794, 0x0000e792, 0x400f0000, 0x00000000, 0x11111111, 0x22222222, 0x33333333,
-    0x44444444, 0x00000000, 0x00000000, 0x00000000,
-                                ],
-               'pc_init' : 0x20000021,
-               'pc_eraseAll' : 0x2000006D,
-               'pc_erase_sector' : 0x200000B1,
-               'pc_program_page' : 0x200000F9,
-               'begin_data' : 0x20003000,       # Analyzer uses a max of 512 B data (128 pages * 4 bytes / page)
-               'page_buffers' : [0x20003000, 0x20003800],   # Enable double buffering
-               'begin_stack' : 0x20001000,
-               'static_base' : 0x20000230,
-               'min_program_length' : 4,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x20004000  # Analyzer 0x20004000..0x20004600
-              };
-
-class Flash_max32600mbed(Flash):
-
-    def __init__(self, target):
-        super(Flash_max32600mbed, self).__init__(target, flash_algo)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.coresight_target import (SVDFile, CoreSightTarget)
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+import logging
+
+# NRF51 specific registers
+RESET = 0x40000544
+RESET_ENABLE = (1 << 0)
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+                                0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+                                0x47702000, 0x47702000, 0x4c26b570, 0x60602002, 0x60e02001, 0x68284d24, 0xd00207c0, 0x60602000,
+                                0xf000bd70, 0xe7f6f82c, 0x4c1eb570, 0x60612102, 0x4288491e, 0x2001d302, 0xe0006160, 0x4d1a60a0,
+                                0xf81df000, 0x07c06828, 0x2000d0fa, 0xbd706060, 0x4605b5f8, 0x4813088e, 0x46142101, 0x4f126041,
+                                0xc501cc01, 0x07c06838, 0x1e76d006, 0x480dd1f8, 0x60412100, 0xbdf84608, 0xf801f000, 0x480ce7f2,
+                                0x06006840, 0xd00b0e00, 0x6849490a, 0xd0072900, 0x4a0a4909, 0xd00007c3, 0x1d09600a, 0xd1f90840,
+                                0x00004770, 0x4001e500, 0x4001e400, 0x10001000, 0x40010400, 0x40010500, 0x40010600, 0x6e524635,
+                                0x00000000, ],
+               'pc_init'          : 0x20000021,
+               'pc_eraseAll'      : 0x20000029,
+               'pc_erase_sector'  : 0x20000049,
+               'pc_program_page'  : 0x20000071,
+               'begin_data'       : 0x20002000, # Analyzer uses a max of 1 KB data (256 pages * 4 bytes / page)
+               'page_buffers'    : [0x20002000, 0x20002400],   # Enable double buffering
+               'begin_stack'      : 0x20001000,
+               'static_base'      : 0x20000170,
+               'min_program_length' : 4,
+               'analyzer_supported' : True,
+               'analyzer_address' : 0x20003000  # Analyzer 0x20003000..0x20003600
+              }
+
+class Flash_nrf51(Flash):
+
+    def __init__(self, target):
+        super(Flash_nrf51, self).__init__(target, flash_algo)
+
+class NRF51(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x40000,      blocksize=0x400, isBootMemory=True),
+        # User Information Configation Registers (UICR) as a flash region
+        FlashRegion(    start=0x10001000,  length=0x100,        blocksize=0x100),
+        RamRegion(      start=0x20000000,  length=0x4000)
+        )
+
+    def __init__(self, link):
+        super(NRF51, self).__init__(link, self.memoryMap)
+        self._svd_location = SVDFile(vendor="Nordic", filename="nrf51.svd", is_local=False)
+
+    def resetn(self):
+        """
+        reset a core. After a call to this function, the core
+        is running
+        """
+        #Regular reset will kick NRF out of DBG mode
+        logging.debug("target_nrf51.reset: enable reset pin")
+        self.writeMemory(RESET, RESET_ENABLE)
+        #reset
+        logging.debug("target_nrf51.reset: trigger nRST pin")
+        self.reset()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/flash/flash_stm32f103rc.py` & `pyOCD-0.9.0/pyOCD/target/target_maxwsnenv.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,53 +1,87 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from flash import Flash
-
-
-
-flash_algo = { 'load_address' : 0x20000000,
-               'instructions' : [
-                                  0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
-                                  0x49384839, 0x49396041, 0x20006041, 0x49364770, 0x60c82034, 0x47702000, 0x47702000, 0xb5004a32,
-                                  0x06006910, 0xf7ffd501, 0x68d0ffeb, 0xd1fc07c0, 0xf0406910, 0x61100004, 0xf0406910, 0x61100040,
-                                  0x07c068d0, 0x6910d1fc, 0x0004f020, 0x20006110, 0x4a25bd00, 0x4603b500, 0x06006910, 0xf7ffd501,
-                                  0x68d1ffcf, 0xd1fc07c9, 0xf0406910, 0x61100002, 0x69106153, 0x0040f040, 0x68d06110, 0xd1fc07c0,
-                                  0xf0206910, 0x61100002, 0xbd002000, 0x4d16b570, 0x460e4603, 0x24006928, 0xd5010600, 0xffb0f7ff,
-                                  0x07c068e8, 0xe014d1fc, 0x0001f040, 0x88106128, 0x68e88018, 0xd1fc07c0, 0x88198810, 0xd0054288,
-                                  0xf0206928, 0x61280001, 0xbd702001, 0x1c9b1c92, 0x69281c64, 0x0f56ebb4, 0xf020d3e6, 0x61280001,
-                                  0xbd702000, 0x45670123, 0x40022000, 0xcdef89ab, 0x00000000,
-                                ],
-               'pc_init'          : 0x2000002F,
-               'pc_eraseAll'      : 0x2000003D,
-               'pc_erase_sector'  : 0x20000073,
-               'pc_program_page'  : 0x200000AD,
-               'static_base'      : 0x20000200,
-               'begin_data'       : 0x20001000, # Analyzer uses a max of 1 KB data (256 pages * 4 bytes / page)
-               'page_buffers'    : [0x20001000, 0x20001800],   # Enable double buffering
-               'begin_stack'      : 0x20002800,
-               'min_program_length' : 2,
-               'analyzer_supported' : True,
-               'analyzer_address' : 0x20003000 # Analyzer 0x20003000..0x20003600
-              };
-
-
-class Flash_stm32f103rc(Flash):
-
-    def __init__(self, target):
-        super(Flash_stm32f103rc, self).__init__(target, flash_algo)
-
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..flash.flash import Flash
+from ..core.coresight_target import CoreSightTarget
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+import logging
+
+flash_algo = { 'load_address' : 0x20000000,
+               'instructions' : [
+    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x68884972, 0x7f80f010, 0x2001d001, 0x200c4770, 0x20006048, 0x496de7fa, 0xf0106888, 0xd0017f80,
+    0x47702001, 0xb1486a48, 0x62482000, 0xb1286a48, 0x62482002, 0xb1086a48, 0xe7f22001, 0xf0206888,
+    0xf0404070, 0x60885000, 0xe7ea2000, 0x4c5fb510, 0xffe1f7ff, 0x2001b108, 0x68a0bd10, 0x407ff420,
+    0x402af440, 0x68a060a0, 0x0002f040, 0xbf0060a0, 0xf01068a0, 0xd1fb7f80, 0xf02068a0, 0x60a04070,
+    0xf0106a60, 0xd0010f02, 0xe7e52001, 0xe7e32000, 0x4605b570, 0xf7ff4c4d, 0xb108ffbe, 0xbd702001,
+    0xf42068a0, 0xf440407f, 0x60a040aa, 0x68a06025, 0x0004f040, 0xbf0060a0, 0xf01068a0, 0xd1fb7f80,
+    0xf02068a0, 0x60a04070, 0xf0106a60, 0xd0010f02, 0xe7e42001, 0xe7e22000, 0x47f0e92d, 0x468a4606,
+    0x4c3a4690, 0x46474655, 0x0f03f018, 0x2001d002, 0x87f0e8bd, 0xf7ff4647, 0xb108ff8e, 0xe7f72002,
+    0xf02068a0, 0x60a06000, 0xf04068a0, 0x60a00010, 0x6026e00d, 0x6320cf01, 0xf04068a0, 0x60a00001,
+    0x68a0bf00, 0x7f80f010, 0x1d36d1fb, 0x2d041f2d, 0xf016d302, 0xd1ec0f1f, 0x2d04bf00, 0x68a0d318,
+    0x6000f020, 0x68a060a0, 0x0010f040, 0xe00d60a0, 0xcf016026, 0x68a06320, 0x0001f040, 0xbf0060a0,
+    0xf01068a0, 0xd1fb7f80, 0x1f2d1d36, 0xd2ef2d04, 0x68a2b1fd, 0x6200f022, 0x68a260a2, 0x0210f042,
+    0xf04f60a2, 0x21ff30ff, 0x683ae005, 0x0201ea62, 0x02094010, 0x2d001e6d, 0x6026d1f7, 0x68a26320,
+    0x0201f042, 0xbf0060a2, 0xf01268a2, 0xd1fb7f80, 0x68a0bf00, 0x4070f020, 0x6a6060a0, 0x0f02f010,
+    0x2003d001, 0x2000e794, 0x0000e792, 0x400f0000, 0x00000000, 0x11111111, 0x22222222, 0x33333333,
+    0x44444444, 0x00000000, 0x00000000, 0x00000000,
+                                ],
+               'pc_init' : 0x20000021,
+               'pc_eraseAll' : 0x2000006D,
+               'pc_erase_sector' : 0x200000B1,
+               'pc_program_page' : 0x200000F9,
+               'begin_data' : 0x20003000,       # Analyzer uses a max of 512 B data (128 pages * 4 bytes / page)
+               'page_buffers' : [0x20003000, 0x20003800],   # Enable double buffering
+               'begin_stack' : 0x20001000,
+               'static_base' : 0x20000230,
+               'min_program_length' : 4,
+               'analyzer_supported' : True,
+               'analyzer_address' : 0x20004000  # Analyzer 0x20004000..0x20004600
+              };
+
+class Flash_maxwsnenv(Flash):
+
+    def __init__(self, target):
+        super(Flash_maxwsnenv, self).__init__(target, flash_algo)
+
+class MAXWSNENV(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        FlashRegion(    start=0,           length=0x40000,      blocksize=0x800, isBootMemory=True),
+        RamRegion(      start=0x20000000,  length=0x8000),
+        RamRegion(      start=0x40000000,  length=0x100000),
+        RamRegion(      start=0xe0000000,  length=0x100000)
+        )
+
+    def __init__(self, link):
+        super(MAXWSNENV, self).__init__(link, self.memoryMap)
+
+    def dsb(self):
+        logging.info("Triggering Destructive Security Bypass...")
+
+        self.link.vendor(1)
+
+        # Reconnect debugger
+        self.link.init()
+
+    def fge(self):
+        logging.info("Triggering Factory Global Erase...")
+
+        self.link.vendor(2)
+
+        # Reconnect debugger
+        self.link.init()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/gdbserver/gdbserver.py` & `pyOCD-0.9.0/pyOCD/gdbserver/gdbserver.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,1089 +1,1285 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from ..target.target import Target
-from pyOCD.pyDAPAccess import DAPAccess
-from ..utility.conversion import hexToByteList, hexEncode, hexDecode
-from gdb_socket import GDBSocket
-from gdb_websocket import GDBWebSocket
-from syscall import GDBSyscallIOHandler
-from ..target import semihost
-import signals
-import logging, threading, socket
-from struct import unpack
-from time import sleep, time
-import sys
-import traceback
-import Queue
-
-CTRL_C = '\x03'
-
-# Logging options. Set to True to enable.
-LOG_MEM = False # Log memory accesses.
-LOG_ACK = False # Log ack or nak.
-LOG_PACKETS = False # Log all packets sent and received.
-
-def checksum(data):
-    return "%02x" % (sum([ord(c) for c in data]) % 256)
-
-## @brief Exception used to signal the GDB server connection closed.
-class ConnectionClosedException(Exception):
-    pass
-
-## @brief Packet I/O thread.
-#
-# This class is a thread used by the GDBServer class to perform all RSP packet I/O. It
-# handles verifying checksums, acking, and receiving Ctrl-C interrupts. There is a queue
-# for received packets. The interface to this queue is the receive() method. The send()
-# method writes outgoing packets to the socket immediately.
-class GDBServerPacketIOThread(threading.Thread):
-    def __init__(self, abstract_socket):
-        super(GDBServerPacketIOThread, self).__init__(name="gdb-packet-thread")
-        self._abstract_socket = abstract_socket
-        self._receive_queue = Queue.Queue()
-        self._shutdown_event = threading.Event()
-        self.interrupt_event = threading.Event()
-        self.send_acks = True
-        self._clear_send_acks = False
-        self._buffer = ''
-        self._expecting_ack = False
-        self.drop_reply = False
-        self._last_packet = ''
-        self._closed = False
-        self.setDaemon(True)
-        self.start()
-
-    def set_send_acks(self, ack):
-        if ack:
-            self.send_acks = True
-        else:
-            self._clear_send_acks = True
-
-    def stop(self):
-        self._shutdown_event.set()
-
-    def send(self, packet):
-        if self._closed or not packet:
-            return
-        if not self.drop_reply:
-            self._last_packet = packet
-            self._write_packet(packet)
-        else:
-            self.drop_reply = False
-            logging.debug("GDB dropped reply %s", packet)
-
-    def receive(self, block=True):
-        if self._closed:
-            raise ConnectionClosedException()
-        while True:
-            try:
-                # If block is false, we'll get an Empty exception immediately if there
-                # are no packets in the queue. Same if block is true and it times out
-                # waiting on an empty queue.
-                return self._receive_queue.get(block, 0.1)
-            except Queue.Empty:
-                # Only exit the loop if block is false or connection closed.
-                if not block:
-                    return None
-                if self._closed:
-                    raise ConnectionClosedException()
-
-    def run(self):
-        self._abstract_socket.setTimeout(0.01)
-
-        while not self._shutdown_event.is_set():
-            try:
-                data = self._abstract_socket.read()
-
-                # Handle closed connection
-                if len(data) == 0:
-                    logging.debug("GDB packet thread: other side closed connection")
-                    self._closed = True
-                    break
-
-                if LOG_PACKETS:
-                    logging.debug('-->>>>>>>>>>>> GDB read %d bytes: %s', len(data), data)
-
-                self._buffer += data
-            except socket.error:
-                pass
-
-            if self._shutdown_event.is_set():
-                break
-
-            self._process_data()
-
-        logging.debug("GDB packet thread stopping")
-
-    def _write_packet(self, packet):
-        if LOG_PACKETS:
-            logging.debug('--<<<<<<<<<<<< GDB send %d bytes: %s', len(packet), packet)
-
-        # Make sure the entire packet is sent.
-        remaining = len(packet)
-        while remaining:
-            written = self._abstract_socket.write(packet)
-            remaining -= written
-            if remaining:
-                packet = packet[written:]
-
-        if self.send_acks:
-            self._expecting_ack = True
-
-    def _check_expected_ack(self):
-        # Handle expected ack.
-        c = self._buffer[0]
-        if c in ('+', '-'):
-            self._buffer = self._buffer[1:]
-            if LOG_ACK:
-                logging.debug('got ack: %s', c)
-            if c == '-':
-                # Handle nack from gdb
-                self._write_packet(self._last_packet)
-                return
-
-            # Handle disabling of acks.
-            if self._clear_send_acks:
-                self.send_acks = False
-                self._clear_send_acks = False
-        else:
-            logging.debug("GDB: expected n/ack but got '%s'", c)
-
-    def _process_data(self):
-        # Process all incoming data until there are no more complete packets.
-        while len(self._buffer):
-            if self._expecting_ack:
-                self._expecting_ack = False
-                self._check_expected_ack()
-
-            # Check for a ctrl-c.
-            if len(self._buffer) and self._buffer[0] == CTRL_C:
-                self.interrupt_event.set()
-                self._buffer = self._buffer[1:]
-
-            try:
-                # Look for complete packet and extract from buffer.
-                pkt_begin = self._buffer.index("$")
-                pkt_end = self._buffer.index("#") + 2
-                if pkt_begin >= 0 and pkt_end < len(self._buffer):
-                    pkt = self._buffer[pkt_begin:pkt_end + 1]
-                    self._buffer = self._buffer[pkt_end + 1:]
-                    self._handling_incoming_packet(pkt)
-                else:
-                    break
-            except ValueError:
-                # No complete packet received yet.
-                break
-
-    def _handling_incoming_packet(self, packet):
-        # Compute checksum
-        data, cksum = packet[1:].split('#')
-        computedCksum = checksum(data)
-        goodPacket = (computedCksum.lower() == cksum.lower())
-
-        if self.send_acks:
-            ack = '+' if goodPacket else '-'
-            self._abstract_socket.write(ack)
-            if LOG_ACK:
-                logging.debug(ack)
-
-        if goodPacket:
-            self._receive_queue.put(packet)
-
-class GDBServer(threading.Thread):
-    """
-    This class start a GDB server listening a gdb connection on a specific port.
-    It implements the RSP (Remote Serial Protocol).
-    """
-    def __init__(self, board, port_urlWSS, options={}):
-        threading.Thread.__init__(self)
-        self.board = board
-        self.target = board.target
-        self.flash = board.flash
-        self.abstract_socket = None
-        self.wss_server = None
-        self.port = 0
-        if isinstance(port_urlWSS, str) == True:
-            self.wss_server = port_urlWSS
-        else:
-            self.port = port_urlWSS
-        self.break_at_hardfault = bool(options.get('break_at_hardfault', True))
-        self.board.target.setVectorCatchFault(self.break_at_hardfault)
-        self.break_on_reset = options.get('break_on_reset', False)
-        self.board.target.setVectorCatchReset(self.break_on_reset)
-        self.step_into_interrupt = options.get('step_into_interrupt', False)
-        self.persist = options.get('persist', False)
-        self.soft_bkpt_as_hard = options.get('soft_bkpt_as_hard', False)
-        self.chip_erase = options.get('chip_erase', None)
-        self.hide_programming_progress = options.get('hide_programming_progress', False)
-        self.fast_program = options.get('fast_program', False)
-        self.enable_semihosting = options.get('enable_semihosting', False)
-        self.telnet_port = options.get('telnet_port', 4444)
-        self.semihost_use_syscalls = options.get('semihost_use_syscalls', False)
-        self.server_listening_callback = options.get('server_listening_callback', None)
-        self.serve_local_only = options.get('serve_local_only', True)
-        self.packet_size = 2048
-        self.packet_io = None
-        self.gdb_features = []
-        self.non_stop = False
-        self.is_target_running = (self.target.getState() == Target.TARGET_RUNNING)
-        self.flashBuilder = None
-        self.lock = threading.Lock()
-        self.shutdown_event = threading.Event()
-        self.detach_event = threading.Event()
-        if self.wss_server == None:
-            self.abstract_socket = GDBSocket(self.port, self.packet_size)
-            if self.serve_local_only:
-                self.abstract_socket.host = 'localhost'
-        else:
-            self.abstract_socket = GDBWebSocket(self.wss_server)
-
-        # Init semihosting and telnet console.
-        if self.semihost_use_syscalls:
-            semihost_io_handler = GDBSyscallIOHandler(self)
-        else:
-            # Use internal IO handler.
-            semihost_io_handler = semihost.InternalSemihostIOHandler()
-        self.telnet_console = semihost.TelnetSemihostIOHandler(self.telnet_port, self.serve_local_only)
-        self.semihost = semihost.SemihostAgent(self.target, io_handler=semihost_io_handler, console=self.telnet_console)
-
-        self.setDaemon(True)
-        self.start()
-
-    def restart(self):
-        if self.isAlive():
-            self.detach_event.set()
-
-    def stop(self):
-        if self.isAlive():
-            self.shutdown_event.set()
-            while self.isAlive():
-                pass
-            logging.info("GDB server thread killed")
-        self.board.uninit()
-
-    def setBoard(self, board, stop=True):
-        self.lock.acquire()
-        if stop:
-            self.restart()
-        self.board = board
-        self.target = board.target
-        self.flash = board.flash
-        self.lock.release()
-        return
-
-    def _cleanup(self):
-        logging.debug("GDB server cleaning up")
-        if self.packet_io:
-            self.packet_io.stop()
-            self.packet_io = None
-        if self.semihost:
-            self.semihost.cleanup()
-            self.semihost = None
-        if self.telnet_console:
-            self.telnet_console.stop()
-            self.telnet_console = None
-
-    def run(self):
-        logging.info('GDB server started at port:%d', self.port)
-
-        while True:
-            try:
-                self.detach_event.clear()
-
-                # Inform callback that the server is running.
-                if self.server_listening_callback:
-                    self.server_listening_callback(self)
-
-                while not self.shutdown_event.isSet() and not self.detach_event.isSet():
-                    connected = self.abstract_socket.connect()
-                    if connected != None:
-                        self.packet_io = GDBServerPacketIOThread(self.abstract_socket)
-                        break
-
-                if self.shutdown_event.isSet():
-                    self._cleanup()
-                    return
-
-                if self.detach_event.isSet():
-                    continue
-
-                logging.info("One client connected!")
-                self._run_connection()
-
-            except Exception as e:
-                logging.error("Unexpected exception: %s", e)
-                traceback.print_exc()
-
-    def _run_connection(self):
-        while True:
-            try:
-                if self.shutdown_event.isSet():
-                    self._cleanup()
-                    return
-
-                if self.detach_event.isSet():
-                    break
-
-                if self.packet_io.interrupt_event.isSet():
-                    if self.non_stop:
-                        self.target.halt()
-                        self.is_target_running = False
-                        self.sendStopNotification()
-                    else:
-                        logging.error("Got unexpected ctrl-c, ignoring")
-                    self.packet_io.interrupt_event.clear()
-
-                if self.non_stop and self.is_target_running:
-                    try:
-                        if self.target.getState() == Target.TARGET_HALTED:
-                            logging.debug("state halted")
-                            self.is_target_running = False
-                            self.sendStopNotification()
-                    except Exception as e:
-                        logging.error("Unexpected exception: %s", e)
-                        traceback.print_exc()
-
-                # read command
-                try:
-                    packet = self.packet_io.receive(block=not self.non_stop)
-                except ConnectionClosedException:
-                    break
-
-                if self.shutdown_event.isSet():
-                    self._cleanup()
-                    return
-
-                if self.detach_event.isSet():
-                    break
-
-                if self.non_stop and packet is None:
-                    sleep(0.1)
-                    continue
-
-                self.lock.acquire()
-
-                if len(packet) != 0:
-                    # decode and prepare resp
-                    resp, detach = self.handleMsg(packet)
-
-                    if resp is not None:
-                        # send resp
-                        self.packet_io.send(resp)
-
-                    if detach:
-                        self.abstract_socket.close()
-                        self.packet_io.stop()
-                        self.packet_io = None
-                        self.lock.release()
-                        if self.persist:
-                            break
-                        else:
-                            self.shutdown_event.set()
-                            return
-
-                self.lock.release()
-
-            except Exception as e:
-                logging.error("Unexpected exception: %s", e)
-                traceback.print_exc()
-
-    def handleMsg(self, msg):
-        try:
-            if msg[0] != '$':
-                logging.debug('msg ignored: first char != $')
-                return None, 0
-
-            # query command
-            if msg[1] == '?':
-                return self.stopReasonQuery(), 0
-
-            # we don't send immediately the response for C and S commands
-            elif msg[1] == 'C' or msg[1] == 'c':
-                return self.resume(msg[1:]), 0
-
-            elif msg[1] == 'D':
-                return self.detach(msg[1:]), 1
-
-            elif msg[1] == 'g':
-                return self.getRegisters(), 0
-
-            elif msg[1] == 'G':
-                return self.setRegisters(msg[2:]), 0
-
-            elif msg[1] == 'H':
-                return self.createRSPPacket('OK'), 0
-
-            elif msg[1] == 'k':
-                return self.kill(), 1
-
-            elif msg[1] == 'm':
-                return self.getMemory(msg[2:]), 0
-
-            elif msg[1] == 'M': # write memory with hex data
-                return self.writeMemoryHex(msg[2:]), 0
-
-            elif msg[1] == 'p':
-                return self.readRegister(msg[2:]), 0
-
-            elif msg[1] == 'P':
-                return self.writeRegister(msg[2:]), 0
-
-            elif msg[1] == 'q':
-                return self.handleQuery(msg[2:]), 0
-
-            elif msg[1] == 'Q':
-                return self.handleGeneralSet(msg[2:]), 0
-
-            elif msg[1] == 'S' or msg[1] == 's':
-                return self.step(msg[1:]), 0
-
-            elif msg[1] == 'T': # check if thread is alive
-                return self.createRSPPacket('OK'), 0
-
-            elif msg[1] == 'v':
-                return self.vCommand(msg[2:]), 0
-
-            elif msg[1] == 'X': # write memory with binary data
-                return self.writeMemory(msg[2:]), 0
-
-            elif msg[1] == 'Z' or msg[1] == 'z':
-                return self.breakpoint(msg[1:]), 0
-
-            else:
-                logging.error("Unknown RSP packet: %s", msg)
-                return self.createRSPPacket(""), 0
-
-        except Exception as e:
-            logging.error("Unhandled exception in handleMsg: %s", e)
-            traceback.print_exc()
-            return self.createRSPPacket("E01"), 0
-
-    def detach(self, data):
-        logging.info("Client detached")
-        resp = "OK"
-        return self.createRSPPacket(resp)
-
-    def kill(self):
-        logging.debug("GDB kill")
-        # Keep target halted and leave vector catches if in persistent mode.
-        if not self.persist:
-            self.board.target.setVectorCatchFault(False)
-            self.board.target.setVectorCatchReset(False)
-            self.board.target.resume()
-        return self.createRSPPacket("")
-
-    def breakpoint(self, data):
-        # handle breakpoint/watchpoint commands
-        split = data.split('#')[0].split(',')
-        addr = int(split[1], 16)
-        logging.debug("GDB breakpoint %s%d @ %x" % (data[0], int(data[1]), addr))
-
-        # handle software breakpoint Z0/z0
-        if data[1] == '0' and not self.soft_bkpt_as_hard:
-            if data[0] == 'Z':
-                if not self.target.setBreakpoint(addr, Target.BREAKPOINT_SW):
-                    return self.createRSPPacket('E01') #EPERM
-            else:
-                self.target.removeBreakpoint(addr)
-            return self.createRSPPacket("OK")
-
-        # handle hardware breakpoint Z1/z1
-        if data[1] == '1' or (self.soft_bkpt_as_hard and data[1] == '0'):
-            if data[0] == 'Z':
-                if self.target.setBreakpoint(addr, Target.BREAKPOINT_HW) == False:
-                    return self.createRSPPacket('E01') #EPERM
-            else:
-                self.target.removeBreakpoint(addr)
-            return self.createRSPPacket("OK")
-
-        # handle hardware watchpoint Z2/z2/Z3/z3/Z4/z4
-        if data[1] == '2':
-            # Write-only watch
-            watchpoint_type = Target.WATCHPOINT_WRITE
-        elif data[1] == '3':
-            # Read-only watch
-            watchpoint_type = Target.WATCHPOINT_READ
-        elif data[1] == '4':
-            # Read-Write watch
-            watchpoint_type = Target.WATCHPOINT_READ_WRITE
-        else:
-            return self.createRSPPacket('E01') #EPERM
-
-        size = int(split[2], 16)
-        if data[0] == 'Z':
-            if self.target.setWatchpoint(addr, size, watchpoint_type) == False:
-                return self.createRSPPacket('E01') #EPERM
-        else:
-            self.target.removeWatchpoint(addr, size, watchpoint_type)
-        return self.createRSPPacket("OK")
-
-    def stopReasonQuery(self):
-        # In non-stop mode, if no threads are stopped we need to reply with OK.
-        if self.non_stop and self.is_target_running:
-            return self.createRSPPacket("OK")
-
-        return self.createRSPPacket(self.target.getTResponse())
-
-    def _get_resume_step_addr(self, data):
-        if data is None:
-            return None
-        data = data.split('#')[0]
-        if ';' not in data:
-            return None
-        # c[;addr]
-        if data[0] in ('c', 's'):
-            addr = int(data[2:], base=16)
-        # Csig[;addr]
-        elif data[0] in ('C', 'S'):
-            addr = int(data[1:].split(';')[1], base=16)
-        return addr
-
-    def resume(self, data):
-        addr = self._get_resume_step_addr(data)
-        self.target.resume()
-        logging.debug("target resumed")
-
-        val = ''
-
-        while True:
-            if self.shutdown_event.isSet():
-                self.packet_io.interrupt_event.clear()
-                return self.createRSPPacket(val)
-
-            # Wait for a ctrl-c to be received.
-            if self.packet_io.interrupt_event.wait(0.01):
-                logging.debug("receive CTRL-C")
-                self.packet_io.interrupt_event.clear()
-                self.target.halt()
-                val = self.target.getTResponse(forceSignal=signals.SIGINT)
-                break
-
-            try:
-                if self.target.getState() == Target.TARGET_HALTED:
-                    # Handle semihosting
-                    if self.enable_semihosting:
-                        was_semihost = self.semihost.check_and_handle_semihost_request()
-
-                        if was_semihost:
-                            self.target.resume()
-                            continue
-
-                    logging.debug("state halted")
-                    val = self.target.getTResponse()
-                    break
-            except Exception as e:
-                try:
-                    self.target.halt()
-                except:
-                    pass
-                traceback.print_exc()
-                logging.debug('Target is unavailable temporarily.')
-                val = 'S%02x' % self.target.getSignalValue()
-                break
-
-        return self.createRSPPacket(val)
-
-    def step(self, data):
-        addr = self._get_resume_step_addr(data)
-        logging.debug("GDB step: %s", data)
-        self.target.step(not self.step_into_interrupt)
-        return self.createRSPPacket(self.target.getTResponse())
-
-    def halt(self):
-        self.target.halt()
-        return self.createRSPPacket(self.target.getTResponse())
-
-    def sendStopNotification(self, forceSignal=None):
-        data = self.target.getTResponse(forceSignal=forceSignal)
-        packet = '%Stop:' + data + '#' + checksum(data)
-        self.packet_io.send(packet)
-
-    def vCommand(self, data):
-        cmd = data.split('#')[0]
-        logging.debug("GDB vCommand: %s", cmd)
-
-        # Flash command.
-        if cmd.startswith('Flash'):
-            return self.flashOp(data)
-
-        # vCont capabilities query.
-        elif 'Cont?' == cmd:
-            return self.createRSPPacket("vCont;c;C;s;S;t")
-
-        # vCont, thread action command.
-        elif cmd.startswith('Cont'):
-            return self.vCont(cmd)
-
-        # vStopped, part of thread stop state notification sequence.
-        elif 'Stopped' in cmd:
-            # Because we only support one thread for now, we can just reply OK to vStopped.
-            return self.createRSPPacket("OK")
-
-        return self.createRSPPacket("")
-
-    # Example: $vCont;s:1;c#c1
-    def vCont(self, cmd):
-        ops = cmd.split(';')[1:] # split and remove 'Cont' from list
-        if not ops:
-            return self.createRSPPacket("OK")
-
-        thread_actions = { 1 : None } # our only thread
-        default_action = None
-        for op in ops:
-            args = op.split(':')
-            action = args[0]
-            if len(args) > 1:
-                thread_id = args[1]
-                if thread_id == '-1' or thread_id == '0':
-                    thread_id = '1'
-                thread_id = int(thread_id, base=16)
-                thread_actions[thread_id] = action
-            else:
-                default_action = action
-
-        logging.debug("thread_actions=%s; default_action=%s", repr(thread_actions), default_action)
-
-        # Only thread 1 is supported at the moment.
-        if thread_actions[1] is None:
-            if default_action is None:
-                return self.createRSPPacket('E01')
-            thread_actions[1] = default_action
-
-        if thread_actions[1][0] in ('c', 'C'):
-            if self.non_stop:
-                self.target.resume()
-                self.is_target_running = True
-                return self.createRSPPacket("OK")
-            else:
-                return self.resume(None)
-        elif thread_actions[1][0] in ('s', 'S'):
-            if self.non_stop:
-                self.target.step(not self.step_into_interrupt)
-                self.packet_io.send(self.createRSPPacket("OK"))
-                self.sendStopNotification()
-                return None
-            else:
-                return self.step(None)
-        elif thread_actions[1] == 't':
-            # Must ignore t command in all-stop mode.
-            if not self.non_stop:
-                return self.createRSPPacket("")
-            self.packet_io.send(self.createRSPPacket("OK"))
-            self.target.halt()
-            self.is_target_running = False
-            self.sendStopNotification(forceSignal=0)
-        else:
-            logging.error("Unsupported vCont action '%s'" % thread_actions[1])
-
-    def flashOp(self, data):
-        ops = data.split(':')[0]
-        logging.debug("flash op: %s", ops)
-
-        if ops == 'FlashErase':
-            return self.createRSPPacket("OK")
-
-        elif ops == 'FlashWrite':
-            write_addr = int(data.split(':')[1], 16)
-            logging.debug("flash write addr: 0x%x", write_addr)
-            # search for second ':' (beginning of data encoded in the message)
-            second_colon = 0
-            idx_begin = 0
-            while second_colon != 2:
-                if data[idx_begin] == ':':
-                    second_colon += 1
-                idx_begin += 1
-
-            # Get flash builder if there isn't one already
-            if self.flashBuilder == None:
-                self.flashBuilder = self.flash.getFlashBuilder()
-
-            # Add data to flash builder
-            self.flashBuilder.addData(write_addr, self.unescape(data[idx_begin:len(data) - 3]))
-
-
-            return self.createRSPPacket("OK")
-
-        # we need to flash everything
-        elif 'FlashDone' in ops :
-
-            def print_progress(progress):
-                # Reset state on 0.0
-                if progress == 0.0:
-                    print_progress.done = False
-
-                # print progress bar
-                if not print_progress.done:
-                    sys.stdout.write('\r')
-                    i = int(progress * 20.0)
-                    sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
-                    sys.stdout.flush()
-
-                # Finish on 1.0
-                if progress >= 1.0:
-                    if not print_progress.done:
-                        print_progress.done = True
-                        sys.stdout.write("\r\n")
-                        sys.stdout.flush()
-
-            if self.hide_programming_progress:
-                progress_cb = None
-            else:
-                 progress_cb = print_progress
-
-            self.flashBuilder.program(chip_erase=self.chip_erase, progress_cb=progress_cb, fast_verify=self.fast_program)
-
-            # Set flash builder to None so that on the next flash command a new
-            # object is used.
-            self.flashBuilder = None
-
-            return self.createRSPPacket("OK")
-
-        return None
-
-    def unescape(self, data):
-        data_idx = 0
-
-        # unpack the data into binary array
-        str_unpack = str(len(data)) + 'B'
-        data = unpack(str_unpack, data)
-        data = list(data)
-
-        # check for escaped characters
-        while data_idx < len(data):
-            if data[data_idx] == 0x7d:
-                data.pop(data_idx)
-                data[data_idx] = data[data_idx] ^ 0x20
-            data_idx += 1
-
-        return data
-
-
-    def getMemory(self, data):
-        split = data.split(',')
-        addr = int(split[0], 16)
-        length = split[1].split('#')[0]
-        length = int(length, 16)
-
-        if LOG_MEM:
-            logging.debug("GDB getMem: addr=%x len=%x", addr, length)
-
-        try:
-            val = ''
-            mem = self.target.readBlockMemoryUnaligned8(addr, length)
-            # Flush so an exception is thrown now if invalid memory was accesses
-            self.target.flush()
-            for x in mem:
-                if x >= 0x10:
-                    val += hex(x)[2:4]
-                else:
-                    val += '0' + hex(x)[2:3]
-        except DAPAccess.TransferError:
-            logging.debug("getMemory failed at 0x%x" % addr)
-            val = 'E01' #EPERM
-        return self.createRSPPacket(val)
-
-    def writeMemoryHex(self, data):
-        split = data.split(',')
-        addr = int(split[0], 16)
-
-        split = split[1].split(':')
-        length = int(split[0], 16)
-
-        split = split[1].split('#')
-        data = hexToByteList(split[0])
-
-        if LOG_MEM:
-            logging.debug("GDB writeMemHex: addr=%x len=%x", addr, length)
-
-        try:
-            if length > 0:
-                self.target.writeBlockMemoryUnaligned8(addr, data)
-                # Flush so an exception is thrown now if invalid memory was accessed
-                self.target.flush()
-            resp = "OK"
-        except DAPAccess.TransferError:
-            logging.debug("writeMemory failed at 0x%x" % addr)
-            resp = 'E01' #EPERM
-
-        return self.createRSPPacket(resp)
-
-    def writeMemory(self, data):
-        split = data.split(',')
-        addr = int(split[0], 16)
-        length = int(split[1].split(':')[0], 16)
-
-        if LOG_MEM:
-            logging.debug("GDB writeMem: addr=%x len=%x", addr, length)
-
-        idx_begin = 0
-        for i in range(len(data)):
-            if data[i] == ':':
-                idx_begin += 1
-                break
-            idx_begin += 1
-
-        data = data[idx_begin:len(data) - 3]
-        data = self.unescape(data)
-
-        try:
-            if length > 0:
-                self.target.writeBlockMemoryUnaligned8(addr, data)
-                # Flush so an exception is thrown now if invalid memory was accessed
-                self.target.flush()
-            resp = "OK"
-        except DAPAccess.TransferError:
-            logging.debug("writeMemory failed at 0x%x" % addr)
-            resp = 'E01' #EPERM
-
-        return self.createRSPPacket(resp)
-
-    def readRegister(self, which):
-        return self.createRSPPacket(self.target.gdbGetRegister(which))
-
-    def writeRegister(self, data):
-        reg = int(data.split('=')[0], 16)
-        val = data.split('=')[1].split('#')[0]
-        self.target.setRegister(reg, val)
-        return self.createRSPPacket("OK")
-
-    def getRegisters(self):
-        return self.createRSPPacket(self.target.getRegisterContext())
-
-    def setRegisters(self, data):
-        self.target.setRegisterContext(data)
-        return self.createRSPPacket("OK")
-
-    def handleQuery(self, msg):
-        query = msg.split(':')
-        logging.debug('GDB received query: %s', query)
-
-        if query is None:
-            logging.error('GDB received query packet malformed')
-            return None
-
-        if query[0] == 'Supported':
-            # Save features sent by gdb.
-            self.gdb_features = query[1].split(';')
-
-            # Build our list of features.
-            features = ['qXfer:features:read+', 'QStartNoAckMode+', 'qXfer:threads:read+', 'QNonStop+']
-            features.append('PacketSize=' + hex(self.packet_size)[2:])
-            if self.target.getMemoryMapXML() is not None:
-                features.append('qXfer:memory-map:read+')
-            resp = ';'.join(features)
-            return self.createRSPPacket(resp)
-
-        elif query[0] == 'Xfer':
-
-            if query[1] == 'features' and query[2] == 'read' and \
-               query[3] == 'target.xml':
-                data = query[4].split(',')
-                resp = self.handleQueryXML('read_feature', int(data[0], 16), int(data[1].split('#')[0], 16))
-                return self.createRSPPacket(resp)
-
-            elif query[1] == 'memory-map' and query[2] == 'read':
-                data = query[4].split(',')
-                resp = self.handleQueryXML('memory_map', int(data[0], 16), int(data[1].split('#')[0], 16))
-                return self.createRSPPacket(resp)
-
-            elif query[1] == 'threads' and query[2] == 'read':
-                data = query[4].split(',')
-                resp = self.handleQueryXML('threads', int(data[0], 16), int(data[1].split('#')[0], 16))
-                return self.createRSPPacket(resp)
-
-            else:
-                logging.debug("Unsupported qXfer request: %s:%s:%s:%s", query[1], query[2], query[3], query[4])
-                return None
-
-        elif query[0].startswith('C'):
-            return self.createRSPPacket("QC1")
-
-        elif query[0].find('Attached') != -1:
-            return self.createRSPPacket("1")
-
-        elif query[0].find('TStatus') != -1:
-            return self.createRSPPacket("")
-
-        elif query[0].find('Tf') != -1:
-            return self.createRSPPacket("")
-
-        elif 'Offsets' in query[0]:
-            resp = "Text=0;Data=0;Bss=0"
-            return self.createRSPPacket(resp)
-
-        elif 'Symbol' in query[0]:
-            resp = "OK"
-            return self.createRSPPacket(resp)
-
-        elif query[0].startswith('Rcmd,'):
-            cmd = hexDecode(query[0][5:].split('#')[0])
-            return self.handleRemoteCommand(cmd)
-
-        else:
-            return self.createRSPPacket("")
-
-    # TODO rewrite the remote command handler
-    def handleRemoteCommand(self, cmd):
-        logging.debug('Remote command: %s', cmd)
-
-        safecmd = {
-            'init'  : ['Init reset sequence', 0x1],
-            'reset' : ['Reset and halt the target', 0x2],
-            'halt'  : ['Halt target', 0x4],
-            # 'resume': ['Resume target', 0x8],
-            'help'  : ['Display this help', 0x80],
-        }
-
-        resp = 'OK'
-        if cmd == 'help':
-            resp = ''.join(['%s\t%s\n' % (k, v[0]) for k, v in safecmd.items()])
-            resp = hexEncode(resp)
-        elif cmd.startswith('arm semihosting'):
-            self.enable_semihosting = 'enable' in cmd
-            logging.info("Semihosting %s", ('enabled' if self.enable_semihosting else 'disabled'))
-        else:
-            resultMask = 0x00
-            cmdList = cmd.split()
-            if cmdList[0] == 'help':
-                # a 'help' is only valid as the first cmd, and only
-                # gives info on the second cmd if it is valid
-                resultMask |= 0x80
-                del cmdList[0]
-
-            for cmd_sub in cmdList:
-                if cmd_sub not in safecmd:
-                    logging.warning("Invalid mon command '%s'", cmd_sub)
-                    resp = 'Invalid Command: "%s"\n' % cmd_sub
-                    resp = hexEncode(resp)
-                    return self.createRSPPacket(resp)
-                elif resultMask == 0x80:
-                    # if the first command was a 'help', we only need
-                    # to return info about the first cmd after it
-                    resp = hexEncode(safecmd[cmd_sub][0]+'\n')
-                    return self.createRSPPacket(resp)
-                resultMask |= safecmd[cmd_sub][1]
-
-            # Run cmds in proper order
-            if resultMask & 0x1:
-                self.target.init()
-            if (resultMask & 0x6) == 0x6:
-                self.target.resetStopOnReset()
-            elif resultMask & 0x2:
-                # on 'reset' still do a reset halt
-                self.target.resetStopOnReset()
-                # self.target.reset()
-            elif resultMask & 0x4:
-                self.target.halt()
-            # if resultMask & 0x8:
-            #     self.target.resume()
-
-        return self.createRSPPacket(resp)
-
-    def handleGeneralSet(self, msg):
-        feature = msg.split('#')[0]
-        logging.debug("GDB general set: %s", feature)
-
-        if feature == 'StartNoAckMode':
-            # Disable acks after the reply and ack.
-            self.packet_io.set_send_acks(False)
-            return self.createRSPPacket("OK")
-
-        elif feature.startswith('NonStop'):
-            enable = feature.split(':')[1]
-            self.non_stop = (enable == '1')
-            return self.createRSPPacket("OK")
-
-        else:
-            return self.createRSPPacket("")
-
-    def handleQueryXML(self, query, offset, size):
-        logging.debug('GDB query %s: offset: %s, size: %s', query, offset, size)
-        xml = ''
-        if query == 'memory_map':
-            xml = self.target.getMemoryMapXML()
-        elif query == 'read_feature':
-            xml = self.target.getTargetXML()
-        elif query == 'threads':
-            xml = self.target.getThreadsXML()
-        else:
-            raise RuntimeError("Invalid XML query (%s)" % query)
-
-        size_xml = len(xml)
-
-        prefix = 'm'
-
-        if offset > size_xml:
-            logging.error('GDB: xml offset > size for %s!', query)
-            return
-
-        if size > (self.packet_size - 4):
-            size = self.packet_size - 4
-
-        nbBytesAvailable = size_xml - offset
-
-        if size > nbBytesAvailable:
-            prefix = 'l'
-            size = nbBytesAvailable
-
-        resp = prefix + xml[offset:offset + size]
-
-        return resp
-
-
-    def createRSPPacket(self, data):
-        resp = '$' + data + '#' + checksum(data)
-        return resp
-
-    def syscall(self, op):
-        logging.debug("GDB server syscall: %s", op)
-        request = self.createRSPPacket('F' + op)
-        self.packet_io.send(request)
-
-        while not self.packet_io.interrupt_event.is_set():
-            # Read a packet.
-            packet = self.packet_io.receive(False)
-            if packet is None:
-                sleep(0.1)
-                continue
-
-            # Check for file I/O response.
-            if packet[0] == '$' and packet[1] == 'F':
-                logging.debug("Syscall: got syscall response " + packet)
-                args = packet[2:packet.index('#')].split(',')
-                result = int(args[0], base=16)
-                errno = int(args[1], base=16) if len(args) > 1 else 0
-                ctrl_c = args[2] if len(args) > 2 else ''
-                if ctrl_c == 'C':
-                    self.packet_io.interrupt_event.set()
-                    self.packet_io.drop_reply = True
-                return result, errno
-
-            # decode and prepare resp
-            resp, detach = self.handleMsg(packet)
-
-            if resp is not None:
-                # send resp
-                self.packet_io.send(resp)
-
-            if detach:
-                self.detach_event.set()
-                logging.warning("GDB server received detach request while waiting for file I/O completion")
-                break
-
-        return -1, 0
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..core.target import Target
+from pyOCD.pyDAPAccess import DAPAccess
+from ..utility.cmdline import convert_vector_catch
+from ..utility.conversion import hexToByteList, hexEncode, hexDecode, hex8leToU32le
+from gdb_socket import GDBSocket
+from gdb_websocket import GDBWebSocket
+from syscall import GDBSyscallIOHandler
+from ..debug import semihost
+from ..debug.cache import MemoryAccessError
+from .context_facade import GDBDebugContextFacade
+from .symbols import GDBSymbolProvider
+from ..rtos import RTOS
+import signals
+import logging, threading, socket
+from struct import unpack
+from time import sleep, time
+import sys
+import traceback
+import Queue
+from xml.etree.ElementTree import (Element, SubElement, tostring)
+
+CTRL_C = '\x03'
+
+# Logging options. Set to True to enable.
+LOG_MEM = False # Log memory accesses.
+LOG_ACK = False # Log ack or nak.
+LOG_PACKETS = False # Log all packets sent and received.
+
+def checksum(data):
+    return "%02x" % (sum([ord(c) for c in data]) % 256)
+
+## @brief Exception used to signal the GDB server connection closed.
+class ConnectionClosedException(Exception):
+    pass
+
+## @brief Packet I/O thread.
+#
+# This class is a thread used by the GDBServer class to perform all RSP packet I/O. It
+# handles verifying checksums, acking, and receiving Ctrl-C interrupts. There is a queue
+# for received packets. The interface to this queue is the receive() method. The send()
+# method writes outgoing packets to the socket immediately.
+class GDBServerPacketIOThread(threading.Thread):
+    def __init__(self, abstract_socket):
+        super(GDBServerPacketIOThread, self).__init__(name="gdb-packet-thread")
+        self.log = logging.getLogger('gdbpacket.%d' % abstract_socket.port)
+        self._abstract_socket = abstract_socket
+        self._receive_queue = Queue.Queue()
+        self._shutdown_event = threading.Event()
+        self.interrupt_event = threading.Event()
+        self.send_acks = True
+        self._clear_send_acks = False
+        self._buffer = ''
+        self._expecting_ack = False
+        self.drop_reply = False
+        self._last_packet = ''
+        self._closed = False
+        self.setDaemon(True)
+        self.start()
+
+    def set_send_acks(self, ack):
+        if ack:
+            self.send_acks = True
+        else:
+            self._clear_send_acks = True
+
+    def stop(self):
+        self._shutdown_event.set()
+
+    def send(self, packet):
+        if self._closed or not packet:
+            return
+        if not self.drop_reply:
+            self._last_packet = packet
+            self._write_packet(packet)
+        else:
+            self.drop_reply = False
+            self.log.debug("GDB dropped reply %s", packet)
+
+    def receive(self, block=True):
+        if self._closed:
+            raise ConnectionClosedException()
+        while True:
+            try:
+                # If block is false, we'll get an Empty exception immediately if there
+                # are no packets in the queue. Same if block is true and it times out
+                # waiting on an empty queue.
+                return self._receive_queue.get(block, 0.1)
+            except Queue.Empty:
+                # Only exit the loop if block is false or connection closed.
+                if not block:
+                    return None
+                if self._closed:
+                    raise ConnectionClosedException()
+
+    def run(self):
+        self._abstract_socket.setTimeout(0.01)
+
+        while not self._shutdown_event.is_set():
+            try:
+                data = self._abstract_socket.read()
+
+                # Handle closed connection
+                if len(data) == 0:
+                    self.log.debug("GDB packet thread: other side closed connection")
+                    self._closed = True
+                    break
+
+                if LOG_PACKETS:
+                    self.log.debug('-->>>>>>>>>>>> GDB read %d bytes: %s', len(data), data)
+
+                self._buffer += data
+            except socket.error:
+                pass
+
+            if self._shutdown_event.is_set():
+                break
+
+            self._process_data()
+
+        self.log.debug("GDB packet thread stopping")
+
+    def _write_packet(self, packet):
+        if LOG_PACKETS:
+            self.log.debug('--<<<<<<<<<<<< GDB send %d bytes: %s', len(packet), packet)
+
+        # Make sure the entire packet is sent.
+        remaining = len(packet)
+        while remaining:
+            written = self._abstract_socket.write(packet)
+            remaining -= written
+            if remaining:
+                packet = packet[written:]
+
+        if self.send_acks:
+            self._expecting_ack = True
+
+    def _check_expected_ack(self):
+        # Handle expected ack.
+        c = self._buffer[0]
+        if c in ('+', '-'):
+            self._buffer = self._buffer[1:]
+            if LOG_ACK:
+                self.log.debug('got ack: %s', c)
+            if c == '-':
+                # Handle nack from gdb
+                self._write_packet(self._last_packet)
+                return
+
+            # Handle disabling of acks.
+            if self._clear_send_acks:
+                self.send_acks = False
+                self._clear_send_acks = False
+        else:
+            self.log.debug("GDB: expected n/ack but got '%s'", c)
+
+    def _process_data(self):
+        # Process all incoming data until there are no more complete packets.
+        while len(self._buffer):
+            if self._expecting_ack:
+                self._expecting_ack = False
+                self._check_expected_ack()
+
+            # Check for a ctrl-c.
+            if len(self._buffer) and self._buffer[0] == CTRL_C:
+                self.interrupt_event.set()
+                self._buffer = self._buffer[1:]
+
+            try:
+                # Look for complete packet and extract from buffer.
+                pkt_begin = self._buffer.index("$")
+                pkt_end = self._buffer.index("#") + 2
+                if pkt_begin >= 0 and pkt_end < len(self._buffer):
+                    pkt = self._buffer[pkt_begin:pkt_end + 1]
+                    self._buffer = self._buffer[pkt_end + 1:]
+                    self._handling_incoming_packet(pkt)
+                else:
+                    break
+            except ValueError:
+                # No complete packet received yet.
+                break
+
+    def _handling_incoming_packet(self, packet):
+        # Compute checksum
+        data, cksum = packet[1:].split('#')
+        computedCksum = checksum(data)
+        goodPacket = (computedCksum.lower() == cksum.lower())
+
+        if self.send_acks:
+            ack = '+' if goodPacket else '-'
+            self._abstract_socket.write(ack)
+            if LOG_ACK:
+                self.log.debug(ack)
+
+        if goodPacket:
+            self._receive_queue.put(packet)
+
+class GDBServer(threading.Thread):
+    """
+    This class start a GDB server listening a gdb connection on a specific port.
+    It implements the RSP (Remote Serial Protocol).
+    """
+    def __init__(self, board, port_urlWSS, options={}):
+        threading.Thread.__init__(self)
+        self.board = board
+        self.target = board.target
+        self.log = logging.getLogger('gdbserver')
+        self.flash = board.flash
+        self.abstract_socket = None
+        self.wss_server = None
+        self.port = 0
+        if isinstance(port_urlWSS, str) == True:
+            self.wss_server = port_urlWSS
+        else:
+            self.port = port_urlWSS
+        self.vector_catch = options.get('vector_catch', Target.CATCH_HARD_FAULT)
+        self.board.target.setVectorCatch(self.vector_catch)
+        self.step_into_interrupt = options.get('step_into_interrupt', False)
+        self.persist = options.get('persist', False)
+        self.soft_bkpt_as_hard = options.get('soft_bkpt_as_hard', False)
+        self.chip_erase = options.get('chip_erase', None)
+        self.hide_programming_progress = options.get('hide_programming_progress', False)
+        self.fast_program = options.get('fast_program', False)
+        self.enable_semihosting = options.get('enable_semihosting', False)
+        self.semihost_console_type = options.get('semihost_console_type', 'telnet')
+        self.telnet_port = options.get('telnet_port', 4444)
+        self.semihost_use_syscalls = options.get('semihost_use_syscalls', False)
+        self.server_listening_callback = options.get('server_listening_callback', None)
+        self.serve_local_only = options.get('serve_local_only', True)
+        self.packet_size = 2048
+        self.packet_io = None
+        self.gdb_features = []
+        self.non_stop = False
+        self.is_target_running = (self.target.getState() == Target.TARGET_RUNNING)
+        self.flashBuilder = None
+        self.lock = threading.Lock()
+        self.shutdown_event = threading.Event()
+        self.detach_event = threading.Event()
+        self.target_context = self.target.getTargetContext()
+        self.target_facade = GDBDebugContextFacade(self.target_context)
+        self.thread_provider = None
+        self.did_init_thread_providers = False
+        self.current_thread_id = 0
+        if self.wss_server == None:
+            self.abstract_socket = GDBSocket(self.port, self.packet_size)
+            if self.serve_local_only:
+                self.abstract_socket.host = 'localhost'
+        else:
+            self.abstract_socket = GDBWebSocket(self.wss_server)
+
+        # Init semihosting and telnet console.
+        if self.semihost_use_syscalls:
+            semihost_io_handler = GDBSyscallIOHandler(self)
+        else:
+            # Use internal IO handler.
+            semihost_io_handler = semihost.InternalSemihostIOHandler()
+
+        self.log.error("semihosting console = %s" % self.semihost_console_type)
+        if self.semihost_console_type == 'telnet':
+            self.telnet_console = semihost.TelnetSemihostIOHandler(self.telnet_port, self.serve_local_only)
+            semihost_console = self.telnet_console
+        else:
+            self.telnet_console = None
+            semihost_console = semihost_io_handler
+        self.semihost = semihost.SemihostAgent(self.target_context, io_handler=semihost_io_handler, console=semihost_console)
+
+        # Command handler table.
+        #
+        # The dict keys are the first character of the incoming command from gdb. Values are a
+        # bi-tuple. The first element is the handler method, and the second element is the start
+        # offset of the command string passed to the handler.
+        #
+        # Start offset values:
+        #  0 - Special case: handler method does not take any parameters.
+        #  1 - Strip off leading "$" from command.
+        #  2 - Strip leading "$" plus character matched through this table.
+        #  3+ - Supported, but not very useful.
+        #
+        self.COMMANDS = {
+        #       CMD    HANDLER                  START    DESCRIPTION
+                '?' : (self.stopReasonQuery,    0   ), # Stop reason query.
+                'c' : (self.resume,             1   ), # Continue (at addr)
+                'C' : (self.resume,             1   ), # Continue with signal.
+                'D' : (self.detach,             1   ), # Detach.
+                'g' : (self.getRegisters,       0   ), # Read general registers.
+                'G' : (self.setRegisters,       2   ), # Write general registers.
+                'H' : (self.setThread,          2   ), # Set thread for subsequent operations.
+                'k' : (self.kill,               0   ), # Kill.
+                'm' : (self.getMemory,          2   ), # Read memory.
+                'M' : (self.writeMemoryHex,     2   ), # Write memory (hex).
+                'p' : (self.readRegister,       2   ), # Read register.
+                'P' : (self.writeRegister,      2   ), # Write register.
+                'q' : (self.handleQuery,        2   ), # General query.
+                'Q' : (self.handleGeneralSet,   2   ), # General set.
+                's' : (self.step,               1   ), # Single step.
+                'S' : (self.step,               1   ), # Step with signal.
+                'T' : (self.isThreadAlive,      1   ), # Thread liveness query.
+                'v' : (self.vCommand,           2   ), # v command.
+                'X' : (self.writeMemory,        2   ), # Write memory (binary).
+                'z' : (self.breakpoint,         1   ), # Insert breakpoint/watchpoint.
+                'Z' : (self.breakpoint,         1   ), # Remove breakpoint/watchpoint.
+            }
+
+        # Commands that kill the connection to gdb.
+        self.DETACH_COMMANDS = ('D', 'k')
+
+        self.setDaemon(True)
+        self.start()
+
+    def restart(self):
+        if self.isAlive():
+            self.detach_event.set()
+
+    def stop(self):
+        if self.isAlive():
+            self.shutdown_event.set()
+            while self.isAlive():
+                pass
+            self.log.info("GDB server thread killed")
+        self.board.uninit()
+
+    def setBoard(self, board, stop=True):
+        self.lock.acquire()
+        if stop:
+            self.restart()
+        self.board = board
+        self.target = board.target
+        self.flash = board.flash
+        self.lock.release()
+        return
+
+    def _cleanup(self):
+        self.log.debug("GDB server cleaning up")
+        if self.packet_io:
+            self.packet_io.stop()
+            self.packet_io = None
+        if self.semihost:
+            self.semihost.cleanup()
+            self.semihost = None
+        if self.telnet_console:
+            self.telnet_console.stop()
+            self.telnet_console = None
+
+    def _cleanup_for_next_connection(self):
+        self.non_stop = False
+        self.thread_provider = None
+        self.did_init_thread_providers = False
+        self.current_thread_id = 0
+
+    def run(self):
+        self.log.info('GDB server started at port:%d', self.port)
+
+        while True:
+            try:
+                self.detach_event.clear()
+
+                # Inform callback that the server is running.
+                if self.server_listening_callback:
+                    self.server_listening_callback(self)
+
+                while not self.shutdown_event.isSet() and not self.detach_event.isSet():
+                    connected = self.abstract_socket.connect()
+                    if connected != None:
+                        self.packet_io = GDBServerPacketIOThread(self.abstract_socket)
+                        break
+
+                if self.shutdown_event.isSet():
+                    self._cleanup()
+                    return
+
+                if self.detach_event.isSet():
+                    continue
+
+                self.log.info("One client connected!")
+                self._run_connection()
+
+            except Exception as e:
+                self.log.error("Unexpected exception: %s", e)
+                traceback.print_exc()
+
+    def _run_connection(self):
+        while True:
+            try:
+                if self.shutdown_event.isSet():
+                    self._cleanup()
+                    return
+
+                if self.detach_event.isSet():
+                    break
+
+                if self.packet_io.interrupt_event.isSet():
+                    if self.non_stop:
+                        self.target.halt()
+                        self.is_target_running = False
+                        self.sendStopNotification()
+                    else:
+                        self.log.error("Got unexpected ctrl-c, ignoring")
+                    self.packet_io.interrupt_event.clear()
+
+                if self.non_stop and self.is_target_running:
+                    try:
+                        if self.target.getState() == Target.TARGET_HALTED:
+                            self.log.debug("state halted")
+                            self.is_target_running = False
+                            self.sendStopNotification()
+                    except Exception as e:
+                        self.log.error("Unexpected exception: %s", e)
+                        traceback.print_exc()
+
+                # read command
+                try:
+                    packet = self.packet_io.receive(block=not self.non_stop)
+                except ConnectionClosedException:
+                    break
+
+                if self.shutdown_event.isSet():
+                    self._cleanup()
+                    return
+
+                if self.detach_event.isSet():
+                    break
+
+                if self.non_stop and packet is None:
+                    sleep(0.1)
+                    continue
+
+                self.lock.acquire()
+
+                if len(packet) != 0:
+                    # decode and prepare resp
+                    resp, detach = self.handleMsg(packet)
+
+                    if resp is not None:
+                        # send resp
+                        self.packet_io.send(resp)
+
+                    if detach:
+                        self.abstract_socket.close()
+                        self.packet_io.stop()
+                        self.packet_io = None
+                        self.lock.release()
+                        if self.persist:
+                            self._cleanup_for_next_connection()
+                            break
+                        else:
+                            self.shutdown_event.set()
+                            return
+
+                self.lock.release()
+
+            except Exception as e:
+                self.log.error("Unexpected exception: %s", e)
+                traceback.print_exc()
+
+    def handleMsg(self, msg):
+        try:
+            assert msg[0] == '$', "invalid first char of message (!= $"
+
+            try:
+                handler, msgStart = self.COMMANDS[msg[1]]
+                if msgStart == 0:
+                    reply = handler()
+                else:
+                    reply = handler(msg[msgStart:])
+                detach = 1 if msg[1] in self.DETACH_COMMANDS else 0
+                return reply, detach
+            except (KeyError, IndexError):
+                self.log.error("Unknown RSP packet: %s", msg)
+                return self.createRSPPacket(""), 0
+
+        except Exception as e:
+            self.log.error("Unhandled exception in handleMsg: %s", e)
+            traceback.print_exc()
+            return self.createRSPPacket("E01"), 0
+
+    def detach(self, data):
+        self.log.info("Client detached")
+        resp = "OK"
+        return self.createRSPPacket(resp)
+
+    def kill(self):
+        self.log.debug("GDB kill")
+        # Keep target halted and leave vector catches if in persistent mode.
+        if not self.persist:
+            self.board.target.setVectorCatch(Target.CATCH_NONE)
+            self.board.target.resume()
+        return self.createRSPPacket("")
+
+    def breakpoint(self, data):
+        # handle breakpoint/watchpoint commands
+        split = data.split('#')[0].split(',')
+        addr = int(split[1], 16)
+        self.log.debug("GDB breakpoint %s%d @ %x" % (data[0], int(data[1]), addr))
+
+        # handle software breakpoint Z0/z0
+        if data[1] == '0' and not self.soft_bkpt_as_hard:
+            if data[0] == 'Z':
+                if not self.target.setBreakpoint(addr, Target.BREAKPOINT_SW):
+                    return self.createRSPPacket('E01') #EPERM
+            else:
+                self.target.removeBreakpoint(addr)
+            return self.createRSPPacket("OK")
+
+        # handle hardware breakpoint Z1/z1
+        if data[1] == '1' or (self.soft_bkpt_as_hard and data[1] == '0'):
+            if data[0] == 'Z':
+                if self.target.setBreakpoint(addr, Target.BREAKPOINT_HW) == False:
+                    return self.createRSPPacket('E01') #EPERM
+            else:
+                self.target.removeBreakpoint(addr)
+            return self.createRSPPacket("OK")
+
+        # handle hardware watchpoint Z2/z2/Z3/z3/Z4/z4
+        if data[1] == '2':
+            # Write-only watch
+            watchpoint_type = Target.WATCHPOINT_WRITE
+        elif data[1] == '3':
+            # Read-only watch
+            watchpoint_type = Target.WATCHPOINT_READ
+        elif data[1] == '4':
+            # Read-Write watch
+            watchpoint_type = Target.WATCHPOINT_READ_WRITE
+        else:
+            return self.createRSPPacket('E01') #EPERM
+
+        size = int(split[2], 16)
+        if data[0] == 'Z':
+            if self.target.setWatchpoint(addr, size, watchpoint_type) == False:
+                return self.createRSPPacket('E01') #EPERM
+        else:
+            self.target.removeWatchpoint(addr, size, watchpoint_type)
+        return self.createRSPPacket("OK")
+
+    def setThread(self, data):
+        if not self.is_threading_enabled():
+            return self.createRSPPacket('OK')
+
+        self.log.debug("setThread:%s", data)
+        op = data[0]
+        thread_id = int(data[1:-3], 16)
+        if not (thread_id in (0, -1) or self.thread_provider.is_valid_thread_id(thread_id)):
+            return self.createRSPPacket('E01')
+
+        if op == 'c':
+            pass
+        elif op == 'g':
+            if thread_id == -1:
+                self.target_facade.set_context(self.target_context)
+            else:
+                if thread_id == 0:
+                    thread = self.thread_provider.current_thread
+                    thread_id = thread.unique_id
+                else:
+                    thread = self.thread_provider.get_thread(thread_id)
+                self.target_facade.set_context(thread.context)
+        else:
+            return self.createRSPPacket('E01')
+
+        self.current_thread_id = thread_id
+        return self.createRSPPacket('OK')
+
+    def isThreadAlive(self, data):
+        threadId = int(data[1:-3], 16)
+
+        if self.is_threading_enabled():
+            isAlive = self.thread_provider.is_valid_thread_id(threadId)
+        else:
+            isAlive = (threadId == 1)
+
+        if isAlive:
+            return self.createRSPPacket('OK')
+        else:
+            self.validateDebugContext()
+            return self.createRSPPacket('E00')
+
+    def validateDebugContext(self):
+        if self.is_threading_enabled():
+            currentThread = self.thread_provider.current_thread
+            if self.current_thread_id != currentThread.unique_id:
+                self.target_facade.set_context(currentThread.context)
+                self.current_thread_id = currentThread.unique_id
+        else:
+            if self.current_thread_id != 1:
+                self.log.debug("Current thread %x is no longer valid, switching context to target", self.current_thread_id)
+                self.target_facade.set_context(self.target_context)
+                self.current_thread_id = 1
+
+    def stopReasonQuery(self):
+        # In non-stop mode, if no threads are stopped we need to reply with OK.
+        if self.non_stop and self.is_target_running:
+            return self.createRSPPacket("OK")
+
+        return self.createRSPPacket(self.getTResponse())
+
+    def _get_resume_step_addr(self, data):
+        if data is None:
+            return None
+        data = data.split('#')[0]
+        if ';' not in data:
+            return None
+        # c[;addr]
+        if data[0] in ('c', 's'):
+            addr = int(data[2:], base=16)
+        # Csig[;addr]
+        elif data[0] in ('C', 'S'):
+            addr = int(data[1:].split(';')[1], base=16)
+        return addr
+
+    def resume(self, data):
+        addr = self._get_resume_step_addr(data)
+        self.target.resume()
+        self.log.debug("target resumed")
+
+        val = ''
+
+        while True:
+            if self.shutdown_event.isSet():
+                self.packet_io.interrupt_event.clear()
+                return self.createRSPPacket(val)
+
+            # Wait for a ctrl-c to be received.
+            if self.packet_io.interrupt_event.wait(0.01):
+                self.log.debug("receive CTRL-C")
+                self.packet_io.interrupt_event.clear()
+                self.target.halt()
+                val = self.getTResponse(forceSignal=signals.SIGINT)
+                break
+
+            try:
+                if self.target.getState() == Target.TARGET_HALTED:
+                    # Handle semihosting
+                    if self.enable_semihosting:
+                        was_semihost = self.semihost.check_and_handle_semihost_request()
+
+                        if was_semihost:
+                            self.target.resume()
+                            continue
+
+                    pc = self.target_context.readCoreRegister('pc')
+                    self.log.debug("state halted; pc=0x%08x", pc)
+                    val = self.getTResponse()
+                    break
+            except Exception as e:
+                try:
+                    self.target.halt()
+                except:
+                    pass
+                traceback.print_exc()
+                self.log.debug('Target is unavailable temporarily.')
+                val = 'S%02x' % self.target_facade.getSignalValue()
+                break
+
+        return self.createRSPPacket(val)
+
+    def step(self, data):
+        addr = self._get_resume_step_addr(data)
+        self.log.debug("GDB step: %s", data)
+        self.target.step(not self.step_into_interrupt)
+        return self.createRSPPacket(self.getTResponse())
+
+    def halt(self):
+        self.target.halt()
+        return self.createRSPPacket(self.getTResponse())
+
+    def sendStopNotification(self, forceSignal=None):
+        data = self.getTResponse(forceSignal=forceSignal)
+        packet = '%Stop:' + data + '#' + checksum(data)
+        self.packet_io.send(packet)
+
+    def vCommand(self, data):
+        cmd = data.split('#')[0]
+
+        # Flash command.
+        if cmd.startswith('Flash'):
+            return self.flashOp(data)
+
+        # vCont capabilities query.
+        elif 'Cont?' == cmd:
+            return self.createRSPPacket("vCont;c;C;s;S;t")
+
+        # vCont, thread action command.
+        elif cmd.startswith('Cont'):
+            return self.vCont(cmd)
+
+        # vStopped, part of thread stop state notification sequence.
+        elif 'Stopped' in cmd:
+            # Because we only support one thread for now, we can just reply OK to vStopped.
+            return self.createRSPPacket("OK")
+
+        return self.createRSPPacket("")
+
+    # Example: $vCont;s:1;c#c1
+    def vCont(self, cmd):
+        ops = cmd.split(';')[1:] # split and remove 'Cont' from list
+        if not ops:
+            return self.createRSPPacket("OK")
+
+        if self.is_threading_enabled():
+            thread_actions = {}
+            threads = self.thread_provider.get_threads()
+            for k in threads:
+                thread_actions[k.unique_id] = None
+            currentThread = self.thread_provider.get_current_thread_id()
+        else:
+            thread_actions = { 1 : None } # our only thread
+            currentThread = 1
+        default_action = None
+
+        for op in ops:
+            args = op.split(':')
+            action = args[0]
+            if len(args) > 1:
+                thread_id = int(args[1], 16)
+                if thread_id == -1 or thread_id == 0:
+                    thread_id = currentThread
+                thread_actions[thread_id] = action
+            else:
+                default_action = action
+
+        self.log.debug("thread_actions=%s; default_action=%s", repr(thread_actions), default_action)
+
+        # Only the current thread is supported at the moment.
+        if thread_actions[currentThread] is None:
+            if default_action is None:
+                return self.createRSPPacket('E01')
+            thread_actions[currentThread] = default_action
+
+        if thread_actions[currentThread][0] in ('c', 'C'):
+            if self.non_stop:
+                self.target.resume()
+                self.is_target_running = True
+                return self.createRSPPacket("OK")
+            else:
+                return self.resume(None)
+        elif thread_actions[currentThread][0] in ('s', 'S'):
+            if self.non_stop:
+                self.target.step(not self.step_into_interrupt)
+                self.packet_io.send(self.createRSPPacket("OK"))
+                self.sendStopNotification()
+                return None
+            else:
+                return self.step(None)
+        elif thread_actions[currentThread] == 't':
+            # Must ignore t command in all-stop mode.
+            if not self.non_stop:
+                return self.createRSPPacket("")
+            self.packet_io.send(self.createRSPPacket("OK"))
+            self.target.halt()
+            self.is_target_running = False
+            self.sendStopNotification(forceSignal=0)
+        else:
+            self.log.error("Unsupported vCont action '%s'" % thread_actions[1])
+
+    def flashOp(self, data):
+        ops = data.split(':')[0]
+        self.log.debug("flash op: %s", ops)
+
+        if ops == 'FlashErase':
+            return self.createRSPPacket("OK")
+
+        elif ops == 'FlashWrite':
+            write_addr = int(data.split(':')[1], 16)
+            self.log.debug("flash write addr: 0x%x", write_addr)
+            # search for second ':' (beginning of data encoded in the message)
+            second_colon = 0
+            idx_begin = 0
+            while second_colon != 2:
+                if data[idx_begin] == ':':
+                    second_colon += 1
+                idx_begin += 1
+
+            # Get flash builder if there isn't one already
+            if self.flashBuilder == None:
+                self.flashBuilder = self.flash.getFlashBuilder()
+
+            # Add data to flash builder
+            self.flashBuilder.addData(write_addr, self.unescape(data[idx_begin:len(data) - 3]))
+
+
+            return self.createRSPPacket("OK")
+
+        # we need to flash everything
+        elif 'FlashDone' in ops :
+
+            def print_progress(progress):
+                # Reset state on 0.0
+                if progress == 0.0:
+                    print_progress.done = False
+
+                # print progress bar
+                if not print_progress.done:
+                    sys.stdout.write('\r')
+                    i = int(progress * 20.0)
+                    sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
+                    sys.stdout.flush()
+
+                # Finish on 1.0
+                if progress >= 1.0:
+                    if not print_progress.done:
+                        print_progress.done = True
+                        sys.stdout.write("\r\n")
+                        sys.stdout.flush()
+
+            if self.hide_programming_progress:
+                progress_cb = None
+            else:
+                 progress_cb = print_progress
+
+            self.flashBuilder.program(chip_erase=self.chip_erase, progress_cb=progress_cb, fast_verify=self.fast_program)
+
+            # Set flash builder to None so that on the next flash command a new
+            # object is used.
+            self.flashBuilder = None
+
+            return self.createRSPPacket("OK")
+
+        return None
+
+    def unescape(self, data):
+        data_idx = 0
+
+        # unpack the data into binary array
+        str_unpack = str(len(data)) + 'B'
+        data = unpack(str_unpack, data)
+        data = list(data)
+
+        # check for escaped characters
+        while data_idx < len(data):
+            if data[data_idx] == 0x7d:
+                data.pop(data_idx)
+                data[data_idx] = data[data_idx] ^ 0x20
+            data_idx += 1
+
+        return data
+
+    def escape(self, data):
+        result = ''
+        for c in data:
+            if c in '#$}*':
+                result += '}' + chr(ord(c) ^ 0x20)
+            else:
+                result += c
+        return result
+
+    def getMemory(self, data):
+        split = data.split(',')
+        addr = int(split[0], 16)
+        length = split[1].split('#')[0]
+        length = int(length, 16)
+
+        if LOG_MEM:
+            self.log.debug("GDB getMem: addr=%x len=%x", addr, length)
+
+        try:
+            val = ''
+            mem = self.target_context.readBlockMemoryUnaligned8(addr, length)
+            # Flush so an exception is thrown now if invalid memory was accesses
+            self.target_context.flush()
+            for x in mem:
+                if x >= 0x10:
+                    val += hex(x)[2:4]
+                else:
+                    val += '0' + hex(x)[2:3]
+        except DAPAccess.TransferError:
+            self.log.debug("getMemory failed at 0x%x" % addr)
+            val = 'E01' #EPERM
+        except MemoryAccessError as e:
+            logging.debug("getMemory failed at 0x%x: %s", addr, str(e))
+            val = 'E01' #EPERM
+        return self.createRSPPacket(val)
+
+    def writeMemoryHex(self, data):
+        split = data.split(',')
+        addr = int(split[0], 16)
+
+        split = split[1].split(':')
+        length = int(split[0], 16)
+
+        split = split[1].split('#')
+        data = hexToByteList(split[0])
+
+        if LOG_MEM:
+            self.log.debug("GDB writeMemHex: addr=%x len=%x", addr, length)
+
+        try:
+            if length > 0:
+                self.target_context.writeBlockMemoryUnaligned8(addr, data)
+                # Flush so an exception is thrown now if invalid memory was accessed
+                self.target_context.flush()
+            resp = "OK"
+        except DAPAccess.TransferError:
+            self.log.debug("writeMemory failed at 0x%x" % addr)
+            resp = 'E01' #EPERM
+        except MemoryAccessError as e:
+            logging.debug("getMemory failed at 0x%x: %s", addr, str(e))
+            val = 'E01' #EPERM
+
+        return self.createRSPPacket(resp)
+
+    def writeMemory(self, data):
+        split = data.split(',')
+        addr = int(split[0], 16)
+        length = int(split[1].split(':')[0], 16)
+
+        if LOG_MEM:
+            self.log.debug("GDB writeMem: addr=%x len=%x", addr, length)
+
+        idx_begin = 0
+        for i in range(len(data)):
+            if data[i] == ':':
+                idx_begin += 1
+                break
+            idx_begin += 1
+
+        data = data[idx_begin:len(data) - 3]
+        data = self.unescape(data)
+
+        try:
+            if length > 0:
+                self.target_context.writeBlockMemoryUnaligned8(addr, data)
+                # Flush so an exception is thrown now if invalid memory was accessed
+                self.target_context.flush()
+            resp = "OK"
+        except DAPAccess.TransferError:
+            self.log.debug("writeMemory failed at 0x%x" % addr)
+            resp = 'E01' #EPERM
+        except MemoryAccessError as e:
+            logging.debug("getMemory failed at 0x%x: %s", addr, str(e))
+            val = 'E01' #EPERM
+
+        return self.createRSPPacket(resp)
+
+    def readRegister(self, which):
+        return self.createRSPPacket(self.target_facade.gdbGetRegister(which))
+
+    def writeRegister(self, data):
+        reg = int(data.split('=')[0], 16)
+        val = data.split('=')[1].split('#')[0]
+        self.target_facade.setRegister(reg, val)
+        return self.createRSPPacket("OK")
+
+    def getRegisters(self):
+        return self.createRSPPacket(self.target_facade.getRegisterContext())
+
+    def setRegisters(self, data):
+        self.target_facade.setRegisterContext(data)
+        return self.createRSPPacket("OK")
+
+    def handleQuery(self, msg):
+        query = msg.split(':')
+        self.log.debug('GDB received query: %s', query)
+
+        if query is None:
+            self.log.error('GDB received query packet malformed')
+            return None
+
+        if query[0] == 'Supported':
+            # Save features sent by gdb.
+            self.gdb_features = query[1].split(';')
+
+            # Build our list of features.
+            features = ['qXfer:features:read+', 'QStartNoAckMode+', 'qXfer:threads:read+', 'QNonStop+']
+            features.append('PacketSize=' + hex(self.packet_size)[2:])
+            if self.target_facade.getMemoryMapXML() is not None:
+                features.append('qXfer:memory-map:read+')
+            resp = ';'.join(features)
+            return self.createRSPPacket(resp)
+
+        elif query[0] == 'Xfer':
+
+            if query[1] == 'features' and query[2] == 'read' and \
+               query[3] == 'target.xml':
+                data = query[4].split(',')
+                resp = self.handleQueryXML('read_feature', int(data[0], 16), int(data[1].split('#')[0], 16))
+                return self.createRSPPacket(resp)
+
+            elif query[1] == 'memory-map' and query[2] == 'read':
+                data = query[4].split(',')
+                resp = self.handleQueryXML('memory_map', int(data[0], 16), int(data[1].split('#')[0], 16))
+                return self.createRSPPacket(resp)
+
+            elif query[1] == 'threads' and query[2] == 'read':
+                data = query[4].split(',')
+                resp = self.handleQueryXML('threads', int(data[0], 16), int(data[1].split('#')[0], 16))
+                return self.createRSPPacket(resp)
+
+            else:
+                self.log.debug("Unsupported qXfer request: %s:%s:%s:%s", query[1], query[2], query[3], query[4])
+                return None
+
+        elif query[0].startswith('C'):
+            if not self.is_threading_enabled():
+                return self.createRSPPacket("QC1")
+            else:
+                self.validateDebugContext()
+                return self.createRSPPacket("QC%x" % self.current_thread_id)
+
+        elif query[0].find('Attached') != -1:
+            return self.createRSPPacket("1")
+
+        elif query[0].find('TStatus') != -1:
+            return self.createRSPPacket("")
+
+        elif query[0].find('Tf') != -1:
+            return self.createRSPPacket("")
+
+        elif 'Offsets' in query[0]:
+            resp = "Text=0;Data=0;Bss=0"
+            return self.createRSPPacket(resp)
+
+        elif 'Symbol' in query[0]:
+            if self.did_init_thread_providers:
+                return self.createRSPPacket("OK")
+            return self.initThreadProviders()
+
+        elif query[0].startswith('Rcmd,'):
+            cmd = hexDecode(query[0][5:].split('#')[0])
+            return self.handleRemoteCommand(cmd)
+
+        else:
+            return self.createRSPPacket("")
+
+    def initThreadProviders(self):
+        symbol_provider = GDBSymbolProvider(self)
+
+        for rtosName, rtosClass in RTOS.iteritems():
+            try:
+                self.log.info("Attempting to load %s", rtosName)
+                rtos = rtosClass(self.target)
+                if rtos.init(symbol_provider):
+                    self.log.info("%s loaded successfully", rtosName)
+                    self.thread_provider = rtos
+                    break
+            except RuntimeError as e:
+                self.log.error("Error during symbol lookup: " + str(e))
+                traceback.print_exc()
+
+        self.did_init_thread_providers = True
+
+        # Done with symbol processing.
+        return self.createRSPPacket("OK")
+
+    def getSymbol(self, name):
+        # Send the symbol request.
+        request = self.createRSPPacket('qSymbol:' + hexEncode(name))
+        self.packet_io.send(request)
+
+        # Read a packet.
+        packet = self.packet_io.receive()
+
+        # Parse symbol value reply packet.
+        packet = packet[1:-3]
+        if not packet.startswith('qSymbol:'):
+            raise RuntimeError("Got unexpected response from gdb when asking for symbol value")
+        packet = packet[8:]
+        symValue, symName = packet.split(':')
+
+        symName = hexDecode(symName)
+        if symName != name:
+            raise RuntimeError("Symbol value reply from gdb has unexpected symbol name")
+        if symValue:
+            symValue = hex8leToU32le(symValue)
+        else:
+            return None
+        return symValue
+
+    # TODO rewrite the remote command handler
+    def handleRemoteCommand(self, cmd):
+        self.log.debug('Remote command: %s', cmd)
+
+        safecmd = {
+            'init'  : ['Init reset sequence', 0x1],
+            'reset' : ['Reset and halt the target', 0x2],
+            'halt'  : ['Halt target', 0x4],
+            # 'resume': ['Resume target', 0x8],
+            'help'  : ['Display this help', 0x80],
+        }
+
+        cmdList = cmd.split()
+        resp = 'OK'
+        if cmd == 'help':
+            resp = ''.join(['%s\t%s\n' % (k, v[0]) for k, v in safecmd.items()])
+            resp = hexEncode(resp)
+        elif cmd.startswith('arm semihosting'):
+            self.enable_semihosting = 'enable' in cmd
+            self.log.info("Semihosting %s", ('enabled' if self.enable_semihosting else 'disabled'))
+        elif cmdList[0] == 'set':
+            if len(cmdList) < 3:
+                resp = hexEncode("Error: invalid set command")
+            elif cmdList[1] == 'vector-catch':
+                try:
+                    self.board.target.setVectorCatch(convert_vector_catch(cmdList[2]))
+                except ValueError as e:
+                    resp = hexEncode("Error: " + str(e))
+            elif cmdList[1] == 'step-into-interrupt':
+                self.step_into_interrupt = (cmdList[2].lower() in ("true", "on", "yes", "1"))
+            else:
+                resp = hexEncode("Error: invalid set option")
+        else:
+            resultMask = 0x00
+            if cmdList[0] == 'help':
+                # a 'help' is only valid as the first cmd, and only
+                # gives info on the second cmd if it is valid
+                resultMask |= 0x80
+                del cmdList[0]
+
+            for cmd_sub in cmdList:
+                if cmd_sub not in safecmd:
+                    self.log.warning("Invalid mon command '%s'", cmd_sub)
+                    resp = 'Invalid Command: "%s"\n' % cmd_sub
+                    resp = hexEncode(resp)
+                    return self.createRSPPacket(resp)
+                elif resultMask == 0x80:
+                    # if the first command was a 'help', we only need
+                    # to return info about the first cmd after it
+                    resp = hexEncode(safecmd[cmd_sub][0]+'\n')
+                    return self.createRSPPacket(resp)
+                resultMask |= safecmd[cmd_sub][1]
+
+            # Run cmds in proper order
+            if resultMask & 0x1:
+                pass
+            if (resultMask & 0x6) == 0x6:
+                self.target.resetStopOnReset()
+            elif resultMask & 0x2:
+                # on 'reset' still do a reset halt
+                self.target.resetStopOnReset()
+                # self.target.reset()
+            elif resultMask & 0x4:
+                self.target.halt()
+            # if resultMask & 0x8:
+            #     self.target.resume()
+
+        return self.createRSPPacket(resp)
+
+    def handleGeneralSet(self, msg):
+        feature = msg.split('#')[0]
+        self.log.debug("GDB general set: %s", feature)
+
+        if feature == 'StartNoAckMode':
+            # Disable acks after the reply and ack.
+            self.packet_io.set_send_acks(False)
+            return self.createRSPPacket("OK")
+
+        elif feature.startswith('NonStop'):
+            enable = feature.split(':')[1]
+            self.non_stop = (enable == '1')
+            return self.createRSPPacket("OK")
+
+        else:
+            return self.createRSPPacket("")
+
+    def handleQueryXML(self, query, offset, size):
+        self.log.debug('GDB query %s: offset: %s, size: %s', query, offset, size)
+        xml = ''
+        if query == 'memory_map':
+            xml = self.target_facade.getMemoryMapXML()
+        elif query == 'read_feature':
+            xml = self.target.getTargetXML()
+        elif query == 'threads':
+            xml = self.getThreadsXML()
+        else:
+            raise RuntimeError("Invalid XML query (%s)" % query)
+
+        size_xml = len(xml)
+
+        prefix = 'm'
+
+        if offset > size_xml:
+            self.log.error('GDB: xml offset > size for %s!', query)
+            return
+
+        if size > (self.packet_size - 4):
+            size = self.packet_size - 4
+
+        nbBytesAvailable = size_xml - offset
+
+        if size > nbBytesAvailable:
+            prefix = 'l'
+            size = nbBytesAvailable
+
+        resp = prefix + self.escape(xml[offset:offset + size])
+
+        return resp
+
+
+    def createRSPPacket(self, data):
+        resp = '$' + data + '#' + checksum(data)
+        return resp
+
+    def syscall(self, op):
+        self.log.debug("GDB server syscall: %s", op)
+        request = self.createRSPPacket('F' + op)
+        self.packet_io.send(request)
+
+        while not self.packet_io.interrupt_event.is_set():
+            # Read a packet.
+            packet = self.packet_io.receive(False)
+            if packet is None:
+                sleep(0.1)
+                continue
+
+            # Check for file I/O response.
+            if packet[0] == '$' and packet[1] == 'F':
+                self.log.debug("Syscall: got syscall response " + packet)
+                args = packet[2:packet.index('#')].split(',')
+                result = int(args[0], base=16)
+                errno = int(args[1], base=16) if len(args) > 1 else 0
+                ctrl_c = args[2] if len(args) > 2 else ''
+                if ctrl_c == 'C':
+                    self.packet_io.interrupt_event.set()
+                    self.packet_io.drop_reply = True
+                return result, errno
+
+            # decode and prepare resp
+            resp, detach = self.handleMsg(packet)
+
+            if resp is not None:
+                # send resp
+                self.packet_io.send(resp)
+
+            if detach:
+                self.detach_event.set()
+                self.log.warning("GDB server received detach request while waiting for file I/O completion")
+                break
+
+        return -1, 0
+
+    def getTResponse(self, forceSignal=None):
+        self.validateDebugContext()
+        response = self.target_facade.getTResponse(forceSignal)
+
+        # Append thread and core
+        if not self.is_threading_enabled():
+            response += "thread:1;core:0;"
+        else:
+            if self.current_thread_id in (-1, 0, 1):
+                response += "thread:%x;core:0;" % self.thread_provider.current_thread.unique_id
+            else:
+                response += "thread:%x;core:0;" % self.current_thread_id
+        self.log.debug("Tresponse=%s", response)
+        return response
+
+    def getThreadsXML(self):
+        root = Element('threads')
+
+        if not self.is_threading_enabled():
+            t = SubElement(root, 'thread', id="1", core="0")
+            t.text = "Thread mode"
+        else:
+            threads = self.thread_provider.get_threads()
+            for thread in threads:
+                hexId = "%x" % thread.unique_id
+                t = SubElement(root, 'thread', id=hexId, core="0")
+
+                desc = thread.description
+                if desc:
+                    desc = thread.name + "; " + desc
+                else:
+                    desc = thread.name
+                t.text = desc
+
+        return '<?xml version="1.0"?><!DOCTYPE feature SYSTEM "threads.dtd">' + tostring(root)
+
+    def is_threading_enabled(self):
+        return (self.thread_provider is not None) and self.thread_provider.is_enabled \
+            and (self.thread_provider.current_thread is not None)
+
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/gdbserver/gdb_socket.py` & `pyOCD-0.9.0/pyOCD/gdbserver/gdb_socket.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import socket, select
-
-class GDBSocket(object):
-    def __init__(self, port, packet_size):
-        self.packet_size = packet_size
-        self.s = None
-        self.conn = None
-        self.port = port
-        self.host = ''
-
-    def init(self):
-        if self.s is None:
-            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-            self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-            self.s.bind((self.host, self.port))
-            self.s.listen(5)
-
-    def connect(self):
-        self.conn = None
-        self.init()
-        rr, _, _ = select.select([self.s], [], [], 0.5)
-        if rr:
-            self.conn, _ = self.s.accept()
-
-        return self.conn
-
-    def read(self):
-        return self.conn.recv(self.packet_size)
-
-    def write(self, data):
-        return self.conn.send(data)
-
-    def close(self):
-        if self.conn is not None:
-            self.conn.close()
-            self.conn = None
-
-        return_value = None
-        if self.s is not None:
-            return_value = self.s.close()
-            self.s = None
-
-        return return_value
-
-
-    def setBlocking(self, blocking):
-        self.conn.setblocking(blocking)
-
-    def setTimeout(self, timeout):
-        self.conn.settimeout(timeout)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import socket, select
+
+class GDBSocket(object):
+    def __init__(self, port, packet_size):
+        self.packet_size = packet_size
+        self.s = None
+        self.conn = None
+        self.port = port
+        self.host = ''
+
+    def init(self):
+        if self.s is None:
+            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+            self.s.bind((self.host, self.port))
+            self.s.listen(5)
+
+    def connect(self):
+        self.conn = None
+        self.init()
+        rr, _, _ = select.select([self.s], [], [], 0.5)
+        if rr:
+            self.conn, _ = self.s.accept()
+
+        return self.conn
+
+    def read(self):
+        return self.conn.recv(self.packet_size)
+
+    def write(self, data):
+        return self.conn.send(data)
+
+    def close(self):
+        if self.conn is not None:
+            self.conn.close()
+            self.conn = None
+
+        return_value = None
+        if self.s is not None:
+            return_value = self.s.close()
+            self.s = None
+
+        return return_value
+
+
+    def setBlocking(self, blocking):
+        self.conn.setblocking(blocking)
+
+    def setTimeout(self, timeout):
+        self.conn.settimeout(timeout)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/gdbserver/gdb_websocket.py` & `pyOCD-0.9.0/pyOCD/gdbserver/gdb_websocket.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-try:
-    from websocket import create_connection
-except:
-    pass
-
-class GDBWebSocket(object):
-    def __init__(self, url):
-        self.url = url
-        self.wss = None
-        return
-
-    def connect(self):
-        self.wss = None
-        try:
-            self.wss = create_connection(self.url)
-        except:
-            pass
-        return self.wss
-
-    def read(self):
-        return self.wss.recv()
-
-    def write(self, data):
-        return self.wss.send(data)
-
-    def close(self):
-        return self.wss.close()
-
-    def setBlocking(self, blocking):
-        if blocking != 0:
-            self.wss.settimeout(None)
-        else:
-            self.wss.settimeout(0)
-
-    def setTimeout(self, timeout):
-        self.wss.settimeout(timeout)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+try:
+    from websocket import create_connection
+except:
+    pass
+
+class GDBWebSocket(object):
+    def __init__(self, url):
+        self.url = url
+        self.wss = None
+        return
+
+    def connect(self):
+        self.wss = None
+        try:
+            self.wss = create_connection(self.url)
+        except:
+            pass
+        return self.wss
+
+    def read(self):
+        return self.wss.recv()
+
+    def write(self, data):
+        return self.wss.send(data)
+
+    def close(self):
+        return self.wss.close()
+
+    def setBlocking(self, blocking):
+        if blocking != 0:
+            self.wss.settimeout(None)
+        else:
+            self.wss.settimeout(0)
+
+    def setTimeout(self, timeout):
+        self.wss.settimeout(timeout)
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/gdbserver/signals.py` & `pyOCD-0.9.0/pyOCD/coresight/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,17 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-SIGINT = 2
-SIGSEGV = 11
-SIGILL = 4
-SIGSTOP = 17
-SIGTRAP = 5
-SIGBUS = 10
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2017 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/gdbserver/__init__.py` & `pyOCD-0.9.0/pyOCD/tools/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from gdbserver import GDBServer
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/cmsis_dap_core.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/cmsis_dap_core.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,362 +1,379 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import logging
-import array
-from .dap_access_api import DAPAccessIntf
-import six
-
-COMMAND_ID = {'DAP_INFO': 0x00,
-              'DAP_LED': 0x01,
-              'DAP_CONNECT': 0x02,
-              'DAP_DISCONNECT': 0x03,
-              'DAP_TRANSFER_CONFIGURE': 0x04,
-              'DAP_TRANSFER': 0x05,
-              'DAP_TRANSFER_BLOCK': 0x06,
-              'DAP_TRANSFER_ABORT': 0x07,
-              'DAP_WRITE_ABORT': 0x08,
-              'DAP_DELAY': 0x09,
-              'DAP_RESET_TARGET': 0x0a,
-              'DAP_SWJ_PINS': 0x10,
-              'DAP_SWJ_CLOCK': 0x11,
-              'DAP_SWJ_SEQUENCE': 0x12,
-              'DAP_SWD_CONFIGURE': 0x13,
-              'DAP_JTAG_SEQUENCE': 0x14,
-              'DAP_JTAG_CONFIGURE': 0x15,
-              'DAP_JTAG_IDCODE': 0x16,
-              'DAP_VENDOR0': 0x80,
-              }
-
-ID_INFO = {'VENDOR_ID': 0x01,
-           'PRODUCT_ID': 0x02,
-           'SERIAL_NUMBER': 0x03,
-           'CMSIS_DAP_FW_VERSION': 0x04,
-           'TARGET_DEVICE_VENDOR': 0x05,
-           'TARGET_DEVICE_NAME': 0x06,
-           'CAPABILITIES': 0xf0,
-           'PACKET_COUNT': 0xfe,
-           'PACKET_SIZE': 0xff
-           }
-
-PINS = {'None': 0x00,
-        'SWCLK_TCK': (1 << 0),
-        'SWDIO_TMS': (1 << 1),
-        'TDI': (1 << 2),
-        'TDO': (1 << 3),
-        'nTRST': (1 << 5),
-        'nRESET': (1 << 7),
-        }
-
-DAP_DEFAULT_PORT = 0
-DAP_SWD_PORT = 1
-DAP_JTAG_POR = 2
-
-DAP_OK = 0
-DAP_ERROR = 0xff
-
-# Responses to DAP_Transfer and DAP_TransferBlock
-DAP_TRANSFER_OK = 1
-DAP_TRANSFER_WAIT = 2
-DAP_TRANSFER_FAULT = 4
-
-MAX_PACKET_SIZE = 0x0E
-
-## @brief This class implements the CMSIS-DAP wire protocol.
-class CMSIS_DAP_Protocol(object):
-    def __init__(self, interface):
-        self.interface = interface
-
-    def dapInfo(self, id_):
-        if not type(id_) in (six.integer_types):
-            id_ = ID_INFO[id_]
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_INFO'])
-        cmd.append(id_)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_INFO']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] == 0:
-            return
-
-        # Integer values
-        if id_ in (ID_INFO['CAPABILITIES'], ID_INFO['PACKET_COUNT'], ID_INFO['PACKET_SIZE']):
-            if resp[1] == 1:
-                return resp[2]
-            if resp[1] == 2:
-                return (resp[3] << 8) | resp[2]
-
-        # String values. They are sent as C strings with a terminating null char, so we strip it out.
-        x = array.array('B', [i for i in resp[2:2 + resp[1]]]).tostring()
-        if x[-1] == '\x00':
-            x = x[0:-1]
-        return x
-
-    def setLed(self):
-        #not yet implemented
-        return
-
-    def connect(self, mode=DAP_DEFAULT_PORT):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_CONNECT'])
-        cmd.append(mode)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_CONNECT']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] == 0:
-            # DAP connect failed
-            raise DAPAccessIntf.CommandError()
-
-        if resp[1] == 1:
-            logging.info('DAP SWD MODE initialised')
-
-        if resp[1] == 2:
-            logging.info('DAP JTAG MODE initialised')
-
-        return resp[1]
-
-    def disconnect(self):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_DISCONNECT'])
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_DISCONNECT']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP Disconnect failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-    def writeAbort(self, data, dap_index=0):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_WRITE_ABORT'])
-        cmd.append(dap_index)
-        cmd.append((data >> 0) & 0xff)
-        cmd.append((data >> 8) & 0xff)
-        cmd.append((data >> 16) & 0xff)
-        cmd.append((data >> 24) & 0xff)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_WRITE_ABORT']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP Write Abort failed
-            raise DAPAccessIntf.CommandError()
-
-        return True
-
-    def resetTarget(self):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_RESET_TARGET'])
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_RESET_TARGET']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP Reset target failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-    def transferConfigure(self, idle_cycles=0x00, wait_retry=0x0050, match_retry=0x0000):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_TRANSFER_CONFIGURE'])
-        cmd.append(idle_cycles)
-        cmd.append(wait_retry & 0xff)
-        cmd.append(wait_retry >> 8)
-        cmd.append(match_retry & 0xff)
-        cmd.append(match_retry >> 8)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_TRANSFER_CONFIGURE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP Transfer Configure failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-
-    def setSWJClock(self, clock=1000000):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_SWJ_CLOCK'])
-        cmd.append(clock & 0xff)
-        cmd.append((clock >> 8) & 0xff)
-        cmd.append((clock >> 16) & 0xff)
-        cmd.append((clock >> 24) & 0xff)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_SWJ_CLOCK']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP SWJ Clock failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-    def setSWJPins(self, output, pin, wait=0):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_SWJ_PINS'])
-        try:
-            p = PINS[pin]
-        except KeyError:
-                logging.error('cannot find %s pin', pin)
-                return
-        cmd.append(output & 0xff)
-        cmd.append(p)
-        cmd.append(wait & 0xff)
-        cmd.append((wait >> 8) & 0xff)
-        cmd.append((wait >> 16) & 0xff)
-        cmd.append((wait >> 24) & 0xff)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_SWJ_PINS']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        return resp[1]
-
-    def swdConfigure(self, conf=0):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_SWD_CONFIGURE'])
-        cmd.append(conf)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_SWD_CONFIGURE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP SWD Configure failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-    def swjSequence(self, data):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_SWJ_SEQUENCE'])
-        cmd.append(len(data) * 8)
-        for i in range(len(data)):
-            cmd.append(data[i])
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_SWJ_SEQUENCE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP SWJ Sequence failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[1]
-
-    def jtagSequence(self, info, tdi):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_JTAG_SEQUENCE'])
-        cmd.append(1)
-        cmd.append(info)
-        cmd.append(tdi)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_JTAG_SEQUENCE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP JTAG Sequence failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[2]
-
-    def jtagConfigure(self, irlen, dev_num=1):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_JTAG_CONFIGURE'])
-        cmd.append(dev_num)
-        cmd.append(irlen)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_JTAG_CONFIGURE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # DAP JTAG Configure failed
-            raise DAPAccessIntf.CommandError()
-
-        return resp[2:]
-
-    def jtagIDCode(self, index=0):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_JTAG_IDCODE'])
-        cmd.append(index)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-        if resp[0] != COMMAND_ID['DAP_JTAG_IDCODE']:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        if resp[1] != DAP_OK:
-            # Operation failed
-            raise DAPAccessIntf.CommandError()
-
-        return  (resp[2] << 0) | \
-                (resp[3] << 8) | \
-                (resp[4] << 16) | \
-                (resp[5] << 24)
-
-    def vendor(self, index, data):
-        cmd = []
-        cmd.append(COMMAND_ID['DAP_VENDOR0'] + index)
-        cmd.extend(data)
-        self.interface.write(cmd)
-
-        resp = self.interface.read()
-
-        if resp[0] != COMMAND_ID['DAP_VENDOR0'] + index:
-            # Response is to a different command
-            raise DAPAccessIntf.DeviceError()
-
-        return resp[1:]
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import logging
+import array
+from .dap_access_api import DAPAccessIntf
+import six
+
+COMMAND_ID = {'DAP_INFO': 0x00,
+              'DAP_LED': 0x01,
+              'DAP_CONNECT': 0x02,
+              'DAP_DISCONNECT': 0x03,
+              'DAP_TRANSFER_CONFIGURE': 0x04,
+              'DAP_TRANSFER': 0x05,
+              'DAP_TRANSFER_BLOCK': 0x06,
+              'DAP_TRANSFER_ABORT': 0x07,
+              'DAP_WRITE_ABORT': 0x08,
+              'DAP_DELAY': 0x09,
+              'DAP_RESET_TARGET': 0x0a,
+              'DAP_SWJ_PINS': 0x10,
+              'DAP_SWJ_CLOCK': 0x11,
+              'DAP_SWJ_SEQUENCE': 0x12,
+              'DAP_SWD_CONFIGURE': 0x13,
+              'DAP_JTAG_SEQUENCE': 0x14,
+              'DAP_JTAG_CONFIGURE': 0x15,
+              'DAP_JTAG_IDCODE': 0x16,
+              'DAP_VENDOR0': 0x80,
+              }
+
+ID_INFO = {'VENDOR_ID': 0x01,
+           'PRODUCT_ID': 0x02,
+           'SERIAL_NUMBER': 0x03,
+           'CMSIS_DAP_FW_VERSION': 0x04,
+           'TARGET_DEVICE_VENDOR': 0x05,
+           'TARGET_DEVICE_NAME': 0x06,
+           'CAPABILITIES': 0xf0,
+           'SWO_BUFFER_SIZE': 0xfd,
+           'PACKET_COUNT': 0xfe,
+           'PACKET_SIZE': 0xff
+           }
+
+PINS = {'None': 0x00,
+        'SWCLK_TCK': (1 << 0),
+        'SWDIO_TMS': (1 << 1),
+        'TDI': (1 << 2),
+        'TDO': (1 << 3),
+        'nTRST': (1 << 5),
+        'nRESET': (1 << 7),
+        }
+
+DAP_DEFAULT_PORT = 0
+DAP_SWD_PORT = 1
+DAP_JTAG_POR = 2
+
+DAP_LED_CONNECT = 0
+DAP_LED_RUNNING = 1
+
+DAP_OK = 0
+DAP_ERROR = 0xff
+
+# Responses to DAP_Transfer and DAP_TransferBlock
+DAP_TRANSFER_OK = 1
+DAP_TRANSFER_WAIT = 2
+DAP_TRANSFER_FAULT = 4
+DAP_TRANSFER_NO_ACK = 7
+
+## @brief This class implements the CMSIS-DAP wire protocol.
+class CMSIS_DAP_Protocol(object):
+    def __init__(self, interface):
+        self.interface = interface
+
+    def dapInfo(self, id_):
+        if not type(id_) in (six.integer_types):
+            id_ = ID_INFO[id_]
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_INFO'])
+        cmd.append(id_)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_INFO']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] == 0:
+            return
+
+        # Integer values
+        if id_ in (ID_INFO['CAPABILITIES'], ID_INFO['SWO_BUFFER_SIZE'], ID_INFO['PACKET_COUNT'], ID_INFO['PACKET_SIZE']):
+            if resp[1] == 1:
+                return resp[2]
+            if resp[1] == 2:
+                return (resp[3] << 8) | resp[2]
+
+        # String values. They are sent as C strings with a terminating null char, so we strip it out.
+        x = array.array('B', [i for i in resp[2:2 + resp[1]]]).tostring()
+        if x[-1] == '\x00':
+            x = x[0:-1]
+        return x
+
+    def setLed(self, type, enabled):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_LED'])
+        cmd.append(type)
+        cmd.append(int(enabled))
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_LED']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != 0:
+            # Second response byte must be 0
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def connect(self, mode=DAP_DEFAULT_PORT):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_CONNECT'])
+        cmd.append(mode)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_CONNECT']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] == 0:
+            # DAP connect failed
+            raise DAPAccessIntf.CommandError()
+
+        if resp[1] == 1:
+            logging.info('DAP SWD MODE initialized')
+
+        if resp[1] == 2:
+            logging.info('DAP JTAG MODE initialized')
+
+        return resp[1]
+
+    def disconnect(self):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_DISCONNECT'])
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_DISCONNECT']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP Disconnect failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def writeAbort(self, data, dap_index=0):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_WRITE_ABORT'])
+        cmd.append(dap_index)
+        cmd.append((data >> 0) & 0xff)
+        cmd.append((data >> 8) & 0xff)
+        cmd.append((data >> 16) & 0xff)
+        cmd.append((data >> 24) & 0xff)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_WRITE_ABORT']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP Write Abort failed
+            raise DAPAccessIntf.CommandError()
+
+        return True
+
+    def resetTarget(self):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_RESET_TARGET'])
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_RESET_TARGET']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP Reset target failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def transferConfigure(self, idle_cycles=0x00, wait_retry=0x0050, match_retry=0x0000):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_TRANSFER_CONFIGURE'])
+        cmd.append(idle_cycles)
+        cmd.append(wait_retry & 0xff)
+        cmd.append(wait_retry >> 8)
+        cmd.append(match_retry & 0xff)
+        cmd.append(match_retry >> 8)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_TRANSFER_CONFIGURE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP Transfer Configure failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+
+    def setSWJClock(self, clock=1000000):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_SWJ_CLOCK'])
+        cmd.append(clock & 0xff)
+        cmd.append((clock >> 8) & 0xff)
+        cmd.append((clock >> 16) & 0xff)
+        cmd.append((clock >> 24) & 0xff)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_SWJ_CLOCK']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP SWJ Clock failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def setSWJPins(self, output, pin, wait=0):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_SWJ_PINS'])
+        try:
+            p = PINS[pin]
+        except KeyError:
+            logging.error('cannot find %s pin', pin)
+            return
+        cmd.append(output & 0xff)
+        cmd.append(p)
+        cmd.append(wait & 0xff)
+        cmd.append((wait >> 8) & 0xff)
+        cmd.append((wait >> 16) & 0xff)
+        cmd.append((wait >> 24) & 0xff)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_SWJ_PINS']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        return resp[1]
+
+    def swdConfigure(self, conf=0):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_SWD_CONFIGURE'])
+        cmd.append(conf)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_SWD_CONFIGURE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP SWD Configure failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def swjSequence(self, data):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_SWJ_SEQUENCE'])
+        cmd.append(len(data) * 8)
+        for i in range(len(data)):
+            cmd.append(data[i])
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_SWJ_SEQUENCE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP SWJ Sequence failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[1]
+
+    def jtagSequence(self, info, tdi):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_JTAG_SEQUENCE'])
+        cmd.append(1)
+        cmd.append(info)
+        cmd.append(tdi)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_JTAG_SEQUENCE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP JTAG Sequence failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[2]
+
+    def jtagConfigure(self, irlen, dev_num=1):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_JTAG_CONFIGURE'])
+        cmd.append(dev_num)
+        cmd.append(irlen)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_JTAG_CONFIGURE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # DAP JTAG Configure failed
+            raise DAPAccessIntf.CommandError()
+
+        return resp[2:]
+
+    def jtagIDCode(self, index=0):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_JTAG_IDCODE'])
+        cmd.append(index)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+        if resp[0] != COMMAND_ID['DAP_JTAG_IDCODE']:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        if resp[1] != DAP_OK:
+            # Operation failed
+            raise DAPAccessIntf.CommandError()
+
+        return  (resp[2] << 0) | \
+                (resp[3] << 8) | \
+                (resp[4] << 16) | \
+                (resp[5] << 24)
+
+    def vendor(self, index, data):
+        cmd = []
+        cmd.append(COMMAND_ID['DAP_VENDOR0'] + index)
+        cmd.extend(data)
+        self.interface.write(cmd)
+
+        resp = self.interface.read()
+
+        if resp[0] != COMMAND_ID['DAP_VENDOR0'] + index:
+            # Response is to a different command
+            raise DAPAccessIntf.DeviceError()
+
+        return resp[1:]
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/dap_access_api.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/dap_access_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,176 +1,200 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from __future__ import absolute_import
-
-from enum import Enum
-
-
-class DAPAccessIntf(object):
-
-    class PORT(Enum):
-        """Physical access ports"""
-        DEFAULT = 0
-        SWD = 1
-        JTAG = 2
-
-    class REG(Enum):
-        """Register for DAP access functions"""
-        DP_0x0 = 0
-        DP_0x4 = 1
-        DP_0x8 = 2
-        DP_0xC = 3
-        AP_0x0 = 4
-        AP_0x4 = 5
-        AP_0x8 = 6
-        AP_0xC = 7
-
-    class ID(Enum):
-        """Information ID used for call to identify"""
-        VENDOR = 1
-        PRODUCT = 2
-        SER_NUM = 3
-        FW_VER = 4
-        DEVICE_VENDOR = 5
-        DEVICE_NAME = 6
-
-    class Error(Exception):
-        """Parent of all error DAPAccess can raise"""
-        pass
-
-    class DeviceError(Error):
-        """Error communicating with device"""
-        pass
-
-    class CommandError(DeviceError):
-        """The host debugger reported failure for the given command"""
-        pass
-
-    class TransferError(CommandError):
-        """Error ocurred with a transfer over SWD or JTAG"""
-        pass
-
-    class TransferTimeoutError(TransferError):
-        """A SWD or JTAG timeout occurred"""
-        pass
-
-    class TransferFaultError(TransferError):
-        """A SWD Fault occurred"""
-        pass
-
-    class TransferProtocolError(TransferError):
-        """A SWD protocol error occurred"""
-        pass
-
-    @staticmethod
-    def get_connected_devices():
-        """Return a list of DAPAccess devices"""
-        raise NotImplementedError()
-
-    @staticmethod
-    def get_device(device_id):
-        """Return the DAPAccess device with the give ID"""
-        raise NotImplementedError()
-
-    @staticmethod
-    def set_args(arg_list):
-        """Set arguments to configure behavior"""
-        raise NotImplementedError()
-
-
-
-    # ------------------------------------------- #
-    #          Host control functions
-    # ------------------------------------------- #
-    def open(self):
-        """Open device and lock it for exclusive access"""
-        raise NotImplementedError()
-
-    def close(self):
-        """Close device and unlock it"""
-        raise NotImplementedError()
-
-    def get_unique_id(self):
-        """Get the unique ID of this device which can be used in get_device
-
-        This function is safe to call before open is called.
-        """
-        raise NotImplementedError()
-
-    def identify(self, item):
-        """Return the requested information for this device"""
-        raise NotImplementedError()
-
-    # ------------------------------------------- #
-    #          Target control functions
-    # ------------------------------------------- #
-    def connect(self, port=None):
-        """Connect to target with JTAG or SWD"""
-        raise NotImplementedError()
-
-    def disconnect(self):
-        """Disconnect from target"""
-        raise NotImplementedError()
-
-    def set_clock(self, frequency):
-        """Set the frequency for JTAG and SWD in Hz
-
-        This function is safe to call before connect is called.
-        """
-        raise NotImplementedError()
-
-    def get_swj_mode(self):
-        """Return the current port type - SWD or JTAG"""
-        raise NotImplementedError()
-
-    def reset(self):
-        """Reset the target"""
-        raise NotImplementedError()
-
-    def assert_reset(self, asserted):
-        """Assert or de-assert target reset line"""
-        raise NotImplementedError()
-
-    def set_deferred_transfer(self, enable):
-        """Allow reads and writes to be buffered for increased speed"""
-        raise NotImplementedError()
-
-    def flush(self):
-        """Write out all unsent commands"""
-        raise NotImplementedError()
-
-    def vendor(self, index, data=None):
-        """Send a vendor specific command"""
-        raise NotImplementedError()
-
-    # ------------------------------------------- #
-    #          DAP Access functions
-    # ------------------------------------------- #
-    def write_reg(self, reg_id, value, dap_index=0):
-        """Write a single word to a DP or AP register"""
-        raise NotImplementedError()
-
-    def read_reg(self, reg_id, dap_index=0, now=True):
-        """Read a single word to a DP or AP register"""
-        raise NotImplementedError()
-
-    def reg_write_repeat(self, num_repeats, reg_id, data_array, dap_index=0):
-        """Write one or more words to the same DP or AP register"""
-        raise NotImplementedError()
-
-    def reg_read_repeat(self, num_repeats, reg_id, dap_index=0, now=True):
-        """Read one or more words from the same DP or AP register"""
-        raise NotImplementedError()
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from __future__ import absolute_import
+
+from enum import Enum
+
+
+class DAPAccessIntf(object):
+
+    class PORT(Enum):
+        """Physical access ports"""
+        DEFAULT = 0
+        SWD = 1
+        JTAG = 2
+
+    class REG(Enum):
+        """Register for DAP access functions"""
+        DP_0x0 = 0
+        DP_0x4 = 1
+        DP_0x8 = 2
+        DP_0xC = 3
+        AP_0x0 = 4
+        AP_0x4 = 5
+        AP_0x8 = 6
+        AP_0xC = 7
+
+    class ID(Enum):
+        """Information ID used for call to identify"""
+        VENDOR = 1
+        PRODUCT = 2
+        SER_NUM = 3
+        FW_VER = 4
+        DEVICE_VENDOR = 5
+        DEVICE_NAME = 6
+        CAPABILITIES = 0xf0
+        SWO_BUFFER_SIZE = 0xfd
+        MAX_PACKET_COUNT = 0xfe
+        MAX_PACKET_SIZE = 0xff
+
+    class Error(Exception):
+        """Parent of all error DAPAccess can raise"""
+        pass
+
+    class DeviceError(Error):
+        """Error communicating with device"""
+        pass
+
+    class CommandError(DeviceError):
+        """The host debugger reported failure for the given command"""
+        pass
+
+    class TransferError(CommandError):
+        """Error ocurred with a transfer over SWD or JTAG"""
+        pass
+
+    class TransferTimeoutError(TransferError):
+        """A SWD or JTAG timeout occurred"""
+        pass
+
+    class TransferFaultError(TransferError):
+        """A SWD Fault occurred"""
+        def __init__(self, faultAddress=None):
+            super(DAPAccessIntf.TransferFaultError, self).__init__(faultAddress)
+            self._address = faultAddress
+
+        @property
+        def fault_address(self):
+            return self._address
+
+        @fault_address.setter
+        def fault_address(self, addr):
+            self._address = addr
+
+        def __str__(self):
+            desc = "SWD/JTAG Transfer Fault"
+            if self._address is not None:
+                desc += " @ 0x%08x" % self._address
+            return desc
+
+    class TransferProtocolError(TransferError):
+        """A SWD protocol error occurred"""
+        pass
+
+    @staticmethod
+    def get_connected_devices():
+        """Return a list of DAPAccess devices"""
+        raise NotImplementedError()
+
+    @staticmethod
+    def get_device(device_id):
+        """Return the DAPAccess device with the give ID"""
+        raise NotImplementedError()
+
+    @staticmethod
+    def set_args(arg_list):
+        """Set arguments to configure behavior"""
+        raise NotImplementedError()
+
+
+
+    # ------------------------------------------- #
+    #          Host control functions
+    # ------------------------------------------- #
+    def open(self):
+        """Open device and lock it for exclusive access"""
+        raise NotImplementedError()
+
+    def close(self):
+        """Close device and unlock it"""
+        raise NotImplementedError()
+
+    def get_unique_id(self):
+        """Get the unique ID of this device which can be used in get_device
+
+        This function is safe to call before open is called.
+        """
+        raise NotImplementedError()
+
+    def identify(self, item):
+        """Return the requested information for this device"""
+        raise NotImplementedError()
+
+    # ------------------------------------------- #
+    #          Target control functions
+    # ------------------------------------------- #
+    def connect(self, port=None):
+        """Initailize DAP IO pins for JTAG or SWD"""
+        raise NotImplementedError()
+
+    def swj_sequence(self):
+        """Send seqeunce to activate JTAG or SWD on the target"""
+        raise NotImplementedError()
+
+    def disconnect(self):
+        """Deinitialize the DAP I/O pins"""
+        raise NotImplementedError()
+
+    def set_clock(self, frequency):
+        """Set the frequency for JTAG and SWD in Hz
+
+        This function is safe to call before connect is called.
+        """
+        raise NotImplementedError()
+
+    def get_swj_mode(self):
+        """Return the current port type - SWD or JTAG"""
+        raise NotImplementedError()
+
+    def reset(self):
+        """Reset the target"""
+        raise NotImplementedError()
+
+    def assert_reset(self, asserted):
+        """Assert or de-assert target reset line"""
+        raise NotImplementedError()
+
+    def set_deferred_transfer(self, enable):
+        """Allow reads and writes to be buffered for increased speed"""
+        raise NotImplementedError()
+
+    def flush(self):
+        """Write out all unsent commands"""
+        raise NotImplementedError()
+
+    def vendor(self, index, data=None):
+        """Send a vendor specific command"""
+        raise NotImplementedError()
+
+    # ------------------------------------------- #
+    #          DAP Access functions
+    # ------------------------------------------- #
+    def write_reg(self, reg_id, value, dap_index=0):
+        """Write a single word to a DP or AP register"""
+        raise NotImplementedError()
+
+    def read_reg(self, reg_id, dap_index=0, now=True):
+        """Read a single word to a DP or AP register"""
+        raise NotImplementedError()
+
+    def reg_write_repeat(self, num_repeats, reg_id, data_array, dap_index=0):
+        """Write one or more words to the same DP or AP register"""
+        raise NotImplementedError()
+
+    def reg_read_repeat(self, num_repeats, reg_id, dap_index=0, now=True):
+        """Read one or more words from the same DP or AP register"""
+        raise NotImplementedError()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/dap_settings.py` & `pyOCD-0.9.0/pyOCD/core/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,22 +1,16 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-class DAPSettings():
-	
-	use_ws = False
-	ws_host = "localhost"
-	ws_port = 8081
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2017 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/hidapi_backend.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/hidapi_backend.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,123 +1,127 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from interface import Interface
-import logging, os
-from ..dap_access_api import DAPAccessIntf
-
-try:
-    import hid
-except:
-    if os.name == "posix" and os.uname()[0] == 'Darwin':
-        logging.error("cython-hidapi is required on a Mac OS X Machine")
-    isAvailable = False
-else:
-    isAvailable = True
-
-class HidApiUSB(Interface):
-    """
-    This class provides basic functions to access
-    a USB HID device using cython-hidapi:
-        - write/read an endpoint
-    """
-    vid = 0
-    pid = 0
-
-    isAvailable = isAvailable
-
-    def __init__(self):
-        super(HidApiUSB, self).__init__()
-        # Vendor page and usage_id = 2
-        self.device = None
-
-    def open(self):
-        try:
-            self.device.open_path(self.device_info['path'])
-        except IOError:
-            raise DAPAccessIntf.DeviceError("Unable to open device")
-
-    @staticmethod
-    def getAllConnectedInterface():
-        """
-        returns all the connected devices which matches HidApiUSB.vid/HidApiUSB.pid.
-        returns an array of HidApiUSB (Interface) objects
-        """
-
-        devices = hid.enumerate()
-
-        if not devices:
-            logging.debug("No Mbed device connected")
-            return []
-
-        boards = []
-
-        for deviceInfo in devices:
-            product_name = deviceInfo['product_string']
-            if (product_name.find("CMSIS-DAP") < 0):
-                # Skip non cmsis-dap devices
-                continue
-
-            try:
-                dev = hid.device(vendor_id=deviceInfo['vendor_id'], product_id=deviceInfo['product_id'],
-                    path=deviceInfo['path'])
-            except IOError:
-                logging.debug("Failed to open Mbed device")
-                continue
-
-            # Create the USB interface object for this device.
-            new_board = HidApiUSB()
-            new_board.vendor_name = deviceInfo['manufacturer_string']
-            new_board.product_name = deviceInfo['product_string']
-            new_board.serial_number = deviceInfo['serial_number']
-            new_board.vid = deviceInfo['vendor_id']
-            new_board.pid = deviceInfo['product_id']
-            new_board.device_info = deviceInfo
-            new_board.device = dev
-            boards.append(new_board)
-
-        return boards
-
-    def write(self, data):
-        """
-        write data on the OUT endpoint associated to the HID interface
-        """
-        for _ in range(64 - len(data)):
-            data.append(0)
-        #logging.debug("send: %s", data)
-        self.device.write([0] + data)
-        return
-
-
-    def read(self, timeout=-1):
-        """
-        read data on the IN endpoint associated to the HID interface
-        """
-        return self.device.read(64)
-
-    def getSerialNumber(self):
-        return self.serial_number
-
-    def close(self):
-        """
-        close the interface
-        """
-        logging.debug("closing interface")
-        self.device.close()
-
-    def setPacketCount(self, count):
-        # No interface level restrictions on count
-        self.packet_count = count
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from interface import Interface
+import logging, os
+from ..dap_access_api import DAPAccessIntf
+
+try:
+    import hid
+except:
+    if os.name == "posix" and os.uname()[0] == 'Darwin':
+        logging.error("cython-hidapi is required on a Mac OS X Machine")
+    isAvailable = False
+else:
+    isAvailable = True
+
+class HidApiUSB(Interface):
+    """
+    This class provides basic functions to access
+    a USB HID device using cython-hidapi:
+        - write/read an endpoint
+    """
+    vid = 0
+    pid = 0
+
+    isAvailable = isAvailable
+
+    def __init__(self):
+        super(HidApiUSB, self).__init__()
+        # Vendor page and usage_id = 2
+        self.device = None
+        self.packet_size = 64
+
+    def open(self):
+        try:
+            self.device.open_path(self.device_info['path'])
+        except IOError:
+            raise DAPAccessIntf.DeviceError("Unable to open device")
+
+    @staticmethod
+    def getAllConnectedInterface():
+        """
+        returns all the connected devices which matches HidApiUSB.vid/HidApiUSB.pid.
+        returns an array of HidApiUSB (Interface) objects
+        """
+
+        devices = hid.enumerate()
+
+        if not devices:
+            logging.debug("No Mbed device connected")
+            return []
+
+        boards = []
+
+        for deviceInfo in devices:
+            product_name = deviceInfo['product_string']
+            if (product_name.find("CMSIS-DAP") < 0):
+                # Skip non cmsis-dap devices
+                continue
+
+            try:
+                dev = hid.device(vendor_id=deviceInfo['vendor_id'], product_id=deviceInfo['product_id'],
+                    path=deviceInfo['path'])
+            except IOError:
+                logging.debug("Failed to open Mbed device")
+                continue
+
+            # Create the USB interface object for this device.
+            new_board = HidApiUSB()
+            new_board.vendor_name = deviceInfo['manufacturer_string']
+            new_board.product_name = deviceInfo['product_string']
+            new_board.serial_number = deviceInfo['serial_number']
+            new_board.vid = deviceInfo['vendor_id']
+            new_board.pid = deviceInfo['product_id']
+            new_board.device_info = deviceInfo
+            new_board.device = dev
+            boards.append(new_board)
+
+        return boards
+
+    def write(self, data):
+        """
+        write data on the OUT endpoint associated to the HID interface
+        """
+        for _ in range(self.packet_size - len(data)):
+            data.append(0)
+        #logging.debug("send: %s", data)
+        self.device.write([0] + data)
+        return
+
+
+    def read(self, timeout=-1):
+        """
+        read data on the IN endpoint associated to the HID interface
+        """
+        return self.device.read(self.packet_size)
+
+    def getSerialNumber(self):
+        return self.serial_number
+
+    def close(self):
+        """
+        close the interface
+        """
+        logging.debug("closing interface")
+        self.device.close()
+
+    def setPacketCount(self, count):
+        # No interface level restrictions on count
+        self.packet_count = count
+
+    def setPacketSize(self, size):
+        self.packet_size = size
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/pyusb_backend.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/pyusb_backend.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,267 +1,271 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from interface import Interface
-import logging, os, threading
-from ..dap_access_api import DAPAccessIntf
-
-try:
-    import usb.core
-    import usb.util
-except:
-    if os.name == "posix" and not os.uname()[0] == 'Darwin':
-        logging.error("PyUSB is required on a Linux Machine")
-    isAvailable = False
-else:
-    isAvailable = True
-
-
-class PyUSB(Interface):
-    """
-    This class provides basic functions to access
-    a USB HID device using pyusb:
-        - write/read an endpoint
-    """
-
-    isAvailable = isAvailable
-
-    def __init__(self):
-        super(PyUSB, self).__init__()
-        self.ep_out = None
-        self.ep_in = None
-        self.dev = None
-        self.intf_number = None
-        self.serial_number = None
-        self.kernel_driver_was_attached = False
-        self.closed = True
-        self.thread = None
-        self.rcv_data = []
-        self.read_sem = threading.Semaphore(0)
-
-    def open(self):
-        assert self.closed is True
-
-        # Get device handle
-        dev = usb.core.find(custom_match=FindDap(self.serial_number))
-        if dev is None:
-            raise DAPAccessIntf.DeviceError("Device %s not found" %
-                                            self.serial_number)
-
-        # get active config
-        config = dev.get_active_configuration()
-
-        # Get hid interface
-        interface = None
-        interface_number = None
-        for interface in config:
-            if interface.bInterfaceClass == 0x03:
-                interface_number = interface.bInterfaceNumber
-                break
-        if interface_number is None or interface is None:
-            raise DAPAccessIntf.DeviceError("Device %s has no hid interface" %
-                                            self.serial_number)
-
-        # Find endpoints
-        ep_in, ep_out = None, None
-        for endpoint in interface:
-            if endpoint.bEndpointAddress & 0x80:
-                ep_in = endpoint
-            else:
-                ep_out = endpoint
-
-        # If there is no EP for OUT then we can use CTRL EP.
-        # The IN EP is required
-        if not ep_in:
-            raise DAPAccessIntf.DeviceError("Unable to open device -"
-                                            " no endpoints")
-
-        # Detach kernel driver
-        kernel_driver_was_attached = False
-        try:
-            if dev.is_kernel_driver_active(interface_number):
-                dev.detach_kernel_driver(interface_number)
-                kernel_driver_was_attached = True
-        except NotImplementedError as e:
-            # Some implementations don't don't have kernel attach/detach
-            logging.debug('Exception detaching kernel driver: %s' %
-                          str(e))
-
-        # Explicitly claim the interface
-        try:
-            usb.util.claim_interface(dev, interface_number)
-        except usb.core.USBError:
-            raise DAPAccessIntf.DeviceError("Unable to open device")
-
-        # Update all class variables if we made it here
-        self.ep_out = ep_out
-        self.ep_in = ep_in
-        self.dev = dev
-        self.intf_number = interface_number
-        self.kernel_driver_was_attached = kernel_driver_was_attached
-
-        # Start RX thread as the last step
-        self.closed = False
-        self.start_rx()
-
-    def start_rx(self):
-        # Flush the RX buffers by reading until timeout exception
-        try:
-            while True:
-                self.ep_in.read(self.ep_in.wMaxPacketSize, 1)
-        except usb.core.USBError:
-            # USB timeout expected
-            pass
-
-        # Start RX thread
-        self.thread = threading.Thread(target=self.rx_task)
-        self.thread.daemon = True
-        self.thread.start()
-
-    def rx_task(self):
-        try:
-            while not self.closed:
-                self.read_sem.acquire()
-                if not self.closed:
-                    self.rcv_data.append(self.ep_in.read(self.ep_in.wMaxPacketSize, 10 * 1000))
-        finally:
-            # Set last element of rcv_data to None on exit
-            self.rcv_data.append(None)
-
-    @staticmethod
-    def getAllConnectedInterface():
-        """
-        returns all the connected devices which matches PyUSB.vid/PyUSB.pid.
-        returns an array of PyUSB (Interface) objects
-        """
-        # find all cmsis-dap devices
-        all_devices = usb.core.find(find_all=True, custom_match=FindDap())
-
-        # iterate on all devices found
-        boards = []
-        for board in all_devices:
-            new_board = PyUSB()
-            new_board.vid = board.idVendor
-            new_board.pid = board.idProduct
-            new_board.product_name = board.product
-            new_board.vendor_name = board.manufacturer
-            new_board.serial_number = board.serial_number
-            boards.append(new_board)
-
-        return boards
-
-    def write(self, data):
-        """
-        write data on the OUT endpoint associated to the HID interface
-        """
-
-        report_size = 64
-        if self.ep_out:
-            report_size = self.ep_out.wMaxPacketSize
-
-        for _ in range(report_size - len(data)):
-            data.append(0)
-
-        self.read_sem.release()
-
-        if not self.ep_out:
-            bmRequestType = 0x21              #Host to device request of type Class of Recipient Interface
-            bmRequest = 0x09              #Set_REPORT (HID class-specific request for transferring data over EP0)
-            wValue = 0x200             #Issuing an OUT report
-            wIndex = self.intf_number  #mBed Board interface number for HID
-            self.dev.ctrl_transfer(bmRequestType, bmRequest, wValue, wIndex, data)
-            return
-            #raise ValueError('EP_OUT endpoint is NULL')
-
-        self.ep_out.write(data)
-        #logging.debug('sent: %s', data)
-        return
-
-
-    def read(self):
-        """
-        read data on the IN endpoint associated to the HID interface
-        """
-        while len(self.rcv_data) == 0:
-            pass
-        if self.rcv_data[0] is None:
-            raise DAPAccessIntf.DeviceError("Device %s read thread exited" %
-                                            self.serial_number)
-        return self.rcv_data.pop(0)
-
-    def setPacketCount(self, count):
-        # No interface level restrictions on count
-        self.packet_count = count
-
-    def getSerialNumber(self):
-        return self.serial_number
-
-    def close(self):
-        """
-        close the interface
-        """
-        assert self.closed is False
-
-        logging.debug("closing interface")
-        self.closed = True
-        self.read_sem.release()
-        self.thread.join()
-        assert self.rcv_data[-1] is None
-        self.rcv_data = []
-        usb.util.release_interface(self.dev, self.intf_number)
-        if self.kernel_driver_was_attached:
-            try:
-                self.dev.attach_kernel_driver(self.intf_number)
-            except Exception as exception:
-                logging.warning('Exception attaching kernel driver: %s',
-                                str(exception))
-        usb.util.dispose_resources(self.dev)
-        self.ep_out = None
-        self.ep_in = None
-        self.dev = None
-        self.intf_number = None
-        self.kernel_driver_was_attached = False
-        self.thread = None
-
-
-class FindDap(object):
-    """CMSIS-DAP match class to be used with usb.core.find"""
-
-    def __init__(self, serial=None):
-        """Create a new FindDap object with an optional serial number"""
-        self._serial = serial
-
-    def __call__(self, dev):
-        """Return True if this is a DAP device, False otherwise"""
-        try:
-            device_string = dev.product
-        except ValueError:
-            # Permission denied error gets reported as ValueError (langid)
-            return False
-        except usb.core.USBError as error:
-            logging.warning("Exception getting product string: %s", error)
-            return False
-        except IndexError as error:
-            logging.warning("Internal pyusb error: %s", error)
-            return False
-        if device_string is None:
-            return False
-        if device_string.find("CMSIS-DAP") < 0:
-            return False
-        if self._serial is not None:
-            if self._serial != dev.serial_number:
-                return False
-        return True
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from interface import Interface
+import logging, os, threading
+from ..dap_access_api import DAPAccessIntf
+
+try:
+    import usb.core
+    import usb.util
+except:
+    if os.name == "posix" and not os.uname()[0] == 'Darwin':
+        logging.error("PyUSB is required on a Linux Machine")
+    isAvailable = False
+else:
+    isAvailable = True
+
+
+class PyUSB(Interface):
+    """
+    This class provides basic functions to access
+    a USB HID device using pyusb:
+        - write/read an endpoint
+    """
+
+    isAvailable = isAvailable
+
+    def __init__(self):
+        super(PyUSB, self).__init__()
+        self.ep_out = None
+        self.ep_in = None
+        self.dev = None
+        self.intf_number = None
+        self.serial_number = None
+        self.kernel_driver_was_attached = False
+        self.closed = True
+        self.thread = None
+        self.rcv_data = []
+        self.read_sem = threading.Semaphore(0)
+        self.packet_size = 64
+
+    def open(self):
+        assert self.closed is True
+
+        # Get device handle
+        dev = usb.core.find(custom_match=FindDap(self.serial_number))
+        if dev is None:
+            raise DAPAccessIntf.DeviceError("Device %s not found" %
+                                            self.serial_number)
+
+        # get active config
+        config = dev.get_active_configuration()
+
+        # Get hid interface
+        interface = None
+        interface_number = None
+        for interface in config:
+            if interface.bInterfaceClass == 0x03:
+                interface_number = interface.bInterfaceNumber
+                break
+        if interface_number is None or interface is None:
+            raise DAPAccessIntf.DeviceError("Device %s has no hid interface" %
+                                            self.serial_number)
+
+        # Find endpoints
+        ep_in, ep_out = None, None
+        for endpoint in interface:
+            if endpoint.bEndpointAddress & 0x80:
+                ep_in = endpoint
+            else:
+                ep_out = endpoint
+
+        # If there is no EP for OUT then we can use CTRL EP.
+        # The IN EP is required
+        if not ep_in:
+            raise DAPAccessIntf.DeviceError("Unable to open device -"
+                                            " no endpoints")
+
+        # Detach kernel driver
+        kernel_driver_was_attached = False
+        try:
+            if dev.is_kernel_driver_active(interface_number):
+                dev.detach_kernel_driver(interface_number)
+                kernel_driver_was_attached = True
+        except NotImplementedError as e:
+            # Some implementations don't don't have kernel attach/detach
+            logging.debug('Exception detaching kernel driver: %s' %
+                          str(e))
+
+        # Explicitly claim the interface
+        try:
+            usb.util.claim_interface(dev, interface_number)
+        except usb.core.USBError:
+            raise DAPAccessIntf.DeviceError("Unable to open device")
+
+        # Update all class variables if we made it here
+        self.ep_out = ep_out
+        self.ep_in = ep_in
+        self.dev = dev
+        self.intf_number = interface_number
+        self.kernel_driver_was_attached = kernel_driver_was_attached
+
+        # Start RX thread as the last step
+        self.closed = False
+        self.start_rx()
+
+    def start_rx(self):
+        # Flush the RX buffers by reading until timeout exception
+        try:
+            while True:
+                self.ep_in.read(self.ep_in.wMaxPacketSize, 1)
+        except usb.core.USBError:
+            # USB timeout expected
+            pass
+
+        # Start RX thread
+        self.thread = threading.Thread(target=self.rx_task)
+        self.thread.daemon = True
+        self.thread.start()
+
+    def rx_task(self):
+        try:
+            while not self.closed:
+                self.read_sem.acquire()
+                if not self.closed:
+                    self.rcv_data.append(self.ep_in.read(self.ep_in.wMaxPacketSize, 10 * 1000))
+        finally:
+            # Set last element of rcv_data to None on exit
+            self.rcv_data.append(None)
+
+    @staticmethod
+    def getAllConnectedInterface():
+        """
+        returns all the connected devices which matches PyUSB.vid/PyUSB.pid.
+        returns an array of PyUSB (Interface) objects
+        """
+        # find all cmsis-dap devices
+        all_devices = usb.core.find(find_all=True, custom_match=FindDap())
+
+        # iterate on all devices found
+        boards = []
+        for board in all_devices:
+            new_board = PyUSB()
+            new_board.vid = board.idVendor
+            new_board.pid = board.idProduct
+            new_board.product_name = board.product
+            new_board.vendor_name = board.manufacturer
+            new_board.serial_number = board.serial_number
+            boards.append(new_board)
+
+        return boards
+
+    def write(self, data):
+        """
+        write data on the OUT endpoint associated to the HID interface
+        """
+
+        report_size = self.packet_size
+        if self.ep_out:
+            report_size = self.ep_out.wMaxPacketSize
+
+        for _ in range(report_size - len(data)):
+            data.append(0)
+
+        self.read_sem.release()
+
+        if not self.ep_out:
+            bmRequestType = 0x21              #Host to device request of type Class of Recipient Interface
+            bmRequest = 0x09              #Set_REPORT (HID class-specific request for transferring data over EP0)
+            wValue = 0x200             #Issuing an OUT report
+            wIndex = self.intf_number  #mBed Board interface number for HID
+            self.dev.ctrl_transfer(bmRequestType, bmRequest, wValue, wIndex, data)
+            return
+            #raise ValueError('EP_OUT endpoint is NULL')
+
+        self.ep_out.write(data)
+        #logging.debug('sent: %s', data)
+        return
+
+
+    def read(self):
+        """
+        read data on the IN endpoint associated to the HID interface
+        """
+        while len(self.rcv_data) == 0:
+            pass
+        if self.rcv_data[0] is None:
+            raise DAPAccessIntf.DeviceError("Device %s read thread exited" %
+                                            self.serial_number)
+        return self.rcv_data.pop(0)
+
+    def setPacketCount(self, count):
+        # No interface level restrictions on count
+        self.packet_count = count
+
+    def setPacketSize(self, size):
+        self.packet_size = size
+
+    def getSerialNumber(self):
+        return self.serial_number
+
+    def close(self):
+        """
+        close the interface
+        """
+        assert self.closed is False
+
+        logging.debug("closing interface")
+        self.closed = True
+        self.read_sem.release()
+        self.thread.join()
+        assert self.rcv_data[-1] is None
+        self.rcv_data = []
+        usb.util.release_interface(self.dev, self.intf_number)
+        if self.kernel_driver_was_attached:
+            try:
+                self.dev.attach_kernel_driver(self.intf_number)
+            except Exception as exception:
+                logging.warning('Exception attaching kernel driver: %s',
+                                str(exception))
+        usb.util.dispose_resources(self.dev)
+        self.ep_out = None
+        self.ep_in = None
+        self.dev = None
+        self.intf_number = None
+        self.kernel_driver_was_attached = False
+        self.thread = None
+
+
+class FindDap(object):
+    """CMSIS-DAP match class to be used with usb.core.find"""
+
+    def __init__(self, serial=None):
+        """Create a new FindDap object with an optional serial number"""
+        self._serial = serial
+
+    def __call__(self, dev):
+        """Return True if this is a DAP device, False otherwise"""
+        try:
+            device_string = dev.product
+        except ValueError:
+            # Permission denied error gets reported as ValueError (langid)
+            return False
+        except usb.core.USBError as error:
+            logging.warning("Exception getting product string: %s", error)
+            return False
+        except IndexError as error:
+            logging.warning("Internal pyusb error: %s", error)
+            return False
+        if device_string is None:
+            return False
+        if device_string.find("CMSIS-DAP") < 0:
+            return False
+        if self._serial is not None:
+            if self._serial != dev.serial_number:
+                return False
+        return True
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/pywinusb_backend.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/pywinusb_backend.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,175 +1,178 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from interface import Interface
-import logging, os, collections
-from time import time
-from ..dap_access_api import DAPAccessIntf
-
-OPEN_TIMEOUT_S = 60.0
-
-try:
-    import pywinusb.hid as hid
-except:
-    if os.name == "nt":
-        logging.error("PyWinUSB is required on a Windows Machine")
-    isAvailable = False
-else:
-    isAvailable = True
-
-class PyWinUSB(Interface):
-    """
-    This class provides basic functions to access
-    a USB HID device using pywinusb:
-        - write/read an endpoint
-    """
-    vid = 0
-    pid = 0
-
-    isAvailable = isAvailable
-
-    def __init__(self):
-        super(PyWinUSB, self).__init__()
-        # Vendor page and usage_id = 2
-        self.report = []
-        # deque used here instead of synchronized Queue
-        # since read speeds are ~10-30% faster and are
-        # comprable to a based list implmentation.
-        self.rcv_data = collections.deque()
-        self.device = None
-        return
-
-    # handler called when a report is received
-    def rx_handler(self, data):
-        #logging.debug("rcv: %s", data[1:])
-        self.rcv_data.append(data[1:])
-
-    def open(self):
-        self.device.set_raw_data_handler(self.rx_handler)
-
-        # Attempt to open the device.
-        # Note - this operation must be retried since
-        # other instances of pyOCD listing board can prevent
-        # opening this device with exclusive access.
-        start = time()
-        while True:
-
-            # Attempt to open the device
-            try:
-                self.device.open(shared=False)
-                break
-            except hid.HIDError:
-                pass
-
-            # Attempt to open the device in shared mode to make
-            # sure it is still there
-            try:
-                self.device.open(shared=True)
-                self.device.close()
-            except hid.HIDError:
-                # If the device could not be opened in read only mode
-                # Then it either has been disconnected or is in use
-                # by another thread/process
-                raise DAPAccessIntf.DeviceError("Unable to open device")
-
-            if time() - start > OPEN_TIMEOUT_S:
-                # If this timeout has elapsed then another process
-                # has locked this device in shared mode. This should
-                # not happen.
-                assert False
-                break
-
-
-    @staticmethod
-    def getAllConnectedInterface():
-        """
-        returns all the connected CMSIS-DAP devices
-        """
-        all_devices = hid.find_all_hid_devices()
-
-        # find devices with good vid/pid
-        all_mbed_devices = []
-        for d in all_devices:
-            if (d.product_name.find("CMSIS-DAP") >= 0):
-                all_mbed_devices.append(d)
-
-        boards = []
-        for dev in all_mbed_devices:
-            try:
-                dev.open(shared=True)
-                report = dev.find_output_reports()
-                if len(report) != 1:
-                    dev.close()
-                    continue
-                new_board = PyWinUSB()
-                new_board.report = report[0]
-                new_board.vendor_name = dev.vendor_name
-                new_board.product_name = dev.product_name
-                new_board.serial_number = dev.serial_number
-                new_board.vid = dev.vendor_id
-                new_board.pid = dev.product_id
-                new_board.device = dev
-                dev.close()
-                boards.append(new_board)
-            except Exception as e:
-                if (str(e) != "Failure to get HID pre parsed data"):
-                    logging.error("Receiving Exception: %s", e)
-                dev.close()
-
-        return boards
-
-    def write(self, data):
-        """
-        write data on the OUT endpoint associated to the HID interface
-        """
-        for _ in range(64 - len(data)):
-            data.append(0)
-        #logging.debug("send: %s", data)
-        self.report.send([0] + data)
-        return
-
-
-    def read(self, timeout=20.0):
-        """
-        read data on the IN endpoint associated to the HID interface
-        """
-        start = time()
-        while len(self.rcv_data) == 0:
-            if time() - start > timeout:
-                # Read operations should typically take ~1-2ms.
-                # If this exception occurs, then it could indicate
-                # a problem in one of the following areas:
-                # 1. Bad usb driver causing either a dropped read or write
-                # 2. CMSIS-DAP firmware problem cause a dropped read or write
-                # 3. CMSIS-DAP is performing a long operation or is being
-                #    halted in a debugger
-                raise Exception("Read timed out")
-        return self.rcv_data.popleft()
-
-    def setPacketCount(self, count):
-        # No interface level restrictions on count
-        self.packet_count = count
-
-    def getSerialNumber(self):
-        return self.serial_number
-
-    def close(self):
-        """
-        close the interface
-        """
-        logging.debug("closing interface")
-        self.device.close()
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from interface import Interface
+import logging, os, collections
+from time import time
+from ..dap_access_api import DAPAccessIntf
+
+OPEN_TIMEOUT_S = 60.0
+
+try:
+    import pywinusb.hid as hid
+except:
+    if os.name == "nt":
+        logging.error("PyWinUSB is required on a Windows Machine")
+    isAvailable = False
+else:
+    isAvailable = True
+
+class PyWinUSB(Interface):
+    """
+    This class provides basic functions to access
+    a USB HID device using pywinusb:
+        - write/read an endpoint
+    """
+    vid = 0
+    pid = 0
+
+    isAvailable = isAvailable
+
+    def __init__(self):
+        super(PyWinUSB, self).__init__()
+        # Vendor page and usage_id = 2
+        self.report = []
+        # deque used here instead of synchronized Queue
+        # since read speeds are ~10-30% faster and are
+        # comprable to a based list implmentation.
+        self.rcv_data = collections.deque()
+        self.device = None
+        self.packet_size = 64
+
+    # handler called when a report is received
+    def rx_handler(self, data):
+        #logging.debug("rcv: %s", data[1:])
+        self.rcv_data.append(data[1:])
+
+    def open(self):
+        self.device.set_raw_data_handler(self.rx_handler)
+
+        # Attempt to open the device.
+        # Note - this operation must be retried since
+        # other instances of pyOCD listing board can prevent
+        # opening this device with exclusive access.
+        start = time()
+        while True:
+
+            # Attempt to open the device
+            try:
+                self.device.open(shared=False)
+                break
+            except hid.HIDError:
+                pass
+
+            # Attempt to open the device in shared mode to make
+            # sure it is still there
+            try:
+                self.device.open(shared=True)
+                self.device.close()
+            except hid.HIDError:
+                # If the device could not be opened in read only mode
+                # Then it either has been disconnected or is in use
+                # by another thread/process
+                raise DAPAccessIntf.DeviceError("Unable to open device")
+
+            if time() - start > OPEN_TIMEOUT_S:
+                # If this timeout has elapsed then another process
+                # has locked this device in shared mode. This should
+                # not happen.
+                assert False
+                break
+
+
+    @staticmethod
+    def getAllConnectedInterface():
+        """
+        returns all the connected CMSIS-DAP devices
+        """
+        all_devices = hid.find_all_hid_devices()
+
+        # find devices with good vid/pid
+        all_mbed_devices = []
+        for d in all_devices:
+            if (d.product_name.find("CMSIS-DAP") >= 0):
+                all_mbed_devices.append(d)
+
+        boards = []
+        for dev in all_mbed_devices:
+            try:
+                dev.open(shared=True)
+                report = dev.find_output_reports()
+                if len(report) != 1:
+                    dev.close()
+                    continue
+                new_board = PyWinUSB()
+                new_board.report = report[0]
+                new_board.vendor_name = dev.vendor_name
+                new_board.product_name = dev.product_name
+                new_board.serial_number = dev.serial_number
+                new_board.vid = dev.vendor_id
+                new_board.pid = dev.product_id
+                new_board.device = dev
+                dev.close()
+                boards.append(new_board)
+            except Exception as e:
+                if (str(e) != "Failure to get HID pre parsed data"):
+                    logging.error("Receiving Exception: %s", e)
+                dev.close()
+
+        return boards
+
+    def write(self, data):
+        """
+        write data on the OUT endpoint associated to the HID interface
+        """
+        for _ in range(self.packet_size - len(data)):
+            data.append(0)
+        #logging.debug("send: %s", data)
+        self.report.send([0] + data)
+        return
+
+
+    def read(self, timeout=20.0):
+        """
+        read data on the IN endpoint associated to the HID interface
+        """
+        start = time()
+        while len(self.rcv_data) == 0:
+            if time() - start > timeout:
+                # Read operations should typically take ~1-2ms.
+                # If this exception occurs, then it could indicate
+                # a problem in one of the following areas:
+                # 1. Bad usb driver causing either a dropped read or write
+                # 2. CMSIS-DAP firmware problem cause a dropped read or write
+                # 3. CMSIS-DAP is performing a long operation or is being
+                #    halted in a debugger
+                raise Exception("Read timed out")
+        return self.rcv_data.popleft()
+
+    def setPacketCount(self, count):
+        # No interface level restrictions on count
+        self.packet_count = count
+
+    def setPacketSize(self, size):
+        self.packet_size = size
+
+    def getSerialNumber(self):
+        return self.serial_number
+
+    def close(self):
+        """
+        close the interface
+        """
+        logging.debug("closing interface")
+        self.device.close()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/interface/ws_backend.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/interface/ws_backend.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,55 +1,55 @@
-from __future__ import print_function
-from future.utils import bytes_to_native_str
-from future.builtins import bytes
-
-from base64 import b64encode, b64decode
-from websocket import create_connection
-from interface import Interface
-
-class WebSocketInterface(Interface):
-    def __init__(self, host='localhost', port=8081):
-        super(WebSocketInterface,self).__init__()
-        self.connected = False
-        try:
-            self.ws = create_connection('ws://%s:%i' % (host, port))
-            self.ws.settimeout(None)
-            self.connected = True
-        except:
-            self.connected = False
-
-    def write(self, data):
-        self.ws.send(b64encode(bytes_to_native_str(bytes(data))))
-
-    def read(self):
-        #It will wait on recv() until data is sent over websocket
-        rawdata = self.ws.recv()
-        #Data is sent in base64 string
-        data = b64decode(rawdata)
-        data = [ord(c) for c in data]
-        return data
-
-    def setPacketCount(self, count):
-        self.packet_count = count
-
-    def close(self):
-        self.ws.close()
-        
-    def getUniqueId(self):
-        """Get the unique id from an interface"""
-        self.write([0x80])
-        raw_id = bytearray(self.read())
-        id_start = 2
-        id_size = raw_id[1]
-        unique_id = str(raw_id[id_start:id_start + id_size])
-        return unique_id
-
-    def getSerialNumber(self):
-        return self.getUniqueId()
-
-    @staticmethod
-    def getAllConnectedInterface(host,port):
-        ws = WebSocketInterface(host,port)
-        if ws.connected:
-            return [ws]
-        else:
-            return []
+from __future__ import print_function
+from future.utils import bytes_to_native_str
+from future.builtins import bytes
+
+from base64 import b64encode, b64decode
+from websocket import create_connection
+from interface import Interface
+
+class WebSocketInterface(Interface):
+    def __init__(self, host='localhost', port=8081):
+        super(WebSocketInterface,self).__init__()
+        self.connected = False
+        try:
+            self.ws = create_connection('ws://%s:%i' % (host, port))
+            self.ws.settimeout(None)
+            self.connected = True
+        except:
+            self.connected = False
+
+    def write(self, data):
+        self.ws.send(b64encode(bytes_to_native_str(bytes(data))))
+
+    def read(self):
+        #It will wait on recv() until data is sent over websocket
+        rawdata = self.ws.recv()
+        #Data is sent in base64 string
+        data = b64decode(rawdata)
+        data = [ord(c) for c in data]
+        return data
+
+    def setPacketCount(self, count):
+        self.packet_count = count
+
+    def close(self):
+        self.ws.close()
+        
+    def getUniqueId(self):
+        """Get the unique id from an interface"""
+        self.write([0x80])
+        raw_id = bytearray(self.read())
+        id_start = 2
+        id_size = raw_id[1]
+        unique_id = str(raw_id[id_start:id_start + id_size])
+        return unique_id
+
+    def getSerialNumber(self):
+        return self.getUniqueId()
+
+    @staticmethod
+    def getAllConnectedInterface(host,port):
+        ws = WebSocketInterface(host,port)
+        if ws.connected:
+            return [ws]
+        else:
+            return []
```

### Comparing `pyOCD-0.8.1a1/pyOCD/pyDAPAccess/__init__.py` & `pyOCD-0.9.0/pyOCD/pyDAPAccess/__init__.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from .dap_access_api import DAPAccessIntf
-from .dap_access_cmsis_dap import DAPAccessCMSISDAP
-
-# alias DAPAccessCMSISDAP as main DAPAccess class
-DAPAccess = DAPAccessCMSISDAP
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from .dap_access_api import DAPAccessIntf
+from .dap_access_cmsis_dap import DAPAccessCMSISDAP
+
+# alias DAPAccessCMSISDAP as main DAPAccess class
+DAPAccess = DAPAccessCMSISDAP
```

### Comparing `pyOCD-0.8.1a1/pyOCD/svd.py` & `pyOCD-0.9.0/pyOCD/debug/svd.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,68 +1,69 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import threading
-import logging
-# Make cmsis_svd optional.
-try:
-    from cmsis_svd.parser import SVDParser
-    isCmsisSvdAvailable = True
-except ImportError:
-    isCmsisSvdAvailable = False
-
-class SVDFile(object):
-    def __init__(self, filename=None, vendor=None, is_local=False):
-        self.filename = filename
-        self.vendor = vendor
-        self.is_local = is_local
-        self.device = None
-
-    def load(self):
-        if not isCmsisSvdAvailable:
-            return
-
-        if self.is_local:
-            self.device = SVDParser.for_xml_file(self.filename).get_device()
-        else:
-            self.device = SVDParser.for_packaged_svd(self.vendor, self.filename).get_device()
-
-## @brief Thread to read an SVD file in the background.
-class SVDLoader(threading.Thread):
-    def __init__(self, svdFile, completionCallback):
-        super(SVDLoader, self).__init__(name='load-svd')
-        self._svd_location = svdFile
-        self._svd_device = None
-        self._callback = completionCallback
-
-    @property
-    def device(self):
-        if not self._svd_device:
-            self.join()
-        return self._svd_device
-
-    def load(self):
-        if not self._svd_device and self._svd_location:
-            self.start()
-
-    def run(self):
-        try:
-            self._svd_location.load()
-            self._svd_device = self._svd_location.device
-            if self._callback:
-                self._callback(self._svd_device)
-        except IOError:
-            logging.warning("Failed to load SVD file %s", self._svd_location.filename)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import threading
+import logging
+# Make cmsis_svd optional.
+try:
+    from cmsis_svd.parser import SVDParser
+    isCmsisSvdAvailable = True
+except ImportError:
+    isCmsisSvdAvailable = False
+
+class SVDFile(object):
+    def __init__(self, filename=None, vendor=None, is_local=False):
+        self.filename = filename
+        self.vendor = vendor
+        self.is_local = is_local
+        self.device = None
+
+    def load(self):
+        if not isCmsisSvdAvailable:
+            return
+
+        if self.is_local:
+            self.device = SVDParser.for_xml_file(self.filename).get_device()
+        else:
+            self.device = SVDParser.for_packaged_svd(self.vendor, self.filename).get_device()
+
+## @brief Thread to read an SVD file in the background.
+class SVDLoader(threading.Thread):
+    def __init__(self, svdFile, completionCallback):
+        super(SVDLoader, self).__init__(name='load-svd')
+        self.daemon = True
+        self._svd_location = svdFile
+        self._svd_device = None
+        self._callback = completionCallback
+
+    @property
+    def device(self):
+        if not self._svd_device:
+            self.join()
+        return self._svd_device
+
+    def load(self):
+        if not self._svd_device and self._svd_location:
+            self.start()
+
+    def run(self):
+        try:
+            self._svd_location.load()
+            self._svd_device = self._svd_location.device
+            if self._callback:
+                self._callback(self._svd_device)
+        except IOError:
+            logging.warning("Failed to load SVD file %s", self._svd_location.filename)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/target/coresight_target.py` & `pyOCD-0.9.0/pyOCD/core/coresight_target.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,208 +1,227 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from .target import Target
-from ..coresight import (dap, ap, cortex_m)
-from ..svd import (SVDFile, SVDLoader)
-import threading
-import logging
-from xml.etree.ElementTree import (Element, SubElement, tostring)
-
-##
-# @brief Debug target that uses CoreSight classes.
-class CoreSightTarget(Target):
-
-    def __init__(self, link, memoryMap=None):
-        super(CoreSightTarget, self).__init__(link, memoryMap)
-        self.part_number = self.__class__.__name__
-        self.cores = {}
-        self.aps = {}
-        self.dp = dap.DebugPort(link)
-        self._selected_core = 0
-        self._svd_load_thread = None
-
-    @property
-    def selected_core(self):
-        return self.cores[self._selected_core]
-
-    def select_core(self, num):
-        if not self.cores.has_key(num):
-            raise ValueError("invalid core number")
-        logging.debug("selected core #%d" % num)
-        self._selected_core = num
-
-    @property
-    ## @brief Waits for SVD file to complete loading before returning.
-    def svd_device(self):
-        if not self._svd_device and self._svd_load_thread:
-            logging.debug("Waiting for SVD load to complete")
-            self._svd_device = self._svd_load_thread.device
-        return self._svd_device
-
-    def loadSVD(self):
-        def svdLoadCompleted(svdDevice):
-            logging.debug("Completed loading SVD")
-            self._svd_device = svdDevice
-            self._svd_load_thread = None
-
-        if not self._svd_device and self._svd_location:
-            logging.debug("Started loading SVD")
-
-            # Spawn thread to load SVD in background.
-            self._svd_load_thread = SVDLoader(self._svd_location, svdLoadCompleted)
-            self._svd_load_thread.load()
-
-    def init(self, bus_accessible=True):
-        # Start loading the SVD file
-        self.loadSVD()
-
-        # Create the DP and turn on debug.
-        self.dp.init()
-        self.dp.power_up_debug()
-
-        # Create an AHB-AP for the CPU.
-        self.aps[0] = ap.AHB_AP(self.dp, 0)
-        self.aps[0].init(bus_accessible)
-
-        # Create CortexM core.
-        self.cores[0] = cortex_m.CortexM(self.link, self.dp, self.aps[0], self.memory_map)
-        if bus_accessible:
-            self.cores[0].init()
-
-    def disconnect(self):
-        for core in self.cores.values():
-            core.disconnect()
-        self.dp.power_down_debug()
-
-    def readIDCode(self):
-        return self.dp.dpidr
-
-    def halt(self):
-        return self.selected_core.halt()
-
-    def step(self, disable_interrupts=True):
-        return self.selected_core.step(disable_interrupts)
-
-    def resume(self):
-        return self.selected_core.resume()
-
-    def writeMemory(self, addr, value, transfer_size=32):
-        return self.selected_core.writeMemory(addr, value, transfer_size)
-
-    def readMemory(self, addr, transfer_size=32, now=True):
-        return self.selected_core.readMemory(addr, transfer_size, now)
-
-    def writeBlockMemoryUnaligned8(self, addr, value):
-        return self.selected_core.writeBlockMemoryUnaligned8(addr, value)
-
-    def writeBlockMemoryAligned32(self, addr, data):
-        return self.selected_core.writeBlockMemoryAligned32(addr, data)
-
-    def readBlockMemoryUnaligned8(self, addr, size):
-        return self.selected_core.readBlockMemoryUnaligned8(addr, size)
-
-    def readBlockMemoryAligned32(self, addr, size):
-        return self.selected_core.readBlockMemoryAligned32(addr, size)
-
-    def readCoreRegister(self, id):
-        return self.selected_core.readCoreRegister(id)
-
-    def writeCoreRegister(self, id, data):
-        return self.selected_core.writeCoreRegister(id, data)
-
-    def readCoreRegisterRaw(self, reg):
-        return self.selected_core.readCoreRegisterRaw(reg)
-
-    def readCoreRegistersRaw(self, reg_list):
-        return self.selected_core.readCoreRegistersRaw(reg_list)
-
-    def writeCoreRegisterRaw(self, reg, data):
-        self.selected_core.writeCoreRegisterRaw(reg, data)
-
-    def writeCoreRegistersRaw(self, reg_list, data_list):
-        self.selected_core.writeCoreRegistersRaw(reg_list, data_list)
-
-    def findBreakpoint(self, addr):
-        return self.selected_core.findBreakpoint(addr)
-
-    def setBreakpoint(self, addr, type=Target.BREAKPOINT_AUTO):
-        return self.selected_core.setBreakpoint(addr, type)
-
-    def getBreakpointType(self, addr):
-        return self.selected_core.getBreakpointType(addr)
-
-    def removeBreakpoint(self, addr):
-        return self.selected_core.removeBreakpoint(addr)
-
-    def setWatchpoint(self, addr, size, type):
-        return self.selected_core.setWatchpoint(addr, size, type)
-
-    def removeWatchpoint(self, addr, size, type):
-        return self.selected_core.removeWatchpoint(addr, size, type)
-
-    def reset(self, software_reset=None):
-        return self.selected_core.reset(software_reset=software_reset)
-
-    def resetStopOnReset(self, software_reset=None):
-        return self.selected_core.resetStopOnReset(software_reset)
-
-    def setTargetState(self, state):
-        return self.selected_core.setTargetState(state)
-
-    def getState(self):
-        return self.selected_core.getState()
-
-    def getMemoryMap(self):
-        return self.memory_map
-
-    def setVectorCatchFault(self, enable):
-        return self.selected_core.setVectorCatchFault(enable)
-
-    def getVectorCatchFault(self):
-        return self.selected_core.getVectorCatchFault()
-
-    def setVectorCatchReset(self, enable):
-        return self.selected_core.setVectorCatchReset(enable)
-
-    def getVectorCatchReset(self):
-        return self.selected_core.getVectorCatchReset()
-
-    # GDB functions
-    def getTargetXML(self):
-        return self.selected_core.getTargetXML()
-
-    def getRegisterContext(self):
-        return self.selected_core.getRegisterContext()
-
-    def setRegisterContext(self, data):
-        return self.selected_core.setRegisterContext(data)
-
-    def setRegister(self, reg, data):
-        return self.selected_core.setRegister(reg, data)
-
-    def getTResponse(self, forceSignal=None):
-        return self.selected_core.getTResponse(forceSignal)
-
-    def getSignalValue(self):
-        return self.selected_core.getSignalValue()
-
-    def getThreadsXML(self):
-        root = Element('threads')
-        t = SubElement(root, 'thread', id="1", core="0")
-        t.text = "Thread mode"
-        return '<?xml version="1.0"?><!DOCTYPE feature SYSTEM "threads.dtd">' + tostring(root)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from .target import Target
+from ..coresight import (dap, ap, cortex_m)
+from ..debug.svd import (SVDFile, SVDLoader)
+from ..debug.context import DebugContext
+from ..debug.cache import CachingDebugContext
+import threading
+import logging
+from xml.etree.ElementTree import (Element, SubElement, tostring)
+
+##
+# @brief Debug target that uses CoreSight classes.
+class CoreSightTarget(Target):
+
+    def __init__(self, link, memoryMap=None):
+        super(CoreSightTarget, self).__init__(link, memoryMap)
+        self.part_number = self.__class__.__name__
+        self.cores = {}
+        self.aps = {}
+        self.dp = dap.DebugPort(link)
+        self._selected_core = 0
+        self._svd_load_thread = None
+        self._root_contexts = {}
+
+    @property
+    def selected_core(self):
+        return self.cores[self._selected_core]
+
+    def select_core(self, num):
+        if not self.cores.has_key(num):
+            raise ValueError("invalid core number")
+        logging.debug("selected core #%d" % num)
+        self._selected_core = num
+
+    @property
+    ## @brief Waits for SVD file to complete loading before returning.
+    def svd_device(self):
+        if not self._svd_device and self._svd_load_thread:
+            logging.debug("Waiting for SVD load to complete")
+            self._svd_device = self._svd_load_thread.device
+        return self._svd_device
+
+    def loadSVD(self):
+        def svdLoadCompleted(svdDevice):
+            logging.debug("Completed loading SVD")
+            self._svd_device = svdDevice
+            self._svd_load_thread = None
+
+        if not self._svd_device and self._svd_location:
+            logging.debug("Started loading SVD")
+
+            # Spawn thread to load SVD in background.
+            self._svd_load_thread = SVDLoader(self._svd_location, svdLoadCompleted)
+            self._svd_load_thread.load()
+
+    def add_ap(self, ap):
+        self.aps[ap.ap_num] = ap
+
+    def add_core(self, core):
+        self.cores[core.core_number] = core
+        self.cores[core.core_number].setTargetContext(CachingDebugContext(DebugContext(core)))
+        self._root_contexts[core.core_number] = None
+
+    def init(self, bus_accessible=True):
+        # Start loading the SVD file
+        self.loadSVD()
+
+        # Create the DP and turn on debug.
+        self.dp.init()
+        self.dp.power_up_debug()
+
+        # Create an AHB-AP for the CPU.
+        ap0 = ap.AHB_AP(self.dp, 0)
+        ap0.init(bus_accessible)
+        self.add_ap(ap0)
+
+        # Create CortexM core.
+        core0 = cortex_m.CortexM(self.link, self.dp, self.aps[0], self.memory_map)
+        if bus_accessible:
+            core0.init()
+        self.add_core(core0)
+
+    def disconnect(self):
+        for core in self.cores.values():
+            core.disconnect()
+        self.dp.power_down_debug()
+
+    def readIDCode(self):
+        return self.dp.dpidr
+
+    @property
+    def run_token(self):
+        return self.selected_core.run_token
+
+    def flush(self):
+        self.dp.flush()
+
+    def halt(self):
+        return self.selected_core.halt()
+
+    def step(self, disable_interrupts=True):
+        return self.selected_core.step(disable_interrupts)
+
+    def resume(self):
+        return self.selected_core.resume()
+
+    def massErase(self):
+        if self.flash is not None:
+            self.flash.init()
+            self.flash.eraseAll()
+            return True
+        else:
+            return False
+
+    def writeMemory(self, addr, value, transfer_size=32):
+        return self.selected_core.writeMemory(addr, value, transfer_size)
+
+    def readMemory(self, addr, transfer_size=32, now=True):
+        return self.selected_core.readMemory(addr, transfer_size, now)
+
+    def writeBlockMemoryUnaligned8(self, addr, value):
+        return self.selected_core.writeBlockMemoryUnaligned8(addr, value)
+
+    def writeBlockMemoryAligned32(self, addr, data):
+        return self.selected_core.writeBlockMemoryAligned32(addr, data)
+
+    def readBlockMemoryUnaligned8(self, addr, size):
+        return self.selected_core.readBlockMemoryUnaligned8(addr, size)
+
+    def readBlockMemoryAligned32(self, addr, size):
+        return self.selected_core.readBlockMemoryAligned32(addr, size)
+
+    def readCoreRegister(self, id):
+        return self.selected_core.readCoreRegister(id)
+
+    def writeCoreRegister(self, id, data):
+        return self.selected_core.writeCoreRegister(id, data)
+
+    def readCoreRegisterRaw(self, reg):
+        return self.selected_core.readCoreRegisterRaw(reg)
+
+    def readCoreRegistersRaw(self, reg_list):
+        return self.selected_core.readCoreRegistersRaw(reg_list)
+
+    def writeCoreRegisterRaw(self, reg, data):
+        self.selected_core.writeCoreRegisterRaw(reg, data)
+
+    def writeCoreRegistersRaw(self, reg_list, data_list):
+        self.selected_core.writeCoreRegistersRaw(reg_list, data_list)
+
+    def findBreakpoint(self, addr):
+        return self.selected_core.findBreakpoint(addr)
+
+    def setBreakpoint(self, addr, type=Target.BREAKPOINT_AUTO):
+        return self.selected_core.setBreakpoint(addr, type)
+
+    def getBreakpointType(self, addr):
+        return self.selected_core.getBreakpointType(addr)
+
+    def removeBreakpoint(self, addr):
+        return self.selected_core.removeBreakpoint(addr)
+
+    def setWatchpoint(self, addr, size, type):
+        return self.selected_core.setWatchpoint(addr, size, type)
+
+    def removeWatchpoint(self, addr, size, type):
+        return self.selected_core.removeWatchpoint(addr, size, type)
+
+    def reset(self, software_reset=None):
+        return self.selected_core.reset(software_reset=software_reset)
+
+    def resetStopOnReset(self, software_reset=None):
+        return self.selected_core.resetStopOnReset(software_reset)
+
+    def setTargetState(self, state):
+        return self.selected_core.setTargetState(state)
+
+    def getState(self):
+        return self.selected_core.getState()
+
+    def getMemoryMap(self):
+        return self.memory_map
+
+    def setVectorCatch(self, enableMask):
+        return self.selected_core.setVectorCatch(enableMask)
+
+    def getVectorCatch(self):
+        return self.selected_core.getVectorCatch()
+
+    # GDB functions
+    def getTargetXML(self):
+        return self.selected_core.getTargetXML()
+
+    def getTargetContext(self, core=None):
+        if core is None:
+            core = self._selected_core
+        return self.cores[core].getTargetContext()
+
+    def getRootContext(self, core=None):
+        if core is None:
+            core = self._selected_core
+        if self._root_contexts[core] is None:
+            return self.getTargetContext()
+        else:
+            return self._root_contexts[core]
+
+    def setRootContext(self, context, core=None):
+        if core is None:
+            core = self._selected_core
+        self._root_contexts[core] = context
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/target/target_k22f.py` & `pyOCD-0.9.0/pyOCD/target/target_RTL8195AM.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,36 +1,41 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from target_kinetis import Kinetis
-from .memory_map import (FlashRegion, RamRegion, MemoryMap)
-from .coresight_target import SVDFile
-import logging
-
-
-class K22F(Kinetis):
-
-    # 512kB flash with 2kB sectors, 128kB RAM
-    memoryMap = MemoryMap(
-        FlashRegion(    start=0,           length=0x80000,     blocksize=0x800, isBootMemory=True),
-        RamRegion(      start=0x1fff0000,  length=0x20000)
-        )
-
-    def __init__(self, link):
-        super(K22F, self).__init__(link, self.memoryMap)
-        self.mdm_idr = 0x001c0000
-        self._svd_location = SVDFile(vendor="Freescale", filename="MK22F51212.svd", is_local=False)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from ..flash.flash import Flash
+from ..core.coresight_target import CoreSightTarget
+from ..core.memory_map import (FlashRegion, RamRegion, MemoryMap)
+import logging
+
+class Flash_rtl8195am(Flash):
+
+    def __init__(self, target):
+        return
+
+class RTL8195AM(CoreSightTarget):
+
+    memoryMap = MemoryMap(
+        RamRegion(      start=0x00000000,  length=0x400000),
+        RamRegion(      start=0x10000000,  length=0x80000),
+        RamRegion(      start=0x30000000,  length=0x200000),
+        RamRegion(      start=0x40000000,  length=0x40000)
+        )
+
+    def __init__(self, link):
+        super(RTL8195AM, self).__init__(link, self.memoryMap)
+
+    def init(self):
+        logging.debug('rtl8195am init')
+        super(RTL8195AM, self).init()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/target/target_kinetis.py` & `pyOCD-0.9.0/pyOCD/target/family/target_kinetis.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,174 +1,174 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from ..coresight import (dap, ap)
-from ..coresight.cortex_m import CortexM
-from pyOCD.target.target import Target
-from .coresight_target import CoreSightTarget
-import logging
-from time import sleep
-
-MDM_STATUS = 0x00000000
-MDM_CTRL = 0x00000004
-MDM_IDR = 0x000000fc
-
-MDM_STATUS_FLASH_MASS_ERASE_ACKNOWLEDGE = (1 << 0)
-MDM_STATUS_FLASH_READY = (1 << 1)
-MDM_STATUS_SYSTEM_SECURITY = (1 << 2)
-MDM_STATUS_MASS_ERASE_ENABLE = (1 << 5)
-MDM_STATUS_CORE_HALTED = (1 << 16)
-
-MDM_CTRL_FLASH_MASS_ERASE_IN_PROGRESS = (1 << 0)
-MDM_CTRL_DEBUG_REQUEST = (1 << 2)
-MDM_CTRL_CORE_HOLD_RESET = (1 << 4)
-
-# Kinetis FCF byte array to disable flash security.
-fcf = [0xff] * 12
-fcf += [0xfe, 0xff, 0xff, 0xff]
-
-# Location of FCF in the memory map.
-FCF_ADDR = 0x400
-
-class Kinetis(CoreSightTarget):
-
-    def __init__(self, link, memoryMap=None):
-        super(Kinetis, self).__init__(link, memoryMap)
-        self.mdm_idr = 0
-        self.mdm_ap = None
-        self.do_auto_unlock = True
-
-    def setAutoUnlock(self, doAutoUnlock):
-        self.do_auto_unlock = doAutoUnlock
-
-    def init(self):
-        super(Kinetis, self).init(bus_accessible=False)
-
-        self.mdm_ap = ap.AccessPort(self.dp, 1)
-        self.aps[1] = self.mdm_ap
-        self.mdm_ap.init(False)
-
-        # check MDM-AP ID
-        if self.mdm_ap.idr != self.mdm_idr:
-            logging.error("%s: bad MDM-AP IDR (is 0x%08x, expected 0x%08x)", self.part_number, val, self.mdm_idr)
-
-        # check for flash security
-        isLocked = self.isLocked()
-        if isLocked:
-            if self.do_auto_unlock:
-                logging.warning("%s in secure state: will try to unlock via mass erase", self.part_number)
-                # keep the target in reset until is had been erased and halted
-                self.dp.assert_reset(True)
-                if not self.massErase():
-                    self.dp.assert_reset(False)
-                    logging.error("%s: mass erase failed", self.part_number)
-                    raise Exception("unable to unlock device")
-                # Use the MDM to keep the target halted after reset has been released
-                self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST)
-                # Enable debug
-                self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
-                self.dp.assert_reset(False)
-                while self.mdm_ap.read_reg(MDM_STATUS) & MDM_STATUS_CORE_HALTED != MDM_STATUS_CORE_HALTED:
-                    logging.debug("Waiting for mdm halt (erase)")
-                    sleep(0.01)
-
-                # release MDM halt once it has taken effect in the DHCSR
-                self.mdm_ap.write_reg(MDM_CTRL, 0)
-
-                isLocked = False
-            else:
-                logging.warning("%s in secure state: not automatically unlocking", self.part_number)
-        else:
-            logging.info("%s not in secure state", self.part_number)
-
-        # Can't do anything more if the target is secure
-        if isLocked:
-            return
-
-        if self.halt_on_connect:
-            # Prevent the target from resetting if it has invalid code
-            self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET)
-            while self.mdm_ap.read_reg(MDM_CTRL) & (MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET) != (MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET):
-                self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET)
-            # Enable debug
-            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
-            # Disable holding the core in reset, leave MDM halt on
-            self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST)
-
-            # Wait until the target is halted
-            while self.mdm_ap.read_reg(MDM_STATUS) & MDM_STATUS_CORE_HALTED != MDM_STATUS_CORE_HALTED:
-                logging.debug("Waiting for mdm halt")
-                sleep(0.01)
-
-            # release MDM halt once it has taken effect in the DHCSR
-            self.mdm_ap.write_reg(MDM_CTRL, 0)
-
-            # sanity check that the target is still halted
-            if self.getState() == Target.TARGET_RUNNING:
-                raise Exception("Target failed to stay halted during init sequence")
-
-        self.aps[0].init(bus_accessible=True)
-        self.cores[0].init()
-
-    def isLocked(self):
-        val = self.mdm_ap.read_reg(MDM_STATUS)
-        if val & MDM_STATUS_SYSTEM_SECURITY:
-            return True
-        else:
-            return False
-
-    ## @brief Returns True if mass erase succeeded, False if it failed or is disabled.
-    # Note: reset should be held for the duration of this function
-    def massErase(self):
-        # Wait until flash is inited.
-        while True:
-            status = self.mdm_ap.read_reg(MDM_STATUS)
-            if status & MDM_STATUS_FLASH_READY:
-                break
-            sleep(0.01)
-
-        # Check if mass erase is enabled.
-        status = self.mdm_ap.read_reg(MDM_STATUS)
-        if not (status & MDM_STATUS_MASS_ERASE_ENABLE):
-            logging.error("Mass erase disabled. MDM status: 0x%x", status)
-            return False
-
-        # Set Flash Mass Erase in Progress bit to start erase.
-        self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_FLASH_MASS_ERASE_IN_PROGRESS)
-
-        # Wait for Flash Mass Erase Acknowledge to be set.
-        while True:
-            val = self.mdm_ap.read_reg(MDM_STATUS)
-            if val & MDM_STATUS_FLASH_MASS_ERASE_ACKNOWLEDGE:
-                break
-            sleep(0.01)
-
-        # Wait for Flash Mass Erase in Progress bit to clear when erase is completed.
-        while True:
-            val = self.mdm_ap.read_reg(MDM_CTRL)
-            if (val == 0):
-                break
-            sleep(0.01)
-
-        # Confirm the part was unlocked
-        val = self.mdm_ap.read_reg(MDM_STATUS)
-        if (val & MDM_STATUS_SYSTEM_SECURITY) == 0:
-            logging.warning("%s secure state: unlocked successfully", self.part_number)
-            return True
-        else:
-            logging.error("Failed to unlock. MDM status: 0x%x", val)
-            return False
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ...coresight import (dap, ap)
+from ...coresight.cortex_m import CortexM
+from ...core.target import Target
+from ...core.coresight_target import CoreSightTarget
+import logging
+from time import sleep
+
+MDM_STATUS = 0x00000000
+MDM_CTRL = 0x00000004
+MDM_IDR = 0x000000fc
+
+MDM_STATUS_FLASH_MASS_ERASE_ACKNOWLEDGE = (1 << 0)
+MDM_STATUS_FLASH_READY = (1 << 1)
+MDM_STATUS_SYSTEM_SECURITY = (1 << 2)
+MDM_STATUS_MASS_ERASE_ENABLE = (1 << 5)
+MDM_STATUS_CORE_HALTED = (1 << 16)
+
+MDM_CTRL_FLASH_MASS_ERASE_IN_PROGRESS = (1 << 0)
+MDM_CTRL_DEBUG_REQUEST = (1 << 2)
+MDM_CTRL_CORE_HOLD_RESET = (1 << 4)
+
+# Kinetis FCF byte array to disable flash security.
+fcf = [0xff] * 12
+fcf += [0xfe, 0xff, 0xff, 0xff]
+
+# Location of FCF in the memory map.
+FCF_ADDR = 0x400
+
+class Kinetis(CoreSightTarget):
+
+    def __init__(self, link, memoryMap=None):
+        super(Kinetis, self).__init__(link, memoryMap)
+        self.mdm_idr = 0
+        self.mdm_ap = None
+        self.do_auto_unlock = True
+
+    def setAutoUnlock(self, doAutoUnlock):
+        self.do_auto_unlock = doAutoUnlock
+
+    def init(self):
+        super(Kinetis, self).init(bus_accessible=False)
+
+        self.mdm_ap = ap.AccessPort(self.dp, 1)
+        self.aps[1] = self.mdm_ap
+        self.mdm_ap.init(False)
+
+        # check MDM-AP ID
+        if self.mdm_ap.idr != self.mdm_idr:
+            logging.error("%s: bad MDM-AP IDR (is 0x%08x, expected 0x%08x)", self.part_number, self.mdm_ap.idr, self.mdm_idr)
+
+        # check for flash security
+        isLocked = self.isLocked()
+        if isLocked:
+            if self.do_auto_unlock:
+                logging.warning("%s in secure state: will try to unlock via mass erase", self.part_number)
+                # keep the target in reset until is had been erased and halted
+                self.dp.assert_reset(True)
+                if not self.massErase():
+                    self.dp.assert_reset(False)
+                    logging.error("%s: mass erase failed", self.part_number)
+                    raise Exception("unable to unlock device")
+                # Use the MDM to keep the target halted after reset has been released
+                self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST)
+                # Enable debug
+                self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
+                self.dp.assert_reset(False)
+                while self.mdm_ap.read_reg(MDM_STATUS) & MDM_STATUS_CORE_HALTED != MDM_STATUS_CORE_HALTED:
+                    logging.debug("Waiting for mdm halt (erase)")
+                    sleep(0.01)
+
+                # release MDM halt once it has taken effect in the DHCSR
+                self.mdm_ap.write_reg(MDM_CTRL, 0)
+
+                isLocked = False
+            else:
+                logging.warning("%s in secure state: not automatically unlocking", self.part_number)
+        else:
+            logging.info("%s not in secure state", self.part_number)
+
+        # Can't do anything more if the target is secure
+        if isLocked:
+            return
+
+        if self.halt_on_connect:
+            # Prevent the target from resetting if it has invalid code
+            self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET)
+            while self.mdm_ap.read_reg(MDM_CTRL) & (MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET) != (MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET):
+                self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST | MDM_CTRL_CORE_HOLD_RESET)
+            # Enable debug
+            self.writeMemory(CortexM.DHCSR, CortexM.DBGKEY | CortexM.C_DEBUGEN)
+            # Disable holding the core in reset, leave MDM halt on
+            self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_DEBUG_REQUEST)
+
+            # Wait until the target is halted
+            while self.mdm_ap.read_reg(MDM_STATUS) & MDM_STATUS_CORE_HALTED != MDM_STATUS_CORE_HALTED:
+                logging.debug("Waiting for mdm halt")
+                sleep(0.01)
+
+            # release MDM halt once it has taken effect in the DHCSR
+            self.mdm_ap.write_reg(MDM_CTRL, 0)
+
+            # sanity check that the target is still halted
+            if self.getState() == Target.TARGET_RUNNING:
+                raise Exception("Target failed to stay halted during init sequence")
+
+        self.aps[0].init(bus_accessible=True)
+        self.cores[0].init()
+
+    def isLocked(self):
+        val = self.mdm_ap.read_reg(MDM_STATUS)
+        if val & MDM_STATUS_SYSTEM_SECURITY:
+            return True
+        else:
+            return False
+
+    ## @brief Returns True if mass erase succeeded, False if it failed or is disabled.
+    # Note: reset should be held for the duration of this function
+    def massErase(self):
+        # Wait until flash is inited.
+        while True:
+            status = self.mdm_ap.read_reg(MDM_STATUS)
+            if status & MDM_STATUS_FLASH_READY:
+                break
+            sleep(0.01)
+
+        # Check if mass erase is enabled.
+        status = self.mdm_ap.read_reg(MDM_STATUS)
+        if not (status & MDM_STATUS_MASS_ERASE_ENABLE):
+            logging.error("Mass erase disabled. MDM status: 0x%x", status)
+            return False
+
+        # Set Flash Mass Erase in Progress bit to start erase.
+        self.mdm_ap.write_reg(MDM_CTRL, MDM_CTRL_FLASH_MASS_ERASE_IN_PROGRESS)
+
+        # Wait for Flash Mass Erase Acknowledge to be set.
+        while True:
+            val = self.mdm_ap.read_reg(MDM_STATUS)
+            if val & MDM_STATUS_FLASH_MASS_ERASE_ACKNOWLEDGE:
+                break
+            sleep(0.01)
+
+        # Wait for Flash Mass Erase in Progress bit to clear when erase is completed.
+        while True:
+            val = self.mdm_ap.read_reg(MDM_CTRL)
+            if (val == 0):
+                break
+            sleep(0.01)
+
+        # Confirm the part was unlocked
+        val = self.mdm_ap.read_reg(MDM_STATUS)
+        if (val & MDM_STATUS_SYSTEM_SECURITY) == 0:
+            logging.warning("%s secure state: unlocked successfully", self.part_number)
+            return True
+        else:
+            logging.error("Failed to unlock. MDM status: 0x%x", val)
+            return False
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/target/target_kw40z4.py` & `pyOCD-0.9.0/pyOCD/gdbserver/symbols.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,35 +1,26 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from target_kinetis import Kinetis
-from .memory_map import (FlashRegion, RamRegion, MemoryMap)
-from .coresight_target import SVDFile
-import logging
-
-
-class KW40Z4(Kinetis):
-
-    memoryMap = MemoryMap(
-        FlashRegion(    start=0,           length=0x28000,      blocksize=0x400, isBootMemory=True),
-        RamRegion(      start=0x1ffff000,  length=0x5000)
-        )
-
-    def __init__(self, transport):
-        super(KW40Z4, self).__init__(transport, self.memoryMap)
-        self.mdm_idr = 0x001c0020
-        self._svd_location = SVDFile(vendor="Freescale", filename="MKW40Z4.svd")
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from ..debug.symbols import SymbolProvider
+
+## @brief Request symbol information from gdb.
+class GDBSymbolProvider(SymbolProvider):
+    def __init__(self, gdbserver):
+        self._gdbserver = gdbserver
+
+    def get_symbol_value(self, name):
+        return self._gdbserver.getSymbol(name)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/test/test_target/test_semihosting.py` & `pyOCD-0.9.0/pyOCD/test/test_semihosting.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,599 +1,603 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import pytest
-import os
-import sys
-import logging
-import pyOCD
-from pyOCD.target.target import Target
-from pyOCD.target import semihost
-from elapsedtimer import ElapsedTimer
-import telnetlib
-
-@pytest.fixture(scope='module', autouse=True)
-def debuglog():
-    logging.basicConfig(level=logging.DEBUG)
-
-@pytest.fixture(scope='module')
-def tgt(request):
-    board = None
-    try:
-        board = pyOCD.board.mbed_board.MbedBoard.chooseBoard(blocking=False, return_first=True)
-    except Exception as error:
-        pass
-    if board is None:
-        pytest.skip("No board present")
-        return
-
-    board.target.resetStopOnReset()
-
-    def cleanup():
-        board.uninit(resume=False)
-
-    request.addfinalizer(cleanup)
-    return board.target
-
-@pytest.fixture(scope='function')
-def semihostagent(tgt, request):
-    io_handler = semihost.InternalSemihostIOHandler()
-    agent = semihost.SemihostAgent(tgt, io_handler)
-    def cleanup():
-        agent.cleanup()
-    request.addfinalizer(cleanup)
-    return agent
-
-@pytest.fixture(scope='module')
-def ramrgn(tgt):
-    map = tgt.getMemoryMap()
-    for rgn in map:
-        if rgn.isRam:
-            return rgn
-    pytest.fail("No RAM available to load test")
-
-class TimeoutError(RuntimeError):
-    pass
-
-def run_til_halt(tgt, semihostagent):
-    with ElapsedTimer('run_til_halt', logger=logging.getLogger('root'), loglevel=logging.INFO) as t:
-        logging.info("Resuming target")
-        tgt.resume()
-
-        try:
-            while True:
-                if t.elapsed >= 2.0:
-                    raise TimeoutError()
-                if tgt.getState() == Target.TARGET_HALTED:
-                    logging.info("Target halted")
-                    didHandle = semihostagent.check_and_handle_semihost_request()
-                    if didHandle:
-                        logging.info("Semihost request handled")
-                    else:
-                        logging.info("Non-semihost break")
-                    return didHandle
-        except TimeoutError:
-            tgt.halt()
-            return False
-        finally:
-            assert tgt.getState() == Target.TARGET_HALTED
-
-NOP = 0x46c0
-BKPT_00 = 0xbe00
-BKPT_AB = 0xbeab
-
-## @brief Semihost IO handler that records output.
-#
-# This handler is only meant to be used for console I/O since it doesn't implement
-# open() or close().
-class RecordingSemihostIOHandler(semihost.SemihostIOHandler):
-    def __init__(self):
-        self._out_data = {}
-        self._in_data = {}
-
-    def set_input_data(self, fd, data):
-        self._in_data[fd] = data
-
-    def get_output_data(self, fd):
-        if self._out_data.has_key(fd):
-            return self._out_data[fd]
-        else:
-            return None
-
-    def write(self, fd, ptr, length):
-        if not self._out_data.has_key(fd):
-            self._out_data[fd] = ''
-        s = self.agent._get_string(ptr, length)
-        self._out_data[fd] += s
-        return 0
-
-    def read(self, fd, ptr, length):
-        if not self._in_data.has_key(fd):
-            return length
-        d = self._in_data[fd][:length]
-        self._in_data[fd] = self._in_data[fd][length:]
-        self.agent.target.writeBlockMemoryUnaligned8(ptr, bytearray(d))
-        return length - len(d)
-
-    def readc(self):
-        if not self._in_data.has_key(semihost.STDIN_FD):
-            return -1
-        d = self._in_data[semihost.STDIN_FD][:1]
-        self._in_data[semihost.STDIN_FD] = self._in_data[semihost.STDIN_FD][1:]
-        if len(d):
-            return ord(d[0])
-        else:
-            return -1
-
-## @brief Utility to build code and set registers to perform a semihost request.
-class SemihostRequestBuilder:
-    def __init__(self, tgt, semihostagent, ramrgn):
-        self.tgt = tgt
-        self.semihostagent = semihostagent
-        self.ramrgn = ramrgn
-
-    def set_agent(self, agent):
-        self.semihostagent = agent
-
-    def setup_semihost_request(self, rqnum):
-        assert self.tgt.getState() == Target.TARGET_HALTED
-
-        self.tgt.write16(self.ramrgn.start, NOP)
-        self.tgt.write16(self.ramrgn.start + 2, BKPT_AB)
-        self.tgt.write16(self.ramrgn.start + 4, BKPT_00)
-
-        self.tgt.writeCoreRegister('pc', self.ramrgn.start)
-        self.tgt.writeCoreRegister('sp', self.ramrgn.start + 0x100)
-        self.tgt.writeCoreRegister('r0', rqnum)
-        self.tgt.writeCoreRegister('r1', self.ramrgn.start + 0x200)
-        self.tgt.flush()
-        return self.ramrgn.start + 0x200
-
-    def do_open(self, filename, mode):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_OPEN)
-
-        # Write filename
-        filename = bytearray(filename + '\x00')
-        self.tgt.writeBlockMemoryUnaligned8(argsptr + 12, filename)
-
-        self.tgt.write32(argsptr, argsptr + 12) # null terminated filename
-        self.tgt.write32(argsptr + 4, semihost.SemihostAgent.OPEN_MODES.index(mode)) # mode
-        self.tgt.write32(argsptr + 8, len(filename) - 1) # filename length minus null terminator
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-    def do_close(self, fd):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_CLOSE)
-        self.tgt.write32(argsptr, fd)
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-    def do_write(self, fd, data):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITE)
-
-        # Write data
-        self.tgt.writeBlockMemoryUnaligned8(argsptr + 12, bytearray(data))
-
-        self.tgt.write32(argsptr, fd) # fd
-        self.tgt.write32(argsptr + 4, argsptr + 12) # data
-        self.tgt.write32(argsptr + 8, len(data)) # data length
-        self.tgt.flush()
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-    def do_writec(self, c):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITEC)
-        self.tgt.write8(argsptr, ord(c))
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-    def do_write0(self, s):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITE0)
-
-        s = bytearray(s + '\x00')
-        self.tgt.writeBlockMemoryUnaligned8(argsptr, s)
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-    def do_read(self, fd, length):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_READ)
-
-        # Clear read buffer.
-        self.tgt.writeBlockMemoryUnaligned8(argsptr + 12, bytearray('\x00') * length)
-
-        self.tgt.write32(argsptr, fd) # fd
-        self.tgt.write32(argsptr + 4, argsptr + 12) # ptr
-        self.tgt.write32(argsptr + 8, length) # data length
-        self.tgt.flush()
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-
-        # Read data put into read buffer.
-        data = str(bytearray(self.tgt.readBlockMemoryUnaligned8(argsptr + 12, length - result)))
-
-        return result, data
-
-    def do_seek(self, fd, pos):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_SEEK)
-
-        self.tgt.write32(argsptr, fd) # fd
-        self.tgt.write32(argsptr + 4, pos) # pos
-        self.tgt.flush()
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-
-        return result
-
-    def do_flen(self, fd):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_FLEN)
-
-        self.tgt.write32(argsptr, fd) # fd
-        self.tgt.flush()
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-
-        return result
-
-    def do_istty(self, fd):
-        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_ISTTY)
-
-        self.tgt.write32(argsptr, fd) # fd
-        self.tgt.flush()
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-
-        return result
-
-    def do_no_args_call(self, rq):
-        argsptr = self.setup_semihost_request(rq)
-        self.tgt.writeCoreRegister('r1', 0) # r1 must be zero on entry
-
-        was_semihost = run_til_halt(self.tgt, self.semihostagent)
-        assert was_semihost
-
-        result = self.tgt.readCoreRegister('r0')
-        return result
-
-@pytest.fixture(scope='function')
-def semihost_builder(tgt, semihostagent, ramrgn):
-    return SemihostRequestBuilder(tgt, semihostagent, ramrgn)
-
-@pytest.fixture(scope='function')
-def console_semihost_builder(semihost_builder):
-    console = RecordingSemihostIOHandler()
-    agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-    semihost_builder.set_agent(agent)
-    return semihost_builder
-
-@pytest.fixture
-def delete_testfile(request):
-    def delete_it():
-        try:
-            os.remove("testfile")
-        except IOError:
-            pass
-    request.addfinalizer(delete_it)
-
-## @brief Tests for semihost requests.
-class TestSemihosting:
-    def test_open_stdio(self, semihost_builder):
-        fd = semihost_builder.do_open(":tt", 'r') # stdin
-        assert fd == 1
-
-        fd = semihost_builder.do_open(":tt", 'w') # stdout
-        assert fd == 2
-
-        fd = semihost_builder.do_open(":tt", 'a') # stderr
-        assert fd == 3
-
-    def test_open_close_file(self, semihost_builder, delete_testfile):
-        fd = semihost_builder.do_open("testfile", 'w+b')
-        assert fd != 0 and fd > 3
-
-        result = semihost_builder.do_close(fd)
-        assert result == 0
-
-    @pytest.mark.parametrize(("writeData", "pos", "readLen", "readResult"), [
-            ("12345678", 0, 8, 0),
-            ("hi", 0, 2, 0),
-            ("hello", 2, 3, 0),
-            ("", 0, 4, 4),
-            ("abcd", -1, 0, 0)
-        ])
-    def test_file_write_read(self, semihost_builder, delete_testfile, writeData, pos, readLen, readResult):
-        fd = semihost_builder.do_open("testfile", 'w+b')
-        assert fd != 0 and fd > 3
-
-        if len(writeData):
-            result = semihost_builder.do_write(fd, writeData)
-            assert result == 0
-
-            result = semihost_builder.do_flen(fd)
-            assert result == len(writeData)
-
-        if pos != -1:
-            result = semihost_builder.do_seek(fd, pos)
-            assert result == 0
-
-        result, data = semihost_builder.do_read(fd, readLen)
-        assert result == readResult
-        assert data == writeData[pos:pos + readLen]
-
-        result = semihost_builder.do_close(fd)
-        assert result == 0
-
-    def test_console_write(self, semihost_builder):
-        console = RecordingSemihostIOHandler()
-        agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-        semihost_builder.set_agent(agent)
-
-        result = semihost_builder.do_write(semihost.STDOUT_FD, 'hello world')
-        assert result == 0
-
-        assert console.get_output_data(semihost.STDOUT_FD) == 'hello world'
-
-    def test_console_writec(self, semihost_builder):
-        console = RecordingSemihostIOHandler()
-        agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-        semihost_builder.set_agent(agent)
-
-        for c in 'abcdef':
-            result = semihost_builder.do_writec(c)
-            assert result == 0
-
-        assert console.get_output_data(semihost.STDOUT_FD) == 'abcdef'
-
-    def test_console_write0(self, semihost_builder):
-        console = RecordingSemihostIOHandler()
-        agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-        semihost_builder.set_agent(agent)
-
-        result = semihost_builder.do_write0('this is a string')
-        assert result == 0
-
-        assert console.get_output_data(semihost.STDOUT_FD) == 'this is a string'
-
-    @pytest.mark.parametrize(("data", "readlen"), [
-            ("12345678", 8),
-            ("hi", 2),
-            ("hello", 3),
-            ("", 4),
-            ("abcd", 0)
-        ])
-    def test_console_read(self, semihost_builder, data, readlen):
-        console = RecordingSemihostIOHandler()
-        agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-        semihost_builder.set_agent(agent)
-
-        console.set_input_data(semihost.STDIN_FD, data)
-
-        result, resultData = semihost_builder.do_read(semihost.STDIN_FD, readlen)
-
-        assert result == (readlen - min(readlen, len(data)))
-
-        expectedData = data[:min(len(data), readlen)]
-        assert resultData == expectedData
-
-    def test_console_readc(self, semihost_builder):
-        console = RecordingSemihostIOHandler()
-        agent = semihost.SemihostAgent(semihost_builder.tgt, console=console)
-        semihost_builder.set_agent(agent)
-
-        console.set_input_data(semihost.STDIN_FD, 'x')
-
-        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_READC)
-        assert chr(result) == 'x'
-
-    def test_clock(self, semihost_builder):
-        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_CLOCK)
-        assert result != -1
-        assert result != 0
-        logging.info("clock = %d cs", result)
-
-        result2 = semihost_builder.do_no_args_call(semihost.TARGET_SYS_CLOCK)
-        assert result2 != -1
-        assert result2 != 0
-        assert result2 > result
-        logging.info("clock = %d cs", result2)
-
-    def test_time(self, semihost_builder):
-        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_TIME)
-        assert result != 0
-        logging.info("time = %d sec", result)
-
-    def test_errno_no_err(self, semihost_builder):
-        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_ERRNO)
-        assert result == 0
-
-    @pytest.mark.parametrize(("fd"), [
-            (semihost.STDIN_FD),
-            (semihost.STDOUT_FD),
-            (semihost.STDERR_FD),
-        ])
-    def test_istty_stdio(self, semihost_builder, fd):
-        result = semihost_builder.do_istty(fd)
-        assert result == 1
-
-    def test_istty_non_stdio(self, semihost_builder, delete_testfile):
-        fd = semihost_builder.do_open("testfile", 'w+b')
-        assert fd != 0 and fd > 3
-
-        result = semihost_builder.do_istty(fd)
-        assert result == 0
-
-        result = semihost_builder.do_close(fd)
-        assert result == 0
-
-@pytest.fixture(scope='function')
-def telnet(request):
-    telnet = semihost.TelnetSemihostIOHandler(4444)
-    def stopit():
-        telnet.stop()
-    request.addfinalizer(stopit)
-    return telnet
-
-@pytest.fixture(scope='function')
-def semihost_telnet_agent(tgt, telnet, request):
-    agent = semihost.SemihostAgent(tgt, console=telnet)
-    def cleanup():
-        agent.cleanup()
-    request.addfinalizer(cleanup)
-    return agent
-
-@pytest.fixture(scope='function')
-def semihost_telnet_builder(tgt, semihost_telnet_agent, ramrgn):
-    return SemihostRequestBuilder(tgt, semihost_telnet_agent, ramrgn)
-
-@pytest.fixture(scope='function')
-def telnet_conn(request):
-    telnet = telnetlib.Telnet('localhost', 4444, 1.0)
-    def cleanup():
-        telnet.close()
-    request.addfinalizer(cleanup)
-    return telnet
-
-class TestSemihostingTelnet:
-    def test_connect(self, semihost_telnet_builder, telnet_conn):
-        result = semihost_telnet_builder.do_no_args_call(semihost.TARGET_SYS_ERRNO)
-        assert result == 0
-
-    def test_write(self, semihost_telnet_builder, telnet_conn):
-        result = semihost_telnet_builder.do_write(semihost.STDOUT_FD, 'hello world')
-        assert result == 0
-
-        index, _, text = telnet_conn.expect(['hello world'])
-        assert index != -1
-        assert text == 'hello world'
-
-    def test_writec(self, semihost_telnet_builder, telnet_conn):
-        for c in 'xyzzy':
-            result = semihost_telnet_builder.do_writec(c)
-            assert result == 0
-
-            index, _, text = telnet_conn.expect([c])
-            assert index != -1
-            assert text == c
-
-    def test_write0(self, semihost_telnet_builder, telnet_conn):
-        result = semihost_telnet_builder.do_write0('hello world')
-        assert result == 0
-
-        index, _, text = telnet_conn.expect(['hello world'])
-        assert index != -1
-        assert text == 'hello world'
-
-    def test_read(self, semihost_telnet_builder, telnet_conn):
-        telnet_conn.write('hello world')
-
-        result, data = semihost_telnet_builder.do_read(semihost.STDIN_FD, 11)
-        assert result == 0
-        assert data == 'hello world'
-
-    def test_readc(self, semihost_telnet_builder, telnet_conn):
-        telnet_conn.write('xyz')
-
-        for c in 'xyz':
-            rc = semihost_telnet_builder.do_no_args_call(semihost.TARGET_SYS_READC)
-            assert chr(rc) == c
-
-class TestSemihostAgent:
-    def test_no_io_handler(self, tgt):
-        a = semihost.SemihostAgent(tgt, io_handler=None, console=None)
-        assert type(a.io_handler) is semihost.SemihostIOHandler
-        assert type(a.console) is semihost.SemihostIOHandler
-        assert a.console is a.io_handler
-
-    def test_only_io_handler(self, tgt):
-        c = RecordingSemihostIOHandler()
-        a = semihost.SemihostAgent(tgt, io_handler=c, console=None)
-        assert a.io_handler is c
-        assert a.console is c
-
-    def test_only_console(self, tgt):
-        c = RecordingSemihostIOHandler()
-        a = semihost.SemihostAgent(tgt, io_handler=None, console=c)
-        assert type(a.io_handler) is semihost.SemihostIOHandler
-        assert a.console is c
-
-@pytest.fixture
-def ioh(tgt):
-    handler = semihost.SemihostIOHandler()
-    agent = semihost.SemihostAgent(tgt, io_handler=handler)
-    return handler, agent
-
-class TestSemihostIOHandlerBase:
-    @pytest.mark.parametrize(("filename", "mode", "expectedFd"), [
-            (":tt", 'r', semihost.STDIN_FD),
-            (":tt", 'w', semihost.STDOUT_FD),
-            (":tt", 'a', semihost.STDERR_FD),
-            (":tt", 'r+b', -1),
-            ("somefile", 'r+b', None),
-        ])
-    def test_std_open(self, tgt, ramrgn, ioh, filename, mode, expectedFd):
-        handler, agent = ioh
-        tgt.writeBlockMemoryUnaligned8(ramrgn.start, bytearray(filename) + bytearray('\x00'))
-        assert handler._std_open(ramrgn.start, len(filename), mode) == (expectedFd, filename)
-
-    @pytest.mark.parametrize(("op", "args"), [
-            ('open', (0, 0, 'r')),
-            ('close', (1,)),
-            ('write', (1, 0, 0)),
-            ('read', (1, 0, 0)),
-            ('readc', tuple()),
-            ('istty', (1,)),
-            ('seek', (1, 0)),
-            ('flen', (1,)),
-            ('remove', (0, 0)),
-            ('rename', (0, 0, 0, 0)),
-        ])
-    def test_unimplemented(self, op, args):
-        handler = semihost.SemihostIOHandler()
-        with pytest.raises(NotImplementedError):
-            handler.__getattribute__(op)(*args)
-
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import pytest
+import os
+import sys
+import logging
+import pyOCD
+from pyOCD.core.target import Target
+from pyOCD.debug import semihost
+from elapsedtimer import ElapsedTimer
+import telnetlib
+
+@pytest.fixture(scope='module')
+def tgt(request):
+    board = None
+    try:
+        board = pyOCD.board.mbed_board.MbedBoard.chooseBoard(blocking=False, return_first=True)
+    except Exception as error:
+        pass
+    if board is None:
+        pytest.skip("No board present")
+        return
+
+    board.target.resetStopOnReset()
+
+    def cleanup():
+        board.uninit(resume=False)
+
+    request.addfinalizer(cleanup)
+    return board.target
+
+@pytest.fixture(scope='module')
+def ctx(tgt):
+    return tgt.getTargetContext()
+
+@pytest.fixture(scope='function')
+def semihostagent(ctx, request):
+    io_handler = semihost.InternalSemihostIOHandler()
+    agent = semihost.SemihostAgent(ctx, io_handler)
+    def cleanup():
+        agent.cleanup()
+    request.addfinalizer(cleanup)
+    return agent
+
+@pytest.fixture(scope='module')
+def ramrgn(tgt):
+    map = tgt.getMemoryMap()
+    for rgn in map:
+        if rgn.isRam:
+            return rgn
+    pytest.fail("No RAM available to load test")
+
+class TimeoutError(RuntimeError):
+    pass
+
+def run_til_halt(tgt, semihostagent):
+    with ElapsedTimer('run_til_halt', logger=logging.getLogger('root'), loglevel=logging.INFO) as t:
+        logging.info("Resuming target")
+        tgt.resume()
+
+        try:
+            while True:
+                if t.elapsed >= 2.0:
+                    raise TimeoutError()
+                if tgt.getState() == Target.TARGET_HALTED:
+                    logging.info("Target halted")
+                    didHandle = semihostagent.check_and_handle_semihost_request()
+                    if didHandle:
+                        logging.info("Semihost request handled")
+                    else:
+                        logging.info("Non-semihost break")
+                    return didHandle
+        except TimeoutError:
+            tgt.halt()
+            return False
+        finally:
+            assert tgt.getState() == Target.TARGET_HALTED
+
+NOP = 0x46c0
+BKPT_00 = 0xbe00
+BKPT_AB = 0xbeab
+
+## @brief Semihost IO handler that records output.
+#
+# This handler is only meant to be used for console I/O since it doesn't implement
+# open() or close().
+class RecordingSemihostIOHandler(semihost.SemihostIOHandler):
+    def __init__(self):
+        self._out_data = {}
+        self._in_data = {}
+
+    def set_input_data(self, fd, data):
+        self._in_data[fd] = data
+
+    def get_output_data(self, fd):
+        if self._out_data.has_key(fd):
+            return self._out_data[fd]
+        else:
+            return None
+
+    def write(self, fd, ptr, length):
+        if not self._out_data.has_key(fd):
+            self._out_data[fd] = ''
+        s = self.agent._get_string(ptr, length)
+        self._out_data[fd] += s
+        return 0
+
+    def read(self, fd, ptr, length):
+        if not self._in_data.has_key(fd):
+            return length
+        d = self._in_data[fd][:length]
+        self._in_data[fd] = self._in_data[fd][length:]
+        self.agent.context.writeBlockMemoryUnaligned8(ptr, bytearray(d))
+        return length - len(d)
+
+    def readc(self):
+        if not self._in_data.has_key(semihost.STDIN_FD):
+            return -1
+        d = self._in_data[semihost.STDIN_FD][:1]
+        self._in_data[semihost.STDIN_FD] = self._in_data[semihost.STDIN_FD][1:]
+        if len(d):
+            return ord(d[0])
+        else:
+            return -1
+
+## @brief Utility to build code and set registers to perform a semihost request.
+class SemihostRequestBuilder:
+    def __init__(self, tgt, semihostagent, ramrgn):
+        self.tgt = tgt
+        self.ctx = tgt.getTargetContext()
+        self.semihostagent = semihostagent
+        self.ramrgn = ramrgn
+
+    def set_agent(self, agent):
+        self.semihostagent = agent
+
+    def setup_semihost_request(self, rqnum):
+        assert self.tgt.getState() == Target.TARGET_HALTED
+
+        self.ctx.write16(self.ramrgn.start, NOP)
+        self.ctx.write16(self.ramrgn.start + 2, BKPT_AB)
+        self.ctx.write16(self.ramrgn.start + 4, BKPT_00)
+
+        self.ctx.writeCoreRegister('pc', self.ramrgn.start)
+        self.ctx.writeCoreRegister('sp', self.ramrgn.start + 0x100)
+        self.ctx.writeCoreRegister('r0', rqnum)
+        self.ctx.writeCoreRegister('r1', self.ramrgn.start + 0x200)
+        self.ctx.flush()
+        return self.ramrgn.start + 0x200
+
+    def do_open(self, filename, mode):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_OPEN)
+
+        # Write filename
+        filename = bytearray(filename + '\x00')
+        self.ctx.writeBlockMemoryUnaligned8(argsptr + 12, filename)
+
+        self.ctx.write32(argsptr, argsptr + 12) # null terminated filename
+        self.ctx.write32(argsptr + 4, semihost.SemihostAgent.OPEN_MODES.index(mode)) # mode
+        self.ctx.write32(argsptr + 8, len(filename) - 1) # filename length minus null terminator
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+    def do_close(self, fd):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_CLOSE)
+        self.ctx.write32(argsptr, fd)
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+    def do_write(self, fd, data):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITE)
+
+        # Write data
+        self.ctx.writeBlockMemoryUnaligned8(argsptr + 12, bytearray(data))
+
+        self.ctx.write32(argsptr, fd) # fd
+        self.ctx.write32(argsptr + 4, argsptr + 12) # data
+        self.ctx.write32(argsptr + 8, len(data)) # data length
+        self.ctx.flush()
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+    def do_writec(self, c):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITEC)
+        self.ctx.write8(argsptr, ord(c))
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+    def do_write0(self, s):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_WRITE0)
+
+        s = bytearray(s + '\x00')
+        self.ctx.writeBlockMemoryUnaligned8(argsptr, s)
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+    def do_read(self, fd, length):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_READ)
+
+        # Clear read buffer.
+        self.ctx.writeBlockMemoryUnaligned8(argsptr + 12, bytearray('\x00') * length)
+
+        self.ctx.write32(argsptr, fd) # fd
+        self.ctx.write32(argsptr + 4, argsptr + 12) # ptr
+        self.ctx.write32(argsptr + 8, length) # data length
+        self.ctx.flush()
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+
+        # Read data put into read buffer.
+        data = str(bytearray(self.tgt.readBlockMemoryUnaligned8(argsptr + 12, length - result)))
+
+        return result, data
+
+    def do_seek(self, fd, pos):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_SEEK)
+
+        self.ctx.write32(argsptr, fd) # fd
+        self.ctx.write32(argsptr + 4, pos) # pos
+        self.ctx.flush()
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+
+        return result
+
+    def do_flen(self, fd):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_FLEN)
+
+        self.ctx.write32(argsptr, fd) # fd
+        self.ctx.flush()
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+
+        return result
+
+    def do_istty(self, fd):
+        argsptr = self.setup_semihost_request(semihost.TARGET_SYS_ISTTY)
+
+        self.ctx.write32(argsptr, fd) # fd
+        self.ctx.flush()
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+
+        return result
+
+    def do_no_args_call(self, rq):
+        argsptr = self.setup_semihost_request(rq)
+        self.ctx.writeCoreRegister('r1', 0) # r1 must be zero on entry
+
+        was_semihost = run_til_halt(self.tgt, self.semihostagent)
+        assert was_semihost
+
+        result = self.ctx.readCoreRegister('r0')
+        return result
+
+@pytest.fixture(scope='function')
+def semihost_builder(tgt, semihostagent, ramrgn):
+    return SemihostRequestBuilder(tgt, semihostagent, ramrgn)
+
+@pytest.fixture(scope='function')
+def console_semihost_builder(semihost_builder):
+    console = RecordingSemihostIOHandler()
+    agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+    semihost_builder.set_agent(agent)
+    return semihost_builder
+
+@pytest.fixture
+def delete_testfile(request):
+    def delete_it():
+        try:
+            os.remove("testfile")
+        except IOError:
+            pass
+    request.addfinalizer(delete_it)
+
+## @brief Tests for semihost requests.
+class TestSemihosting:
+    def test_open_stdio(self, semihost_builder):
+        fd = semihost_builder.do_open(":tt", 'r') # stdin
+        assert fd == 1
+
+        fd = semihost_builder.do_open(":tt", 'w') # stdout
+        assert fd == 2
+
+        fd = semihost_builder.do_open(":tt", 'a') # stderr
+        assert fd == 3
+
+    def test_open_close_file(self, semihost_builder, delete_testfile):
+        fd = semihost_builder.do_open("testfile", 'w+b')
+        assert fd != 0 and fd > 3
+
+        result = semihost_builder.do_close(fd)
+        assert result == 0
+
+    @pytest.mark.parametrize(("writeData", "pos", "readLen", "readResult"), [
+            ("12345678", 0, 8, 0),
+            ("hi", 0, 2, 0),
+            ("hello", 2, 3, 0),
+            ("", 0, 4, 4),
+            ("abcd", -1, 0, 0)
+        ])
+    def test_file_write_read(self, semihost_builder, delete_testfile, writeData, pos, readLen, readResult):
+        fd = semihost_builder.do_open("testfile", 'w+b')
+        assert fd != 0 and fd > 3
+
+        if len(writeData):
+            result = semihost_builder.do_write(fd, writeData)
+            assert result == 0
+
+            result = semihost_builder.do_flen(fd)
+            assert result == len(writeData)
+
+        if pos != -1:
+            result = semihost_builder.do_seek(fd, pos)
+            assert result == 0
+
+        result, data = semihost_builder.do_read(fd, readLen)
+        assert result == readResult
+        assert data == writeData[pos:pos + readLen]
+
+        result = semihost_builder.do_close(fd)
+        assert result == 0
+
+    def test_console_write(self, semihost_builder):
+        console = RecordingSemihostIOHandler()
+        agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+        semihost_builder.set_agent(agent)
+
+        result = semihost_builder.do_write(semihost.STDOUT_FD, 'hello world')
+        assert result == 0
+
+        assert console.get_output_data(semihost.STDOUT_FD) == 'hello world'
+
+    def test_console_writec(self, semihost_builder):
+        console = RecordingSemihostIOHandler()
+        agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+        semihost_builder.set_agent(agent)
+
+        for c in 'abcdef':
+            result = semihost_builder.do_writec(c)
+            assert result == 0
+
+        assert console.get_output_data(semihost.STDOUT_FD) == 'abcdef'
+
+    def test_console_write0(self, semihost_builder):
+        console = RecordingSemihostIOHandler()
+        agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+        semihost_builder.set_agent(agent)
+
+        result = semihost_builder.do_write0('this is a string')
+        assert result == 0
+
+        assert console.get_output_data(semihost.STDOUT_FD) == 'this is a string'
+
+    @pytest.mark.parametrize(("data", "readlen"), [
+            ("12345678", 8),
+            ("hi", 2),
+            ("hello", 3),
+            ("", 4),
+            ("abcd", 0)
+        ])
+    def test_console_read(self, semihost_builder, data, readlen):
+        console = RecordingSemihostIOHandler()
+        agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+        semihost_builder.set_agent(agent)
+
+        console.set_input_data(semihost.STDIN_FD, data)
+
+        result, resultData = semihost_builder.do_read(semihost.STDIN_FD, readlen)
+
+        assert result == (readlen - min(readlen, len(data)))
+
+        expectedData = data[:min(len(data), readlen)]
+        assert resultData == expectedData
+
+    def test_console_readc(self, semihost_builder):
+        console = RecordingSemihostIOHandler()
+        agent = semihost.SemihostAgent(semihost_builder.ctx, console=console)
+        semihost_builder.set_agent(agent)
+
+        console.set_input_data(semihost.STDIN_FD, 'x')
+
+        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_READC)
+        assert chr(result) == 'x'
+
+    def test_clock(self, semihost_builder):
+        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_CLOCK)
+        assert result != -1
+        assert result != 0
+        logging.info("clock = %d cs", result)
+
+        result2 = semihost_builder.do_no_args_call(semihost.TARGET_SYS_CLOCK)
+        assert result2 != -1
+        assert result2 != 0
+        assert result2 > result
+        logging.info("clock = %d cs", result2)
+
+    def test_time(self, semihost_builder):
+        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_TIME)
+        assert result != 0
+        logging.info("time = %d sec", result)
+
+    def test_errno_no_err(self, semihost_builder):
+        result = semihost_builder.do_no_args_call(semihost.TARGET_SYS_ERRNO)
+        assert result == 0
+
+    @pytest.mark.parametrize(("fd"), [
+            (semihost.STDIN_FD),
+            (semihost.STDOUT_FD),
+            (semihost.STDERR_FD),
+        ])
+    def test_istty_stdio(self, semihost_builder, fd):
+        result = semihost_builder.do_istty(fd)
+        assert result == 1
+
+    def test_istty_non_stdio(self, semihost_builder, delete_testfile):
+        fd = semihost_builder.do_open("testfile", 'w+b')
+        assert fd != 0 and fd > 3
+
+        result = semihost_builder.do_istty(fd)
+        assert result == 0
+
+        result = semihost_builder.do_close(fd)
+        assert result == 0
+
+@pytest.fixture(scope='function')
+def telnet(request):
+    telnet = semihost.TelnetSemihostIOHandler(4444)
+    def stopit():
+        telnet.stop()
+    request.addfinalizer(stopit)
+    return telnet
+
+@pytest.fixture(scope='function')
+def semihost_telnet_agent(ctx, telnet, request):
+    agent = semihost.SemihostAgent(ctx, console=telnet)
+    def cleanup():
+        agent.cleanup()
+    request.addfinalizer(cleanup)
+    return agent
+
+@pytest.fixture(scope='function')
+def semihost_telnet_builder(tgt, semihost_telnet_agent, ramrgn):
+    return SemihostRequestBuilder(tgt, semihost_telnet_agent, ramrgn)
+
+@pytest.fixture(scope='function')
+def telnet_conn(request):
+    from time import sleep
+    # Sleep for a bit to ensure the semihost telnet server has started up in its own thread.
+    sleep(0.25)
+    telnet = telnetlib.Telnet('localhost', 4444, 10.0)
+    def cleanup():
+        telnet.close()
+    request.addfinalizer(cleanup)
+    return telnet
+
+class TestSemihostingTelnet:
+    def test_connect(self, semihost_telnet_builder, telnet_conn):
+        result = semihost_telnet_builder.do_no_args_call(semihost.TARGET_SYS_ERRNO)
+        assert result == 0
+
+    def test_write(self, semihost_telnet_builder, telnet_conn):
+        result = semihost_telnet_builder.do_write(semihost.STDOUT_FD, 'hello world')
+        assert result == 0
+
+        index, _, text = telnet_conn.expect(['hello world'])
+        assert index != -1
+        assert text == 'hello world'
+
+    def test_writec(self, semihost_telnet_builder, telnet_conn):
+        for c in 'xyzzy':
+            result = semihost_telnet_builder.do_writec(c)
+            assert result == 0
+
+            index, _, text = telnet_conn.expect([c])
+            assert index != -1
+            assert text == c
+
+    def test_write0(self, semihost_telnet_builder, telnet_conn):
+        result = semihost_telnet_builder.do_write0('hello world')
+        assert result == 0
+
+        index, _, text = telnet_conn.expect(['hello world'])
+        assert index != -1
+        assert text == 'hello world'
+
+    def test_read(self, semihost_telnet_builder, telnet_conn):
+        telnet_conn.write('hello world')
+
+        result, data = semihost_telnet_builder.do_read(semihost.STDIN_FD, 11)
+        assert result == 0
+        assert data == 'hello world'
+
+    def test_readc(self, semihost_telnet_builder, telnet_conn):
+        telnet_conn.write('xyz')
+
+        for c in 'xyz':
+            rc = semihost_telnet_builder.do_no_args_call(semihost.TARGET_SYS_READC)
+            assert chr(rc) == c
+
+class TestSemihostAgent:
+    def test_no_io_handler(self, ctx):
+        a = semihost.SemihostAgent(ctx, io_handler=None, console=None)
+        assert type(a.io_handler) is semihost.SemihostIOHandler
+        assert type(a.console) is semihost.SemihostIOHandler
+        assert a.console is a.io_handler
+
+    def test_only_io_handler(self, ctx):
+        c = RecordingSemihostIOHandler()
+        a = semihost.SemihostAgent(ctx, io_handler=c, console=None)
+        assert a.io_handler is c
+        assert a.console is c
+
+    def test_only_console(self, ctx):
+        c = RecordingSemihostIOHandler()
+        a = semihost.SemihostAgent(ctx, io_handler=None, console=c)
+        assert type(a.io_handler) is semihost.SemihostIOHandler
+        assert a.console is c
+
+@pytest.fixture
+def ioh(ctx):
+    handler = semihost.SemihostIOHandler()
+    agent = semihost.SemihostAgent(ctx, io_handler=handler)
+    return handler, agent
+
+class TestSemihostIOHandlerBase:
+    @pytest.mark.parametrize(("filename", "mode", "expectedFd"), [
+            (":tt", 'r', semihost.STDIN_FD),
+            (":tt", 'w', semihost.STDOUT_FD),
+            (":tt", 'a', semihost.STDERR_FD),
+            (":tt", 'r+b', -1),
+            ("somefile", 'r+b', None),
+        ])
+    def test_std_open(self, ctx, ramrgn, ioh, filename, mode, expectedFd):
+        handler, agent = ioh
+        ctx.writeBlockMemoryUnaligned8(ramrgn.start, bytearray(filename) + bytearray('\x00'))
+        assert handler._std_open(ramrgn.start, len(filename), mode) == (expectedFd, filename)
+
+    @pytest.mark.parametrize(("op", "args"), [
+            ('open', (0, 0, 'r')),
+            ('close', (1,)),
+            ('write', (1, 0, 0)),
+            ('read', (1, 0, 0)),
+            ('readc', tuple()),
+            ('istty', (1,)),
+            ('seek', (1, 0)),
+            ('flen', (1,)),
+            ('remove', (0, 0)),
+            ('rename', (0, 0, 0, 0)),
+        ])
+    def test_unimplemented(self, op, args):
+        handler = semihost.SemihostIOHandler()
+        with pytest.raises(NotImplementedError):
+            handler.__getattribute__(op)(*args)
+
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/test/test_utility/test_cmdline.py` & `pyOCD-0.9.0/pyOCD/test/test_cmdline.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from pyOCD.utility.cmdline import split_command_line
-
-class TestSplitCommandLine:
-    def test_split(self):
-        assert split_command_line('foo') == ['foo']
-        assert split_command_line(['foo']) == ['foo']
-        assert split_command_line('foo bar') == ['foo', 'bar']
-        assert split_command_line(['foo bar']) == ['foo', 'bar']
-
-    def test_split_strings(self):
-        assert split_command_line('"foo"') == ['foo']
-        assert split_command_line('"foo bar"') == ['foo bar']
-        assert split_command_line(['"foo"']) == ['foo']
-        assert split_command_line('a "b c" d') == ['a', "b c", 'd']
-        assert split_command_line("'foo bar'") == ['foo bar']
-
-    def test_split_whitespace(self):
-        assert split_command_line('a b') == ['a', 'b']
-        assert split_command_line('a\tb') == ['a', 'b']
-        assert split_command_line('a\rb') == ['a', 'b']
-        assert split_command_line('a\nb') == ['a', 'b']
-        assert split_command_line('a   \tb') == ['a', 'b']
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from pyOCD.utility.cmdline import split_command_line
+
+class TestSplitCommandLine:
+    def test_split(self):
+        assert split_command_line('foo') == ['foo']
+        assert split_command_line(['foo']) == ['foo']
+        assert split_command_line('foo bar') == ['foo', 'bar']
+        assert split_command_line(['foo bar']) == ['foo', 'bar']
+
+    def test_split_strings(self):
+        assert split_command_line('"foo"') == ['foo']
+        assert split_command_line('"foo bar"') == ['foo bar']
+        assert split_command_line(['"foo"']) == ['foo']
+        assert split_command_line('a "b c" d') == ['a', "b c", 'd']
+        assert split_command_line("'foo bar'") == ['foo bar']
+
+    def test_split_whitespace(self):
+        assert split_command_line('a b') == ['a', 'b']
+        assert split_command_line('a\tb') == ['a', 'b']
+        assert split_command_line('a\rb') == ['a', 'b']
+        assert split_command_line('a\nb') == ['a', 'b']
+        assert split_command_line('a   \tb') == ['a', 'b']
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/tools/flash_tool.py` & `pyOCD-0.9.0/pyOCD/tools/flash_tool.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,235 +1,244 @@
-#!/usr/bin/env python
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import argparse
-import os
-import sys
-import logging
-import itertools
-from struct import unpack
-
-try:
-    from intelhex import IntelHex
-    intelhex_available = True
-except ImportError:
-    intelhex_available = False
-
-import pyOCD
-from pyOCD import __version__
-from pyOCD.board import MbedBoard
-from pyOCD.pyDAPAccess import DAPAccess
-
-LEVELS = {
-    'debug': logging.DEBUG,
-    'info': logging.INFO,
-    'warning': logging.WARNING,
-    'error': logging.ERROR,
-    'critical': logging.CRITICAL
-}
-
-board = None
-
-supported_formats = ['bin', 'hex']
-supported_targets = pyOCD.target.TARGET.keys()
-supported_targets.remove('cortex_m')  # No generic programming
-
-debug_levels = LEVELS.keys()
-
-def int_base_0(x):
-    return int(x, base=0)
-
-epi = """--chip_erase and --sector_erase can be used alone as individual commands, or they
-can be used in conjunction with flashing a binary or hex file. For the former, only the erase option
-will be performed. With a file, the erase options specify whether to erase the entire chip before
-flashing the file, or just to erase only those sectors occupied by the file. For a standalone
-sector erase, the --address and --count options are used to specify the start address of the
-sector to erase and the number of sectors to erase.
-"""
-
-# Keep args in snyc with gdb_server.py when possible
-parser = argparse.ArgumentParser(description='Flash utility', epilog=epi)
-parser.add_argument("file", nargs='?', default=None, help="File to program")
-parser.add_argument("format", nargs='?', choices=supported_formats, default=None, help="File format. Default is to use the file extension (.bin or .hex)")
-parser.add_argument('--version', action='version', version=__version__)
-# reserved: "-p", "--port"
-# reserved: "-c", "--cmd-port"
-parser.add_argument("-b", "--board", dest="board_id", default=None,
-                    help="Connect to board by board id.  Use -l to list all connected boards.")
-parser.add_argument("-l", "--list", action="store_true", dest="list_all", default=False,
-                    help="List all connected boards.")
-parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='info',
-                    help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels),
-                    metavar="LEVEL")
-parser.add_argument("-t", "--target", dest="target_override", choices=supported_targets, default=None,
-                    help="Override target to debug.  Supported targets are: " + ", ".join(supported_targets),
-                    metavar="TARGET")
-# reserved: "-n", "--nobreak"
-# reserved: "-r", "--reset-break"
-# reserved: "-s", "--step-int"
-parser.add_argument("-f", "--frequency", dest="frequency", default=1000000, type=int,
-                    help="Set the SWD clock frequency in Hz.")
-# reserved: "-o", "--persist"
-# reserved: "-k", "--soft-bkpt-as-hard"
-group = parser.add_mutually_exclusive_group()
-group.add_argument("-ce", "--chip_erase", action="store_true", help="Use chip erase when programming.")
-group.add_argument("-se", "--sector_erase", action="store_true", help="Use sector erase when programming.")
-parser.add_argument("-u", "--unlock", action="store_true", default=False, help="Unlock the device.")
-parser.add_argument("-a", "--address", default=None, type=int_base_0,
-                    help="Address. Used for the sector address with sector erase, and for the address where to flash a binary.")
-parser.add_argument("-n", "--count", default=1, type=int_base_0,
-                    help="Number of sectors to erase. Only applies to sector erase. Default is 1.")
-parser.add_argument("-s", "--skip", default=0, type=int_base_0,
-                    help="Skip programming the first N bytes.  This can only be used with binary files")
-parser.add_argument("-hp", "--hide_progress", action="store_true", help="Don't display programming progress.")
-parser.add_argument("-fp", "--fast_program", action="store_true",
-                    help="Use only the CRC of each page to determine if it already has the same data.")
-parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
-
-# Notes
-# -Currently "--unlock" does nothing since kinetis parts will automatically get unlocked
-
-def setup_logging(args):
-    # Set logging level
-    level = LEVELS.get(args.debug_level, logging.NOTSET)
-    logging.basicConfig(level=level)
-
-
-def ranges(i):
-    for a, b in itertools.groupby(enumerate(i), lambda (x, y): y - x):
-        b = list(b)
-        yield b[0][1], b[-1][1]
-
-
-def print_progress(progress):
-    # Reset state on 0.0
-    if progress == 0.0:
-        print_progress.done = False
-
-    # print progress bar
-    if not print_progress.done:
-        sys.stdout.write('\r')
-        i = int(progress * 20.0)
-        sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
-        sys.stdout.flush()
-
-    # Finish on 1.0
-    if progress >= 1.0:
-        if not print_progress.done:
-            print_progress.done = True
-            sys.stdout.write("\n")
-
-
-def main():
-    args = parser.parse_args()
-    setup_logging(args)
-    DAPAccess.set_args(args.daparg)
-
-    # Sanity checks before attaching to board
-    if args.format == 'hex' and not intelhex_available:
-        print("Unable to program hex file")
-        print("Module 'intelhex' must be installed first")
-        exit()
-
-    if args.list_all:
-        MbedBoard.listConnectedBoards()
-    else:
-        board_selected = MbedBoard.chooseBoard(board_id=args.board_id, target_override=args.target_override,
-                                               frequency=args.frequency, blocking=False)
-        if board_selected is None:
-            print("Error: There is no board connected.")
-            sys.exit(1)
-        with board_selected as board:
-            flash = board.flash
-            link = board.link
-
-            progress = print_progress
-            if args.hide_progress:
-                progress = None
-
-            has_file = args.file is not None
-
-            chip_erase = None
-            if args.chip_erase:
-                chip_erase = True
-            elif args.sector_erase:
-                chip_erase = False
-
-            if not has_file:
-                if chip_erase:
-                    print("Erasing chip...")
-                    flash.init()
-                    flash.eraseAll()
-                    print("Done")
-                elif args.sector_erase and args.address is not None:
-                    flash.init()
-                    page_addr = args.address
-                    for i in range(args.count):
-                        page_info = flash.getPageInfo(page_addr)
-                        if not page_info:
-                            break
-                        # Align page address on first time through.
-                        if i == 0:
-                            delta = page_addr % page_info.size
-                            if delta:
-                                print("Warning: sector address 0x%08x is unaligned" % page_addr)
-                                page_addr -= delta
-                        print("Erasing sector 0x%08x" % page_addr)
-                        flash.erasePage(page_addr)
-                        page_addr += page_info.size
-                else:
-                    print("No operation performed")
-                return
-
-            # If no format provided, use the file's extension.
-            if not args.format:
-                args.format = os.path.splitext(args.file)[1][1:]
-
-            # Binary file format
-            if args.format == 'bin':
-                # If no address is specified use the start of rom
-                if args.address is None:
-                    args.address = board.flash.getFlashInfo().rom_start
-
-                with open(args.file, "rb") as f:
-                    f.seek(args.skip, 0)
-                    data = f.read()
-                args.address += args.skip
-                data = unpack(str(len(data)) + 'B', data)
-                flash.flashBlock(args.address, data, chip_erase=chip_erase, progress_cb=progress,
-                                 fast_verify=args.fast_program)
-
-            # Intel hex file format
-            elif args.format == 'hex':
-                hex = IntelHex(args.file)
-                addresses = hex.addresses()
-                addresses.sort()
-
-                flash_builder = flash.getFlashBuilder()
-
-                data_list = list(ranges(addresses))
-                for start, end in data_list:
-                    size = end - start + 1
-                    data = list(hex.tobinarray(start=start, size=size))
-                    flash_builder.addData(start, data)
-                flash_builder.program(chip_erase=chip_erase, progress_cb=progress, fast_verify=args.fast_program)
-
-            else:
-                print("Unknown file format '%s'" % args.format)
-
-if __name__ == '__main__':
-    main()
+#!/usr/bin/env python
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import argparse
+import os
+import sys
+import logging
+import itertools
+from struct import unpack
+
+try:
+    from intelhex import IntelHex
+    intelhex_available = True
+except ImportError:
+    intelhex_available = False
+
+import pyOCD
+from pyOCD import __version__
+from pyOCD.board import MbedBoard
+from pyOCD.pyDAPAccess import DAPAccess
+
+LEVELS = {
+    'debug': logging.DEBUG,
+    'info': logging.INFO,
+    'warning': logging.WARNING,
+    'error': logging.ERROR,
+    'critical': logging.CRITICAL
+}
+
+board = None
+
+supported_formats = ['bin', 'hex']
+supported_targets = pyOCD.target.TARGET.keys()
+supported_targets.remove('cortex_m')  # No generic programming
+
+debug_levels = LEVELS.keys()
+
+def int_base_0(x):
+    return int(x, base=0)
+
+epi = """--chip_erase and --sector_erase can be used alone as individual commands, or they
+can be used in conjunction with flashing a binary or hex file. For the former, only the erase option
+will be performed. With a file, the erase options specify whether to erase the entire chip before
+flashing the file, or just to erase only those sectors occupied by the file. For a standalone
+sector erase, the --address and --count options are used to specify the start address of the
+sector to erase and the number of sectors to erase.
+"""
+
+# Keep args in snyc with gdb_server.py when possible
+parser = argparse.ArgumentParser(description='Flash utility', epilog=epi)
+parser.add_argument("file", nargs='?', default=None, help="File to program")
+parser.add_argument("format", nargs='?', choices=supported_formats, default=None, help="File format. Default is to use the file extension (.bin or .hex)")
+parser.add_argument('--version', action='version', version=__version__)
+# reserved: "-p", "--port"
+# reserved: "-c", "--cmd-port"
+parser.add_argument("-b", "--board", dest="board_id", default=None,
+                    help="Connect to board by board id.  Use -l to list all connected boards.")
+parser.add_argument("-l", "--list", action="store_true", dest="list_all", default=False,
+                    help="List all connected boards.")
+parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='info',
+                    help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels),
+                    metavar="LEVEL")
+parser.add_argument("-t", "--target", dest="target_override", choices=supported_targets, default=None,
+                    help="Override target to debug.  Supported targets are: " + ", ".join(supported_targets),
+                    metavar="TARGET")
+# reserved: "-n", "--nobreak"
+# reserved: "-r", "--reset-break"
+# reserved: "-s", "--step-int"
+parser.add_argument("-f", "--frequency", dest="frequency", default=1000000, type=int,
+                    help="Set the SWD clock frequency in Hz.")
+# reserved: "-o", "--persist"
+# reserved: "-k", "--soft-bkpt-as-hard"
+group = parser.add_mutually_exclusive_group()
+group.add_argument("-ce", "--chip_erase", action="store_true", help="Use chip erase when programming.")
+group.add_argument("-se", "--sector_erase", action="store_true", help="Use sector erase when programming.")
+parser.add_argument("-u", "--unlock", action="store_true", default=False, help="Unlock the device.")
+parser.add_argument("-a", "--address", default=None, type=int_base_0,
+                    help="Address. Used for the sector address with sector erase, and for the address where to flash a binary.")
+parser.add_argument("-n", "--count", default=1, type=int_base_0,
+                    help="Number of sectors to erase. Only applies to sector erase. Default is 1.")
+parser.add_argument("-s", "--skip", default=0, type=int_base_0,
+                    help="Skip programming the first N bytes.  This can only be used with binary files")
+parser.add_argument("-hp", "--hide_progress", action="store_true", help="Don't display programming progress.")
+parser.add_argument("-fp", "--fast_program", action="store_true",
+                    help="Use only the CRC of each page to determine if it already has the same data.")
+parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
+parser.add_argument("--mass-erase", action="store_true", help="Mass erase the target device.")
+
+# Notes
+# -Currently "--unlock" does nothing since kinetis parts will automatically get unlocked
+
+def setup_logging(args):
+    # Set logging level
+    level = LEVELS.get(args.debug_level, logging.NOTSET)
+    logging.basicConfig(level=level)
+
+
+def ranges(i):
+    for a, b in itertools.groupby(enumerate(i), lambda (x, y): y - x):
+        b = list(b)
+        yield b[0][1], b[-1][1]
+
+
+def print_progress(progress):
+    # Reset state on 0.0
+    if progress == 0.0:
+        print_progress.done = False
+
+    # print progress bar
+    if not print_progress.done:
+        sys.stdout.write('\r')
+        i = int(progress * 20.0)
+        sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
+        sys.stdout.flush()
+
+    # Finish on 1.0
+    if progress >= 1.0:
+        if not print_progress.done:
+            print_progress.done = True
+            sys.stdout.write("\n")
+
+
+def main():
+    args = parser.parse_args()
+    setup_logging(args)
+    DAPAccess.set_args(args.daparg)
+
+    # Sanity checks before attaching to board
+    if args.format == 'hex' and not intelhex_available:
+        print("Unable to program hex file")
+        print("Module 'intelhex' must be installed first")
+        exit()
+
+    if args.list_all:
+        MbedBoard.listConnectedBoards()
+    else:
+        board_selected = MbedBoard.chooseBoard(board_id=args.board_id, target_override=args.target_override,
+                                               frequency=args.frequency, blocking=False)
+        if board_selected is None:
+            print("Error: There is no board connected.")
+            sys.exit(1)
+        with board_selected as board:
+            flash = board.flash
+            link = board.link
+
+            progress = print_progress
+            if args.hide_progress:
+                progress = None
+
+            has_file = args.file is not None
+
+            chip_erase = None
+            if args.chip_erase:
+                chip_erase = True
+            elif args.sector_erase:
+                chip_erase = False
+
+            if args.mass_erase:
+                print("Mass erasing device...")
+                if board.target.massErase():
+                    print("Successfully erased.")
+                else:
+                    print("Failed.")
+                return
+
+            if not has_file:
+                if chip_erase:
+                    print("Erasing chip...")
+                    flash.init()
+                    flash.eraseAll()
+                    print("Done")
+                elif args.sector_erase and args.address is not None:
+                    flash.init()
+                    page_addr = args.address
+                    for i in range(args.count):
+                        page_info = flash.getPageInfo(page_addr)
+                        if not page_info:
+                            break
+                        # Align page address on first time through.
+                        if i == 0:
+                            delta = page_addr % page_info.size
+                            if delta:
+                                print("Warning: sector address 0x%08x is unaligned" % page_addr)
+                                page_addr -= delta
+                        print("Erasing sector 0x%08x" % page_addr)
+                        flash.erasePage(page_addr)
+                        page_addr += page_info.size
+                else:
+                    print("No operation performed")
+                return
+
+            # If no format provided, use the file's extension.
+            if not args.format:
+                args.format = os.path.splitext(args.file)[1][1:]
+
+            # Binary file format
+            if args.format == 'bin':
+                # If no address is specified use the start of rom
+                if args.address is None:
+                    args.address = board.flash.getFlashInfo().rom_start
+
+                with open(args.file, "rb") as f:
+                    f.seek(args.skip, 0)
+                    data = f.read()
+                args.address += args.skip
+                data = unpack(str(len(data)) + 'B', data)
+                flash.flashBlock(args.address, data, chip_erase=chip_erase, progress_cb=progress,
+                                 fast_verify=args.fast_program)
+
+            # Intel hex file format
+            elif args.format == 'hex':
+                hex = IntelHex(args.file)
+                addresses = hex.addresses()
+                addresses.sort()
+
+                flash_builder = flash.getFlashBuilder()
+
+                data_list = list(ranges(addresses))
+                for start, end in data_list:
+                    size = end - start + 1
+                    data = list(hex.tobinarray(start=start, size=size))
+                    flash_builder.addData(start, data)
+                flash_builder.program(chip_erase=chip_erase, progress_cb=progress, fast_verify=args.fast_program)
+
+            else:
+                print("Unknown file format '%s'" % args.format)
+
+if __name__ == '__main__':
+    main()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/tools/gdb_server.py` & `pyOCD-0.9.0/pyOCD/tools/gdb_server.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,285 +1,326 @@
-#!/usr/bin/env python
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import sys
-import logging
-import traceback
-import argparse
-import json
-import pkg_resources
-
-import pyOCD.board.mbed_board
-from pyOCD import __version__
-from pyOCD.svd import isCmsisSvdAvailable
-from pyOCD.gdbserver import GDBServer
-from pyOCD.board import MbedBoard
-from pyOCD.utility.cmdline import split_command_line
-from pyOCD.pyDAPAccess.dap_access_cmsis_dap import DAPAccessCMSISDAP
-import pyOCD.board.mbed_board
-from pyOCD.pyDAPAccess import DAPAccess
-
-LEVELS = {
-    'debug': logging.DEBUG,
-    'info': logging.INFO,
-    'warning': logging.WARNING,
-    'error': logging.ERROR,
-    'critical': logging.CRITICAL
-}
-
-supported_targets = pyOCD.target.TARGET.keys()
-debug_levels = LEVELS.keys()
-
-class GDBServerTool(object):
-    def __init__(self):
-        self.args = None
-        self.gdb_server_settings = None
-        self.echo_msg = None
-
-    def build_parser(self):
-        # Keep args in snyc with flash_tool.py when possible
-        parser = argparse.ArgumentParser(description='PyOCD GDB Server')
-        parser.add_argument('--version', action='version', version=__version__)
-        parser.add_argument("-p", "--port", dest="port_number", type=int, default=3333, help="Write the port number that GDB server will open.")
-        parser.add_argument("-T", "--telnet-port", dest="telnet_port", type=int, default=4444, help="Specify the telnet port for semihosting.")
-        parser.add_argument("--allow-remote", dest="serve_local_only", default=True, action="store_false", help="Allow remote TCP/IP connections (default is no).")
-        parser.add_argument("-b", "--board", dest="board_id", default=None, help="Connect to board by board id.  Use -l to list all connected boards.")
-        parser.add_argument("-l", "--list", action="store_true", dest="list_all", default=False, help="List all connected boards.")
-        parser.add_argument("--list-targets", action="store_true", dest="list_targets", default=False, help="List all available targets.")
-        parser.add_argument("--json", action="store_true", dest="output_json", default=False, help="Output lists in JSON format. Only applies to --list and --list-targets.")
-        parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='info', help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels), metavar="LEVEL")
-        parser.add_argument("-t", "--target", dest="target_override", choices=supported_targets, default=None, help="Override target to debug.  Supported targets are: " + ", ".join(supported_targets), metavar="TARGET")
-        parser.add_argument("-n", "--nobreak", dest="break_at_hardfault", default=True, action="store_false", help="Disable halt at hardfault handler.")
-        parser.add_argument("-r", "--reset-break", dest="break_on_reset", default=False, action="store_true", help="Halt the target when reset.")
-        parser.add_argument("-s", "--step-int", dest="step_into_interrupt", default=False, action="store_true", help="Allow single stepping to step into interrupts.")
-        parser.add_argument("-f", "--frequency", dest="frequency", default=1000000, type=int, help="Set the SWD clock frequency in Hz.")
-        parser.add_argument("-o", "--persist", dest="persist", default=False, action="store_true", help="Keep GDB server running even after remote has detached.")
-        parser.add_argument("-bh", "--soft-bkpt-as-hard", dest="soft_bkpt_as_hard", default=False, action="store_true", help="Replace software breakpoints with hardware breakpoints.")
-        group = parser.add_mutually_exclusive_group()
-        group.add_argument("-ce", "--chip_erase", action="store_true", help="Use chip erase when programming.")
-        group.add_argument("-se", "--sector_erase", action="store_true", help="Use sector erase when programming.")
-        # -Currently "--unlock" does nothing since kinetis parts will automatically get unlocked
-        parser.add_argument("-u", "--unlock", action="store_true", default=False, help="Unlock the device.")
-        # reserved: "-a", "--address"
-        # reserved: "-s", "--skip"
-        parser.add_argument("-hp", "--hide_progress", action="store_true", help="Don't display programming progress.")
-        parser.add_argument("-fp", "--fast_program", action="store_true", help="Use only the CRC of each page to determine if it already has the same data.")
-        parser.add_argument("-S", "--semihosting", dest="enable_semihosting", action="store_true", help="Enable semihosting.")
-        parser.add_argument("-G", "--gdb-syscall", dest="semihost_use_syscalls", action="store_true", help="Use GDB syscalls for semihosting file I/O.")
-        parser.add_argument("-c", "--command", dest="commands", metavar="CMD", action='append', nargs='+', help="Run command (OpenOCD compatibility).")
-        parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
-        return parser
-
-    def get_chip_erase(self, args):
-        # Determine programming mode
-        chip_erase = None
-        if args.chip_erase:
-            chip_erase = True
-        elif args.sector_erase:
-            chip_erase = False
-        return chip_erase
-
-
-    def get_gdb_server_settings(self, args):
-        # Set gdb server settings
-        return {
-            'break_at_hardfault' : args.break_at_hardfault,
-            'step_into_interrupt' : args.step_into_interrupt,
-            'break_on_reset' : args.break_on_reset,
-            'persist' : args.persist,
-            'soft_bkpt_as_hard' : args.soft_bkpt_as_hard,
-            'chip_erase': self.get_chip_erase(args),
-            'hide_programming_progress' : args.hide_progress,
-            'fast_program' : args.fast_program,
-            'server_listening_callback' : self.server_listening,
-            'enable_semihosting' : args.enable_semihosting,
-            'telnet_port' : args.telnet_port,
-            'semihost_use_syscalls' : args.semihost_use_syscalls,
-            'serve_local_only' : args.serve_local_only,
-        }
-
-
-    def setup_logging(self, args):
-        level = LEVELS.get(args.debug_level, logging.NOTSET)
-        logging.basicConfig(level=level)
-
-    ## @brief Handle OpenOCD commands for compatibility.
-    def process_commands(self, commands):
-        if commands is None:
-            return
-        for cmd_list in commands:
-            try:
-                cmd_list = split_command_line(cmd_list)
-                cmd = cmd_list[0]
-                if cmd == 'gdb_port':
-                    if len(cmd_list) < 2:
-                        print "Missing port argument"
-                    else:
-                        self.args.port_number = int(cmd_list[1], base=0)
-                elif cmd == 'telnet_port':
-                    if len(cmd_list) < 2:
-                        print "Missing port argument"
-                    else:
-                        self.gdb_server_settings['telnet_port'] = int(cmd_list[1], base=0)
-                elif cmd == 'echo':
-                    self.echo_msg = ' '.join(cmd_list[1:])
-                else:
-                    print "Unsupported command: %s" % ' '.join(cmd_list)
-            except IndexError:
-                pass
-
-    def server_listening(self, server):
-        if self.echo_msg is not None:
-            print >> sys.stderr, self.echo_msg
-            sys.stderr.flush()
-
-    def disable_logging(self):
-        logging.getLogger().setLevel(logging.FATAL)
-
-    def list_boards(self):
-        self.disable_logging()
-
-        try:
-            all_mbeds = MbedBoard.getAllConnectedBoards(close=True, blocking=False)
-            status = 0
-            error = ""
-        except Exception as e:
-            all_mbeds = []
-            status = 1
-            error = str(e)
-            if not self.args.output_json:
-                raise
-
-        if self.args.output_json:
-            boards = []
-            obj = {
-                'pyocd_version' : __version__,
-                'version' : { 'major' : 1, 'minor' : 0 },
-                'status' : status,
-                'boards' : boards,
-                }
-
-            if status != 0:
-                obj['error'] = error
-
-            for mbed in all_mbeds:
-                d = {
-                    'unique_id' : mbed.unique_id,
-                    'info' : mbed.getInfo(),
-                    'board_name' : mbed.getBoardName(),
-                    'target' : mbed.getTargetType(),
-                    'vendor_name' : '',
-                    'product_name' : '',
-                    }
-
-                # Reopen the link so we can access the USB vendor and product names from the inteface.
-                # If it's not a USB based link, then we don't attempt this.
-                if isinstance(mbed.link, DAPAccessCMSISDAP):
-                    try:
-                        mbed.link.open()
-                        d['vendor_name'] = mbed.link._interface.vendor_name
-                        d['product_name'] = mbed.link._interface.product_name
-                        mbed.link.close()
-                    except Exception:
-                        pass
-                boards.append(d)
-
-            print json.dumps(obj, indent=4)
-        else:
-            index = 0
-            if len(all_mbeds) > 0:
-                for mbed in all_mbeds:
-                    print("%d => %s boardId => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'), mbed.unique_id))
-                    index += 1
-            else:
-                print("No available boards are connected")
-
-    def list_targets(self):
-        self.disable_logging()
-
-        if self.args.output_json:
-            targets = []
-            obj = {
-                'pyocd_version' : __version__,
-                'version' : { 'major' : 1, 'minor' : 0 },
-                'status' : 0,
-                'targets' : targets
-                }
-
-            for name in supported_targets:
-                t = pyOCD.target.TARGET[name](None)
-                d = {
-                    'name' : name,
-                    'part_number' : t.part_number,
-                    }
-                if t._svd_location is not None and isCmsisSvdAvailable:
-                    if t._svd_location.is_local:
-                        d['svd_path'] = t._svd_location.filename
-                    else:
-                        resource = "data/{vendor}/{filename}".format(
-                            vendor=t._svd_location.vendor,
-                            filename=t._svd_location.filename
-                        )
-                        d['svd_path'] = pkg_resources.resource_filename("cmsis_svd", resource)
-                targets.append(d)
-
-            print json.dumps(obj, indent=4) #, sys.stdout)
-        else:
-            for t in supported_targets:
-                print t
-
-    def run(self, args=None):
-        self.args = self.build_parser().parse_args(args)
-        self.gdb_server_settings = self.get_gdb_server_settings(self.args)
-        self.setup_logging(self.args)
-        DAPAccess.set_args(self.args.daparg)
-
-        self.process_commands(self.args.commands)
-
-        gdb = None
-        if self.args.list_all == True:
-            self.list_boards()
-        elif self.args.list_targets == True:
-            self.list_targets()
-        else:
-            try:
-                board_selected = MbedBoard.chooseBoard(
-                    board_id=self.args.board_id,
-                    target_override=self.args.target_override,
-                    frequency=self.args.frequency)
-                with board_selected as board:
-                    gdb = GDBServer(board, self.args.port_number, self.gdb_server_settings)
-                    while gdb.isAlive():
-                        gdb.join(timeout=0.5)
-            except KeyboardInterrupt:
-                if gdb != None:
-                    gdb.stop()
-            except Exception as e:
-                print "uncaught exception: %s" % e
-                traceback.print_exc()
-                if gdb != None:
-                    gdb.stop()
-                return 1
-
-        # Successful exit.
-        return 0
-
-def main():
-    sys.exit(GDBServerTool().run())
-
-if __name__ == '__main__':
-    main()
+#!/usr/bin/env python
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import sys
+import logging
+import traceback
+import argparse
+import json
+import pkg_resources
+
+import pyOCD.board.mbed_board
+from pyOCD import __version__
+from pyOCD.debug.svd import isCmsisSvdAvailable
+from pyOCD.gdbserver import GDBServer
+from pyOCD.board import MbedBoard
+from pyOCD.utility.cmdline import (split_command_line, VECTOR_CATCH_CHAR_MAP, convert_vector_catch)
+from pyOCD.pyDAPAccess.dap_access_cmsis_dap import DAPAccessCMSISDAP
+import pyOCD.board.mbed_board
+from pyOCD.pyDAPAccess import DAPAccess
+
+LEVELS = {
+    'debug': logging.DEBUG,
+    'info': logging.INFO,
+    'warning': logging.WARNING,
+    'error': logging.ERROR,
+    'critical': logging.CRITICAL
+}
+
+supported_targets = pyOCD.target.TARGET.keys()
+debug_levels = LEVELS.keys()
+
+class InvalidArgumentError(RuntimeError):
+    pass
+
+## @brief Argparse type function to validate the supplied target device name.
+#
+# If the target name is valid, it is returned unmodified to become the --target option's
+# attribute value.
+def validate_target(value):
+    if value.lower() not in supported_targets:
+        raise InvalidArgumentError("invalid target option '{}'".format(value))
+    return value
+
+class GDBServerTool(object):
+    def __init__(self):
+        self.args = None
+        self.gdb_server_settings = None
+        self.echo_msg = None
+
+    def build_parser(self):
+        # Build epilog with list of targets.
+        epilog = "Available targets for use with --target option: " + ", ".join(supported_targets)
+
+        # Keep args in snyc with flash_tool.py when possible
+        parser = argparse.ArgumentParser(description='PyOCD GDB Server', epilog=epilog)
+        parser.add_argument('--version', action='version', version=__version__)
+        parser.add_argument("-p", "--port", dest="port_number", type=int, default=3333, help="Write the port number that GDB server will open.")
+        parser.add_argument("-sc", "--semihost-console", dest="semihost_console_type", default="telnet", choices=('telnet', 'stdx'), help="Console for semihosting.")
+        parser.add_argument("-T", "--telnet-port", dest="telnet_port", type=int, default=4444, help="Specify the telnet port for semihosting.")
+        parser.add_argument("--allow-remote", dest="serve_local_only", default=True, action="store_false", help="Allow remote TCP/IP connections (default is no).")
+        parser.add_argument("-b", "--board", dest="board_id", default=None, help="Connect to board by board id.  Use -l to list all connected boards.")
+        parser.add_argument("-l", "--list", action="store_true", dest="list_all", default=False, help="List all connected boards.")
+        parser.add_argument("--list-targets", action="store_true", dest="list_targets", default=False, help="List all available targets.")
+        parser.add_argument("--json", action="store_true", dest="output_json", default=False, help="Output lists in JSON format. Only applies to --list and --list-targets.")
+        parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='info', help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels), metavar="LEVEL")
+        parser.add_argument("-t", "--target", dest="target_override", default=None, help="Override target to debug.", metavar="TARGET", type=validate_target)
+        parser.add_argument("-n", "--nobreak", dest="no_break_at_hardfault", action="store_true", help="Disable halt at hardfault handler. (Deprecated)")
+        parser.add_argument("-r", "--reset-break", dest="break_on_reset", action="store_true", help="Halt the target when reset. (Deprecated)")
+        parser.add_argument("-C", "--vector-catch", default='h', help="Enable vector catch sources, one letter per enabled source in any order, or 'all' or 'none'. (h=hard fault, b=bus fault, m=mem fault, i=irq err, s=state err, c=check err, p=nocp, r=reset, a=all, n=none). (Default is hard fault.)")
+        parser.add_argument("-s", "--step-int", dest="step_into_interrupt", default=False, action="store_true", help="Allow single stepping to step into interrupts.")
+        parser.add_argument("-f", "--frequency", dest="frequency", default=1000000, type=int, help="Set the SWD clock frequency in Hz.")
+        parser.add_argument("-o", "--persist", dest="persist", default=False, action="store_true", help="Keep GDB server running even after remote has detached.")
+        parser.add_argument("-bh", "--soft-bkpt-as-hard", dest="soft_bkpt_as_hard", default=False, action="store_true", help="Replace software breakpoints with hardware breakpoints.")
+        group = parser.add_mutually_exclusive_group()
+        group.add_argument("-ce", "--chip_erase", action="store_true", help="Use chip erase when programming.")
+        group.add_argument("-se", "--sector_erase", action="store_true", help="Use sector erase when programming.")
+        # -Currently "--unlock" does nothing since kinetis parts will automatically get unlocked
+        parser.add_argument("-u", "--unlock", action="store_true", default=False, help="Unlock the device.")
+        # reserved: "-a", "--address"
+        # reserved: "-s", "--skip"
+        parser.add_argument("-hp", "--hide_progress", action="store_true", help="Don't display programming progress.")
+        parser.add_argument("-fp", "--fast_program", action="store_true", help="Use only the CRC of each page to determine if it already has the same data.")
+        parser.add_argument("-S", "--semihosting", dest="enable_semihosting", action="store_true", help="Enable semihosting.")
+        parser.add_argument("-G", "--gdb-syscall", dest="semihost_use_syscalls", action="store_true", help="Use GDB syscalls for semihosting file I/O.")
+        parser.add_argument("-c", "--command", dest="commands", metavar="CMD", action='append', nargs='+', help="Run command (OpenOCD compatibility).")
+        parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
+        self.parser = parser
+        return parser
+
+    def get_chip_erase(self, args):
+        # Determine programming mode
+        chip_erase = None
+        if args.chip_erase:
+            chip_erase = True
+        elif args.sector_erase:
+            chip_erase = False
+        return chip_erase
+
+    def get_vector_catch(self, args):
+        vector_catch = args.vector_catch.lower()
+
+        # Handle deprecated options.
+        if args.break_on_reset:
+            vector_catch += 'r'
+        if args.no_break_at_hardfault:
+            # Must handle all case specially since we can't just filter 'h'.
+            if vector_catch == 'all' or 'a' in vector_catch:
+                vector_catch = 'bmiscpr' # Does not include 'h'.
+            else:
+                vector_catch = vector_catch.replace('h', '')
+
+        try:
+            return convert_vector_catch(vector_catch)
+        except ValueError as e:
+            # Reraise as an invalid argument error.
+            raise InvalidArgumentError(e.message)
+
+    def get_gdb_server_settings(self, args):
+        # Set gdb server settings
+        return {
+            'step_into_interrupt' : args.step_into_interrupt,
+            'persist' : args.persist,
+            'soft_bkpt_as_hard' : args.soft_bkpt_as_hard,
+            'chip_erase': self.get_chip_erase(args),
+            'hide_programming_progress' : args.hide_progress,
+            'fast_program' : args.fast_program,
+            'server_listening_callback' : self.server_listening,
+            'enable_semihosting' : args.enable_semihosting,
+            'semihost_console_type' : args.semihost_console_type,
+            'telnet_port' : args.telnet_port,
+            'semihost_use_syscalls' : args.semihost_use_syscalls,
+            'serve_local_only' : args.serve_local_only,
+            'vector_catch' : self.get_vector_catch(args),
+        }
+
+
+    def setup_logging(self, args):
+        format = "%(relativeCreated)07d:%(levelname)s:%(module)s:%(message)s"
+        level = LEVELS.get(args.debug_level, logging.NOTSET)
+        logging.basicConfig(level=level, format=format)
+
+    ## @brief Handle OpenOCD commands for compatibility.
+    def process_commands(self, commands):
+        if commands is None:
+            return
+        for cmd_list in commands:
+            try:
+                cmd_list = split_command_line(cmd_list)
+                cmd = cmd_list[0]
+                if cmd == 'gdb_port':
+                    if len(cmd_list) < 2:
+                        print "Missing port argument"
+                    else:
+                        self.args.port_number = int(cmd_list[1], base=0)
+                elif cmd == 'telnet_port':
+                    if len(cmd_list) < 2:
+                        print "Missing port argument"
+                    else:
+                        self.gdb_server_settings['telnet_port'] = int(cmd_list[1], base=0)
+                elif cmd == 'echo':
+                    self.echo_msg = ' '.join(cmd_list[1:])
+                else:
+                    print "Unsupported command: %s" % ' '.join(cmd_list)
+            except IndexError:
+                pass
+
+    def server_listening(self, server):
+        if self.echo_msg is not None:
+            print >> sys.stderr, self.echo_msg
+            sys.stderr.flush()
+
+    def disable_logging(self):
+        logging.getLogger().setLevel(logging.FATAL)
+
+    def list_boards(self):
+        self.disable_logging()
+
+        try:
+            all_mbeds = MbedBoard.getAllConnectedBoards(close=True, blocking=False)
+            status = 0
+            error = ""
+        except Exception as e:
+            all_mbeds = []
+            status = 1
+            error = str(e)
+            if not self.args.output_json:
+                raise
+
+        if self.args.output_json:
+            boards = []
+            obj = {
+                'pyocd_version' : __version__,
+                'version' : { 'major' : 1, 'minor' : 0 },
+                'status' : status,
+                'boards' : boards,
+                }
+
+            if status != 0:
+                obj['error'] = error
+
+            for mbed in all_mbeds:
+                d = {
+                    'unique_id' : mbed.unique_id,
+                    'info' : mbed.getInfo(),
+                    'board_name' : mbed.getBoardName(),
+                    'target' : mbed.getTargetType(),
+                    'vendor_name' : '',
+                    'product_name' : '',
+                    }
+
+                # Reopen the link so we can access the USB vendor and product names from the inteface.
+                # If it's not a USB based link, then we don't attempt this.
+                if isinstance(mbed.link, DAPAccessCMSISDAP):
+                    try:
+                        mbed.link.open()
+                        d['vendor_name'] = mbed.link._interface.vendor_name
+                        d['product_name'] = mbed.link._interface.product_name
+                        mbed.link.close()
+                    except Exception:
+                        pass
+                boards.append(d)
+
+            print json.dumps(obj, indent=4)
+        else:
+            index = 0
+            if len(all_mbeds) > 0:
+                for mbed in all_mbeds:
+                    print("%d => %s boardId => %s" % (index, mbed.getInfo().encode('ascii', 'ignore'), mbed.unique_id))
+                    index += 1
+            else:
+                print("No available boards are connected")
+
+    def list_targets(self):
+        self.disable_logging()
+
+        if self.args.output_json:
+            targets = []
+            obj = {
+                'pyocd_version' : __version__,
+                'version' : { 'major' : 1, 'minor' : 0 },
+                'status' : 0,
+                'targets' : targets
+                }
+
+            for name in supported_targets:
+                t = pyOCD.target.TARGET[name](None)
+                d = {
+                    'name' : name,
+                    'part_number' : t.part_number,
+                    }
+                if t._svd_location is not None and isCmsisSvdAvailable:
+                    if t._svd_location.is_local:
+                        d['svd_path'] = t._svd_location.filename
+                    else:
+                        resource = "data/{vendor}/{filename}".format(
+                            vendor=t._svd_location.vendor,
+                            filename=t._svd_location.filename
+                        )
+                        d['svd_path'] = pkg_resources.resource_filename("cmsis_svd", resource)
+                targets.append(d)
+
+            print json.dumps(obj, indent=4) #, sys.stdout)
+        else:
+            for t in supported_targets:
+                print t
+
+    def run(self, args=None):
+        try:
+            self.args = self.build_parser().parse_args(args)
+            self.gdb_server_settings = self.get_gdb_server_settings(self.args)
+            self.setup_logging(self.args)
+            DAPAccess.set_args(self.args.daparg)
+
+            self.process_commands(self.args.commands)
+
+            gdb = None
+            if self.args.list_all == True:
+                self.list_boards()
+            elif self.args.list_targets == True:
+                self.list_targets()
+            else:
+                try:
+                    board_selected = MbedBoard.chooseBoard(
+                        board_id=self.args.board_id,
+                        target_override=self.args.target_override,
+                        frequency=self.args.frequency)
+                    with board_selected as board:
+                        gdb = GDBServer(board, self.args.port_number, self.gdb_server_settings)
+                        while gdb.isAlive():
+                            gdb.join(timeout=0.5)
+                except KeyboardInterrupt:
+                    if gdb != None:
+                        gdb.stop()
+                except Exception as e:
+                    print "uncaught exception: %s" % e
+                    traceback.print_exc()
+                    if gdb != None:
+                        gdb.stop()
+                    return 1
+
+            # Successful exit.
+            return 0
+        except InvalidArgumentError as e:
+            self.parser.error(e)
+            return 1
+
+def main():
+    sys.exit(GDBServerTool().run())
+
+if __name__ == '__main__':
+    main()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/tools/pyocd.py` & `pyOCD-0.9.0/pyOCD/tools/pyocd.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,894 +1,1291 @@
-#!/usr/bin/env python
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import argparse
-import logging
-import os
-import sys
-import optparse
-from optparse import make_option
-import traceback
-
-import pyOCD
-from pyOCD import __version__
-from pyOCD.board import MbedBoard
-from pyOCD.target import target_kinetis
-from pyOCD.pyDAPAccess import DAPAccess
-from pyOCD.target.target import Target
-from pyOCD.utility import mask
-
-# Make disasm optional.
-try:
-    import capstone
-    isCapstoneAvailable = True
-except ImportError:
-    isCapstoneAvailable = False
-
-LEVELS = {
-        'debug':logging.DEBUG,
-        'info':logging.INFO,
-        'warning':logging.WARNING,
-        'error':logging.ERROR,
-        'critical':logging.CRITICAL
-        }
-
-CORE_STATUS_DESC = {
-        Target.TARGET_HALTED : "Halted",
-        Target.TARGET_RUNNING : "Running",
-        Target.TARGET_RESET : "Reset",
-        Target.TARGET_SLEEPING : "Sleeping",
-        Target.TARGET_LOCKUP : "Lockup",
-        }
-
-## Default SWD clock in kHz.
-DEFAULT_CLOCK_FREQ_KHZ = 1000
-
-## Command info and help.
-COMMAND_INFO = {
-        'list' : {
-            'aliases' : [],
-            'args' : "",
-            'help' : "Show available targets"
-            },
-        'erase' : {
-            'aliases' : [],
-            'args' : "ADDR [COUNT]",
-            'help' : "Erase internal flash sectors"
-            },
-        'unlock' :  {
-            'aliases' : [],
-            'args' : "",
-            'help' : "Unlock security on the target"
-            },
-        'info' : {
-            'aliases' : ['i'],
-            'args' : "",
-            'help' : "Display target type and IDs"
-            },
-        'status' : {
-            'aliases' : ['stat'],
-            'args' : "",
-            'help' : "Show the target's current state"
-            },
-        'reg' : {
-            'aliases' : [],
-            'args' : "[REG]",
-            'help' : "Print all or one register"
-            },
-        'wreg' : {
-            'aliases' : [],
-            'args' : "REG VALUE",
-            'help' : "Set the value of a register"
-            },
-        'reset' : {
-            'aliases' : [],
-            'args' : "[-h/--halt]",
-            'help' : "Reset the target"
-            },
-        'read8' : {
-            'aliases' : ['read', 'r'],
-            'args' : "ADDR [LEN]",
-            'help' : "Read 8-bit bytes"
-            },
-        'read16' : {
-            'aliases' : ['r16'],
-            'args' : "ADDR [LEN]",
-            'help' : "Read 16-bit halfwords"
-            },
-        'read32' : {
-            'aliases' : ['r32'],
-            'args' : "ADDR [LEN]",
-            'help' : "Read 32-bit words"
-            },
-        'write8' : {
-            'aliases' : ['write', 'w'],
-            'args' : "ADDR DATA...",
-            'help' : "Write 8-bit bytes"
-            },
-        'write16' : {
-            'aliases' : ['w16'],
-            'args' : "ADDR DATA...",
-            'help' : "Write 16-bit halfwords"
-            },
-        'write32' : {
-            'aliases' : ['w32'],
-            'args' : "ADDR DATA...",
-            'help' : "Write 32-bit words"
-            },
-        'go' : {
-            'aliases' : ['g'],
-            'args' : "",
-            'help' : "Resume execution of the target"
-            },
-        'step' : {
-            'aliases' : ['s'],
-            'args' : "",
-            'help' : "Step one instruction"
-            },
-        'halt' : {
-            'aliases' : ['h'],
-            'args' : "",
-            'help' : "Halt the target"
-            },
-        'help' : {
-            'aliases' : ['?'],
-            'args' : "[CMD]",
-            'help' : "Show help for commands"
-            },
-        'disasm' : {
-            'aliases' : ['d'],
-            'args' : "[-c/--center] ADDR [LEN]",
-            'help' : "Disassemble instructions at an address"
-            },
-        'log' : {
-            'aliases' : [],
-            'args' : "LEVEL",
-            'help' : "Set log level to one of debug, info, warning, error, critical"
-            },
-        'clock' : {
-            'aliases' : [],
-            'args' : "KHZ",
-            'help' : "Set SWD or JTAG clock frequency"
-            },
-        'exit' : {
-            'aliases' : ['quit'],
-            'args' : "",
-            'help' : "Quit pyocd-tool"
-            },
-        'core' : {
-            'aliases' : [],
-            'args' : "[NUM]",
-            'help' : "Select CPU core by number or print selected core"
-            },
-        }
-
-def hex_width(value, width):
-    if width == 8:
-        return "%02x" % value
-    elif width == 16:
-        return "%04x" % value
-    elif width == 32:
-        return "%08x" % value
-    else:
-        raise ToolError("unrecognized register width (%d)" % reg.size)
-
-def dumpHexData(data, startAddress=0, width=8):
-    i = 0
-    while i < len(data):
-        print "%08x: " % (startAddress + i),
-
-        while i < len(data):
-            d = data[i]
-            i += 1
-            if width == 8:
-                print "%02x" % d,
-                if i % 4 == 0:
-                    print "",
-                if i % 16 == 0:
-                    break
-            elif width == 16:
-                print "%04x" % d,
-                if i % 8 == 0:
-                    break
-            elif width == 32:
-                print "%08x" % d,
-                if i % 4 == 0:
-                    break
-        print
-
-class ToolError(Exception):
-    pass
-
-class ToolExitException(Exception):
-    pass
-
-def cmdoptions(opts):
-    def process_opts(fn):
-        parser = optparse.OptionParser(add_help_option=False)
-        for opt in opts:
-            parser.add_option(opt)
-        def foo(inst, args):
-            namespace, other_args = parser.parse_args(args)
-            return fn(inst, namespace, other_args)
-        return foo
-    return process_opts
-
-class PyOCDConsole(object):
-    PROMPT = '>>> '
-
-    def __init__(self, tool):
-        self.tool = tool
-        self.last_command = ''
-
-    def run(self):
-        try:
-            while True:
-                try:
-                    line = raw_input(self.PROMPT)
-                    line = line.strip()
-                    if line:
-                        self.process_command_line(line)
-                        self.last_command = line
-                    elif self.last_command:
-                        self.process_command(self.last_command)
-                except KeyboardInterrupt:
-                    print
-        except EOFError:
-            # Print a newline when we get a Ctrl-D on a Posix system.
-            # Windows exits with a Ctrl-Z+Return, so there is no need for this.
-            if os.name != "nt":
-                print
-
-    def process_command_line(self, line):
-        for cmd in line.split(';'):
-            self.process_command(cmd)
-
-    def process_command(self, cmd):
-        try:
-            if (cmd.strip())[0] == '$':
-                cmd = cmd[1:].strip()
-                self.tool.handle_python(cmd)
-                return
-
-            args = cmd.split()
-            cmd = args[0].lower()
-            args = args[1:]
-
-            # Handle help.
-            if cmd in ['?', 'help']:
-                self.show_help(args)
-                return
-
-            # Handle register name as command.
-            if cmd in pyOCD.coresight.cortex_m.CORE_REGISTER:
-                self.tool.handle_reg([cmd])
-                return
-
-            # Check for valid command.
-            if cmd not in self.tool.command_list:
-                print "Error: unrecognized command '%s'" % cmd
-                return
-
-            # Run command.
-            handler = self.tool.command_list[cmd]
-            handler(args)
-        except ValueError:
-            print "Error: invalid argument"
-            traceback.print_exc()
-        except DAPAccess.TransferError:
-            print "Error: transfer failed"
-            traceback.print_exc()
-        except ToolError as e:
-            print "Error:", e
-        except Exception as e:
-            print "Unexpected exception:", e
-            traceback.print_exc()
-
-    def show_help(self, args):
-        if not args:
-            self.list_commands()
-
-    def list_commands(self):
-        cmds = sorted(COMMAND_INFO.keys())
-        print "Commands:\n---------"
-        for cmd in cmds:
-            info = COMMAND_INFO[cmd]
-            print "{cmd:<25} {args:<20} {help}".format(
-                cmd=', '.join(sorted([cmd] + info['aliases'])),
-                **info)
-        print
-        print "All register names are also available as commands that print the register's value."
-        print "Any ADDR or LEN argument will accept a register name."
-
-class PyOCDTool(object):
-    def __init__(self):
-        self.board = None
-        self.exitCode = 0
-        self.command_list = {
-                'list' :    self.handle_list,
-                'erase' :   self.handle_erase,
-                'unlock' :  self.handle_unlock,
-                'info' :    self.handle_info,
-                'i' :       self.handle_info,
-                'status' :  self.handle_status,
-                'stat' :    self.handle_status,
-                'reg' :     self.handle_reg,
-                'wreg' :    self.handle_write_reg,
-                'reset' :   self.handle_reset,
-                'read' :    self.handle_read8,
-                'read8' :   self.handle_read8,
-                'read16' :  self.handle_read16,
-                'read32' :  self.handle_read32,
-                'r' :       self.handle_read8,
-                'r16' :     self.handle_read16,
-                'r32' :     self.handle_read32,
-                'write' :   self.handle_write8,
-                'write8' :  self.handle_write8,
-                'write16' : self.handle_write16,
-                'write32' : self.handle_write32,
-                'w' :       self.handle_write8,
-                'w16' :     self.handle_write16,
-                'w32' :     self.handle_write32,
-                'go' :      self.handle_go,
-                'g' :       self.handle_go,
-                'step' :    self.handle_step,
-                's' :       self.handle_step,
-                'halt' :    self.handle_halt,
-                'h' :       self.handle_halt,
-                'disasm' :  self.handle_disasm,
-                'd' :       self.handle_disasm,
-                'map' :     self.handle_memory_map,
-                'log' :     self.handle_log,
-                'clock' :   self.handle_clock,
-                'exit' :    self.handle_exit,
-                'quit' :    self.handle_exit,
-                'core' :    self.handle_core,
-            }
-
-    def get_args(self):
-        debug_levels = LEVELS.keys()
-
-        epi = "Available commands:\n" + ', '.join(sorted(self.command_list.keys()))
-
-        parser = argparse.ArgumentParser(description='Target inspection utility', epilog=epi)
-        parser.add_argument('--version', action='version', version=__version__)
-        parser.add_argument("-H", "--halt", action="store_true", help="Halt core upon connect.")
-        parser.add_argument('-k', "--clock", metavar='KHZ', default=DEFAULT_CLOCK_FREQ_KHZ, type=int, help="Set SWD speed in kHz. (Default 1 MHz.)")
-        parser.add_argument('-b', "--board", action='store', metavar='ID', help="Use the specified board. ")
-        parser.add_argument('-t', "--target", action='store', metavar='TARGET', help="Override target.")
-        parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='warning', help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels), metavar="LEVEL")
-        parser.add_argument("cmd", nargs='?', default=None, help="Command")
-        parser.add_argument("args", nargs='*', help="Arguments for the command.")
-        parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
-        return parser.parse_args()
-
-    def configure_logging(self):
-        level = LEVELS.get(self.args.debug_level, logging.WARNING)
-        logging.basicConfig(level=level)
-
-    def run(self):
-        try:
-            # Read command-line arguments.
-            self.args = self.get_args()
-            self.cmd = self.args.cmd
-            if self.cmd:
-                self.cmd = self.cmd.lower()
-
-            # Set logging level
-            self.configure_logging()
-            DAPAccess.set_args(self.args.daparg)
-
-            # Check for a valid command.
-            if self.cmd and self.cmd not in self.command_list:
-                print "Error: unrecognized command '%s'" % self.cmd
-                return 1
-
-            # List command must be dealt with specially.
-            if self.cmd == 'list':
-                self.handle_list([])
-                return 0
-
-            if self.args.clock != DEFAULT_CLOCK_FREQ_KHZ:
-                print "Setting SWD clock to %d kHz" % self.args.clock
-
-            # Connect to board.
-            self.board = MbedBoard.chooseBoard(board_id=self.args.board, target_override=self.args.target, init_board=False, frequency=(self.args.clock * 1000))
-            self.board.target.setAutoUnlock(False)
-            self.board.target.setHaltOnConnect(False)
-            try:
-                self.board.init()
-            except Exception as e:
-                print "Exception while initing board: %s" % e
-                traceback.print_exc()
-                self.exitCode = 1
-                return self.exitCode
-
-            self.target = self.board.target
-            self.link = self.board.link
-            self.flash = self.board.flash
-
-            self.svd_device = self.target.svd_device
-            self.peripherals = {}
-            if self.svd_device:
-                for p in self.svd_device.peripherals:
-                    self.peripherals[p.name.lower()] = p
-
-            # Halt if requested.
-            if self.args.halt:
-                self.handle_halt([])
-
-            # Handle a device with flash security enabled.
-            self.didErase = False
-            if self.target.isLocked() and self.cmd != 'unlock':
-                print "Error: Target is locked, cannot complete operation. Use unlock command to mass erase and unlock."
-                if self.cmd and self.cmd not in ['reset', 'info']:
-                    return 1
-
-            # If no command, enter interactive mode.
-            if not self.cmd:
-                # Say what we're connected to.
-                print "Connected to %s [%s]: %s" % (self.target.part_number,
-                    CORE_STATUS_DESC[self.target.getState()], self.board.getUniqueID())
-
-                # Remove list command that disrupts the connection.
-                self.command_list.pop('list')
-                COMMAND_INFO.pop('list')
-
-                # Run the command line.
-                console = PyOCDConsole(self)
-                console.run()
-            else:
-                # Invoke action handler.
-                result = self.command_list[self.cmd](self.args.args)
-                if result is not None:
-                    self.exitCode = result
-
-        except ToolExitException:
-            self.exitCode = 0
-        except ValueError:
-            print "Error: invalid argument"
-        except DAPAccess.TransferError:
-            print "Error: transfer failed"
-            traceback.print_exc()
-            self.exitCode = 2
-        except ToolError as e:
-            print "Error:", e
-            self.exitCode = 1
-        finally:
-            if self.board != None:
-                # Pass false to prevent target resume.
-                self.board.uninit(False)
-
-        return self.exitCode
-
-    def handle_list(self, args):
-        MbedBoard.listConnectedBoards()
-
-    def handle_info(self, args):
-        print "Target:       %s" % self.target.part_number
-        print "Unique ID:    %s" % self.board.getUniqueID()
-        print "DAP IDCODE:   0x%08x" % self.target.readIDCode()
-        print "Cores:        %d" % len(self.target.cores)
-        for i, c in enumerate(self.target.cores):
-            core = self.target.cores[c]
-            print "Core %d type:  %s" % (i, pyOCD.coresight.cortex_m.CORE_TYPE_NAME[core.core_type])
-
-    def handle_status(self, args):
-        if self.target.isLocked():
-            print "Security:       Locked"
-        else:
-            print "Security:       Unlocked"
-        if isinstance(self.target, pyOCD.target.target_kinetis.Kinetis):
-            print "MDM-AP Control: 0x%08x" % self.target.mdm_ap.read_reg(target_kinetis.MDM_CTRL)
-            print "MDM-AP Status:  0x%08x" % self.target.mdm_ap.read_reg(target_kinetis.MDM_STATUS)
-        for i, c in enumerate(self.target.cores):
-            core = self.target.cores[c]
-            print "Core %d status:  %s" % (i, CORE_STATUS_DESC[core.getState()])
-
-    def handle_reg(self, args):
-        # If there are no args, print all register values.
-        if len(args) < 1:
-            self.dump_registers()
-            return
-
-        if len(args) == 2 and args[0].lower() == '-f':
-            del args[0]
-            show_fields = True
-        else:
-            show_fields = False
-
-        reg = args[0].lower()
-        if reg in pyOCD.coresight.cortex_m.CORE_REGISTER:
-            value = self.target.readCoreRegister(reg)
-            if type(value) is int:
-                print "%s = 0x%08x (%d)" % (reg, value, value)
-            elif type(value) is float:
-                print "%s = %g" % (reg, value)
-            else:
-                raise ToolError("Unknown register value type")
-        else:
-            subargs = reg.split('.')
-            if self.peripherals.has_key(subargs[0]):
-                p = self.peripherals[subargs[0]]
-                if len(subargs) > 1:
-                    r = [x for x in p.registers if x.name.lower() == subargs[1]]
-                    if len(r):
-                        self._dump_peripheral_register(p, r[0], True)
-                    else:
-                        raise ToolError("invalid register '%s' for %s" % (subargs[1], p.name))
-                else:
-                    for r in p.registers:
-                        self._dump_peripheral_register(p, r, show_fields)
-            else:
-                raise ToolError("invalid peripheral '%s'" % (subargs[0]))
-
-    def handle_write_reg(self, args):
-        if len(args) < 1:
-            raise ToolError("No register specified")
-        if len(args) < 2:
-            raise ToolError("No value specified")
-
-        reg = args[0].lower()
-        if reg.startswith('s'):
-            value = float(args[1])
-        else:
-            value = self.convert_value(args[1])
-        self.target.writeCoreRegister(reg, value)
-
-    @cmdoptions([make_option('-h', "--halt", action="store_true")])
-    def handle_reset(self, args, other):
-        print "Resetting target"
-        if args.halt:
-            self.target.resetStopOnReset()
-
-            status = self.target.getState()
-            if status != Target.TARGET_HALTED:
-                print "Failed to halt device on reset"
-            else:
-                print "Successfully halted device on reset"
-        else:
-            self.target.reset()
-
-    @cmdoptions([make_option('-c', "--center", action="store_true")])
-    def handle_disasm(self, args, other):
-        if len(other) == 0:
-            print "Error: no address specified"
-            return 1
-        addr = self.convert_value(other[0])
-        if len(other) < 2:
-            count = 6
-        else:
-            count = self.convert_value(other[1])
-
-        if args.center:
-            addr -= count // 2
-
-        # Since we're disassembling, make sure the Thumb bit is cleared.
-        addr &= ~1
-
-        # Print disasm of data.
-        data = self.target.readBlockMemoryUnaligned8(addr, count)
-        self.print_disasm(str(bytearray(data)), addr)
-
-    def handle_read8(self, args):
-        return self.do_read(args, 8)
-
-    def handle_read16(self, args):
-        return self.do_read(args, 16)
-
-    def handle_read32(self, args):
-        return self.do_read(args, 32)
-
-    def handle_write8(self, args):
-        return self.do_write(args, 8)
-
-    def handle_write16(self, args):
-        return self.do_write(args, 16)
-
-    def handle_write32(self, args):
-        return self.do_write(args, 32)
-
-    def do_read(self, args, width):
-        if len(args) == 0:
-            print "Error: no address specified"
-            return 1
-        addr = self.convert_value(args[0])
-        if len(args) < 2:
-            count = 4
-        else:
-            count = self.convert_value(args[1])
-
-        if width == 8:
-            data = self.target.readBlockMemoryUnaligned8(addr, count)
-            byteData = data
-        elif width == 16:
-            byteData = self.target.readBlockMemoryUnaligned8(addr, count)
-            data = pyOCD.utility.conversion.byteListToU16leList(byteData)
-        elif width == 32:
-            byteData = self.target.readBlockMemoryUnaligned8(addr, count)
-            data = pyOCD.utility.conversion.byteListToU32leList(byteData)
-
-        # Print hex dump of output.
-        dumpHexData(data, addr, width=width)
-
-    def do_write(self, args, width):
-        if len(args) == 0:
-            print "Error: no address specified"
-            return 1
-        addr = self.convert_value(args[0])
-        if len(args) <= 1:
-            print "Error: no data for write"
-            return 1
-        else:
-            data = [self.convert_value(d) for d in args[1:]]
-
-        if width == 8:
-            pass
-        elif width == 16:
-            data = pyOCD.utility.conversion.u16leListToByteList(data)
-        elif width == 32:
-            data = pyOCD.utility.conversion.u32leListToByteList(data)
-
-        if self.isFlashWrite(addr, width, data):
-            self.target.flash.init()
-            self.target.flash.programPhrase(addr, data)
-        else:
-            self.target.writeBlockMemoryUnaligned8(addr, data)
-
-    def handle_erase(self, args):
-        if len(args) < 1:
-            raise ToolError("invalid arguments")
-        addr = int(args[0], base=0)
-        if len(args) < 2:
-            count = 1
-        else:
-            count = int(args[1], base=0)
-        self.flash.init()
-        while count:
-            info = self.flash.getPageInfo(addr)
-            self.flash.erasePage(info.base_addr)
-            print "Erased page 0x%08x" % info.base_addr
-            count -= 1
-            addr += info.size
-
-    def handle_unlock(self, args):
-        # Currently the same as erase.
-        if not self.didErase:
-            self.target.massErase()
-
-    def handle_go(self, args):
-        self.target.resume()
-        status = self.target.getState()
-        if status == Target.TARGET_RUNNING:
-            print "Successfully resumed device"
-        else:
-            print "Failed to resume device"
-
-    def handle_step(self, args):
-        self.target.step()
-        print "Successfully stepped device"
-
-    def handle_halt(self, args):
-        self.target.halt()
-
-        status = self.target.getState()
-        if status != Target.TARGET_HALTED:
-            print "Failed to halt device"
-            return 1
-        else:
-            print "Successfully halted device"
-
-    def handle_memory_map(self, args):
-        self.print_memory_map()
-
-    def handle_log(self, args):
-        if len(args) < 1:
-            print "Error: no log level provided"
-            return 1
-        if args[0].lower() not in LEVELS:
-            print "Error: log level must be one of {%s}" % ','.join(LEVELS.keys())
-            return 1
-        logging.getLogger().setLevel(LEVELS[args[0].lower()])
-
-    def handle_clock(self, args):
-        if len(args) < 1:
-            print "Error: no clock frequency provided"
-            return 1
-        try:
-            freq_Hz = int(args[0]) * 1000
-        except:
-            print "Error: invalid frequency"
-            return 1
-        self.link.set_clock(freq_Hz)
-        if self.link.get_swj_mode() == DAPAccess.PORT.SWD:
-            swd_jtag = 'SWD'
-        else:
-            swd_jtag = 'JTAG'
-
-        if freq_Hz >= 1000000:
-            nice_freq = "%.2f MHz" % (freq_Hz / 1000000)
-        elif freq_Hz > 1000:
-            nice_freq = "%.2f kHz" % (freq_Hz / 1000)
-        else:
-            nice_freq = "%d Hz" % freq_Hz
-
-        print "Changed %s frequency to %s" % (swd_jtag, nice_freq)
-
-    def handle_exit(self, args):
-        raise ToolExitException()
-
-    def handle_python(self, args):
-        try:
-            env = {
-                    'board' : self.board,
-                    'target' : self.target,
-                    'link' : self.link,
-                    'flash' : self.flash,
-                }
-            result = eval(args, globals(), env)
-            if result is not None:
-                if type(result) is int:
-                    print "0x%08x (%d)" % (result, result)
-                else:
-                    print result
-        except Exception as e:
-            print "Exception while executing expression:", e
-            traceback.print_exc()
-
-    def handle_core(self, args):
-        if len(args) < 1:
-            print "Core %d is selected" % self.target.selected_core.core_number
-            return
-        core = int(args[0], base=0)
-        self.target.select_core(core)
-        print "Selected core %d" % core
-
-    def isFlashWrite(self, addr, width, data):
-        mem_map = self.board.target.getMemoryMap()
-        region = mem_map.getRegionForAddress(addr)
-        if (region is None) or (not region.isFlash):
-            return False
-
-        if width == 8:
-            l = len(data)
-        elif width == 16:
-            l = len(data) * 2
-        elif width == 32:
-            l = len(data) * 4
-
-        return region.containsRange(addr, length=l)
-
-    ## @brief Convert an argument to a 32-bit integer.
-    #
-    # Handles the usual decimal, binary, and hex numbers with the appropriate prefix.
-    # Also recognizes register names and address dereferencing. Dereferencing using the
-    # ARM assembler syntax. To dereference, put the value in brackets, i.e. '[r0]' or
-    # '[0x1040]'. You can also use put an offset in the brackets after a comma, such as
-    # '[r3,8]'. The offset can be positive or negative, and any supported base.
-    def convert_value(self, arg):
-        arg = arg.lower().replace('_', '')
-        deref = (arg[0] == '[')
-        if deref:
-            arg = arg[1:-1]
-            offset = 0
-            if ',' in arg:
-                arg, offset = arg.split(',')
-                arg = arg.strip()
-                offset = int(offset.strip(), base=0)
-
-        if arg in pyOCD.coresight.cortex_m.CORE_REGISTER:
-            value = self.target.readCoreRegister(arg)
-            print "%s = 0x%08x" % (arg, value)
-        else:
-            subargs = arg.split('.')
-            if self.peripherals.has_key(subargs[0]) and len(subargs) > 1:
-                p = self.peripherals[subargs[0]]
-                r = [x for x in p.registers if x.name.lower() == subargs[1]]
-                if len(r):
-                    value = p.base_address + r[0].address_offset
-                else:
-                    raise ToolError("invalid register '%s' for %s" % (subargs[1], p.name))
-            else:
-                value = int(arg, base=0)
-
-        if deref:
-            value = pyOCD.utility.conversion.byteListToU32leList(self.target.readBlockMemoryUnaligned8(value + offset, 4))[0]
-            print "[%s,%d] = 0x%08x" % (arg, offset, value)
-
-        return value
-
-    def dump_registers(self):
-        # Registers organized into columns for display.
-        regs = ['r0', 'r6', 'r12',
-                'r1', 'r7', 'sp',
-                'r2', 'r8', 'lr',
-                'r3', 'r9', 'pc',
-                'r4', 'r10', 'xpsr',
-                'r5', 'r11', 'primask']
-
-        for i, reg in enumerate(regs):
-            regValue = self.target.readCoreRegister(reg)
-            print "{:>8} {:#010x} ".format(reg + ':', regValue),
-            if i % 3 == 2:
-                print
-
-    def _dump_peripheral_register(self, periph, reg, show_fields):
-        addr = periph.base_address + reg.address_offset
-        value = self.target.readMemory(addr, reg.size)
-        value_str = hex_width(value, reg.size)
-        print "%s.%s @ %08x = %s" % (periph.name, reg.name, addr, value_str)
-
-        if show_fields:
-            for f in reg.fields:
-                if f.is_reserved:
-                    continue
-                msb = f.bit_offset + f.bit_width - 1
-                lsb = f.bit_offset
-                f_value = mask.bfx(value, msb, lsb)
-                v_enum = None
-                if f.enumerated_values:
-                    for v in f.enumerated_values:
-                        if v.value == f_value:
-                            v_enum = v
-                            break
-                if f.bit_width == 1:
-                    bits_str = "%d" % lsb
-                else:
-                    bits_str = "%d:%d" % (msb, lsb)
-                f_value_str = "%x" % f_value
-                digits = (f.bit_width + 3) / 4
-                f_value_str = "0" * (digits - len(f_value_str)) + f_value_str
-                f_value_bin_str = bin(f_value)[2:]
-                f_value_bin_str = "0" * (f.bit_width - len(f_value_bin_str)) + f_value_bin_str
-                if v_enum:
-                    f_value_enum_str = " %s: %s" % (v.name, v_enum.description)
-                else:
-                    f_value_enum_str = ""
-                print "  %s[%s] = %s (%s)%s" % (f.name, bits_str, f_value_str, f_value_bin_str, f_value_enum_str)
-
-    def print_memory_map(self):
-        print "Region          Start         End           Blocksize"
-        for region in self.target.getMemoryMap():
-            print "{:<15} {:#010x}    {:#010x}    {}".format(region.name, region.start, region.end, region.blocksize if region.isFlash else '-')
-
-    def print_disasm(self, code, startAddr):
-        if not isCapstoneAvailable:
-            print "Warning: Disassembly is not available because the Capstone library is not installed"
-            return
-
-        pc = self.target.readCoreRegister('pc') & ~1
-        md = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_THUMB)
-
-        addrLine = 0
-        text = ''
-        for i in md.disasm(code, startAddr):
-            hexBytes = ''
-            for b in i.bytes:
-                hexBytes += '%02x' % b
-            pc_marker = '*' if (pc == i.address) else ' '
-            text += "{addr:#010x}:{pc_marker} {bytes:<10}{mnemonic:<8}{args}\n".format(addr=i.address, pc_marker=pc_marker, bytes=hexBytes, mnemonic=i.mnemonic, args=i.op_str)
-
-        print text
-
-
-def main():
-    sys.exit(PyOCDTool().run())
-
-
-if __name__ == '__main__':
-    main()
+#!/usr/bin/env python
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import argparse
+import logging
+import os
+import sys
+import optparse
+from optparse import make_option
+import traceback
+
+# Attempt to import readline.
+try:
+    import readline
+except ImportError:
+    pass
+
+import pyOCD
+from pyOCD import __version__
+from pyOCD.board import MbedBoard
+from pyOCD.target.family import target_kinetis
+from pyOCD.pyDAPAccess import DAPAccess
+from pyOCD.core.target import Target
+from pyOCD.utility import mask
+
+# Make disasm optional.
+try:
+    import capstone
+    isCapstoneAvailable = True
+except ImportError:
+    isCapstoneAvailable = False
+
+LEVELS = {
+        'debug':logging.DEBUG,
+        'info':logging.INFO,
+        'warning':logging.WARNING,
+        'error':logging.ERROR,
+        'critical':logging.CRITICAL
+        }
+
+CORE_STATUS_DESC = {
+        Target.TARGET_HALTED : "Halted",
+        Target.TARGET_RUNNING : "Running",
+        Target.TARGET_RESET : "Reset",
+        Target.TARGET_SLEEPING : "Sleeping",
+        Target.TARGET_LOCKUP : "Lockup",
+        }
+
+VC_NAMES_MAP = {
+        Target.CATCH_HARD_FAULT : "hard fault",
+        Target.CATCH_BUS_FAULT : "bus fault",
+        Target.CATCH_MEM_FAULT : "memory fault",
+        Target.CATCH_INTERRUPT_ERR : "interrupt error",
+        Target.CATCH_STATE_ERR : "state error",
+        Target.CATCH_CHECK_ERR : "check error",
+        Target.CATCH_COPROCESSOR_ERR : "coprocessor error",
+        Target.CATCH_CORE_RESET : "core reset",
+        }
+
+DP_REGS_MAP = {
+        0x0 : DAPAccess.REG.DP_0x0,
+        0x4 : DAPAccess.REG.DP_0x4,
+        0x8 : DAPAccess.REG.DP_0x8,
+        0xc : DAPAccess.REG.DP_0xC
+        }
+
+## Default SWD clock in kHz.
+DEFAULT_CLOCK_FREQ_KHZ = 1000
+
+## Command info and help.
+COMMAND_INFO = {
+        'list' : {
+            'aliases' : [],
+            'args' : "",
+            'help' : "Show available targets"
+            },
+        'erase' : {
+            'aliases' : [],
+            'args' : "ADDR [COUNT]",
+            'help' : "Erase internal flash sectors"
+            },
+        'unlock' :  {
+            'aliases' : [],
+            'args' : "",
+            'help' : "Unlock security on the target"
+            },
+        'status' : {
+            'aliases' : ['stat'],
+            'args' : "",
+            'help' : "Show the target's current state"
+            },
+        'reg' : {
+            'aliases' : [],
+            'args' : "[-f] [REG]",
+            'help' : "Print all or one register"
+            },
+        'wreg' : {
+            'aliases' : [],
+            'args' : "REG VALUE",
+            'help' : "Set the value of a register"
+            },
+        'reset' : {
+            'aliases' : [],
+            'args' : "[-h/--halt]",
+            'help' : "Reset the target"
+            },
+        'savemem' : {
+            'aliases' : [],
+            'args' : "ADDR LEN FILENAME",
+            "help" : "Save a range of memory to a binary file"
+            },
+        'loadmem' : {
+            'aliases' : [],
+            'args' : "ADDR FILENAME",
+            "help" : "Load a binary file to an address in memory"
+            },
+        'read8' : {
+            'aliases' : ['read', 'r', 'rb'],
+            'args' : "ADDR [LEN]",
+            'help' : "Read 8-bit bytes"
+            },
+        'read16' : {
+            'aliases' : ['r16', 'rh'],
+            'args' : "ADDR [LEN]",
+            'help' : "Read 16-bit halfwords"
+            },
+        'read32' : {
+            'aliases' : ['r32', 'rw'],
+            'args' : "ADDR [LEN]",
+            'help' : "Read 32-bit words"
+            },
+        'write8' : {
+            'aliases' : ['write', 'w', 'wb'],
+            'args' : "ADDR DATA...",
+            'help' : "Write 8-bit bytes"
+            },
+        'write16' : {
+            'aliases' : ['w16', 'wh'],
+            'args' : "ADDR DATA...",
+            'help' : "Write 16-bit halfwords"
+            },
+        'write32' : {
+            'aliases' : ['w32', 'ww'],
+            'args' : "ADDR DATA...",
+            'help' : "Write 32-bit words"
+            },
+        'go' : {
+            'aliases' : ['g'],
+            'args' : "",
+            'help' : "Resume execution of the target"
+            },
+        'step' : {
+            'aliases' : ['s'],
+            'args' : "",
+            'help' : "Step one instruction"
+            },
+        'halt' : {
+            'aliases' : ['h'],
+            'args' : "",
+            'help' : "Halt the target"
+            },
+        'break' : {
+            'aliases' : [],
+            'args' : "ADDR",
+            'help' : "Set a breakpoint address"
+            },
+        'rmbreak' : {
+            'aliases' : [],
+            'args' : "ADDR",
+            'help' : "Remove a breakpoint"
+            },
+        'lsbreak' : {
+            'aliases' : [],
+            'args' : "",
+            'help' : "List breakpoints"
+            },
+        'help' : {
+            'aliases' : ['?'],
+            'args' : "[CMD]",
+            'help' : "Show help for commands"
+            },
+        'disasm' : {
+            'aliases' : ['d'],
+            'args' : "[-c/--center] ADDR [LEN]",
+            'help' : "Disassemble instructions at an address",
+            'extra_help' : "Only available if the capstone library is installed."
+            },
+        'exit' : {
+            'aliases' : ['quit'],
+            'args' : "",
+            'help' : "Quit pyocd-tool"
+            },
+        'core' : {
+            'aliases' : [],
+            'args' : "[NUM]",
+            'help' : "Select CPU core by number or print selected core"
+            },
+        'readdp' : {
+            'aliases' : ['rdp'],
+            'args' : "ADDR",
+            'help' : "Read DP register"
+            },
+        'writedp' : {
+            'aliases' : ['wdp'],
+            'args' : "ADDR DATA",
+            'help' : "Read DP register"
+            },
+        'readap' : {
+            'aliases' : ['rap'],
+            'args' : "[APSEL] ADDR",
+            'help' : "Read AP register"
+            },
+        'writeap' : {
+            'aliases' : ['wap'],
+            'args' : "[APSEL] ADDR DATA",
+            'help' : "Read AP register"
+            },
+        'reinit' : {
+            'aliases' : [],
+            'args' : "",
+            'help' : "Reinitialize the target object"
+            },
+        'show' : {
+            'aliases' : [],
+            'args' : "INFO",
+            'help' : "Report info about the target",
+            },
+        'set' : {
+            'aliases' : [],
+            'args' : "NAME VALUE",
+            'help' : "Set an option value",
+            'extra_help' : "Available info names: vc, vectorcatch.",
+            },
+        }
+
+INFO_HELP = {
+        'map' : {
+            'aliases' : [],
+            'help' : "Target memory map.",
+            },
+        'peripherals' : {
+            'aliases' : [],
+            'help' : "List of target peripheral instances.",
+            },
+        'uid' : {
+            'aliases' : [],
+            'help' : "Target's unique ID",
+            },
+        'cores' : {
+            'aliases' : [],
+            'help' : "Information about CPU cores in the target.",
+            },
+        'target' : {
+            'aliases' : [],
+            'help' : "General target information.",
+            },
+        }
+
+OPTION_HELP = {
+        'vector-catch' : {
+            'aliases' : ['vc'],
+            'help' : "Control enabled vector catch sources. Value is a concatenation of one letter per enabled source in any order, or 'all' or 'none'. (h=hard fault, b=bus fault, m=mem fault, i=irq err, s=state err, c=check err, p=nocp, r=reset, a=all, n=none).",
+            },
+        'step-into-interrupt' : {
+            'aliases' : ['si'],
+            'help' : "Set whether to enable or disable interrupts when single stepping. Set to 1 to enable."
+            },
+        'nreset' : {
+            'aliases' : [],
+            'help' : "Set nRESET signal state. Accepts a value of 0 or 1."
+            },
+        'log' : {
+            'aliases' : [],
+            'help' : "Set log level to one of debug, info, warning, error, critical"
+            },
+        'clock' : {
+            'aliases' : [],
+            'help' : "Set SWD or JTAG clock frequency"
+            },
+        }
+
+def hex_width(value, width):
+    if width == 8:
+        return "%02x" % value
+    elif width == 16:
+        return "%04x" % value
+    elif width == 32:
+        return "%08x" % value
+    else:
+        raise ToolError("unrecognized register width (%d)" % reg.size)
+
+def dumpHexData(data, startAddress=0, width=8):
+    i = 0
+    while i < len(data):
+        print "%08x: " % (startAddress + i),
+
+        while i < len(data):
+            d = data[i]
+            i += 1
+            if width == 8:
+                print "%02x" % d,
+                if i % 4 == 0:
+                    print "",
+                if i % 16 == 0:
+                    break
+            elif width == 16:
+                print "%04x" % d,
+                if i % 8 == 0:
+                    break
+            elif width == 32:
+                print "%08x" % d,
+                if i % 4 == 0:
+                    break
+        print
+
+class ToolError(Exception):
+    pass
+
+class ToolExitException(Exception):
+    pass
+
+def cmdoptions(opts):
+    def process_opts(fn):
+        parser = optparse.OptionParser(add_help_option=False)
+        for opt in opts:
+            parser.add_option(opt)
+        def foo(inst, args):
+            namespace, other_args = parser.parse_args(args)
+            return fn(inst, namespace, other_args)
+        return foo
+    return process_opts
+
+class PyOCDConsole(object):
+    PROMPT = '>>> '
+
+    def __init__(self, tool):
+        self.tool = tool
+        self.last_command = ''
+
+    def run(self):
+        try:
+            while True:
+                try:
+                    line = raw_input(self.PROMPT)
+                    line = line.strip()
+                    if line:
+                        self.process_command_line(line)
+                        self.last_command = line
+                    elif self.last_command:
+                        self.process_command(self.last_command)
+                except KeyboardInterrupt:
+                    print
+        except EOFError:
+            # Print a newline when we get a Ctrl-D on a Posix system.
+            # Windows exits with a Ctrl-Z+Return, so there is no need for this.
+            if os.name != "nt":
+                print
+
+    def process_command_line(self, line):
+        for cmd in line.split(';'):
+            self.process_command(cmd)
+
+    def process_command(self, cmd):
+        try:
+            firstChar = (cmd.strip())[0]
+            if firstChar in '$!':
+                cmd = cmd[1:].strip()
+                if firstChar == '$':
+                    self.tool.handle_python(cmd)
+                elif firstChar == '!':
+                    os.system(cmd)
+                return
+
+            args = pyOCD.utility.cmdline.split_command_line(cmd)
+            cmd = args[0].lower()
+            args = args[1:]
+
+            # Handle register name as command.
+            if cmd in pyOCD.coresight.cortex_m.CORE_REGISTER:
+                self.tool.handle_reg([cmd])
+                return
+
+            # Check for valid command.
+            if cmd not in self.tool.command_list:
+                print "Error: unrecognized command '%s'" % cmd
+                return
+
+            # Run command.
+            handler = self.tool.command_list[cmd]
+            handler(args)
+        except ValueError:
+            print "Error: invalid argument"
+            traceback.print_exc()
+        except DAPAccess.TransferError as e:
+            print "Error:", e
+            traceback.print_exc()
+        except ToolError as e:
+            print "Error:", e
+        except ToolExitException:
+            raise
+        except Exception as e:
+            print "Unexpected exception:", e
+            traceback.print_exc()
+
+class PyOCDTool(object):
+    def __init__(self):
+        self.board = None
+        self.exitCode = 0
+        self.step_into_interrupt = False
+        self.command_list = {
+                'list' :    self.handle_list,
+                'erase' :   self.handle_erase,
+                'unlock' :  self.handle_unlock,
+                'status' :  self.handle_status,
+                'stat' :    self.handle_status,
+                'reg' :     self.handle_reg,
+                'wreg' :    self.handle_write_reg,
+                'reset' :   self.handle_reset,
+                'savemem' : self.handle_savemem,
+                'loadmem' : self.handle_loadmem,
+                'read' :    self.handle_read8,
+                'read8' :   self.handle_read8,
+                'read16' :  self.handle_read16,
+                'read32' :  self.handle_read32,
+                'r' :       self.handle_read8,
+                'rb' :      self.handle_read8,
+                'r16' :     self.handle_read16,
+                'rh' :      self.handle_read16,
+                'r32' :     self.handle_read32,
+                'rw' :      self.handle_read32,
+                'write' :   self.handle_write8,
+                'write8' :  self.handle_write8,
+                'write16' : self.handle_write16,
+                'write32' : self.handle_write32,
+                'w' :       self.handle_write8,
+                'wb' :      self.handle_write8,
+                'w16' :     self.handle_write16,
+                'wh' :      self.handle_write16,
+                'w32' :     self.handle_write32,
+                'ww' :      self.handle_write32,
+                'go' :      self.handle_go,
+                'g' :       self.handle_go,
+                'step' :    self.handle_step,
+                's' :       self.handle_step,
+                'halt' :    self.handle_halt,
+                'h' :       self.handle_halt,
+                'break' :   self.handle_breakpoint,
+                'rmbreak' : self.handle_remove_breakpoint,
+                'lsbreak' : self.handle_list_breakpoints,
+                'disasm' :  self.handle_disasm,
+                'd' :       self.handle_disasm,
+                'exit' :    self.handle_exit,
+                'quit' :    self.handle_exit,
+                'core' :    self.handle_core,
+                'readdp' :  self.handle_readdp,
+                'writedp' : self.handle_writedp,
+                'readap' :  self.handle_readap,
+                'writeap' : self.handle_writeap,
+                'rdp' :     self.handle_readdp,
+                'wdp' :     self.handle_writedp,
+                'rap' :     self.handle_readap,
+                'wap' :     self.handle_writeap,
+                'reinit' :  self.handle_reinit,
+                'show' :    self.handle_show,
+                'set' :     self.handle_set,
+                'help' :    self.handle_help,
+                '?' :       self.handle_help,
+            }
+        self.info_list = {
+                'map' :         self.handle_show_map,
+                'peripherals' : self.handle_show_peripherals,
+                'uid' :         self.handle_show_unique_id,
+                'cores' :       self.handle_show_cores,
+                'target' :      self.handle_show_target,
+            }
+        self.option_list = {
+                'vector-catch' :        self.handle_set_vectorcatch,
+                'vc' :                  self.handle_set_vectorcatch,
+                'step-into-interrupt' : self.handle_set_step_interrupts,
+                'si' :                  self.handle_set_step_interrupts,
+                'nreset' :              self.handle_set_nreset,
+                'log' :                 self.handle_set_log,
+                'clock' :               self.handle_set_clock,
+            }
+
+    def get_args(self):
+        debug_levels = LEVELS.keys()
+
+        epi = "Available commands:\n" + ', '.join(sorted(self.command_list.keys()))
+
+        parser = argparse.ArgumentParser(description='Target inspection utility', epilog=epi)
+        parser.add_argument('--version', action='version', version=__version__)
+        parser.add_argument("-H", "--halt", action="store_true", help="Halt core upon connect.")
+        parser.add_argument("-N", "--no-init", action="store_true", help="Do not init debug system.")
+        parser.add_argument('-k', "--clock", metavar='KHZ', default=DEFAULT_CLOCK_FREQ_KHZ, type=int, help="Set SWD speed in kHz. (Default 1 MHz.)")
+        parser.add_argument('-b', "--board", action='store', metavar='ID', help="Use the specified board. ")
+        parser.add_argument('-t', "--target", action='store', metavar='TARGET', help="Override target.")
+        parser.add_argument("-d", "--debug", dest="debug_level", choices=debug_levels, default='warning', help="Set the level of system logging output. Supported choices are: " + ", ".join(debug_levels), metavar="LEVEL")
+        parser.add_argument("cmd", nargs='?', default=None, help="Command")
+        parser.add_argument("args", nargs='*', help="Arguments for the command.")
+        parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
+        return parser.parse_args()
+
+    def configure_logging(self):
+        level = LEVELS.get(self.args.debug_level, logging.WARNING)
+        logging.basicConfig(level=level)
+
+    def run(self):
+        try:
+            # Read command-line arguments.
+            self.args = self.get_args()
+            self.cmd = self.args.cmd
+            if self.cmd:
+                self.cmd = self.cmd.lower()
+
+            # Set logging level
+            self.configure_logging()
+            DAPAccess.set_args(self.args.daparg)
+
+            # Check for a valid command.
+            if self.cmd and self.cmd not in self.command_list:
+                print "Error: unrecognized command '%s'" % self.cmd
+                return 1
+
+            # Handle certain commands without connecting.
+            if self.cmd == 'list':
+                self.handle_list([])
+                return 0
+            elif self.cmd == 'help':
+                self.handle_help(self.args.args)
+                return 0
+
+            if self.args.clock != DEFAULT_CLOCK_FREQ_KHZ:
+                print "Setting SWD clock to %d kHz" % self.args.clock
+
+            # Connect to board.
+            self.board = MbedBoard.chooseBoard(board_id=self.args.board, target_override=self.args.target, init_board=False, frequency=(self.args.clock * 1000))
+            self.board.target.setAutoUnlock(False)
+            self.board.target.setHaltOnConnect(False)
+            try:
+                if not self.args.no_init:
+                    self.board.init()
+            except DAPAccess.TransferFaultError as e:
+                if not self.board.target.isLocked():
+                    print "Transfer fault while initing board: %s" % e
+                    traceback.print_exc()
+                    self.exitCode = 1
+                    return self.exitCode
+            except Exception as e:
+                print "Exception while initing board: %s" % e
+                traceback.print_exc()
+                self.exitCode = 1
+                return self.exitCode
+
+            self.target = self.board.target
+            self.link = self.board.link
+            self.flash = self.board.flash
+
+            self.svd_device = self.target.svd_device
+            self.peripherals = {}
+            if self.svd_device:
+                for p in self.svd_device.peripherals:
+                    self.peripherals[p.name.lower()] = p
+
+            # Halt if requested.
+            if self.args.halt:
+                self.handle_halt([])
+
+            # Handle a device with flash security enabled.
+            self.didErase = False
+            if not self.args.no_init and self.target.isLocked() and self.cmd != 'unlock':
+                print "Warning: Target is locked, limited operations available. Use unlock command to mass erase and unlock."
+
+            # If no command, enter interactive mode.
+            if not self.cmd:
+                if not self.args.no_init:
+                    try:
+                        # Say what we're connected to.
+                        print "Connected to %s [%s]: %s" % (self.target.part_number,
+                            CORE_STATUS_DESC[self.target.getState()], self.board.getUniqueID())
+                    except DAPAccess.TransferFaultError:
+                        pass
+
+                # Run the command line.
+                console = PyOCDConsole(self)
+                console.run()
+            else:
+                # Invoke action handler.
+                result = self.command_list[self.cmd](self.args.args)
+                if result is not None:
+                    self.exitCode = result
+
+        except ToolExitException:
+            self.exitCode = 0
+        except ValueError:
+            print "Error: invalid argument"
+        except DAPAccess.TransferError:
+            print "Error: transfer failed"
+            traceback.print_exc()
+            self.exitCode = 2
+        except ToolError as e:
+            print "Error:", e
+            self.exitCode = 1
+        finally:
+            if self.board != None:
+                # Pass false to prevent target resume.
+                self.board.uninit(False)
+
+        return self.exitCode
+
+    def handle_list(self, args):
+        MbedBoard.listConnectedBoards()
+
+    def handle_status(self, args):
+        if self.target.isLocked():
+            print "Security:       Locked"
+        else:
+            print "Security:       Unlocked"
+        if isinstance(self.target, target_kinetis.Kinetis):
+            print "MDM-AP Status:  0x%08x" % self.target.mdm_ap.read_reg(target_kinetis.MDM_STATUS)
+        if not self.target.isLocked():
+            for i, c in enumerate(self.target.cores):
+                core = self.target.cores[c]
+                print "Core %d status:  %s" % (i, CORE_STATUS_DESC[core.getState()])
+
+    def handle_reg(self, args):
+        # If there are no args, print all register values.
+        if len(args) < 1:
+            self.dump_registers()
+            return
+
+        if len(args) == 2 and args[0].lower() == '-f':
+            del args[0]
+            show_fields = True
+        else:
+            show_fields = False
+
+        reg = args[0].lower()
+        if reg in pyOCD.coresight.cortex_m.CORE_REGISTER:
+            value = self.target.readCoreRegister(reg)
+            if type(value) is int:
+                print "%s = 0x%08x (%d)" % (reg, value, value)
+            elif type(value) is float:
+                print "%s = %g" % (reg, value)
+            else:
+                raise ToolError("Unknown register value type")
+        else:
+            subargs = reg.split('.')
+            if self.peripherals.has_key(subargs[0]):
+                p = self.peripherals[subargs[0]]
+                if len(subargs) > 1:
+                    r = [x for x in p.registers if x.name.lower() == subargs[1]]
+                    if len(r):
+                        self._dump_peripheral_register(p, r[0], True)
+                    else:
+                        raise ToolError("invalid register '%s' for %s" % (subargs[1], p.name))
+                else:
+                    for r in p.registers:
+                        self._dump_peripheral_register(p, r, show_fields)
+            else:
+                raise ToolError("invalid peripheral '%s'" % (subargs[0]))
+
+    def handle_write_reg(self, args):
+        if len(args) < 1:
+            raise ToolError("No register specified")
+        if len(args) < 2:
+            raise ToolError("No value specified")
+
+        reg = args[0].lower()
+        if reg in pyOCD.coresight.cortex_m.CORE_REGISTER:
+            if reg.startswith('s') and reg != 'sp':
+                value = float(args[1])
+            else:
+                value = self.convert_value(args[1])
+            self.target.writeCoreRegister(reg, value)
+        else:
+            value = self.convert_value(args[1])
+            subargs = reg.split('.')
+            if len(subargs) < 2:
+                raise ToolError("no register specified")
+            if self.peripherals.has_key(subargs[0]):
+                p = self.peripherals[subargs[0]]
+                r = [x for x in p.registers if x.name.lower() == subargs[1]]
+                if len(r):
+                    r = r[0]
+                    addr = p.base_address + r.address_offset
+                    if len(subargs) == 2:
+                        print "writing 0x%x to 0x%x:%d (%s)" % (value, addr, r.size, r.name)
+                        self.target.writeMemory(addr, value, r.size)
+                    elif len(subargs) == 3:
+                        f = [x for x in r.fields if x.name.lower() == subargs[2]]
+                        if len(f):
+                            f = f[0]
+                            msb = f.bit_offset + f.bit_width - 1
+                            lsb = f.bit_offset
+                            originalValue = self.target.readMemory(addr, r.size)
+                            value = mask.bfi(originalValue, msb, lsb, value)
+                            print "writing 0x%x to 0x%x[%d:%d]:%d (%s.%s)" % (value, addr, msb, lsb, r.size, r.name, f.name)
+                            self.target.writeMemory(addr, value, r.size)
+                    else:
+                        raise ToolError("too many dots")
+                    self._dump_peripheral_register(p, r, True)
+                else:
+                    raise ToolError("invalid register '%s' for %s" % (subargs[1], p.name))
+            else:
+                raise ToolError("invalid peripheral '%s'" % (subargs[0]))
+
+    @cmdoptions([make_option('-h', "--halt", action="store_true")])
+    def handle_reset(self, args, other):
+        print "Resetting target"
+        if args.halt:
+            self.target.resetStopOnReset()
+
+            status = self.target.getState()
+            if status != Target.TARGET_HALTED:
+                print "Failed to halt device on reset"
+            else:
+                print "Successfully halted device on reset"
+        else:
+            self.target.reset()
+
+    def handle_set_nreset(self, args):
+        if len(args) != 1:
+            print "Missing reset state"
+            return
+        state = int(args[0], base=0)
+        print "nRESET = %d" % (state)
+        self.target.dp.assert_reset((state == 0))
+
+    @cmdoptions([make_option('-c', "--center", action="store_true")])
+    def handle_disasm(self, args, other):
+        if len(other) == 0:
+            print "Error: no address specified"
+            return 1
+        addr = self.convert_value(other[0])
+        if len(other) < 2:
+            count = 6
+        else:
+            count = self.convert_value(other[1])
+
+        if args.center:
+            addr -= count // 2
+
+        # Since we're disassembling, make sure the Thumb bit is cleared.
+        addr &= ~1
+
+        # Print disasm of data.
+        data = self.target.readBlockMemoryUnaligned8(addr, count)
+        self.print_disasm(str(bytearray(data)), addr)
+
+    def handle_read8(self, args):
+        return self.do_read(args, 8)
+
+    def handle_read16(self, args):
+        return self.do_read(args, 16)
+
+    def handle_read32(self, args):
+        return self.do_read(args, 32)
+
+    def handle_write8(self, args):
+        return self.do_write(args, 8)
+
+    def handle_write16(self, args):
+        return self.do_write(args, 16)
+
+    def handle_write32(self, args):
+        return self.do_write(args, 32)
+
+    def handle_savemem(self, args):
+        if len(args) < 3:
+            print "Error: missing argument"
+            return 1
+        addr = self.convert_value(args[0])
+        count = self.convert_value(args[1])
+        filename = args[2]
+
+        data = bytearray(self.target.readBlockMemoryUnaligned8(addr, count))
+
+        with open(filename, 'wb') as f:
+            f.write(data)
+            print "Saved %d bytes to %s" % (count, filename)
+
+    def handle_loadmem(self, args):
+        if len(args) < 2:
+            print "Error: missing argument"
+            return 1
+        addr = self.convert_value(args[0])
+        filename = args[1]
+
+        with open(filename, 'rb') as f:
+            data = bytearray(f.read())
+            self.target.writeBlockMemoryUnaligned8(addr, data)
+            print "Loaded %d bytes to 0x%08x" % (len(data), addr)
+
+    def do_read(self, args, width):
+        if len(args) == 0:
+            print "Error: no address specified"
+            return 1
+        addr = self.convert_value(args[0])
+        if len(args) < 2:
+            count = width // 8
+        else:
+            count = self.convert_value(args[1])
+
+        if width == 8:
+            data = self.target.readBlockMemoryUnaligned8(addr, count)
+            byteData = data
+        elif width == 16:
+            byteData = self.target.readBlockMemoryUnaligned8(addr, count)
+            data = pyOCD.utility.conversion.byteListToU16leList(byteData)
+        elif width == 32:
+            byteData = self.target.readBlockMemoryUnaligned8(addr, count)
+            data = pyOCD.utility.conversion.byteListToU32leList(byteData)
+
+        # Print hex dump of output.
+        dumpHexData(data, addr, width=width)
+
+    def do_write(self, args, width):
+        if len(args) == 0:
+            print "Error: no address specified"
+            return 1
+        addr = self.convert_value(args[0])
+        if len(args) <= 1:
+            print "Error: no data for write"
+            return 1
+        else:
+            data = [self.convert_value(d) for d in args[1:]]
+
+        if width == 8:
+            pass
+        elif width == 16:
+            data = pyOCD.utility.conversion.u16leListToByteList(data)
+        elif width == 32:
+            data = pyOCD.utility.conversion.u32leListToByteList(data)
+
+        if self.isFlashWrite(addr, width, data):
+            self.target.flash.init()
+            self.target.flash.programPhrase(addr, data)
+        else:
+            self.target.writeBlockMemoryUnaligned8(addr, data)
+            self.target.flush()
+
+    def handle_erase(self, args):
+        if len(args) < 1:
+            raise ToolError("invalid arguments")
+        addr = self.convert_value(args[0])
+        if len(args) < 2:
+            count = 1
+        else:
+            count = self.convert_value(args[1])
+        self.flash.init()
+        while count:
+            info = self.flash.getPageInfo(addr)
+            self.flash.erasePage(info.base_addr)
+            print "Erased page 0x%08x" % info.base_addr
+            count -= 1
+            addr += info.size
+
+    def handle_unlock(self, args):
+        # Currently the same as erase.
+        if not self.didErase:
+            self.target.massErase()
+
+    def handle_go(self, args):
+        self.target.resume()
+        status = self.target.getState()
+        if status == Target.TARGET_RUNNING:
+            print "Successfully resumed device"
+        else:
+            print "Failed to resume device"
+
+    def handle_step(self, args):
+        self.target.step(disable_interrupts=not self.step_into_interrupt)
+        addr = self.target.readCoreRegister('pc')
+        if isCapstoneAvailable:
+            addr &= ~1
+            data = self.target.readBlockMemoryUnaligned8(addr, 4)
+            self.print_disasm(str(bytearray(data)), addr, maxInstructions=1)
+        else:
+            print "PC = 0x%08x" % (addr)
+
+    def handle_halt(self, args):
+        self.target.halt()
+
+        status = self.target.getState()
+        if status != Target.TARGET_HALTED:
+            print "Failed to halt device"
+            return 1
+        else:
+            print "Successfully halted device"
+
+    def handle_breakpoint(self, args):
+        if len(args) < 1:
+            raise ToolError("no breakpoint address provided")
+        addr = self.convert_value(args[0])
+        if self.target.setBreakpoint(addr):
+            self.target.selected_core.bp_manager.flush()
+            print "Set breakpoint at 0x%08x" % addr
+        else:
+            print "Failed to set breakpoint at 0x%08x" % addr
+
+    def handle_remove_breakpoint(self, args):
+        if len(args) < 1:
+            raise ToolError("no breakpoint address provided")
+        addr = self.convert_value(args[0])
+        try:
+            type = self.target.getBreakpointType(addr)
+            self.target.removeBreakpoint(addr)
+            self.target.selected_core.bp_manager.flush()
+            print "Removed breakpoint at 0x%08x" % addr
+        except:
+            print "Failed to remove breakpoint at 0x%08x" % addr
+
+    def handle_list_breakpoints(self, args):
+        availableBpCount = self.target.selected_core.availableBreakpoint()
+        print "%d hardware breakpoints available" % availableBpCount
+        bps = self.target.selected_core.bp_manager.get_breakpoints()
+        if not len(bps):
+            print "No breakpoints installed"
+        else:
+            for i, addr in enumerate(bps):
+                print "%d: 0x%08x" % (i, addr)
+
+    def handle_set_log(self, args):
+        if len(args) < 1:
+            print "Error: no log level provided"
+            return 1
+        if args[0].lower() not in LEVELS:
+            print "Error: log level must be one of {%s}" % ','.join(LEVELS.keys())
+            return 1
+        logging.getLogger().setLevel(LEVELS[args[0].lower()])
+
+    def handle_set_clock(self, args):
+        if len(args) < 1:
+            print "Error: no clock frequency provided"
+            return 1
+        try:
+            freq_Hz = self.convert_value(args[0]) * 1000
+        except:
+            print "Error: invalid frequency"
+            return 1
+        self.link.set_clock(freq_Hz)
+        if self.link.get_swj_mode() == DAPAccess.PORT.SWD:
+            swd_jtag = 'SWD'
+        else:
+            swd_jtag = 'JTAG'
+
+        if freq_Hz >= 1000000:
+            nice_freq = "%.2f MHz" % (freq_Hz / 1000000)
+        elif freq_Hz > 1000:
+            nice_freq = "%.2f kHz" % (freq_Hz / 1000)
+        else:
+            nice_freq = "%d Hz" % freq_Hz
+
+        print "Changed %s frequency to %s" % (swd_jtag, nice_freq)
+
+    def handle_exit(self, args):
+        raise ToolExitException()
+
+    def handle_python(self, args):
+        try:
+            env = {
+                    'board' : self.board,
+                    'target' : self.target,
+                    'link' : self.link,
+                    'flash' : self.flash,
+                }
+            result = eval(args, globals(), env)
+            if result is not None:
+                if type(result) is int:
+                    print "0x%08x (%d)" % (result, result)
+                else:
+                    print result
+        except Exception as e:
+            print "Exception while executing expression:", e
+            traceback.print_exc()
+
+    def handle_core(self, args):
+        if len(args) < 1:
+            print "Core %d is selected" % self.target.selected_core.core_number
+            return
+        core = int(args[0], base=0)
+        self.target.select_core(core)
+        print "Selected core %d" % core
+
+    def handle_readdp(self, args):
+        if len(args) < 1:
+            print "Missing DP address"
+            return
+        addr_int = self.convert_value(args[0])
+        addr = DP_REGS_MAP[addr_int]
+        result = self.target.dp.read_reg(addr)
+        print "DP register 0x%x = 0x%08x" % (addr_int, result)
+
+    def handle_writedp(self, args):
+        if len(args) < 1:
+            print "Missing DP address"
+            return
+        if len(args) < 2:
+            print "Missing value"
+            return
+        addr_int = self.convert_value(args[0])
+        addr = DP_REGS_MAP[addr_int]
+        data = self.convert_value(args[1])
+        self.target.dp.write_reg(addr, data)
+
+    def handle_readap(self, args):
+        if len(args) < 1:
+            print "Missing AP address"
+            return
+        if len(args) == 1:
+            addr = self.convert_value(args[0])
+        elif len(args) == 2:
+            addr = (self.convert_value(args[0]) << 24) | self.convert_value(args[1])
+        result = self.target.dp.readAP(addr)
+        print "AP register 0x%x = 0x%08x" % (addr, result)
+
+    def handle_writeap(self, args):
+        if len(args) < 1:
+            print "Missing AP address"
+            return
+        if len(args) < 2:
+            print "Missing value"
+            return
+        if len(args) == 2:
+            addr = self.convert_value(args[0])
+            data_arg = 1
+        elif len(args) == 3:
+            addr = (self.convert_value(args[0]) << 24) | self.convert_value(args[1])
+            data_arg = 2
+        data = self.convert_value(args[data_arg])
+        self.target.dp.writeAP(addr, data)
+
+    def handle_reinit(self, args):
+        self.target.init()
+
+    def handle_show(self, args):
+        if len(args) < 1:
+            raise ToolError("missing info name argument")
+        infoName = args[0]
+        try:
+            self.info_list[infoName](args[1:])
+        except KeyError:
+            raise ToolError("unkown info name '%s'" % infoName)
+
+    def handle_show_unique_id(self, args):
+        print "Unique ID:    %s" % self.board.getUniqueID()
+
+    def handle_show_target(self, args):
+        print "Target:       %s" % self.target.part_number
+        print "DAP IDCODE:   0x%08x" % self.target.readIDCode()
+
+    def handle_show_cores(self, args):
+        if self.target.isLocked():
+            print "Target is locked"
+        else:
+            print "Cores:        %d" % len(self.target.cores)
+            for i, c in enumerate(self.target.cores):
+                core = self.target.cores[c]
+                print "Core %d type:  %s" % (i, pyOCD.coresight.cortex_m.CORE_TYPE_NAME[core.core_type])
+
+    def handle_show_map(self, args):
+        print "Region          Start         End                 Size    Blocksize"
+        for region in self.target.getMemoryMap():
+            print "{:<15} {:#010x}    {:#010x}    {:#10x}    {}".format(region.name, region.start, region.end, region.length, region.blocksize if region.isFlash else '-')
+
+    def handle_show_peripherals(self, args):
+        for periph in sorted(self.peripherals.values(), key=lambda x:x.base_address):
+            print "0x%08x: %s" % (periph.base_address, periph.name)
+
+    def handle_set(self, args):
+        if len(args) < 1:
+            raise ToolError("missing option name argument")
+        name = args[0]
+        try:
+            self.option_list[name](args[1:])
+        except KeyError:
+            raise ToolError("unkown option name '%s'" % name)
+
+    def handle_set_vectorcatch(self, args):
+        if len(args) == 0:
+            catch = self.target.getVectorCatch()
+
+            print "Vector catch:"
+            for mask in sorted(VC_NAMES_MAP.iterkeys()):
+                name = VC_NAMES_MAP[mask]
+                s = "ON" if (catch & mask) else "OFF"
+                print "  {:3} {}".format(s, name)
+        else:
+            try:
+                self.target.setVectorCatch(pyOCD.utility.cmdline.convert_vector_catch(args[0]))
+            except ValueError as e:
+                print e
+
+    def handle_set_step_interrupts(self, args):
+        if len(args) == 0:
+            print "Interrupts while stepping:", ("enabled" if self.step_into_interrupt else "disabled")
+        else:
+            self.step_into_interrupt = (args[0] in ('1', 'true', 'yes', 'on'))
+
+    def handle_help(self, args):
+        if not args:
+            self.list_commands()
+        else:
+            cmd = args[0]
+            for name, info in COMMAND_INFO.iteritems():
+                if cmd == name or cmd in info['aliases']:
+                    print "Usage: {cmd} {args}".format(cmd=cmd, args=info['args'])
+                    if len(info['aliases']):
+                        print "Aliases:", ", ".join(info['aliases'])
+                    print info['help']
+                    if info.has_key('extra_help'):
+                        print info['extra_help']
+
+    def list_commands(self):
+        cmds = sorted(COMMAND_INFO.keys())
+        print "Commands:\n---------"
+        for cmd in cmds:
+            info = COMMAND_INFO[cmd]
+            print "{cmd:<25} {args:<20} {help}".format(
+                cmd=', '.join(sorted([cmd] + info['aliases'])),
+                **info)
+
+        print "\nInfo:\n---------"
+        for name in sorted(INFO_HELP.keys()):
+            info = INFO_HELP[name]
+            print "{name:<25} {help}".format(
+                name=', '.join(sorted([name] + info['aliases'])),
+                help=info['help'])
+
+        print "\nOptions:\n---------"
+        for name in sorted(OPTION_HELP.keys()):
+            info = OPTION_HELP[name]
+            print "{name:<25} {help}".format(
+                name=', '.join(sorted([name] + info['aliases'])),
+                help=info['help'])
+
+        print """
+All register names are also available as commands that print the register's value.
+Any ADDR or LEN argument will accept a register name.
+Prefix line with $ to execute a Python expression.
+Prefix line with ! to execute a shell command."""
+
+    def isFlashWrite(self, addr, width, data):
+        mem_map = self.board.target.getMemoryMap()
+        region = mem_map.getRegionForAddress(addr)
+        if (region is None) or (not region.isFlash):
+            return False
+
+        if width == 8:
+            l = len(data)
+        elif width == 16:
+            l = len(data) * 2
+        elif width == 32:
+            l = len(data) * 4
+
+        return region.containsRange(addr, length=l)
+
+    ## @brief Convert an argument to a 32-bit integer.
+    #
+    # Handles the usual decimal, binary, and hex numbers with the appropriate prefix.
+    # Also recognizes register names and address dereferencing. Dereferencing using the
+    # ARM assembler syntax. To dereference, put the value in brackets, i.e. '[r0]' or
+    # '[0x1040]'. You can also use put an offset in the brackets after a comma, such as
+    # '[r3,8]'. The offset can be positive or negative, and any supported base.
+    def convert_value(self, arg):
+        arg = arg.lower().replace('_', '')
+        deref = (arg[0] == '[')
+        if deref:
+            arg = arg[1:-1]
+            offset = 0
+            if ',' in arg:
+                arg, offset = arg.split(',')
+                arg = arg.strip()
+                offset = int(offset.strip(), base=0)
+
+        if arg in pyOCD.coresight.cortex_m.CORE_REGISTER:
+            value = self.target.readCoreRegister(arg)
+            print "%s = 0x%08x" % (arg, value)
+        else:
+            subargs = arg.split('.')
+            if self.peripherals.has_key(subargs[0]) and len(subargs) > 1:
+                p = self.peripherals[subargs[0]]
+                r = [x for x in p.registers if x.name.lower() == subargs[1]]
+                if len(r):
+                    value = p.base_address + r[0].address_offset
+                else:
+                    raise ToolError("invalid register '%s' for %s" % (subargs[1], p.name))
+            else:
+                value = int(arg, base=0)
+
+        if deref:
+            value = pyOCD.utility.conversion.byteListToU32leList(self.target.readBlockMemoryUnaligned8(value + offset, 4))[0]
+            print "[%s,%d] = 0x%08x" % (arg, offset, value)
+
+        return value
+
+    def dump_registers(self):
+        # Registers organized into columns for display.
+        regs = ['r0', 'r6', 'r12',
+                'r1', 'r7', 'sp',
+                'r2', 'r8', 'lr',
+                'r3', 'r9', 'pc',
+                'r4', 'r10', 'xpsr',
+                'r5', 'r11', 'primask']
+
+        for i, reg in enumerate(regs):
+            regValue = self.target.readCoreRegister(reg)
+            print "{:>8} {:#010x} ".format(reg + ':', regValue),
+            if i % 3 == 2:
+                print
+
+    def _dump_peripheral_register(self, periph, reg, show_fields):
+        addr = periph.base_address + reg.address_offset
+        value = self.target.readMemory(addr, reg.size)
+        value_str = hex_width(value, reg.size)
+        print "%s.%s @ %08x = %s" % (periph.name, reg.name, addr, value_str)
+
+        if show_fields:
+            for f in reg.fields:
+                if f.is_reserved:
+                    continue
+                msb = f.bit_offset + f.bit_width - 1
+                lsb = f.bit_offset
+                f_value = mask.bfx(value, msb, lsb)
+                v_enum = None
+                if f.enumerated_values:
+                    for v in f.enumerated_values:
+                        if v.value == f_value:
+                            v_enum = v
+                            break
+                if f.bit_width == 1:
+                    bits_str = "%d" % lsb
+                else:
+                    bits_str = "%d:%d" % (msb, lsb)
+                f_value_str = "%x" % f_value
+                digits = (f.bit_width + 3) / 4
+                f_value_str = "0" * (digits - len(f_value_str)) + f_value_str
+                f_value_bin_str = bin(f_value)[2:]
+                f_value_bin_str = "0" * (f.bit_width - len(f_value_bin_str)) + f_value_bin_str
+                if v_enum:
+                    f_value_enum_str = " %s: %s" % (v.name, v_enum.description)
+                else:
+                    f_value_enum_str = ""
+                print "  %s[%s] = %s (%s)%s" % (f.name, bits_str, f_value_str, f_value_bin_str, f_value_enum_str)
+
+    def print_disasm(self, code, startAddr, maxInstructions=None):
+        if not isCapstoneAvailable:
+            print "Warning: Disassembly is not available because the Capstone library is not installed"
+            return
+
+        pc = self.target.readCoreRegister('pc') & ~1
+        md = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_THUMB)
+
+        addrLine = 0
+        text = ''
+        n = 0
+        for i in md.disasm(code, startAddr):
+            hexBytes = ''
+            for b in i.bytes:
+                hexBytes += '%02x' % b
+            pc_marker = '*' if (pc == i.address) else ' '
+            text += "{addr:#010x}:{pc_marker} {bytes:<10}{mnemonic:<8}{args}\n".format(addr=i.address, pc_marker=pc_marker, bytes=hexBytes, mnemonic=i.mnemonic, args=i.op_str)
+            n += 1
+            if (maxInstructions is not None) and (n >= maxInstructions):
+                break
+
+        print text
+
+
+def main():
+    sys.exit(PyOCDTool().run())
+
+
+if __name__ == '__main__':
+    main()
```

### Comparing `pyOCD-0.8.1a1/pyOCD/tools/__init__.py` & `pyOCD-0.9.0/pyOCD/target/family/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2017 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
```

### Comparing `pyOCD-0.8.1a1/pyOCD/utility/conversion.py` & `pyOCD-0.9.0/pyOCD/utility/conversion.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,102 +1,107 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import struct
-import binascii
-
-
-def byteListToU32leList(data):
-    """Convert a list of bytes to a list of 32-bit integers (little endian)"""
-    res = []
-    for i in range(len(data) / 4):
-        res.append(data[i * 4 + 0] |
-                   data[i * 4 + 1] << 8 |
-                   data[i * 4 + 2] << 16 |
-                   data[i * 4 + 3] << 24)
-    return res
-
-
-def u32leListToByteList(data):
-    """Convert a word array into a byte array"""
-    res = []
-    for x in data:
-        res.append((x >> 0) & 0xff)
-        res.append((x >> 8) & 0xff)
-        res.append((x >> 16) & 0xff)
-        res.append((x >> 24) & 0xff)
-    return res
-
-
-def u16leListToByteList(data):
-    """Convert a halfword array into a byte array"""
-    byteData = []
-    for h in data:
-        byteData.extend([h & 0xff, (h >> 8) & 0xff])
-    return byteData
-
-
-def byteListToU16leList(byteData):
-    """Convert a byte array into a halfword array"""
-    data = []
-    for i in range(0, len(byteData), 2):
-        data.append(byteData[i] | (byteData[i + 1] << 8))
-    return data
-
-
-def u32BEToFloat32BE(data):
-    """Convert a 32-bit int to an IEEE754 float"""
-    d = struct.pack(">I", data)
-    return struct.unpack(">f", d)[0]
-
-
-def float32beToU32be(data):
-    """Convert an IEEE754 float to a 32-bit int"""
-    d = struct.pack(">f", data)
-    return struct.unpack(">I", d)[0]
-
-
-def u32beToHex8le(val):
-    """Create 8-digit hexadecimal string from 32-bit register value"""
-    return ''.join("%02x" % (x & 0xFF) for x in (
-        val,
-        val >> 8,
-        val >> 16,
-        val >> 24,
-    ))
-
-
-def hex8leToU32be(data):
-    """Build 32-bit register value from little-endian 8-digit hexadecimal string"""
-    return int(data[6:8] + data[4:6] + data[2:4] + data[0:2], 16)
-
-
-def byteToHex2(val):
-    """Create 2-digit hexadecimal string from 8-bit value"""
-    return "%02x" % int(val)
-
-
-def hexToByteList(data):
-    """Convert string of hex bytes to list of integers"""
-    return [ord(i) for i in binascii.unhexlify(data)]
-
-
-def hexDecode(cmd):
-    return binascii.unhexlify(cmd)
-
-
-def hexEncode(string):
-    return binascii.hexlify(string)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import struct
+import binascii
+
+
+def byteListToU32leList(data):
+    """Convert a list of bytes to a list of 32-bit integers (little endian)"""
+    res = []
+    for i in range(len(data) // 4):
+        res.append(data[i * 4 + 0] |
+                   data[i * 4 + 1] << 8 |
+                   data[i * 4 + 2] << 16 |
+                   data[i * 4 + 3] << 24)
+    return res
+
+
+def u32leListToByteList(data):
+    """Convert a word array into a byte array"""
+    res = []
+    for x in data:
+        res.append((x >> 0) & 0xff)
+        res.append((x >> 8) & 0xff)
+        res.append((x >> 16) & 0xff)
+        res.append((x >> 24) & 0xff)
+    return res
+
+
+def u16leListToByteList(data):
+    """Convert a halfword array into a byte array"""
+    byteData = []
+    for h in data:
+        byteData.extend([h & 0xff, (h >> 8) & 0xff])
+    return byteData
+
+
+def byteListToU16leList(byteData):
+    """Convert a byte array into a halfword array"""
+    data = []
+    for i in range(0, len(byteData), 2):
+        data.append(byteData[i] | (byteData[i + 1] << 8))
+    return data
+
+
+def u32BEToFloat32BE(data):
+    """Convert a 32-bit int to an IEEE754 float"""
+    d = struct.pack(">I", data)
+    return struct.unpack(">f", d)[0]
+
+
+def float32beToU32be(data):
+    """Convert an IEEE754 float to a 32-bit int"""
+    d = struct.pack(">f", data)
+    return struct.unpack(">I", d)[0]
+
+
+def u32beToHex8le(val):
+    """Create 8-digit hexadecimal string from 32-bit register value"""
+    return ''.join("%02x" % (x & 0xFF) for x in (
+        val,
+        val >> 8,
+        val >> 16,
+        val >> 24,
+    ))
+
+
+def hex8leToU32be(data):
+    """Build 32-bit register value from little-endian 8-digit hexadecimal string"""
+    return int(data[6:8] + data[4:6] + data[2:4] + data[0:2], 16)
+
+
+def hex8leToU32le(data):
+    """Build 32-bit register value from little-endian 8-digit hexadecimal string"""
+    return int(data[0:2] + data[2:4] + data[4:6] + data[6:8], 16)
+
+
+def byteToHex2(val):
+    """Create 2-digit hexadecimal string from 8-bit value"""
+    return "%02x" % int(val)
+
+
+def hexToByteList(data):
+    """Convert string of hex bytes to list of integers"""
+    return [ord(i) for i in binascii.unhexlify(data)]
+
+
+def hexDecode(cmd):
+    return binascii.unhexlify(cmd)
+
+
+def hexEncode(string):
+    return binascii.hexlify(string)
```

### Comparing `pyOCD-0.8.1a1/pyOCD/utility/mask.py` & `pyOCD-0.9.0/pyOCD/utility/mask.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-## @brief Returns a mask with specified bit ranges set.
-#
-# An integer mask is generated based on the bits and bit ranges specified by the
-# arguments. Any number of arguments can be provided. Each argument may be either
-# a 2-tuple of integers, a list of integers, or an individual integer. The result
-# is the combination of masks produced by the arguments.
-#
-# - 2-tuple: The tuple is a bit range with the first element being the MSB and the
-#       second element the LSB. All bits from LSB up to and included MSB are set.
-# - list: Each bit position specified by the list elements is set.
-# - int: The specified bit position is set.
-#
-# @return An integer mask value computed from the logical OR'ing of masks generated
-#   by each argument.
-#
-# Example:
-# @code
-#   >>> hex(bitmask((23,17),1))
-#   0xfe0002
-#   >>> hex(bitmask([4,0,2],(31,24))
-#   0xff000015
-# @endcode
-def bitmask(*args):
-    mask = 0
-
-    for a in args:
-        if type(a) is tuple:
-            for b in range(a[1], a[0]+1):
-                mask |= 1 << b
-        elif type(a) is list:
-            for b in a:
-                mask |= 1 << b
-        elif type(a) is int:
-            mask |= 1 << a
-
-    return mask
-
-## @brief Return the 32-bit inverted value of the argument.
-def invert32(value):
-    return 0xffffffff & ~value
-
-## @brief Extract a value from a bitfield.
-def bfx(value, msb, lsb):
-    mask = bitmask((msb, lsb))
-    return (value & mask) >> lsb
-
-## @brief Change a bitfield value.
-def bfi(value, msb, lsb, field):
-    mask = bitmask((msb, lsb))
-    value &= ~mask
-    value |= (field & mask) << lsb
-    return value
-
-def _msb( n ):
-    ndx = 0
-    while ( 1 < n ):
-        n = ( n >> 1 )
-        ndx += 1
-    return ndx
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+## @brief Returns a mask with specified bit ranges set.
+#
+# An integer mask is generated based on the bits and bit ranges specified by the
+# arguments. Any number of arguments can be provided. Each argument may be either
+# a 2-tuple of integers, a list of integers, or an individual integer. The result
+# is the combination of masks produced by the arguments.
+#
+# - 2-tuple: The tuple is a bit range with the first element being the MSB and the
+#       second element the LSB. All bits from LSB up to and included MSB are set.
+# - list: Each bit position specified by the list elements is set.
+# - int: The specified bit position is set.
+#
+# @return An integer mask value computed from the logical OR'ing of masks generated
+#   by each argument.
+#
+# Example:
+# @code
+#   >>> hex(bitmask((23,17),1))
+#   0xfe0002
+#   >>> hex(bitmask([4,0,2],(31,24))
+#   0xff000015
+# @endcode
+def bitmask(*args):
+    mask = 0
+
+    for a in args:
+        if type(a) is tuple:
+            for b in range(a[1], a[0]+1):
+                mask |= 1 << b
+        elif type(a) is list:
+            for b in a:
+                mask |= 1 << b
+        elif type(a) is int:
+            mask |= 1 << a
+
+    return mask
+
+## @brief Return the 32-bit inverted value of the argument.
+def invert32(value):
+    return 0xffffffff & ~value
+
+## @brief Extract a value from a bitfield.
+def bfx(value, msb, lsb):
+    mask = bitmask((msb, lsb))
+    return (value & mask) >> lsb
+
+## @brief Change a bitfield value.
+def bfi(value, msb, lsb, field):
+    mask = bitmask((msb, lsb))
+    value &= ~mask
+    value |= (field & mask) << lsb
+    return value
+
+def _msb( n ):
+    ndx = 0
+    while ( 1 < n ):
+        n = ( n >> 1 )
+        ndx += 1
+    return ndx
+
```

### Comparing `pyOCD-0.8.1a1/pyOCD/utility/__init__.py` & `pyOCD-0.9.0/pyOCD/utility/__init__.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import conversion
-import cmdline
-import mask
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import conversion
+import cmdline
+import mask
```

### Comparing `pyOCD-0.8.1a1/pyOCD/__init__.py` & `pyOCD-0.9.0/pyOCD/board/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,19 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import board
-import flash
-import gdbserver
-import target
-import utility
-import coresight
-
-from ._version import version as __version__
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import mbed_board
+from mbed_board import MbedBoard
```

### Comparing `pyOCD-0.8.1a1/pyOCD.egg-info/PKG-INFO` & `pyOCD-0.9.0/pyOCD.egg-info/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,265 +1,265 @@
-Metadata-Version: 1.1
-Name: pyOCD
-Version: 0.8.1a1
-Summary: CMSIS-DAP debugger for Python
-Home-page: https://github.com/mbedmicro/pyOCD
-Author: Martin Kojtal, Russ Butler
-Author-email: martin.kojtal@arm.com, russ.butler@arm.com
-License: Apache 2.0
-Description: pyOCD
-        =====
-        
-        pyOCD is an Open Source python 2.7 based library for programming and debugging 
-        ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
-        supported.
-        
-        You can use the following interfaces:
-        
-        #. From a python interpretor:
-        
-           -  halt, step, resume execution
-           -  read/write memory
-           -  read/write block memory
-           -  read-write core register
-           -  set/remove hardware breakpoints
-           -  flash new binary
-           -  reset
-        
-        #. From a GDB client, you have all the features provided by gdb:
-        
-           -  load a .elf file
-           -  read/write memory
-           -  read/write core register
-           -  set/remove hardware breakpoints
-           -  high level stepping
-           -  ...
-        
-        Installation
-        ------------
-        
-        The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
-        
-        .. code:: shell
-        
-            $ pip install --pre -U pyocd
-        
-        To install the latest development version (master branch), you can do
-        the following:
-        
-        .. code:: shell
-        
-            $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
-        
-        Note that you may run into permissions issues running these commands.
-        You have a few options here:
-        
-        #. Run with ``sudo -H`` to install pyOCD and dependencies globally
-        #. Specify the ``--user`` option to install local to your user
-        #. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
-           local to a specific project working set.
-        
-        You can also install from source by cloning the git repository and running
-        
-        .. code:: shell
-        
-            python setup.py install
-        
-        Standalone GDB Server
-        ---------------------
-        
-        When you install pyOCD via pip, you should be able to execute the
-        following in order to start a GDB server powered by pyOCD:
-        
-        .. code:: shell
-        
-            pyocd-gdbserver
-        
-        You can get additional help by running ``pyocd-gdbserver --help``.
-        
-        Recommended GDB and IDE setup
-        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-        
-        The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
-        To view register the Embedded System Register Viewer plugin can be used.
-        These can be installed from inside eclipse using the following links:
-        GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
-        Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
-        
-        The pyOCD gdb server executable will run as a drop in place replacement for
-        OpenOCD. If a supported mbed development board is being debugged the target
-        does not need to be specified, as pyOCD will automatically determine this.
-        If an external processor is being debugged then ``-t [processor]`` must
-        be added to the command line. For more information on setup see
-        `this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
-        
-        Development Setup
-        -----------------
-        
-        PyOCD developers are recommended to setup a working environment using
-        `virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
-        the code, you can setup a virtualenv and install the PyOCD
-        dependencies for the current platform by doing the following:
-        
-        .. code:: console
-        
-            $ virtualenv env
-            $ source env/bin/activate
-            $ pip install -r dev-requirements.txt
-        
-        On Windows, the virtualenv would be activated by executing
-        ``env\Scripts\activate``.
-        
-        To run the unittests, you can execute the following.  Because of how
-        nose searches for tests, specifying the directory is important as it
-        will otherwise attempt to run non-unit tests as well (which will
-        hang).
-        
-        .. code:: console
-        
-            $ nosetests pyOCD/tests
-        
-        To get code coverage results, do the following:
-        
-        .. code:: console
-        
-            $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
-            $ firefox cover/index.html
-        
-        Examples
-        --------
-        
-        Tests
-        ~~~~~
-        
-        A series of tests are provided in the test directory:
-        
-        -  basic\_test.py: a simple test that checks:
-        
-           -  read/write core registers
-           -  read/write memory
-           -  stop/resume/step the execution
-           -  reset the target
-           -  erase pages
-           -  flash a binary
-            
-        -  gdb\_test.py: launch a gdbserver
-        -  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
-        
-           -  "-p", "--port", help = "Write the port number that GDB server will open."
-           -  "-b", "--board", help="Connect to board by board id."
-           -  "-l", "--list", help = "List all connected boards."
-           -  "-d", "--debug", help = "Set the level of system logging output."
-           -  "-t", "--target", help = "Override target to debug."
-           -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
-           -  "-r", "--reset-break", help = "Halt the target when reset."
-           -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
-           -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
-           -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
-           -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
-           -  "-ce", "--chip\_erase", help="Use chip erase when programming."
-           -  "-se", "--sector\_erase", help="Use sector erase when programming."
-           -  "-hp", "--hide\_progress", help = "Don't display programming progress."
-           -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
-        
-        Hello World example code
-        ~~~~~~~~~~~~~~~~~~~~~~~~
-        
-        .. code:: python
-        
-            from pyOCD.board import MbedBoard
-        
-            import logging
-            logging.basicConfig(level=logging.INFO)
-        
-            board = MbedBoard.chooseBoard()
-        
-            target = board.target
-            flash = board.flash
-            target.resume()
-            target.halt()
-        
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-                pc: 0xA64
-        
-            target.step()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-                pc: 0xA30
-        
-            target.step()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0xA32
-        
-            flash.flashBinary("binaries/l1_lpc1768.bin")
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0x10000000
-        
-            target.reset()
-            target.halt()
-            print "pc: 0x%X" % target.readCoreRegister("pc")
-               pc: 0xAAC
-        
-            board.uninit()
-        
-        GDB server example
-        ~~~~~~~~~~~~~~~~~~
-        
-        Python:
-        
-        .. code:: python
-        
-            from pyOCD.gdbserver import GDBServer
-            from pyOCD.board import MbedBoard
-        
-            import logging
-            logging.basicConfig(level=logging.INFO)
-        
-            board = MbedBoard.chooseBoard()
-        
-            # start gdbserver
-            gdb = GDBServer(board, 3333)
-        
-        gdb server:
-        
-        ::
-        
-            arm-none-eabi-gdb basic.elf
-        
-            <gdb> target remote localhost:3333
-            <gdb> load
-            <gdb> continue
-        
-        Architecture
-        ------------
-        Target
-        ~~~~~~
-        
-        A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
-        ``readMemory``, etc. You can inherit from Target to implement your own methods.
-        
-        Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
-        
-        Transport
-        ~~~~~~~~~
-        
-        Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
-        Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
-        
-        You can inherit from ``Transport`` and implement your own methods.
-        Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
-        
-        Flash
-        ~~~~~
-        
-        Contains flash algorithm in order to flash a new binary into the target.
-        
-        gdbserver
-        ~~~~~~~~~
-        Start a GDB server. The server listens on a specific port. You can then
-        connect a GDB client to it and debug/program the target.
-        
-        Then you can debug a board which is composed by an interface, a target, a transport and a flash
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python
+Metadata-Version: 1.1
+Name: pyOCD
+Version: 0.9.0
+Summary: CMSIS-DAP debugger for Python
+Home-page: https://github.com/mbedmicro/pyOCD
+Author: Martin Kojtal, Russ Butler
+Author-email: martin.kojtal@arm.com, russ.butler@arm.com
+License: Apache 2.0
+Description: pyOCD
+        =====
+        
+        pyOCD is an Open Source python 2.7 based library for programming and debugging 
+        ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
+        supported.
+        
+        You can use the following interfaces:
+        
+        #. From a python interpretor:
+        
+           -  halt, step, resume execution
+           -  read/write memory
+           -  read/write block memory
+           -  read-write core register
+           -  set/remove hardware breakpoints
+           -  flash new binary
+           -  reset
+        
+        #. From a GDB client, you have all the features provided by gdb:
+        
+           -  load a .elf file
+           -  read/write memory
+           -  read/write core register
+           -  set/remove hardware breakpoints
+           -  high level stepping
+           -  ...
+        
+        Installation
+        ------------
+        
+        The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
+        
+        .. code:: shell
+        
+            $ pip install --pre -U pyocd
+        
+        To install the latest development version (master branch), you can do
+        the following:
+        
+        .. code:: shell
+        
+            $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
+        
+        Note that you may run into permissions issues running these commands.
+        You have a few options here:
+        
+        #. Run with ``sudo -H`` to install pyOCD and dependencies globally
+        #. Specify the ``--user`` option to install local to your user
+        #. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
+           local to a specific project working set.
+        
+        You can also install from source by cloning the git repository and running
+        
+        .. code:: shell
+        
+            python setup.py install
+        
+        Standalone GDB Server
+        ---------------------
+        
+        When you install pyOCD via pip, you should be able to execute the
+        following in order to start a GDB server powered by pyOCD:
+        
+        .. code:: shell
+        
+            pyocd-gdbserver
+        
+        You can get additional help by running ``pyocd-gdbserver --help``.
+        
+        Recommended GDB and IDE setup
+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+        
+        The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
+        To view register the Embedded System Register Viewer plugin can be used.
+        These can be installed from inside eclipse using the following links:
+        GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
+        Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
+        
+        The pyOCD gdb server executable will run as a drop in place replacement for
+        OpenOCD. If a supported mbed development board is being debugged the target
+        does not need to be specified, as pyOCD will automatically determine this.
+        If an external processor is being debugged then ``-t [processor]`` must
+        be added to the command line. For more information on setup see
+        `this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
+        
+        Development Setup
+        -----------------
+        
+        PyOCD developers are recommended to setup a working environment using
+        `virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
+        the code, you can setup a virtualenv and install the PyOCD
+        dependencies for the current platform by doing the following:
+        
+        .. code:: console
+        
+            $ virtualenv env
+            $ source env/bin/activate
+            $ pip install -r dev-requirements.txt
+        
+        On Windows, the virtualenv would be activated by executing
+        ``env\Scripts\activate``.
+        
+        To run the unittests, you can execute the following.  Because of how
+        nose searches for tests, specifying the directory is important as it
+        will otherwise attempt to run non-unit tests as well (which will
+        hang).
+        
+        .. code:: console
+        
+            $ nosetests pyOCD/tests
+        
+        To get code coverage results, do the following:
+        
+        .. code:: console
+        
+            $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
+            $ firefox cover/index.html
+        
+        Examples
+        --------
+        
+        Tests
+        ~~~~~
+        
+        A series of tests are provided in the test directory:
+        
+        -  basic\_test.py: a simple test that checks:
+        
+           -  read/write core registers
+           -  read/write memory
+           -  stop/resume/step the execution
+           -  reset the target
+           -  erase pages
+           -  flash a binary
+            
+        -  gdb\_test.py: launch a gdbserver
+        -  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
+        
+           -  "-p", "--port", help = "Write the port number that GDB server will open."
+           -  "-b", "--board", help="Connect to board by board id."
+           -  "-l", "--list", help = "List all connected boards."
+           -  "-d", "--debug", help = "Set the level of system logging output."
+           -  "-t", "--target", help = "Override target to debug."
+           -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
+           -  "-r", "--reset-break", help = "Halt the target when reset."
+           -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
+           -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
+           -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
+           -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
+           -  "-ce", "--chip\_erase", help="Use chip erase when programming."
+           -  "-se", "--sector\_erase", help="Use sector erase when programming."
+           -  "-hp", "--hide\_progress", help = "Don't display programming progress."
+           -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
+        
+        Hello World example code
+        ~~~~~~~~~~~~~~~~~~~~~~~~
+        
+        .. code:: python
+        
+            from pyOCD.board import MbedBoard
+        
+            import logging
+            logging.basicConfig(level=logging.INFO)
+        
+            board = MbedBoard.chooseBoard()
+        
+            target = board.target
+            flash = board.flash
+            target.resume()
+            target.halt()
+        
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #    pc: 0xA64
+        
+            target.step()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #    pc: 0xA30
+        
+            target.step()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0xA32
+        
+            flash.flashBinary("binaries/l1_lpc1768.bin")
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0x10000000
+        
+            target.reset()
+            target.halt()
+            print "pc: 0x%X" % target.readCoreRegister("pc")
+            #   pc: 0xAAC
+        
+            board.uninit()
+        
+        GDB server example
+        ~~~~~~~~~~~~~~~~~~
+        
+        Python:
+        
+        .. code:: python
+        
+            from pyOCD.gdbserver import GDBServer
+            from pyOCD.board import MbedBoard
+        
+            import logging
+            logging.basicConfig(level=logging.INFO)
+        
+            board = MbedBoard.chooseBoard()
+        
+            # start gdbserver
+            gdb = GDBServer(board, 3333)
+        
+        gdb server:
+        
+        ::
+        
+            arm-none-eabi-gdb basic.elf
+        
+            <gdb> target remote localhost:3333
+            <gdb> load
+            <gdb> continue
+        
+        Architecture
+        ------------
+        Target
+        ~~~~~~
+        
+        A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
+        ``readMemory``, etc. You can inherit from Target to implement your own methods.
+        
+        Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
+        
+        Transport
+        ~~~~~~~~~
+        
+        Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
+        Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
+        
+        You can inherit from ``Transport`` and implement your own methods.
+        Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
+        
+        Flash
+        ~~~~~
+        
+        Contains flash algorithm in order to flash a new binary into the target.
+        
+        gdbserver
+        ~~~~~~~~~
+        Start a GDB server. The server listens on a specific port. You can then
+        connect a GDB client to it and debug/program the target.
+        
+        Then you can debug a board which is composed by an interface, a target, a transport and a flash
+        
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python
```

### Comparing `pyOCD-0.8.1a1/README.rst` & `pyOCD-0.9.0/README.rst`

 * *Files 14% similar despite different names*

```diff
@@ -1,252 +1,252 @@
-pyOCD
-=====
-
-pyOCD is an Open Source python 2.7 based library for programming and debugging 
-ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
-supported.
-
-You can use the following interfaces:
-
-#. From a python interpretor:
-
-   -  halt, step, resume execution
-   -  read/write memory
-   -  read/write block memory
-   -  read-write core register
-   -  set/remove hardware breakpoints
-   -  flash new binary
-   -  reset
-
-#. From a GDB client, you have all the features provided by gdb:
-
-   -  load a .elf file
-   -  read/write memory
-   -  read/write core register
-   -  set/remove hardware breakpoints
-   -  high level stepping
-   -  ...
-
-Installation
-------------
-
-The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
-
-.. code:: shell
-
-    $ pip install --pre -U pyocd
-
-To install the latest development version (master branch), you can do
-the following:
-
-.. code:: shell
-
-    $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
-
-Note that you may run into permissions issues running these commands.
-You have a few options here:
-
-#. Run with ``sudo -H`` to install pyOCD and dependencies globally
-#. Specify the ``--user`` option to install local to your user
-#. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
-   local to a specific project working set.
-
-You can also install from source by cloning the git repository and running
-
-.. code:: shell
-
-    python setup.py install
-
-Standalone GDB Server
----------------------
-
-When you install pyOCD via pip, you should be able to execute the
-following in order to start a GDB server powered by pyOCD:
-
-.. code:: shell
-
-    pyocd-gdbserver
-
-You can get additional help by running ``pyocd-gdbserver --help``.
-
-Recommended GDB and IDE setup
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
-To view register the Embedded System Register Viewer plugin can be used.
-These can be installed from inside eclipse using the following links:
-GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
-Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
-
-The pyOCD gdb server executable will run as a drop in place replacement for
-OpenOCD. If a supported mbed development board is being debugged the target
-does not need to be specified, as pyOCD will automatically determine this.
-If an external processor is being debugged then ``-t [processor]`` must
-be added to the command line. For more information on setup see
-`this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
-
-Development Setup
------------------
-
-PyOCD developers are recommended to setup a working environment using
-`virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
-the code, you can setup a virtualenv and install the PyOCD
-dependencies for the current platform by doing the following:
-
-.. code:: console
-
-    $ virtualenv env
-    $ source env/bin/activate
-    $ pip install -r dev-requirements.txt
-
-On Windows, the virtualenv would be activated by executing
-``env\Scripts\activate``.
-
-To run the unittests, you can execute the following.  Because of how
-nose searches for tests, specifying the directory is important as it
-will otherwise attempt to run non-unit tests as well (which will
-hang).
-
-.. code:: console
-
-    $ nosetests pyOCD/tests
-
-To get code coverage results, do the following:
-
-.. code:: console
-
-    $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
-    $ firefox cover/index.html
-
-Examples
---------
-
-Tests
-~~~~~
-
-A series of tests are provided in the test directory:
-
--  basic\_test.py: a simple test that checks:
-
-   -  read/write core registers
-   -  read/write memory
-   -  stop/resume/step the execution
-   -  reset the target
-   -  erase pages
-   -  flash a binary
-    
--  gdb\_test.py: launch a gdbserver
--  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
-
-   -  "-p", "--port", help = "Write the port number that GDB server will open."
-   -  "-b", "--board", help="Connect to board by board id."
-   -  "-l", "--list", help = "List all connected boards."
-   -  "-d", "--debug", help = "Set the level of system logging output."
-   -  "-t", "--target", help = "Override target to debug."
-   -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
-   -  "-r", "--reset-break", help = "Halt the target when reset."
-   -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
-   -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
-   -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
-   -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
-   -  "-ce", "--chip\_erase", help="Use chip erase when programming."
-   -  "-se", "--sector\_erase", help="Use sector erase when programming."
-   -  "-hp", "--hide\_progress", help = "Don't display programming progress."
-   -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
-
-Hello World example code
-~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. code:: python
-
-    from pyOCD.board import MbedBoard
-
-    import logging
-    logging.basicConfig(level=logging.INFO)
-
-    board = MbedBoard.chooseBoard()
-
-    target = board.target
-    flash = board.flash
-    target.resume()
-    target.halt()
-
-    print "pc: 0x%X" % target.readCoreRegister("pc")
-        pc: 0xA64
-
-    target.step()
-    print "pc: 0x%X" % target.readCoreRegister("pc")
-        pc: 0xA30
-
-    target.step()
-    print "pc: 0x%X" % target.readCoreRegister("pc")
-       pc: 0xA32
-
-    flash.flashBinary("binaries/l1_lpc1768.bin")
-    print "pc: 0x%X" % target.readCoreRegister("pc")
-       pc: 0x10000000
-
-    target.reset()
-    target.halt()
-    print "pc: 0x%X" % target.readCoreRegister("pc")
-       pc: 0xAAC
-
-    board.uninit()
-
-GDB server example
-~~~~~~~~~~~~~~~~~~
-
-Python:
-
-.. code:: python
-
-    from pyOCD.gdbserver import GDBServer
-    from pyOCD.board import MbedBoard
-
-    import logging
-    logging.basicConfig(level=logging.INFO)
-
-    board = MbedBoard.chooseBoard()
-
-    # start gdbserver
-    gdb = GDBServer(board, 3333)
-
-gdb server:
-
-::
-
-    arm-none-eabi-gdb basic.elf
-
-    <gdb> target remote localhost:3333
-    <gdb> load
-    <gdb> continue
-
-Architecture
-------------
-Target
-~~~~~~
-
-A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
-``readMemory``, etc. You can inherit from Target to implement your own methods.
-
-Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
-
-Transport
-~~~~~~~~~
-
-Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
-Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
-
-You can inherit from ``Transport`` and implement your own methods.
-Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
-
-Flash
-~~~~~
-
-Contains flash algorithm in order to flash a new binary into the target.
-
-gdbserver
-~~~~~~~~~
-Start a GDB server. The server listens on a specific port. You can then
-connect a GDB client to it and debug/program the target.
-
-Then you can debug a board which is composed by an interface, a target, a transport and a flash
+pyOCD
+=====
+
+pyOCD is an Open Source python 2.7 based library for programming and debugging 
+ARM Cortex-M microcontrollers using CMSIS-DAP. Linux, OSX and Windows are 
+supported.
+
+You can use the following interfaces:
+
+#. From a python interpretor:
+
+   -  halt, step, resume execution
+   -  read/write memory
+   -  read/write block memory
+   -  read-write core register
+   -  set/remove hardware breakpoints
+   -  flash new binary
+   -  reset
+
+#. From a GDB client, you have all the features provided by gdb:
+
+   -  load a .elf file
+   -  read/write memory
+   -  read/write core register
+   -  set/remove hardware breakpoints
+   -  high level stepping
+   -  ...
+
+Installation
+------------
+
+The latest stable version of pyOCD may be done via  `pip <https://pip.pypa.io/en/stable/index.html>`__ as follows:
+
+.. code:: shell
+
+    $ pip install --pre -U pyocd
+
+To install the latest development version (master branch), you can do
+the following:
+
+.. code:: shell
+
+    $ pip install --pre -U https://github.com/mbedmicro/pyOCD/archive/master.zip
+
+Note that you may run into permissions issues running these commands.
+You have a few options here:
+
+#. Run with ``sudo -H`` to install pyOCD and dependencies globally
+#. Specify the ``--user`` option to install local to your user
+#. Run the command in a `virtualenv <https://virtualenv.pypa.io/en/latest/>`__ 
+   local to a specific project working set.
+
+You can also install from source by cloning the git repository and running
+
+.. code:: shell
+
+    python setup.py install
+
+Standalone GDB Server
+---------------------
+
+When you install pyOCD via pip, you should be able to execute the
+following in order to start a GDB server powered by pyOCD:
+
+.. code:: shell
+
+    pyocd-gdbserver
+
+You can get additional help by running ``pyocd-gdbserver --help``.
+
+Recommended GDB and IDE setup
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The GDB server works well with Eclipse and the GNU ARM Eclipse OpenOCD plug-in.
+To view register the Embedded System Register Viewer plugin can be used.
+These can be installed from inside eclipse using the following links:
+GNU ARM Eclipse: http://gnuarmeclipse.sourceforge.net/updates
+Embedded System Register Viewer: http://embsysregview.sourceforge.net/update
+
+The pyOCD gdb server executable will run as a drop in place replacement for
+OpenOCD. If a supported mbed development board is being debugged the target
+does not need to be specified, as pyOCD will automatically determine this.
+If an external processor is being debugged then ``-t [processor]`` must
+be added to the command line. For more information on setup see
+`this post for OpenOCD <http://gnuarmeclipse.livius.net/blog/openocd-debugging/>`__
+
+Development Setup
+-----------------
+
+PyOCD developers are recommended to setup a working environment using
+`virtualenv <https://virtualenv.pypa.io/en/latest/>`__. After cloning
+the code, you can setup a virtualenv and install the PyOCD
+dependencies for the current platform by doing the following:
+
+.. code:: console
+
+    $ virtualenv env
+    $ source env/bin/activate
+    $ pip install -r dev-requirements.txt
+
+On Windows, the virtualenv would be activated by executing
+``env\Scripts\activate``.
+
+To run the unittests, you can execute the following.  Because of how
+nose searches for tests, specifying the directory is important as it
+will otherwise attempt to run non-unit tests as well (which will
+hang).
+
+.. code:: console
+
+    $ nosetests pyOCD/tests
+
+To get code coverage results, do the following:
+
+.. code:: console
+
+    $ nosetests --with-coverage --cover-html --cover-package=pyOCD pyOCD/tests
+    $ firefox cover/index.html
+
+Examples
+--------
+
+Tests
+~~~~~
+
+A series of tests are provided in the test directory:
+
+-  basic\_test.py: a simple test that checks:
+
+   -  read/write core registers
+   -  read/write memory
+   -  stop/resume/step the execution
+   -  reset the target
+   -  erase pages
+   -  flash a binary
+    
+-  gdb\_test.py: launch a gdbserver
+-  gdb\_server.py: an enhanced version of gdbserver which provides the following options:
+
+   -  "-p", "--port", help = "Write the port number that GDB server will open."
+   -  "-b", "--board", help="Connect to board by board id."
+   -  "-l", "--list", help = "List all connected boards."
+   -  "-d", "--debug", help = "Set the level of system logging output."
+   -  "-t", "--target", help = "Override target to debug."
+   -  "-n", "--nobreak", help = "Disable halt at hardfault handler."
+   -  "-r", "--reset-break", help = "Halt the target when reset."
+   -  "-s", "--step-int", help = "Allow single stepping to step into interrupts."
+   -  "-f", "--frequency", help = "Set the SWD clock frequency in Hz."
+   -  "-o", "--persist", help = "Keep GDB server running even after remote has detached."
+   -  "-bh", "--soft-bkpt-as-hard", help = "Replace software breakpoints with hardware breakpoints."
+   -  "-ce", "--chip\_erase", help="Use chip erase when programming."
+   -  "-se", "--sector\_erase", help="Use sector erase when programming."
+   -  "-hp", "--hide\_progress", help = "Don't display programming progress."
+   -  "-fp", "--fast\_program", help = "Use only the CRC of each page to determine if it already has the same data."
+
+Hello World example code
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. code:: python
+
+    from pyOCD.board import MbedBoard
+
+    import logging
+    logging.basicConfig(level=logging.INFO)
+
+    board = MbedBoard.chooseBoard()
+
+    target = board.target
+    flash = board.flash
+    target.resume()
+    target.halt()
+
+    print "pc: 0x%X" % target.readCoreRegister("pc")
+    #    pc: 0xA64
+
+    target.step()
+    print "pc: 0x%X" % target.readCoreRegister("pc")
+    #    pc: 0xA30
+
+    target.step()
+    print "pc: 0x%X" % target.readCoreRegister("pc")
+    #   pc: 0xA32
+
+    flash.flashBinary("binaries/l1_lpc1768.bin")
+    print "pc: 0x%X" % target.readCoreRegister("pc")
+    #   pc: 0x10000000
+
+    target.reset()
+    target.halt()
+    print "pc: 0x%X" % target.readCoreRegister("pc")
+    #   pc: 0xAAC
+
+    board.uninit()
+
+GDB server example
+~~~~~~~~~~~~~~~~~~
+
+Python:
+
+.. code:: python
+
+    from pyOCD.gdbserver import GDBServer
+    from pyOCD.board import MbedBoard
+
+    import logging
+    logging.basicConfig(level=logging.INFO)
+
+    board = MbedBoard.chooseBoard()
+
+    # start gdbserver
+    gdb = GDBServer(board, 3333)
+
+gdb server:
+
+::
+
+    arm-none-eabi-gdb basic.elf
+
+    <gdb> target remote localhost:3333
+    <gdb> load
+    <gdb> continue
+
+Architecture
+------------
+Target
+~~~~~~
+
+A target defines basic functionalities such as ``step``, ``resume``, ``halt``,
+``readMemory``, etc. You can inherit from Target to implement your own methods.
+
+Then declare your target in TARGET (in ``pyOCD.target.__init__.py``)
+
+Transport
+~~~~~~~~~
+
+Defines the transport used to communicate. In particular, you can find CMSIS-DAP.
+Implements methods such as ``memWriteAP``, ``memReadAP``, ``writeDP``, ``readDP``, ...
+
+You can inherit from ``Transport`` and implement your own methods.
+Then declare your transport in ``TRANSPORT`` (in ``pyOCD.transport.__init__.py``)
+
+Flash
+~~~~~
+
+Contains flash algorithm in order to flash a new binary into the target.
+
+gdbserver
+~~~~~~~~~
+Start a GDB server. The server listens on a specific port. You can then
+connect a GDB client to it and debug/program the target.
+
+Then you can debug a board which is composed by an interface, a target, a transport and a flash
```

### Comparing `pyOCD-0.8.1a1/setup.py` & `pyOCD-0.9.0/setup.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2012-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-from setuptools import setup, find_packages
-import sys
-
-install_requires = ['intelhex', 'six', 'enum34', 'future', 'websocket-client']
-if sys.platform.startswith('linux'):
-    install_requires.extend([
-        'pyusb>=1.0.0b2',
-    ])
-elif sys.platform.startswith('win'):
-    install_requires.extend([
-        'pywinusb>=0.4.0',
-    ])
-elif sys.platform.startswith('darwin'):
-    install_requires.extend([
-        'hidapi',
-    ])
-
-setup(
-    name="pyOCD",
-    use_scm_version={
-        'local_scheme': 'dirty-tag',
-        'write_to': 'pyOCD/_version.py'
-    },
-    setup_requires=['setuptools_scm!=1.5.3,!=1.5.4'],
-    description="CMSIS-DAP debugger for Python",
-    long_description=open('README.rst', 'Ur').read(),
-    author="Martin Kojtal, Russ Butler",
-    author_email="martin.kojtal@arm.com, russ.butler@arm.com",
-    url='https://github.com/mbedmicro/pyOCD',
-    license="Apache 2.0",
-    install_requires=install_requires,
-    classifiers=[
-        "Development Status :: 4 - Beta",
-        "License :: OSI Approved :: Apache Software License",
-        "Programming Language :: Python",
-    ],
-    extras_require={
-        'dissassembler': ['capstone']
-    },
-    entry_points={
-        'console_scripts': [
-            'pyocd-gdbserver = pyOCD.tools.gdb_server:main',
-            'pyocd-flashtool = pyOCD.tools.flash_tool:main',
-            'pyocd-tool = pyOCD.tools.pyocd:main',
-        ],
-    },
-    use_2to3=True,
-    packages=find_packages(),
-    include_package_data=True,  # include files from MANIFEST.in
-)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2012-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+from setuptools import setup, find_packages
+import sys
+
+install_requires = ['intelhex', 'six', 'enum34', 'future', 'websocket-client', 'intervaltree']
+if sys.platform.startswith('linux'):
+    install_requires.extend([
+        'pyusb>=1.0.0b2',
+    ])
+elif sys.platform.startswith('win'):
+    install_requires.extend([
+        'pywinusb>=0.4.0',
+    ])
+elif sys.platform.startswith('darwin'):
+    install_requires.extend([
+        'hidapi',
+    ])
+
+setup(
+    name="pyOCD",
+    use_scm_version={
+        'local_scheme': 'dirty-tag',
+        'write_to': 'pyOCD/_version.py'
+    },
+    setup_requires=['setuptools_scm!=1.5.3,!=1.5.4'],
+    description="CMSIS-DAP debugger for Python",
+    long_description=open('README.rst', 'Ur').read(),
+    author="Martin Kojtal, Russ Butler",
+    author_email="martin.kojtal@arm.com, russ.butler@arm.com",
+    url='https://github.com/mbedmicro/pyOCD',
+    license="Apache 2.0",
+    install_requires=install_requires,
+    classifiers=[
+        "Development Status :: 4 - Beta",
+        "License :: OSI Approved :: Apache Software License",
+        "Programming Language :: Python",
+    ],
+    extras_require={
+        'dissassembler': ['capstone']
+    },
+    entry_points={
+        'console_scripts': [
+            'pyocd-gdbserver = pyOCD.tools.gdb_server:main',
+            'pyocd-flashtool = pyOCD.tools.flash_tool:main',
+            'pyocd-tool = pyOCD.tools.pyocd:main',
+        ],
+    },
+    use_2to3=True,
+    packages=find_packages(),
+    include_package_data=True,  # include files from MANIFEST.in
+)
```

### Comparing `pyOCD-0.8.1a1/test/basic_test.py` & `pyOCD-0.9.0/test/basic_test.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,223 +1,223 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import argparse, os, sys
-from time import sleep
-from random import randrange
-import math
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-sys.path.insert(0, parentdir)
-
-import pyOCD
-from pyOCD.board import MbedBoard
-from pyOCD.utility.conversion import float32beToU32be
-import logging
-
-def basic_test(board_id, file):
-    with MbedBoard.chooseBoard(board_id=board_id) as board:
-        addr = 0
-        size = 0
-        f = None
-        binary_file = "l1_"
-
-        target_type = board.getTargetType()
-
-        if file is None:
-            binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
-        else:
-            binary_file = file
-
-        print "binary file: %s" % binary_file
-
-        memory_map = board.target.getMemoryMap()
-        ram_regions = [region for region in memory_map if region.type == 'ram']
-        ram_region = ram_regions[0]
-        rom_region = memory_map.getBootMemory()
-
-        addr = ram_region.start + 1
-        size = 0x502
-        addr_bin = rom_region.start
-        addr_flash = rom_region.start + rom_region.length // 2
-
-        target = board.target
-        link = board.link
-        flash = board.flash
-
-
-        print "\r\n\r\n------ GET Unique ID ------"
-        print "Unique ID: %s" % board.getUniqueID()
-
-        print "\r\n\r\n------ TEST READ / WRITE CORE REGISTER ------"
-        pc = target.readCoreRegister('pc')
-        print "initial pc: 0x%X" % target.readCoreRegister('pc')
-        # write in pc dummy value
-        target.writeCoreRegister('pc', 0x3D82)
-        print "now pc: 0x%X" % target.readCoreRegister('pc')
-        # write initial pc value
-        target.writeCoreRegister('pc', pc)
-        print "initial pc value rewritten: 0x%X" % target.readCoreRegister('pc')
-
-        msp = target.readCoreRegister('msp')
-        psp = target.readCoreRegister('psp')
-        print "MSP = 0x%08x; PSP = 0x%08x" % (msp, psp)
-
-        control = target.readCoreRegister('control')
-        faultmask = target.readCoreRegister('faultmask')
-        basepri = target.readCoreRegister('basepri')
-        primask = target.readCoreRegister('primask')
-        print "CONTROL = 0x%02x; FAULTMASK = 0x%02x; BASEPRI = 0x%02x; PRIMASK = 0x%02x" % (control, faultmask, basepri, primask)
-
-        target.writeCoreRegister('primask', 1)
-        newPrimask = target.readCoreRegister('primask')
-        print "New PRIMASK = 0x%02x" % newPrimask
-        target.writeCoreRegister('primask', primask)
-        newPrimask = target.readCoreRegister('primask')
-        print "Restored PRIMASK = 0x%02x" % newPrimask
-
-        if target.has_fpu:
-            s0 = target.readCoreRegister('s0')
-            print "S0 = %g (0x%08x)" % (s0, float32beToU32be(s0))
-            target.writeCoreRegister('s0', math.pi)
-            newS0 = target.readCoreRegister('s0')
-            print "New S0 = %g (0x%08x)" % (newS0, float32beToU32be(newS0))
-            target.writeCoreRegister('s0', s0)
-            newS0 = target.readCoreRegister('s0')
-            print "Restored S0 = %g (0x%08x)" % (newS0, float32beToU32be(newS0))
-
-
-        print "\r\n\r\n------ TEST HALT / RESUME ------"
-
-        print "resume"
-        target.resume()
-        sleep(0.2)
-
-        print "halt"
-        target.halt()
-        print "HALT: pc: 0x%X" % target.readCoreRegister('pc')
-        sleep(0.2)
-
-
-        print "\r\n\r\n------ TEST STEP ------"
-
-        print "reset and halt"
-        target.resetStopOnReset()
-        currentPC = target.readCoreRegister('pc')
-        print "HALT: pc: 0x%X" % currentPC
-        sleep(0.2)
-
-        for i in range(4):
-            print "step"
-            target.step()
-            newPC = target.readCoreRegister('pc')
-            print "STEP: pc: 0x%X" % newPC
-            currentPC = newPC
-            sleep(0.2)
-
-
-        print "\r\n\r\n------ TEST READ / WRITE MEMORY ------"
-        target.halt()
-        print "READ32/WRITE32"
-        val = randrange(0, 0xffffffff)
-        print "write32 0x%X at 0x%X" % (val, addr)
-        target.writeMemory(addr, val)
-        res = target.readMemory(addr)
-        print "read32 at 0x%X: 0x%X" % (addr, res)
-        if res != val:
-            print "ERROR in READ/WRITE 32"
-
-        print "\r\nREAD16/WRITE16"
-        val = randrange(0, 0xffff)
-        print "write16 0x%X at 0x%X" % (val, addr + 2)
-        target.writeMemory(addr + 2, val, 16)
-        res = target.readMemory(addr + 2, 16)
-        print "read16 at 0x%X: 0x%X" % (addr + 2, res)
-        if res != val:
-            print "ERROR in READ/WRITE 16"
-
-        print "\r\nREAD8/WRITE8"
-        val = randrange(0, 0xff)
-        print "write8 0x%X at 0x%X" % (val, addr + 1)
-        target.writeMemory(addr + 1, val, 8)
-        res = target.readMemory(addr + 1, 8)
-        print "read8 at 0x%X: 0x%X" % (addr + 1, res)
-        if res != val:
-            print "ERROR in READ/WRITE 8"
-
-
-        print "\r\n\r\n------ TEST READ / WRITE MEMORY BLOCK ------"
-        data = [randrange(1, 50) for x in range(size)]
-        target.writeBlockMemoryUnaligned8(addr, data)
-        block = target.readBlockMemoryUnaligned8(addr, size)
-        error = False
-        for i in range(len(block)):
-            if (block[i] != data[i]):
-                error = True
-                print "ERROR: 0x%X, 0x%X, 0x%X!!!" % ((addr + i), block[i], data[i])
-        if error:
-            print "TEST FAILED"
-        else:
-            print "TEST PASSED"
-
-
-        print "\r\n\r\n------ TEST RESET ------"
-        target.reset()
-        sleep(0.1)
-        target.halt()
-
-        for i in range(5):
-            target.step()
-            print "pc: 0x%X" % target.readCoreRegister('pc')
-
-        print "\r\n\r\n------ TEST PROGRAM/ERASE PAGE ------"
-        # Fill 3 pages with 0x55
-        page_size = flash.getPageInfo(addr_flash).size
-        fill = [0x55] * page_size
-        flash.init()
-        for i in range(0, 3):
-            address = addr_flash + page_size * i
-            # Test only supports a location with 3 aligned
-            # pages of the same size
-            current_page_size = flash.getPageInfo(addr_flash).size
-            assert page_size == current_page_size
-            assert address % current_page_size == 0
-            flash.erasePage(address)
-            flash.programPage(address, fill)
-        # Erase the middle page
-        flash.erasePage(addr_flash + page_size)
-        # Verify the 1st and 3rd page were not erased, and that the 2nd page is fully erased
-        data = target.readBlockMemoryUnaligned8(addr_flash, page_size * 3)
-        expected = fill + [0xFF] * page_size + fill
-        if data == expected:
-            print "TEST PASSED"
-        else:
-            print "TEST FAILED"
-
-        print "\r\n\r\n----- FLASH NEW BINARY -----"
-        flash.flashBinary(binary_file, addr_bin)
-
-        target.reset()
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description='A CMSIS-DAP python debugger')
-    parser.add_argument('-f', help='binary file', dest="file")
-    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
-    args = parser.parse_args()
-    level = logging.DEBUG if args.debug else logging.INFO
-    logging.basicConfig(level=level)
-    file = args.file
-    basic_test(None, file)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import argparse, os, sys
+from time import sleep
+from random import randrange
+import math
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.insert(0, parentdir)
+
+import pyOCD
+from pyOCD.board import MbedBoard
+from pyOCD.utility.conversion import float32beToU32be
+import logging
+
+def basic_test(board_id, file):
+    with MbedBoard.chooseBoard(board_id=board_id) as board:
+        addr = 0
+        size = 0
+        f = None
+        binary_file = "l1_"
+
+        target_type = board.getTargetType()
+
+        if file is None:
+            binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
+        else:
+            binary_file = file
+
+        print "binary file: %s" % binary_file
+
+        memory_map = board.target.getMemoryMap()
+        ram_regions = [region for region in memory_map if region.type == 'ram']
+        ram_region = ram_regions[0]
+        rom_region = memory_map.getBootMemory()
+
+        addr = ram_region.start + 1
+        size = 0x502
+        addr_bin = rom_region.start
+        addr_flash = rom_region.start + rom_region.length // 2
+
+        target = board.target
+        link = board.link
+        flash = board.flash
+
+
+        print "\r\n\r\n------ GET Unique ID ------"
+        print "Unique ID: %s" % board.getUniqueID()
+
+        print "\r\n\r\n------ TEST READ / WRITE CORE REGISTER ------"
+        pc = target.readCoreRegister('pc')
+        print "initial pc: 0x%X" % target.readCoreRegister('pc')
+        # write in pc dummy value
+        target.writeCoreRegister('pc', 0x3D82)
+        print "now pc: 0x%X" % target.readCoreRegister('pc')
+        # write initial pc value
+        target.writeCoreRegister('pc', pc)
+        print "initial pc value rewritten: 0x%X" % target.readCoreRegister('pc')
+
+        msp = target.readCoreRegister('msp')
+        psp = target.readCoreRegister('psp')
+        print "MSP = 0x%08x; PSP = 0x%08x" % (msp, psp)
+
+        control = target.readCoreRegister('control')
+        faultmask = target.readCoreRegister('faultmask')
+        basepri = target.readCoreRegister('basepri')
+        primask = target.readCoreRegister('primask')
+        print "CONTROL = 0x%02x; FAULTMASK = 0x%02x; BASEPRI = 0x%02x; PRIMASK = 0x%02x" % (control, faultmask, basepri, primask)
+
+        target.writeCoreRegister('primask', 1)
+        newPrimask = target.readCoreRegister('primask')
+        print "New PRIMASK = 0x%02x" % newPrimask
+        target.writeCoreRegister('primask', primask)
+        newPrimask = target.readCoreRegister('primask')
+        print "Restored PRIMASK = 0x%02x" % newPrimask
+
+        if target.has_fpu:
+            s0 = target.readCoreRegister('s0')
+            print "S0 = %g (0x%08x)" % (s0, float32beToU32be(s0))
+            target.writeCoreRegister('s0', math.pi)
+            newS0 = target.readCoreRegister('s0')
+            print "New S0 = %g (0x%08x)" % (newS0, float32beToU32be(newS0))
+            target.writeCoreRegister('s0', s0)
+            newS0 = target.readCoreRegister('s0')
+            print "Restored S0 = %g (0x%08x)" % (newS0, float32beToU32be(newS0))
+
+
+        print "\r\n\r\n------ TEST HALT / RESUME ------"
+
+        print "resume"
+        target.resume()
+        sleep(0.2)
+
+        print "halt"
+        target.halt()
+        print "HALT: pc: 0x%X" % target.readCoreRegister('pc')
+        sleep(0.2)
+
+
+        print "\r\n\r\n------ TEST STEP ------"
+
+        print "reset and halt"
+        target.resetStopOnReset()
+        currentPC = target.readCoreRegister('pc')
+        print "HALT: pc: 0x%X" % currentPC
+        sleep(0.2)
+
+        for i in range(4):
+            print "step"
+            target.step()
+            newPC = target.readCoreRegister('pc')
+            print "STEP: pc: 0x%X" % newPC
+            currentPC = newPC
+            sleep(0.2)
+
+
+        print "\r\n\r\n------ TEST READ / WRITE MEMORY ------"
+        target.halt()
+        print "READ32/WRITE32"
+        val = randrange(0, 0xffffffff)
+        print "write32 0x%X at 0x%X" % (val, addr)
+        target.writeMemory(addr, val)
+        res = target.readMemory(addr)
+        print "read32 at 0x%X: 0x%X" % (addr, res)
+        if res != val:
+            print "ERROR in READ/WRITE 32"
+
+        print "\r\nREAD16/WRITE16"
+        val = randrange(0, 0xffff)
+        print "write16 0x%X at 0x%X" % (val, addr + 2)
+        target.writeMemory(addr + 2, val, 16)
+        res = target.readMemory(addr + 2, 16)
+        print "read16 at 0x%X: 0x%X" % (addr + 2, res)
+        if res != val:
+            print "ERROR in READ/WRITE 16"
+
+        print "\r\nREAD8/WRITE8"
+        val = randrange(0, 0xff)
+        print "write8 0x%X at 0x%X" % (val, addr + 1)
+        target.writeMemory(addr + 1, val, 8)
+        res = target.readMemory(addr + 1, 8)
+        print "read8 at 0x%X: 0x%X" % (addr + 1, res)
+        if res != val:
+            print "ERROR in READ/WRITE 8"
+
+
+        print "\r\n\r\n------ TEST READ / WRITE MEMORY BLOCK ------"
+        data = [randrange(1, 50) for x in range(size)]
+        target.writeBlockMemoryUnaligned8(addr, data)
+        block = target.readBlockMemoryUnaligned8(addr, size)
+        error = False
+        for i in range(len(block)):
+            if (block[i] != data[i]):
+                error = True
+                print "ERROR: 0x%X, 0x%X, 0x%X!!!" % ((addr + i), block[i], data[i])
+        if error:
+            print "TEST FAILED"
+        else:
+            print "TEST PASSED"
+
+
+        print "\r\n\r\n------ TEST RESET ------"
+        target.reset()
+        sleep(0.1)
+        target.halt()
+
+        for i in range(5):
+            target.step()
+            print "pc: 0x%X" % target.readCoreRegister('pc')
+
+        print "\r\n\r\n------ TEST PROGRAM/ERASE PAGE ------"
+        # Fill 3 pages with 0x55
+        page_size = flash.getPageInfo(addr_flash).size
+        fill = [0x55] * page_size
+        flash.init()
+        for i in range(0, 3):
+            address = addr_flash + page_size * i
+            # Test only supports a location with 3 aligned
+            # pages of the same size
+            current_page_size = flash.getPageInfo(addr_flash).size
+            assert page_size == current_page_size
+            assert address % current_page_size == 0
+            flash.erasePage(address)
+            flash.programPage(address, fill)
+        # Erase the middle page
+        flash.erasePage(addr_flash + page_size)
+        # Verify the 1st and 3rd page were not erased, and that the 2nd page is fully erased
+        data = target.readBlockMemoryUnaligned8(addr_flash, page_size * 3)
+        expected = fill + [0xFF] * page_size + fill
+        if data == expected:
+            print "TEST PASSED"
+        else:
+            print "TEST FAILED"
+
+        print "\r\n\r\n----- FLASH NEW BINARY -----"
+        flash.flashBinary(binary_file, addr_bin)
+
+        target.reset()
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='A CMSIS-DAP python debugger')
+    parser.add_argument('-f', help='binary file', dest="file")
+    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
+    args = parser.parse_args()
+    level = logging.DEBUG if args.debug else logging.INFO
+    logging.basicConfig(level=level)
+    file = args.file
+    basic_test(None, file)
```

### Comparing `pyOCD-0.8.1a1/test/blank_test.py` & `pyOCD-0.9.0/test/blank_test.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-#!/usr/bin/env python
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2013 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import os, sys
-from time import sleep
-from random import randrange
-import math
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-sys.path.insert(0, parentdir)
-
-import pyOCD
-from pyOCD.board import MbedBoard
-import logging
-
-logging.basicConfig(level=logging.INFO)
-
-print "\r\n\r\n------ Test attaching to locked board ------"
-for i in range(0, 10):
-    with MbedBoard.chooseBoard() as board:
-        # Erase and then reset - This locks Kinetis devices
-        board.flash.init()
-        board.flash.eraseAll()
-        board.target.reset()
-
-print "\r\n\r\n------ Testing Attaching to board ------"
-for i in range(0, 100):
-    with MbedBoard.chooseBoard() as board:
-        board.target.halt()
-        sleep(0.01)
-        board.target.resume()
-        sleep(0.01)
-
-print "\r\n\r\n------ Flashing new code ------"
-with MbedBoard.chooseBoard() as board:
-    binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
-    board.flash.flashBinary(binary_file)
-
-print "\r\n\r\n------ Testing Attaching to regular board ------"
-for i in range(0, 10):
-    with MbedBoard.chooseBoard() as board:
-        board.target.resetStopOnReset()
-        board.target.halt()
-        sleep(0.2)
-        board.target.resume()
-        sleep(0.2)
+#!/usr/bin/env python
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2013 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import os, sys
+from time import sleep
+from random import randrange
+import math
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.insert(0, parentdir)
+
+import pyOCD
+from pyOCD.board import MbedBoard
+import logging
+
+logging.basicConfig(level=logging.INFO)
+
+print "\r\n\r\n------ Test attaching to locked board ------"
+for i in range(0, 10):
+    with MbedBoard.chooseBoard() as board:
+        # Erase and then reset - This locks Kinetis devices
+        board.flash.init()
+        board.flash.eraseAll()
+        board.target.reset()
+
+print "\r\n\r\n------ Testing Attaching to board ------"
+for i in range(0, 100):
+    with MbedBoard.chooseBoard() as board:
+        board.target.halt()
+        sleep(0.01)
+        board.target.resume()
+        sleep(0.01)
+
+print "\r\n\r\n------ Flashing new code ------"
+with MbedBoard.chooseBoard() as board:
+    binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
+    board.flash.flashBinary(binary_file)
+
+print "\r\n\r\n------ Testing Attaching to regular board ------"
+for i in range(0, 10):
+    with MbedBoard.chooseBoard() as board:
+        board.target.resetStopOnReset()
+        board.target.halt()
+        sleep(0.2)
+        board.target.resume()
+        sleep(0.2)
```

### Comparing `pyOCD-0.8.1a1/test/cortex_test.py` & `pyOCD-0.9.0/test/cortex_test.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,317 +1,320 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import argparse, os, sys
-from time import sleep, time
-from random import randrange
-import math
-import argparse
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-sys.path.insert(0, parentdir)
-
-import pyOCD
-from pyOCD.board import MbedBoard
-from pyOCD.utility.conversion import float32beToU32be
-from pyOCD.pyDAPAccess import DAPAccess
-from test_util import Test, TestResult
-import logging
-from random import randrange
-
-TEST_COUNT = 20
-
-class CortexTestResult(TestResult):
-    def __init__(self):
-        super(CortexTestResult, self).__init__(None, None, None)
-
-class CortexTest(Test):
-    def __init__(self):
-        super(CortexTest, self).__init__("Cortex Test", cortex_test)
-
-    def print_perf_info(self, result_list, output_file=None):
-        pass
-
-    def run(self, board):
-        try:
-            result = self.test_function(board.getUniqueID())
-        except Exception as e:
-            result = CortexTestResult()
-            result.passed = False
-            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
-        result.board = board
-        result.test = self
-        return result
-
-def same(d1, d2):
-    if len(d1) != len(d2):
-        return False
-    for i in range(len(d1)):
-        if d1[i] != d2[i]:
-            return False
-    return True
-
-def test_function(board, function):
-    board.link.flush()
-    start = time()
-    for i in range(0, TEST_COUNT):
-        function()
-        board.link.flush()
-    stop = time()
-    return (stop - start) / float(TEST_COUNT)
-
-def cortex_test(board_id):
-    with MbedBoard.chooseBoard(board_id=board_id, frequency=1000000) as board:
-        target_type = board.getTargetType()
-
-        binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
-
-        test_clock = 10000000
-        addr_invalid = 0x3E000000 # Last 16MB of ARM SRAM region - typically empty
-        if target_type == "nrf51":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-        if target_type == "ncs36510":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-
-        memory_map = board.target.getMemoryMap()
-        ram_regions = [region for region in memory_map if region.type == 'ram']
-        ram_region = ram_regions[0]
-        rom_region = memory_map.getBootMemory()
-
-        addr = ram_region.start + 1
-        size = 0x502
-        addr_bin = rom_region.start
-
-        target = board.target
-        link = board.link
-        flash = board.flash
-
-        link.set_clock(test_clock)
-        link.set_deferred_transfer(True)
-
-        test_pass_count = 0
-        test_count = 0
-        result = CortexTestResult()
-
-        print "\r\n\r\n----- FLASH NEW BINARY BEFORE TEST -----"
-        flash.flashBinary(binary_file, addr_bin)
-        # Let the target run for a bit so it
-        # can initialize the watchdog if it needs to
-        target.resume()
-        sleep(0.2)
-        target.halt()
-
-        print "PROGRAMMING COMPLETE"
-
-
-        print "\r\n\r\n----- TESTING CORTEX-M PERFORMANCE -----"
-        test_time = test_function(board, target.getTResponse)
-        print("Function getTResponse time: %f" % test_time)
-
-        # Step
-        test_time = test_function(board, target.step)
-        print("Function step time: %f" % test_time)
-
-        # Breakpoint
-        def set_remove_breakpoint():
-            target.setBreakpoint(0)
-            target.removeBreakpoint(0)
-        test_time = test_function(board, set_remove_breakpoint)
-        print("Add and remove breakpoint: %f" % test_time)
-
-        # getRegisterContext
-        test_time = test_function(board, target.getRegisterContext)
-        print("Function getRegisterContext: %f" % test_time)
-
-        # setRegisterContext
-        context = target.getRegisterContext()
-        def set_register_context():
-            target.setRegisterContext(context)
-        test_time = test_function(board, set_register_context)
-        print("Function setRegisterContext: %f" % test_time)
-
-        # Run / Halt
-        def run_halt():
-            target.resume()
-            target.halt()
-        test_time = test_function(board, run_halt)
-        print("Resume and halt: %f" % test_time)
-
-        # GDB stepping
-        def simulate_step():
-            target.step()
-            target.getTResponse()
-            target.setBreakpoint(0)
-            target.resume()
-            target.halt()
-            target.getTResponse()
-            target.removeBreakpoint(0)
-        test_time = test_function(board, simulate_step)
-        print("Simulated GDB step: %f" % test_time)
-
-        # Test passes if there are no exceptions
-        test_pass_count += 1
-        test_count += 1
-        print("TEST PASSED")
-
-
-        print "\r\n\r\n------ Testing Invalid Memory Access Recovery ------"
-        memory_access_pass = True
-        try:
-            target.readBlockMemoryUnaligned8(addr_invalid, 0x1000)
-            target.flush()
-            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
-            if target_type != "nrf51":
-                memory_access_pass = False
-        except DAPAccess.TransferFaultError:
-            pass
-
-        try:
-            target.readBlockMemoryUnaligned8(addr_invalid + 1, 0x1000)
-            target.flush()
-            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
-            if target_type != "nrf51":
-                memory_access_pass = False
-        except DAPAccess.TransferFaultError:
-            pass
-
-        data = [0x00] * 0x1000
-        try:
-            target.writeBlockMemoryUnaligned8(addr_invalid, data)
-            target.flush()
-            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
-            if target_type != "nrf51":
-                memory_access_pass = False
-        except DAPAccess.TransferFaultError:
-            pass
-
-        data = [0x00] * 0x1000
-        try:
-            target.writeBlockMemoryUnaligned8(addr_invalid + 1, data)
-            target.flush()
-            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
-            if target_type != "nrf51":
-                memory_access_pass = False
-        except DAPAccess.TransferFaultError:
-            pass
-
-        data = [randrange(0, 255) for x in range(size)]
-        target.writeBlockMemoryUnaligned8(addr, data)
-        block = target.readBlockMemoryUnaligned8(addr, size)
-        if same(data, block):
-            print "Aligned access pass"
-        else:
-            print("Memory read does not match memory written")
-            memory_access_pass = False
-
-        data = [randrange(0, 255) for x in range(size)]
-        target.writeBlockMemoryUnaligned8(addr + 1, data)
-        block = target.readBlockMemoryUnaligned8(addr + 1, size)
-        if same(data, block):
-            print "Unaligned access pass"
-        else:
-            print("Unaligned memory read does not match memory written")
-            memory_access_pass = False
-
-        test_count += 1
-        if memory_access_pass:
-            test_pass_count += 1
-            print "TEST PASSED"
-        else:
-            print "TEST FAILED"
-
-        print "\r\n\r\n------ Testing Software Breakpoints ------"
-        test_passed = True
-        orig8x2 = target.readBlockMemoryUnaligned8(addr, 2)
-        orig8 = target.read8(addr)
-        orig16 = target.read16(addr & ~1)
-        orig32 = target.read32(addr & ~3)
-        origAligned32 = target.readBlockMemoryAligned32(addr & ~3, 1)
-
-        def test_filters():
-            test_passed = True
-            filtered = target.readBlockMemoryUnaligned8(addr, 2)
-            if same(orig8x2, filtered):
-                print "2 byte unaligned passed"
-            else:
-                print "2 byte unaligned failed (read %x-%x, expected %x-%x)" % (filtered[0], filtered[1], orig8x2[0], orig8x2[1])
-                test_passed = False
-
-            for now in (True, False):
-                filtered = target.read8(addr, now)
-                if not now:
-                    filtered = filtered()
-                if filtered == orig8:
-                    print "8-bit passed [now=%s]" % now
-                else:
-                    print "8-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig8)
-                    test_passed = False
-
-                filtered = target.read16(addr & ~1, now)
-                if not now:
-                    filtered = filtered()
-                if filtered == orig16:
-                    print "16-bit passed [now=%s]" % now
-                else:
-                    print "16-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig16)
-                    test_passed = False
-
-                filtered = target.read32(addr & ~3, now)
-                if not now:
-                    filtered = filtered()
-                if filtered == orig32:
-                    print "32-bit passed [now=%s]" % now
-                else:
-                    print "32-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig32)
-                    test_passed = False
-
-            filtered = target.readBlockMemoryAligned32(addr & ~3, 1)
-            if same(filtered, origAligned32):
-                print "32-bit aligned passed"
-            else:
-                print "32-bit aligned failed (read %x, expected %x)" % (filtered[0], origAligned32[0])
-                test_passed = False
-            return test_passed
-
-        print "Installed software breakpoint at 0x%08x" % addr
-        target.setBreakpoint(addr, pyOCD.target.target.Target.BREAKPOINT_SW)
-        test_passed = test_filters() and test_passed
-
-        print "Removed software breakpoint"
-        target.removeBreakpoint(addr)
-        test_passed = test_filters() and test_passed
-
-        test_count += 1
-        if test_passed:
-            test_pass_count += 1
-            print "TEST PASSED"
-        else:
-            print "TEST FAILED"
-
-        target.reset()
-
-        result.passed = test_count == test_pass_count
-        return result
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description='pyOCD cpu test')
-    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
-    args = parser.parse_args()
-    level = logging.DEBUG if args.debug else logging.INFO
-    logging.basicConfig(level=level)
-    cortex_test(None)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import argparse, os, sys
+from time import sleep, time
+from random import randrange
+import math
+import argparse
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.insert(0, parentdir)
+
+import pyOCD
+from pyOCD.board import MbedBoard
+from pyOCD.utility.conversion import float32beToU32be
+from pyOCD.pyDAPAccess import DAPAccess
+from test_util import Test, TestResult
+import logging
+from random import randrange
+
+TEST_COUNT = 20
+
+class CortexTestResult(TestResult):
+    def __init__(self):
+        super(CortexTestResult, self).__init__(None, None, None)
+
+class CortexTest(Test):
+    def __init__(self):
+        super(CortexTest, self).__init__("Cortex Test", cortex_test)
+
+    def print_perf_info(self, result_list, output_file=None):
+        pass
+
+    def run(self, board):
+        try:
+            result = self.test_function(board.getUniqueID())
+        except Exception as e:
+            result = CortexTestResult()
+            result.passed = False
+            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
+        result.board = board
+        result.test = self
+        return result
+
+def same(d1, d2):
+    if len(d1) != len(d2):
+        return False
+    for i in range(len(d1)):
+        if d1[i] != d2[i]:
+            return False
+    return True
+
+def test_function(board, function):
+    board.link.flush()
+    start = time()
+    for i in range(0, TEST_COUNT):
+        function()
+        board.link.flush()
+    stop = time()
+    return (stop - start) / float(TEST_COUNT)
+
+def cortex_test(board_id):
+    with MbedBoard.chooseBoard(board_id=board_id, frequency=1000000) as board:
+        target_type = board.getTargetType()
+
+        binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
+
+        test_clock = 10000000
+        addr_invalid = 0x3E000000 # Last 16MB of ARM SRAM region - typically empty
+        if target_type == "nrf51":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+        if target_type == "ncs36510":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+
+        memory_map = board.target.getMemoryMap()
+        ram_regions = [region for region in memory_map if region.type == 'ram']
+        ram_region = ram_regions[0]
+        rom_region = memory_map.getBootMemory()
+
+        addr = ram_region.start + 1
+        size = 0x502
+        addr_bin = rom_region.start
+
+        target = board.target
+        link = board.link
+        flash = board.flash
+
+        link.set_clock(test_clock)
+        link.set_deferred_transfer(True)
+
+        test_pass_count = 0
+        test_count = 0
+        result = CortexTestResult()
+
+        debugContext = target.getTargetContext()
+        gdbFacade = pyOCD.gdbserver.context_facade.GDBDebugContextFacade(debugContext)
+
+        print "\r\n\r\n----- FLASH NEW BINARY BEFORE TEST -----"
+        flash.flashBinary(binary_file, addr_bin)
+        # Let the target run for a bit so it
+        # can initialize the watchdog if it needs to
+        target.resume()
+        sleep(0.2)
+        target.halt()
+
+        print "PROGRAMMING COMPLETE"
+
+
+        print "\r\n\r\n----- TESTING CORTEX-M PERFORMANCE -----"
+        test_time = test_function(board, gdbFacade.getTResponse)
+        print("Function getTResponse time: %f" % test_time)
+
+        # Step
+        test_time = test_function(board, target.step)
+        print("Function step time: %f" % test_time)
+
+        # Breakpoint
+        def set_remove_breakpoint():
+            target.setBreakpoint(0)
+            target.removeBreakpoint(0)
+        test_time = test_function(board, set_remove_breakpoint)
+        print("Add and remove breakpoint: %f" % test_time)
+
+        # getRegisterContext
+        test_time = test_function(board, gdbFacade.getRegisterContext)
+        print("Function getRegisterContext: %f" % test_time)
+
+        # setRegisterContext
+        context = gdbFacade.getRegisterContext()
+        def set_register_context():
+            gdbFacade.setRegisterContext(context)
+        test_time = test_function(board, set_register_context)
+        print("Function setRegisterContext: %f" % test_time)
+
+        # Run / Halt
+        def run_halt():
+            target.resume()
+            target.halt()
+        test_time = test_function(board, run_halt)
+        print("Resume and halt: %f" % test_time)
+
+        # GDB stepping
+        def simulate_step():
+            target.step()
+            gdbFacade.getTResponse()
+            target.setBreakpoint(0)
+            target.resume()
+            target.halt()
+            gdbFacade.getTResponse()
+            target.removeBreakpoint(0)
+        test_time = test_function(board, simulate_step)
+        print("Simulated GDB step: %f" % test_time)
+
+        # Test passes if there are no exceptions
+        test_pass_count += 1
+        test_count += 1
+        print("TEST PASSED")
+
+
+        print "\r\n\r\n------ Testing Invalid Memory Access Recovery ------"
+        memory_access_pass = True
+        try:
+            target.readBlockMemoryUnaligned8(addr_invalid, 0x1000)
+            target.flush()
+            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
+            if target_type != "nrf51":
+                memory_access_pass = False
+        except DAPAccess.TransferFaultError:
+            pass
+
+        try:
+            target.readBlockMemoryUnaligned8(addr_invalid + 1, 0x1000)
+            target.flush()
+            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
+            if target_type != "nrf51":
+                memory_access_pass = False
+        except DAPAccess.TransferFaultError:
+            pass
+
+        data = [0x00] * 0x1000
+        try:
+            target.writeBlockMemoryUnaligned8(addr_invalid, data)
+            target.flush()
+            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
+            if target_type != "nrf51":
+                memory_access_pass = False
+        except DAPAccess.TransferFaultError:
+            pass
+
+        data = [0x00] * 0x1000
+        try:
+            target.writeBlockMemoryUnaligned8(addr_invalid + 1, data)
+            target.flush()
+            # If no exception is thrown the tests fails except on nrf51 where invalid addresses read as 0
+            if target_type != "nrf51":
+                memory_access_pass = False
+        except DAPAccess.TransferFaultError:
+            pass
+
+        data = [randrange(0, 255) for x in range(size)]
+        target.writeBlockMemoryUnaligned8(addr, data)
+        block = target.readBlockMemoryUnaligned8(addr, size)
+        if same(data, block):
+            print "Aligned access pass"
+        else:
+            print("Memory read does not match memory written")
+            memory_access_pass = False
+
+        data = [randrange(0, 255) for x in range(size)]
+        target.writeBlockMemoryUnaligned8(addr + 1, data)
+        block = target.readBlockMemoryUnaligned8(addr + 1, size)
+        if same(data, block):
+            print "Unaligned access pass"
+        else:
+            print("Unaligned memory read does not match memory written")
+            memory_access_pass = False
+
+        test_count += 1
+        if memory_access_pass:
+            test_pass_count += 1
+            print "TEST PASSED"
+        else:
+            print "TEST FAILED"
+
+        print "\r\n\r\n------ Testing Software Breakpoints ------"
+        test_passed = True
+        orig8x2 = target.readBlockMemoryUnaligned8(addr, 2)
+        orig8 = target.read8(addr)
+        orig16 = target.read16(addr & ~1)
+        orig32 = target.read32(addr & ~3)
+        origAligned32 = target.readBlockMemoryAligned32(addr & ~3, 1)
+
+        def test_filters():
+            test_passed = True
+            filtered = target.readBlockMemoryUnaligned8(addr, 2)
+            if same(orig8x2, filtered):
+                print "2 byte unaligned passed"
+            else:
+                print "2 byte unaligned failed (read %x-%x, expected %x-%x)" % (filtered[0], filtered[1], orig8x2[0], orig8x2[1])
+                test_passed = False
+
+            for now in (True, False):
+                filtered = target.read8(addr, now)
+                if not now:
+                    filtered = filtered()
+                if filtered == orig8:
+                    print "8-bit passed [now=%s]" % now
+                else:
+                    print "8-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig8)
+                    test_passed = False
+
+                filtered = target.read16(addr & ~1, now)
+                if not now:
+                    filtered = filtered()
+                if filtered == orig16:
+                    print "16-bit passed [now=%s]" % now
+                else:
+                    print "16-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig16)
+                    test_passed = False
+
+                filtered = target.read32(addr & ~3, now)
+                if not now:
+                    filtered = filtered()
+                if filtered == orig32:
+                    print "32-bit passed [now=%s]" % now
+                else:
+                    print "32-bit failed [now=%s] (read %x, expected %x)" % (now, filtered, orig32)
+                    test_passed = False
+
+            filtered = target.readBlockMemoryAligned32(addr & ~3, 1)
+            if same(filtered, origAligned32):
+                print "32-bit aligned passed"
+            else:
+                print "32-bit aligned failed (read %x, expected %x)" % (filtered[0], origAligned32[0])
+                test_passed = False
+            return test_passed
+
+        print "Installed software breakpoint at 0x%08x" % addr
+        target.setBreakpoint(addr, pyOCD.core.target.Target.BREAKPOINT_SW)
+        test_passed = test_filters() and test_passed
+
+        print "Removed software breakpoint"
+        target.removeBreakpoint(addr)
+        test_passed = test_filters() and test_passed
+
+        test_count += 1
+        if test_passed:
+            test_pass_count += 1
+            print "TEST PASSED"
+        else:
+            print "TEST FAILED"
+
+        target.reset()
+
+        result.passed = test_count == test_pass_count
+        return result
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='pyOCD cpu test')
+    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
+    args = parser.parse_args()
+    level = logging.DEBUG if args.debug else logging.INFO
+    logging.basicConfig(level=level)
+    cortex_test(None)
```

### Comparing `pyOCD-0.8.1a1/test/flash_test.py` & `pyOCD-0.9.0/test/flash_test.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,424 +1,427 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from __future__ import print_function
-
-import argparse, os, sys
-from time import sleep, time
-from random import randrange
-import math
-import struct
-import traceback
-import argparse
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-sys.path.insert(0, parentdir)
-
-import pyOCD
-from pyOCD.board import MbedBoard
-from pyOCD.utility.conversion import float32beToU32be
-from pyOCD.flash.flash import Flash
-from pyOCD.flash.flash_builder import FlashBuilder
-from test_util import Test, TestResult
-
-addr = 0
-size = 0
-
-board = None
-
-import logging
-
-class FlashTestResult(TestResult):
-    def __init__(self):
-        super(FlashTestResult, self).__init__(None, None, None)
-        self.chip_erase_rate_erased = None
-        self.page_erase_rate_same = None
-        self.page_erase_rate = None
-        self.analyze = None
-        self.analyze_rate = None
-        self.chip_erase_rate = None
-
-class FlashTest(Test):
-    def __init__(self):
-        super(FlashTest, self).__init__("Flash Test", flash_test)
-
-    def print_perf_info(self, result_list, output_file=None):
-        result_list = filter(lambda x: isinstance(x, FlashTestResult), result_list)
-
-        print("\r\n\r\n------ Analyzer Performance ------", file=output_file)
-        perf_format_str = "{:<10}{:<12}{:<18}{:<18}"
-        print(perf_format_str.format("Target", "Analyzer", "Rate", "Time"),
-              file=output_file)
-        print("", file=output_file)
-        for result in result_list:
-            if result.passed:
-                analyze_rate = "%f KB/s" % (result.analyze_rate / float(1000))
-                analyze_time = "%s s" % result.analyze_time
-            else:
-                analyze_rate = "Fail"
-                analyze_time = "Fail"
-            print(perf_format_str.format(result.board.target_type,
-                                         result.analyze, analyze_rate,
-                                         analyze_time),
-                  file=output_file)
-        print("", file=output_file)
-
-        print("\r\n\r\n------ Test Rate ------", file=output_file)
-        rate_format_str = "{:<10}{:<20}{:<20}{:<20}"
-        print(rate_format_str.format("Target", "Chip Erase", "Page Erase",
-                                     "Page Erase (Same data)"),
-              file=output_file)
-        print("", file=output_file)
-        for result in result_list:
-            if result.passed:
-                chip_erase_rate = "%f KB/s" % (result.chip_erase_rate / float(1000))
-                page_erase_rate = "%f KB/s" % (result.page_erase_rate / float(1000))
-                page_erase_rate_same = "%f KB/s" % (result.page_erase_rate_same / float(1000))
-            else:
-                chip_erase_rate = "Fail"
-                page_erase_rate = "Fail"
-                page_erase_rate_same = "Fail"
-            print(rate_format_str.format(result.board.target_type,
-                                         chip_erase_rate, page_erase_rate,
-                                         page_erase_rate_same),
-                  file=output_file)
-        print("", file=output_file)
-
-    def run(self, board):
-        try:
-            result = self.test_function(board.getUniqueID())
-        except Exception as e:
-            result = FlashTestResult()
-            result.passed = False
-            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
-            traceback.print_exc(file=sys.stdout)
-        result.board = board
-        result.test = self
-        return result
-
-
-def same(d1, d2):
-    if len(d1) != len(d2):
-        return False
-    for i in range(len(d1)):
-        if d1[i] != d2[i]:
-            return False
-    return True
-
-
-def flash_test(board_id):
-    with MbedBoard.chooseBoard(board_id=board_id, frequency=1000000) as board:
-        target_type = board.getTargetType()
-
-        test_clock = 10000000
-        if target_type == "nrf51":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-        if target_type == "ncs36510":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-
-        memory_map = board.target.getMemoryMap()
-        ram_regions = [region for region in memory_map if region.type == 'ram']
-        ram_region = ram_regions[0]
-
-        ram_start = ram_region.start
-        ram_size = ram_region.length
-
-        # Grab boot flash and any regions coming immediately after
-        rom_region = memory_map.getBootMemory()
-        rom_start = rom_region.start
-        rom_size = rom_region.length
-        for region in memory_map:
-            if region.isFlash and (region.start == rom_start + rom_size):
-                rom_size += region.length
-
-        target = board.target
-        link = board.link
-        flash = board.flash
-
-        link.set_clock(test_clock)
-        link.set_deferred_transfer(True)
-
-        test_pass_count = 0
-        test_count = 0
-        result = FlashTestResult()
-
-        def print_progress(progress):
-            assert progress >= 0.0
-            assert progress <= 1.0
-            assert (progress == 0 and print_progress.prev_progress == 1.0) or (progress >= print_progress.prev_progress)
-
-            # Reset state on 0.0
-            if progress == 0.0:
-                print_progress.prev_progress = 0
-                print_progress.backwards_progress = False
-                print_progress.done = False
-
-            # Check for backwards progress
-            if progress < print_progress.prev_progress:
-                print_progress.backwards_progress = True
-            print_progress.prev_progress = progress
-
-            # print progress bar
-            if not print_progress.done:
-                sys.stdout.write('\r')
-                i = int(progress * 20.0)
-                sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
-                sys.stdout.flush()
-
-            # Finish on 1.0
-            if progress >= 1.0:
-                if not print_progress.done:
-                    print_progress.done = True
-                    sys.stdout.write("\n")
-                    if print_progress.backwards_progress:
-                        print("Progress went backwards during flash")
-        print_progress.prev_progress = 0
-
-        binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
-        with open(binary_file, "rb") as f:
-            data = f.read()
-        data = struct.unpack("%iB" % len(data), data)
-        unused = rom_size - len(data)
-
-        addr = rom_start
-        size = len(data)
-
-        # Turn on extra checks for the next 4 tests
-        flash.setFlashAlgoDebug(True)
-
-        print("\r\n\r\n------ Test Basic Page Erase ------")
-        info = flash.flashBlock(addr, data, False, False, progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
-        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Basic Chip Erase ------")
-        info = flash.flashBlock(addr, data, False, True, progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
-        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_CHIP_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Smart Page Erase ------")
-        info = flash.flashBlock(addr, data, True, False, progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
-        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Smart Chip Erase ------")
-        info = flash.flashBlock(addr, data, True, True, progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
-        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_CHIP_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        flash.setFlashAlgoDebug(False)
-
-        print("\r\n\r\n------ Test Basic Page Erase (Entire chip) ------")
-        new_data = list(data)
-        new_data.extend(unused * [0x77])
-        info = flash.flashBlock(addr, new_data, False, False, progress_cb=print_progress)
-        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-            result.page_erase_rate = float(len(new_data)) / float(info.program_time)
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Fast Verify ------")
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress, fast_verify=True)
-        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Offset Write ------")
-        addr = rom_start + rom_size / 2
-        page_size = flash.getPageInfo(addr).size
-        new_data = [0x55] * page_size * 2
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(addr, len(new_data))
-        if same(data_flashed, new_data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Multiple Block Writes ------")
-        addr = rom_start + rom_size / 2
-        page_size = flash.getPageInfo(addr).size
-        more_data = [0x33] * page_size * 2
-        addr = (rom_start + rom_size / 2) + 1 #cover multiple pages
-        fb = flash.getFlashBuilder()
-        fb.addData(rom_start, data)
-        fb.addData(addr, more_data)
-        fb.program(progress_cb=print_progress)
-        data_flashed = target.readBlockMemoryUnaligned8(rom_start, len(data))
-        data_flashed_more = target.readBlockMemoryUnaligned8(addr, len(more_data))
-        if same(data_flashed, data) and same(data_flashed_more, more_data):
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Overlapping Blocks ------")
-        test_pass = False
-        addr = (rom_start + rom_size / 2) #cover multiple pages
-        page_size = flash.getPageInfo(addr).size
-        new_data = [0x33] * page_size
-        fb = flash.getFlashBuilder()
-        fb.addData(addr, new_data)
-        try:
-            fb.addData(addr + 1, new_data)
-        except ValueError as e:
-            print("Exception: %s" % e)
-            test_pass = True
-        if test_pass:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Empty Block Write ------")
-        # Freebee if nothing asserts
-        fb = flash.getFlashBuilder()
-        fb.program()
-        print("TEST PASSED")
-        test_pass_count += 1
-        test_count += 1
-
-        print("\r\n\r\n------ Test Missing Progress Callback ------")
-        # Freebee if nothing asserts
-        addr = rom_start
-        flash.flashBlock(rom_start, data, True)
-        print("TEST PASSED")
-        test_pass_count += 1
-        test_count += 1
-
-        # Only run test if the reset handler can be programmed (rom start at address 0)
-        if rom_start == 0:
-            print("\r\n\r\n------ Test Non-Thumb reset handler ------")
-            non_thumb_data = list(data)
-            # Clear bit 0 of 2nd word - reset handler
-            non_thumb_data[4] = non_thumb_data[4] & ~1
-            flash.flashBlock(rom_start, non_thumb_data)
-            flash.flashBlock(rom_start, data)
-            print("TEST PASSED")
-            test_pass_count += 1
-            test_count += 1
-
-        # Note - The decision based tests below are order dependent since they
-        # depend on the previous state of the flash
-
-        print("\r\n\r\n------ Test Chip Erase Decision ------")
-        new_data = list(data)
-        new_data.extend([0xff] * unused) # Pad with 0xFF
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
-        if info.program_type == FlashBuilder.FLASH_CHIP_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-            result.chip_erase_rate_erased = float(len(new_data)) / float(info.program_time)
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Chip Erase Decision 2 ------")
-        new_data = list(data)
-        new_data.extend([0x00] * unused) # Pad with 0x00
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
-        if info.program_type == FlashBuilder.FLASH_CHIP_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-            result.chip_erase_rate = float(len(new_data)) / float(info.program_time)
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Page Erase Decision ------")
-        new_data = list(data)
-        new_data.extend([0x00] * unused) # Pad with 0x00
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
-        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-            result.page_erase_rate_same = float(len(new_data)) / float(info.program_time)
-            result.analyze = info.analyze_type
-            result.analyze_time = info.analyze_time
-            result.analyze_rate = float(len(new_data)) / float(info.analyze_time)
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\n------ Test Page Erase Decision 2 ------")
-        new_data = list(data)
-        size_same = unused * 5 / 6
-        size_differ = unused - size_same
-        new_data.extend([0x00] * size_same) # Pad 5/6 with 0x00 and 1/6 with 0xFF
-        new_data.extend([0x55] * size_differ)
-        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
-        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
-            print("TEST PASSED")
-            test_pass_count += 1
-        else:
-            print("TEST FAILED")
-        test_count += 1
-
-        print("\r\n\r\nTest Summary:")
-        print("Pass count %i of %i tests" % (test_pass_count, test_count))
-        if test_pass_count == test_count:
-            print("FLASH TEST SCRIPT PASSED")
-        else:
-            print("FLASH TEST SCRIPT FAILED")
-
-        target.reset()
-
-        result.passed = test_count == test_pass_count
-        return result
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description='pyOCD flash test')
-    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
-    args = parser.parse_args()
-    level = logging.DEBUG if args.debug else logging.INFO
-    logging.basicConfig(level=level)
-    # Set to debug to print some of the decisions made while flashing
-    board = pyOCD.board.mbed_board.MbedBoard.getAllConnectedBoards(close=True)[0]
-    test = FlashTest()
-    result = [test.run(board)]
-    test.print_perf_info(result)
-
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from __future__ import print_function
+
+import argparse, os, sys
+from time import sleep, time
+from random import randrange
+import math
+import struct
+import traceback
+import argparse
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.insert(0, parentdir)
+
+import pyOCD
+from pyOCD.board import MbedBoard
+from pyOCD.pyDAPAccess import DAPAccess
+from pyOCD.utility.conversion import float32beToU32be
+from pyOCD.flash.flash import Flash
+from pyOCD.flash.flash_builder import FlashBuilder
+from test_util import Test, TestResult
+
+addr = 0
+size = 0
+
+board = None
+
+import logging
+
+class FlashTestResult(TestResult):
+    def __init__(self):
+        super(FlashTestResult, self).__init__(None, None, None)
+        self.chip_erase_rate_erased = None
+        self.page_erase_rate_same = None
+        self.page_erase_rate = None
+        self.analyze = None
+        self.analyze_rate = None
+        self.chip_erase_rate = None
+
+class FlashTest(Test):
+    def __init__(self):
+        super(FlashTest, self).__init__("Flash Test", flash_test)
+
+    def print_perf_info(self, result_list, output_file=None):
+        result_list = filter(lambda x: isinstance(x, FlashTestResult), result_list)
+
+        print("\r\n\r\n------ Analyzer Performance ------", file=output_file)
+        perf_format_str = "{:<10}{:<12}{:<18}{:<18}"
+        print(perf_format_str.format("Target", "Analyzer", "Rate", "Time"),
+              file=output_file)
+        print("", file=output_file)
+        for result in result_list:
+            if result.passed:
+                analyze_rate = "%f KB/s" % (result.analyze_rate / float(1000))
+                analyze_time = "%s s" % result.analyze_time
+            else:
+                analyze_rate = "Fail"
+                analyze_time = "Fail"
+            print(perf_format_str.format(result.board.target_type,
+                                         result.analyze, analyze_rate,
+                                         analyze_time),
+                  file=output_file)
+        print("", file=output_file)
+
+        print("\r\n\r\n------ Test Rate ------", file=output_file)
+        rate_format_str = "{:<10}{:<20}{:<20}{:<20}"
+        print(rate_format_str.format("Target", "Chip Erase", "Page Erase",
+                                     "Page Erase (Same data)"),
+              file=output_file)
+        print("", file=output_file)
+        for result in result_list:
+            if result.passed:
+                chip_erase_rate = "%f KB/s" % (result.chip_erase_rate / float(1000))
+                page_erase_rate = "%f KB/s" % (result.page_erase_rate / float(1000))
+                page_erase_rate_same = "%f KB/s" % (result.page_erase_rate_same / float(1000))
+            else:
+                chip_erase_rate = "Fail"
+                page_erase_rate = "Fail"
+                page_erase_rate_same = "Fail"
+            print(rate_format_str.format(result.board.target_type,
+                                         chip_erase_rate, page_erase_rate,
+                                         page_erase_rate_same),
+                  file=output_file)
+        print("", file=output_file)
+
+    def run(self, board):
+        try:
+            result = self.test_function(board.getUniqueID())
+        except Exception as e:
+            result = FlashTestResult()
+            result.passed = False
+            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
+            traceback.print_exc(file=sys.stdout)
+        result.board = board
+        result.test = self
+        return result
+
+
+def same(d1, d2):
+    if len(d1) != len(d2):
+        return False
+    for i in range(len(d1)):
+        if d1[i] != d2[i]:
+            return False
+    return True
+
+
+def flash_test(board_id):
+    with MbedBoard.chooseBoard(board_id=board_id, frequency=1000000) as board:
+        target_type = board.getTargetType()
+
+        test_clock = 10000000
+        if target_type == "nrf51":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+        if target_type == "ncs36510":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+
+        memory_map = board.target.getMemoryMap()
+        ram_regions = [region for region in memory_map if region.type == 'ram']
+        ram_region = ram_regions[0]
+
+        ram_start = ram_region.start
+        ram_size = ram_region.length
+
+        # Grab boot flash and any regions coming immediately after
+        rom_region = memory_map.getBootMemory()
+        rom_start = rom_region.start
+        rom_size = rom_region.length
+        for region in memory_map:
+            if region.isFlash and (region.start == rom_start + rom_size):
+                rom_size += region.length
+
+        target = board.target
+        link = board.link
+        flash = board.flash
+
+        link.set_clock(test_clock)
+        link.set_deferred_transfer(True)
+
+        test_pass_count = 0
+        test_count = 0
+        result = FlashTestResult()
+
+        def print_progress(progress):
+            assert progress >= 0.0
+            assert progress <= 1.0
+            assert (progress == 0 and print_progress.prev_progress == 1.0) or (progress >= print_progress.prev_progress)
+
+            # Reset state on 0.0
+            if progress == 0.0:
+                print_progress.prev_progress = 0
+                print_progress.backwards_progress = False
+                print_progress.done = False
+
+            # Check for backwards progress
+            if progress < print_progress.prev_progress:
+                print_progress.backwards_progress = True
+            print_progress.prev_progress = progress
+
+            # print progress bar
+            if not print_progress.done:
+                sys.stdout.write('\r')
+                i = int(progress * 20.0)
+                sys.stdout.write("[%-20s] %3d%%" % ('=' * i, round(progress * 100)))
+                sys.stdout.flush()
+
+            # Finish on 1.0
+            if progress >= 1.0:
+                if not print_progress.done:
+                    print_progress.done = True
+                    sys.stdout.write("\n")
+                    if print_progress.backwards_progress:
+                        print("Progress went backwards during flash")
+        print_progress.prev_progress = 0
+
+        binary_file = os.path.join(parentdir, 'binaries', board.getTestBinary())
+        with open(binary_file, "rb") as f:
+            data = f.read()
+        data = struct.unpack("%iB" % len(data), data)
+        unused = rom_size - len(data)
+
+        addr = rom_start
+        size = len(data)
+
+        # Turn on extra checks for the next 4 tests
+        flash.setFlashAlgoDebug(True)
+
+        print("\r\n\r\n------ Test Basic Page Erase ------")
+        info = flash.flashBlock(addr, data, False, False, progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
+        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Basic Chip Erase ------")
+        info = flash.flashBlock(addr, data, False, True, progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
+        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_CHIP_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Smart Page Erase ------")
+        info = flash.flashBlock(addr, data, True, False, progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
+        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Smart Chip Erase ------")
+        info = flash.flashBlock(addr, data, True, True, progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(addr, size)
+        if same(data_flashed, data) and info.program_type is FlashBuilder.FLASH_CHIP_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        flash.setFlashAlgoDebug(False)
+
+        print("\r\n\r\n------ Test Basic Page Erase (Entire chip) ------")
+        new_data = list(data)
+        new_data.extend(unused * [0x77])
+        info = flash.flashBlock(addr, new_data, False, False, progress_cb=print_progress)
+        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+            result.page_erase_rate = float(len(new_data)) / float(info.program_time)
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Fast Verify ------")
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress, fast_verify=True)
+        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Offset Write ------")
+        addr = rom_start + rom_size / 2
+        page_size = flash.getPageInfo(addr).size
+        new_data = [0x55] * page_size * 2
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(addr, len(new_data))
+        if same(data_flashed, new_data) and info.program_type is FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Multiple Block Writes ------")
+        addr = rom_start + rom_size / 2
+        page_size = flash.getPageInfo(addr).size
+        more_data = [0x33] * page_size * 2
+        addr = (rom_start + rom_size / 2) + 1 #cover multiple pages
+        fb = flash.getFlashBuilder()
+        fb.addData(rom_start, data)
+        fb.addData(addr, more_data)
+        fb.program(progress_cb=print_progress)
+        data_flashed = target.readBlockMemoryUnaligned8(rom_start, len(data))
+        data_flashed_more = target.readBlockMemoryUnaligned8(addr, len(more_data))
+        if same(data_flashed, data) and same(data_flashed_more, more_data):
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Overlapping Blocks ------")
+        test_pass = False
+        addr = (rom_start + rom_size / 2) #cover multiple pages
+        page_size = flash.getPageInfo(addr).size
+        new_data = [0x33] * page_size
+        fb = flash.getFlashBuilder()
+        fb.addData(addr, new_data)
+        try:
+            fb.addData(addr + 1, new_data)
+        except ValueError as e:
+            print("Exception: %s" % e)
+            test_pass = True
+        if test_pass:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Empty Block Write ------")
+        # Freebee if nothing asserts
+        fb = flash.getFlashBuilder()
+        fb.program()
+        print("TEST PASSED")
+        test_pass_count += 1
+        test_count += 1
+
+        print("\r\n\r\n------ Test Missing Progress Callback ------")
+        # Freebee if nothing asserts
+        addr = rom_start
+        flash.flashBlock(rom_start, data, True)
+        print("TEST PASSED")
+        test_pass_count += 1
+        test_count += 1
+
+        # Only run test if the reset handler can be programmed (rom start at address 0)
+        if rom_start == 0:
+            print("\r\n\r\n------ Test Non-Thumb reset handler ------")
+            non_thumb_data = list(data)
+            # Clear bit 0 of 2nd word - reset handler
+            non_thumb_data[4] = non_thumb_data[4] & ~1
+            flash.flashBlock(rom_start, non_thumb_data)
+            flash.flashBlock(rom_start, data)
+            print("TEST PASSED")
+            test_pass_count += 1
+            test_count += 1
+
+        # Note - The decision based tests below are order dependent since they
+        # depend on the previous state of the flash
+
+        print("\r\n\r\n------ Test Chip Erase Decision ------")
+        new_data = list(data)
+        new_data.extend([0xff] * unused) # Pad with 0xFF
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
+        if info.program_type == FlashBuilder.FLASH_CHIP_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+            result.chip_erase_rate_erased = float(len(new_data)) / float(info.program_time)
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Chip Erase Decision 2 ------")
+        new_data = list(data)
+        new_data.extend([0x00] * unused) # Pad with 0x00
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
+        if info.program_type == FlashBuilder.FLASH_CHIP_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+            result.chip_erase_rate = float(len(new_data)) / float(info.program_time)
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Page Erase Decision ------")
+        new_data = list(data)
+        new_data.extend([0x00] * unused) # Pad with 0x00
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
+        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+            result.page_erase_rate_same = float(len(new_data)) / float(info.program_time)
+            result.analyze = info.analyze_type
+            result.analyze_time = info.analyze_time
+            result.analyze_rate = float(len(new_data)) / float(info.analyze_time)
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\n------ Test Page Erase Decision 2 ------")
+        new_data = list(data)
+        size_same = unused * 5 / 6
+        size_differ = unused - size_same
+        new_data.extend([0x00] * size_same) # Pad 5/6 with 0x00 and 1/6 with 0xFF
+        new_data.extend([0x55] * size_differ)
+        info = flash.flashBlock(addr, new_data, progress_cb=print_progress)
+        if info.program_type == FlashBuilder.FLASH_PAGE_ERASE:
+            print("TEST PASSED")
+            test_pass_count += 1
+        else:
+            print("TEST FAILED")
+        test_count += 1
+
+        print("\r\n\r\nTest Summary:")
+        print("Pass count %i of %i tests" % (test_pass_count, test_count))
+        if test_pass_count == test_count:
+            print("FLASH TEST SCRIPT PASSED")
+        else:
+            print("FLASH TEST SCRIPT FAILED")
+
+        target.reset()
+
+        result.passed = test_count == test_pass_count
+        return result
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='pyOCD flash test')
+    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
+    parser.add_argument("-da", "--daparg", dest="daparg", nargs='+', help="Send setting to DAPAccess layer.")
+    args = parser.parse_args()
+    level = logging.DEBUG if args.debug else logging.INFO
+    logging.basicConfig(level=level)
+    DAPAccess.set_args(args.daparg)
+    # Set to debug to print some of the decisions made while flashing
+    board = pyOCD.board.mbed_board.MbedBoard.getAllConnectedBoards(close=True)[0]
+    test = FlashTest()
+    result = [test.run(board)]
+    test.print_perf_info(result)
+
```

### Comparing `pyOCD-0.8.1a1/test/gdb_script.py` & `pyOCD-0.9.0/test/gdb_script.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,497 +1,503 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-# Notes about this script
-# 1. This script runs inside arm-none-eabi-gdb-py
-# 2. GDB processes commands inside a queue on a worker
-#    thread.  Commands that change the state of the target
-#    should run from this queue via gdb.post_event(cb).
-# 3. After running a command that changes the state of a target
-#    in the background, like "continue&", the code needs to
-#    return so the event processing that occurs on the worker
-#    thread can continue.  No target state changes will be
-#    seen until the worker thread gets a chance to process the data.
-# 4. To make the code flow better with #3 the main test function,
-#    run_test, takes advantage of the 'yield' call.  After
-#    performing a background operation that causes the target run
-#    'yield' must be called with a timeout value.  The code
-#    will wait for the target to halt for the time specified and
-#    if no signal arrives in that time the target is explicitly
-#    halted.
-# 5. Only use packages in the standard library in this script.
-#    Since the current version of arm-none-eabi-gdb-py.exe is
-#    only 32 bit on windows, there must be a 32 bit python
-#    install for it to work.  If your primary version of python
-#    is 64 bit, you can install the 32 bit version as a non
-#    primary version.  This will allow arm-none-eabi-gdb-py.exe
-#    to work.  The only problem with this is that when pyOCD
-#    is installed through pip only the 64 bit version of
-#    pyOCD and it's dependencies will get installed.
-#    If only the standard library is used here then this
-#    script will have no external dependencies.
-
-import gdb
-from time import time
-from threading import Timer
-from functools import partial
-from random import randrange
-from itertools import product
-import traceback
-import json
-
-DEFAULT_TIMEOUT = 2.0
-STACK_OFFSET = 0x800
-TEST_RAM_OFFSET = 0x800
-MAX_TEST_SIZE = 0x1000
-MAX_BKPT = 10
-
-assert STACK_OFFSET < MAX_TEST_SIZE
-assert TEST_RAM_OFFSET < MAX_TEST_SIZE
-
-TEST_PARAM_FILE = "test_params.txt"
-TEST_RESULT_FILE = "test_results.txt"
-
-monitor_commands = [
-    "help",
-    "help reset",
-    "help halt",
-    "help resume",
-    "init",
-    "reset",
-    "reset halt",
-    "reset halt resume",
-    "halt",
-    "resume",
-    "reg",
-    "arm semihosting enable",
-    "arm semihosting disable",
-    # Invalid Command
-    "fawehfawoefhad"
-]
-
-SIZE_TO_C_TYPE = {
-    1: "uint8_t*",
-    2: "uint16_t*",
-    4: "uint32_t*",
-}
-
-TO_GDB_ACCESS = {
-    "read": gdb.WP_READ,
-    "write": gdb.WP_WRITE,
-    "read_write": gdb.WP_ACCESS,
-}
-
-
-def test_step_type(step_type):
-    step_count = 20
-    start = time()
-    for _ in range(step_count):
-        gdb.execute(step_type)
-    end = time()
-    seconds_per_operation = (end - start) / step_count
-    return seconds_per_operation
-
-
-def is_event_breakpoint(event, bkpt=None):
-    if not isinstance(event, gdb.BreakpointEvent):
-        return False
-    if bkpt is None:
-        return True
-    return event.breakpoints[-1] is bkpt
-
-
-def is_event_signal(event, signal_name):
-    if not isinstance(event, gdb.SignalEvent):
-        return False
-    return event.stop_signal == signal_name
-
-
-def has_read(name):
-    if name == "read":
-        return True
-    if name == "read_write":
-        return True
-    assert name == "write"
-    return False
-
-
-def has_write(name):
-    if name == "write":
-        return True
-    if name == "read_write":
-        return True
-    assert name == "read"
-    return False
-
-
-def size_to_type(size):
-    return SIZE_TO_C_TYPE[size]
-
-
-def to_gdb_access(access):
-    return TO_GDB_ACCESS[access]
-
-
-def should_trigger_break(bkpt_size, bkpt_access,
-                         bkpt_addr, size, access, addr):
-    left_access_addr = addr
-    right_access_addr = addr + size - 1
-    left_bkpt_addr = bkpt_addr
-    right_bkpt_addr = bkpt_addr + bkpt_size
-    overlap = (left_access_addr <= right_bkpt_addr and
-               right_access_addr >= left_bkpt_addr)
-    read_break = has_read(bkpt_access) and has_read(access)
-    write_break = has_write(bkpt_access) and has_write(access)
-    should_break = overlap and (read_break or write_break)
-    return should_break
-
-
-def valid_watchpoint(bkpt_size, bkpt_access, bkpt_addr):
-    # Unaligned breakpoints are not allowed
-    return bkpt_addr % bkpt_size == 0
-
-
-# Initial setup
-with open(TEST_PARAM_FILE, "rb") as f:
-    test_params = json.loads(f.read())
-
-
-def run_test():
-
-    test_result = {}
-    rom_start = test_params['rom_start']
-    ram_start = test_params['ram_start']
-    ram_length = test_params['ram_length']
-    invalid_addr = test_params["invalid_start"]
-    error_on_invalid_access = test_params["expect_error_on_invalid_access"]
-    ignore_hw_bkpt_result = test_params["ignore_hw_bkpt_result"]
-
-    assert ram_length >= MAX_TEST_SIZE
-    stack_addr = ram_start + STACK_OFFSET
-    test_ram_addr = ram_start + TEST_RAM_OFFSET
-
-    fail_count = 0
-    try:
-        # Turn off confirmations that would block the script
-        gdb.execute("set pagination off")
-        gdb.execute("set confirm off")
-
-        # Allow GDB to access even unmapped regions
-        gdb.execute("set mem inaccessible-by-default off")
-
-        # Set raw logging
-        gdb.execute("set remotelogfile gdb_test_raw.txt")
-
-        # Connect to server
-        gdb.execute("target remote localhost:3334")
-
-        # Possibly useful other commands for reference:
-        # info breakpoints
-        # info mem
-        # show code-cache
-        # show stack-cache
-        # show dcache
-        # show mem inaccessible-by-default
-        # show can-use-hw-watchpoints
-        # info all-registers
-        # set logging file gdb.txt
-        # set logging on
-
-        # Test running the monitor commands
-        for command in monitor_commands:
-            gdb.execute("mon %s" % command)
-
-        # Reset the target and let it run so it has
-        # a chance to disable the watchdog
-        gdb.execute("mon reset halt")
-        gdb.execute("c&")
-        event = yield(0.1)
-        if not is_event_signal(event, "SIGINT"):
-            fail_count += 1
-            print("Error - target not interrupted as expected")
-
-        # Load test program and symbols
-        test_binary = "gdb_test_program/gdb_test.bin"
-        test_elf = "gdb_test_program/gdb_test.elf"
-        gdb.execute("restore %s binary 0x%x" % (test_binary, ram_start))
-        gdb.execute("add-symbol-file %s 0x%x" % (test_elf, ram_start))
-
-        # Set pc to the test program.  Make sure
-        # interrupts are disabled to prevent
-        # other code from running.
-        gdb.execute("set $primask = 1")
-        gdb.execute("set $sp = 0x%x" % stack_addr)
-        gdb.execute("b main")
-        breakpoint = gdb.Breakpoint("main")
-        gdb.execute("set $pc = main")
-        gdb.execute("c&")
-        event = yield(DEFAULT_TIMEOUT)
-        if not is_event_breakpoint(event, breakpoint):
-            fail_count += 1
-            print("Error - could not set pc to function")
-        breakpoint.delete()
-
-        # Test the speed of the different step types
-        test_result["step_time_si"] = test_step_type("si")
-        test_result["step_time_s"] = test_step_type("s")
-        test_result["step_time_n"] = test_step_type("n")
-        # TODO,c1728p9 - test speed getting stack trace
-        # TODO,c1728p9 - test speed with cache turned on
-        # TODO,c1728p9 - check speed vs breakpoints
-
-        # Let target run to initialize variables
-        gdb.execute("c&")
-        event = yield(0.1)
-        if not is_event_signal(event, "SIGINT"):
-            fail_count += 1
-            print("Error - target not interrupted as expected")
-
-        # Check number of supported breakpoints, along
-        # with graceful handling of a request using
-        # more than the supported number of breakpoints
-        break_list = []
-        for i in range(MAX_BKPT):
-            addr = rom_start + i * 4
-            breakpoint = gdb.Breakpoint("*0x%x" % addr)
-            break_list.append(breakpoint)
-        while True:
-            try:
-                gdb.execute("c&")
-                yield(0.1)
-                break
-            except gdb.error:
-                bkpt = break_list.pop()
-                bkpt.delete()
-        test_result["breakpoint_count"] = len(break_list)
-        for bkpt in break_list:
-            bkpt.delete()
-
-        # Check number of supported watchpoints, along
-        # with graceful handling of a request using
-        # more than the supported number of watchpoints
-        watch_list = []
-        for i in range(MAX_BKPT):
-            addr = rom_start + i * 4
-            breakpoint = gdb.Breakpoint("*0x%x" % addr,
-                                        gdb.BP_WATCHPOINT, gdb.WP_ACCESS)
-            watch_list.append(breakpoint)
-        while True:
-            try:
-                gdb.execute("c&")
-                yield(0.1)
-                break
-            except gdb.error:
-                bkpt = watch_list.pop()
-                bkpt.delete()
-        test_result["watchpoint_count"] = len(watch_list)
-        for bkpt in watch_list:
-            bkpt.delete()
-
-        # Make sure breakpoint is hit as expected
-        rmt_func = "breakpoint_test"
-        gdb.execute("set var run_breakpoint_test = 1")
-        breakpoint = gdb.Breakpoint(rmt_func)
-        gdb.execute("c&")
-        event = yield(DEFAULT_TIMEOUT)
-        if not is_event_breakpoint(event, breakpoint):
-            fail_count += 1
-            print("Error - breakpoint 1 test failed")
-        func_name = gdb.selected_frame().function().name
-        if rmt_func != func_name:
-            fail_count += 1
-            print("ERROR - break occurred at wrong function %s" % func_name)
-        breakpoint.delete()
-        gdb.execute("set var run_breakpoint_test = 0")
-
-        # Let target run, make sure breakpoint isn't hit
-        gdb.execute("set var run_breakpoint_test = 1")
-        gdb.execute("c&")
-        event = yield(0.1)
-        if not is_event_signal(event, "SIGINT"):
-            fail_count += 1
-            print("Error - target not interrupted as expected")
-        gdb.execute("set var run_breakpoint_test = 0")
-
-        # Make sure hardware breakpoint is hit as expected
-        rmt_func = "breakpoint_test"
-        gdb.execute("set var run_breakpoint_test = 1")
-        gdb.execute("hbreak %s" % rmt_func)
-        gdb.execute("c&")
-        event = yield(DEFAULT_TIMEOUT)
-# TODO, c1728p9 - determine why there isn't a breakpoint event returned
-#         if not is_event_breakpoint(event):
-#             fail_count += 1
-#             print("Error - breakpoint 2 test failed")
-        func_name = gdb.selected_frame().function().name
-        if rmt_func != func_name and not ignore_hw_bkpt_result:
-            fail_count += 1
-            print("ERROR - break occurred at wrong function %s" % func_name)
-        gdb.execute("clear %s" % rmt_func)
-        gdb.execute("set var run_breakpoint_test = 0")
-
-        # Test valid memory write
-        addr_value_list = [(test_ram_addr + i * 4,
-                           randrange(1, 50)) for i in range(4)]
-        for addr, value in addr_value_list:
-            gdb.execute("set *((int *) 0x%x) = 0x%x" % (addr, value))
-
-        # Test invalid memory write
-        invalid_addr_list = [invalid_addr + i * 4 for i in range(4)]
-        for addr in invalid_addr_list:
-            try:
-                gdb.execute("x 0x%x" % addr)
-                if error_on_invalid_access:
-                    fail_count += 1
-            except gdb.MemoryError:
-                pass
-
-        # Test valid memory read
-        for addr, value in addr_value_list:
-            val_read = gdb.parse_and_eval("*((int *) 0x%x)" % addr)
-            val_read = int(val_read)
-            assert value == val_read
-
-        # Test invalid memory read
-        for addr in invalid_addr_list:
-            try:
-                gdb.execute("x 0x%x" % addr)
-                if error_on_invalid_access:
-                    fail_count += 1
-            except gdb.MemoryError:
-                pass
-
-        # Test watchpoints
-        access_addr = long(gdb.parse_and_eval("&watchpoint_write_buffer[1]"))
-        bkpt_sizes = [1, 2, 4]
-        bkpt_accesses = ["read", "write", "read_write"]
-        # use "range(-4, 8, 1)" for extended testing
-        bkpt_addresses = [access_addr + offset for offset in range(0, 4, 1)]
-        sizes = [1, 2, 4]
-        accesses = ["read", "write", "read_write"]
-        addresses = [access_addr]
-        generator = product(bkpt_sizes, bkpt_accesses, bkpt_addresses,
-                            sizes, accesses, addresses)
-        for bkpt_size, bkpt_access, bkpt_addr, size, access, addr in generator:
-            gdb_size = size_to_type(bkpt_size)
-            gdb_access = to_gdb_access(bkpt_access)
-            gdb.execute("set var watchpoint_write = %i" %
-                        (1 if has_write(access) else 0))
-            gdb.execute("set var watchpoint_read = %i" %
-                        (1 if has_read(access) else 0))
-            gdb.execute("set var watchpoint_size = %i" % size)
-            gdb.execute("set var write_address = %i" % addr)
-            breakpoint = gdb.Breakpoint("*(%s)0x%x" % (gdb_size, bkpt_addr),
-                                        gdb.BP_WATCHPOINT, gdb_access)
-
-            # Run until breakpoint is hit
-            gdb.execute("c&")
-            event = yield(0.1)
-            bkpt_hit = not is_event_signal(event, "SIGINT")
-
-            # Compare against expected result
-            should_break = should_trigger_break(bkpt_size, bkpt_access,
-                                                bkpt_addr, size, access, addr)
-            valid = valid_watchpoint(bkpt_size, bkpt_access, bkpt_addr)
-
-            if valid and bkpt_hit != should_break:
-                fail_count += 1
-                print("Error - watchpoint problem:")
-                print("  Watchpoint was hit %s" % bkpt_hit)
-                print("  Watchpoint should be hit %s" % should_break)
-                print("  bkpt_size %s, bkpt_access %s, bkpt_address 0x%x, "
-                      "size %s, access %s, addr 0x%x" %
-                      (bkpt_size, bkpt_access, bkpt_addr, size, access, addr))
-                print()
-
-            breakpoint.delete()
-
-        # TODO,c1728p9 - test reading/writing registers
-
-        # TODO,c1728p9 - test stepping into interrupts
-
-        # TODO,c1728p9 - test vector catch
-            # -test hard fault handling
-            # -test reset catch
-        # TODO,c1728p9 - test signals/hard fault
-
-        if fail_count:
-            print("Test completed with %i errors" % fail_count)
-        else:
-            print("Test completed successfully")
-    except:
-        print("Main Error:")
-        traceback.print_exc()
-        fail_count += 1
-    finally:
-        test_result["fail_count"] = fail_count
-        with open(TEST_RESULT_FILE, "wb") as f:
-            f.write(json.dumps(test_result))
-        gdb.execute("detach")
-        gdb.execute("quit %i" % fail_count)
-
-
-ignore_events = True
-interrupt_timer = None
-interrupt_arg = None
-generator = run_test()
-
-
-# Post task to halt the processor
-def post_interrupt_task(interrupt_arg):
-    # Halt the target by interrupting it
-    # This must only run on GDB's queue
-    def interrupt_task():
-        if not interrupt_arg["aborted"]:
-            gdb.execute("interrupt")
-    gdb.post_event(interrupt_task)
-
-
-# Run the main test by repreatedly calling the generator
-# This must only run on GDB's queue
-def run_generator(event):
-    global ignore_events
-    global interrupt_timer
-    global interrupt_arg
-    ignore_events = True
-    if interrupt_timer is not None:
-        interrupt_timer.cancel()
-        interrupt_arg["aborted"] = True
-    interrupt_arg = None
-    stop_delay = 0
-    try:
-        stop_delay = generator.send(event)
-    except:
-        print("Error")
-        traceback.print_exc()
-    interrupt_arg = {"aborted": False}
-    interrupt_timer = Timer(stop_delay, post_interrupt_task, [interrupt_arg])
-    interrupt_timer.start()
-    ignore_events = False
-
-
-# Runs on stop events and posts run_generator to the
-# main queue so it can continue execution
-def stop_handler(event):
-    if ignore_events:
-        return
-    bound_run_generator = partial(run_generator, event)
-    gdb.post_event(bound_run_generator)
-gdb.events.stop.connect(stop_handler)
-
-# Start testing
-bound_run_generator = partial(run_generator, None)
-gdb.post_event(bound_run_generator)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+# Notes about this script
+# 1. This script runs inside arm-none-eabi-gdb-py
+# 2. GDB processes commands inside a queue on a worker
+#    thread.  Commands that change the state of the target
+#    should run from this queue via gdb.post_event(cb).
+# 3. After running a command that changes the state of a target
+#    in the background, like "continue&", the code needs to
+#    return so the event processing that occurs on the worker
+#    thread can continue.  No target state changes will be
+#    seen until the worker thread gets a chance to process the data.
+# 4. To make the code flow better with #3 the main test function,
+#    run_test, takes advantage of the 'yield' call.  After
+#    performing a background operation that causes the target run
+#    'yield' must be called with a timeout value.  The code
+#    will wait for the target to halt for the time specified and
+#    if no signal arrives in that time the target is explicitly
+#    halted.
+# 5. Only use packages in the standard library in this script.
+#    Since the current version of arm-none-eabi-gdb-py.exe is
+#    only 32 bit on windows, there must be a 32 bit python
+#    install for it to work.  If your primary version of python
+#    is 64 bit, you can install the 32 bit version as a non
+#    primary version.  This will allow arm-none-eabi-gdb-py.exe
+#    to work.  The only problem with this is that when pyOCD
+#    is installed through pip only the 64 bit version of
+#    pyOCD and it's dependencies will get installed.
+#    If only the standard library is used here then this
+#    script will have no external dependencies.
+
+import gdb
+from time import time
+from threading import Timer
+from functools import partial
+from random import randrange
+from itertools import product
+import traceback
+import json
+
+DEFAULT_TIMEOUT = 2.0
+STACK_OFFSET = 0x800
+TEST_RAM_OFFSET = 0x800
+MAX_TEST_SIZE = 0x1000
+MAX_BKPT = 10
+
+assert STACK_OFFSET < MAX_TEST_SIZE
+assert TEST_RAM_OFFSET < MAX_TEST_SIZE
+
+TEST_PARAM_FILE = "test_params.txt"
+TEST_RESULT_FILE = "test_results.txt"
+
+monitor_commands = [
+    "help",
+    "help reset",
+    "help halt",
+    "help resume",
+    "init",
+    "reset",
+    "reset halt",
+    "reset halt resume",
+    "halt",
+    "resume",
+    "reg",
+    "arm semihosting enable",
+    "arm semihosting disable",
+    # Invalid Command
+    "fawehfawoefhad"
+]
+
+SIZE_TO_C_TYPE = {
+    1: "uint8_t*",
+    2: "uint16_t*",
+    4: "uint32_t*",
+}
+
+TO_GDB_ACCESS = {
+    "read": gdb.WP_READ,
+    "write": gdb.WP_WRITE,
+    "read_write": gdb.WP_ACCESS,
+}
+
+
+def test_step_type(step_type):
+    step_count = 20
+    start = time()
+    for _ in range(step_count):
+        gdb.execute(step_type)
+    end = time()
+    seconds_per_operation = (end - start) / step_count
+    return seconds_per_operation
+
+
+def is_event_breakpoint(event, bkpt=None):
+    if not isinstance(event, gdb.BreakpointEvent):
+        return False
+    if bkpt is None:
+        return True
+    return event.breakpoints[-1] is bkpt
+
+
+def is_event_signal(event, signal_name):
+    if not isinstance(event, gdb.SignalEvent):
+        return False
+    return event.stop_signal == signal_name
+
+
+def has_read(name):
+    if name == "read":
+        return True
+    if name == "read_write":
+        return True
+    assert name == "write"
+    return False
+
+
+def has_write(name):
+    if name == "write":
+        return True
+    if name == "read_write":
+        return True
+    assert name == "read"
+    return False
+
+
+def size_to_type(size):
+    return SIZE_TO_C_TYPE[size]
+
+
+def to_gdb_access(access):
+    return TO_GDB_ACCESS[access]
+
+
+def should_trigger_break(bkpt_size, bkpt_access,
+                         bkpt_addr, size, access, addr):
+    left_access_addr = addr
+    right_access_addr = addr + size - 1
+    left_bkpt_addr = bkpt_addr
+    right_bkpt_addr = bkpt_addr + bkpt_size
+    overlap = (left_access_addr <= right_bkpt_addr and
+               right_access_addr >= left_bkpt_addr)
+    read_break = has_read(bkpt_access) and has_read(access)
+    write_break = has_write(bkpt_access) and has_write(access)
+    should_break = overlap and (read_break or write_break)
+    return should_break
+
+
+def valid_watchpoint(bkpt_size, bkpt_access, bkpt_addr):
+    # Unaligned breakpoints are not allowed
+    return bkpt_addr % bkpt_size == 0
+
+
+# Initial setup
+with open(TEST_PARAM_FILE, "rb") as f:
+    test_params = json.loads(f.read())
+
+
+def run_test():
+
+    test_result = {}
+    rom_start = test_params['rom_start']
+    ram_start = test_params['ram_start']
+    ram_length = test_params['ram_length']
+    invalid_addr = test_params["invalid_start"]
+    error_on_invalid_access = test_params["expect_error_on_invalid_access"]
+    ignore_hw_bkpt_result = test_params["ignore_hw_bkpt_result"]
+
+    assert ram_length >= MAX_TEST_SIZE
+    stack_addr = ram_start + STACK_OFFSET
+    test_ram_addr = ram_start + TEST_RAM_OFFSET
+
+    fail_count = 0
+    try:
+        # Turn off confirmations that would block the script
+        gdb.execute("set pagination off")
+        gdb.execute("set confirm off")
+
+        # Allow GDB to access even unmapped regions
+        gdb.execute("set mem inaccessible-by-default off")
+
+        # Set raw logging
+        gdb.execute("set remotelogfile gdb_test_raw.txt")
+
+        # Connect to server
+        gdb.execute("target remote localhost:3334")
+
+        # Possibly useful other commands for reference:
+        # info breakpoints
+        # info mem
+        # show code-cache
+        # show stack-cache
+        # show dcache
+        # show mem inaccessible-by-default
+        # show can-use-hw-watchpoints
+        # info all-registers
+        # set logging file gdb.txt
+        # set logging on
+
+        # Test running the monitor commands
+        for command in monitor_commands:
+            gdb.execute("mon %s" % command)
+
+        # Reset the target and let it run so it has
+        # a chance to disable the watchdog
+        gdb.execute("mon reset halt")
+        gdb.execute("c&")
+        event = yield(0.1)
+        if not is_event_signal(event, "SIGINT"):
+            fail_count += 1
+            print("Error - target not interrupted as expected")
+
+        # Load test program and symbols
+        test_binary = "../src/gdb_test_program/gdb_test.bin"
+        test_elf = "../src/gdb_test_program/gdb_test.elf"
+        gdb.execute("restore %s binary 0x%x" % (test_binary, ram_start))
+        gdb.execute("add-symbol-file %s 0x%x" % (test_elf, ram_start))
+
+        # Set pc to the test program.  Make sure
+        # interrupts are disabled to prevent
+        # other code from running.
+        gdb.execute("set $primask = 1")
+        gdb.execute("set $sp = 0x%x" % stack_addr)
+        gdb.execute("b main")
+        breakpoint = gdb.Breakpoint("main")
+        gdb.execute("set $pc = main")
+        gdb.execute("c&")
+        event = yield(DEFAULT_TIMEOUT)
+        if not is_event_breakpoint(event, breakpoint):
+            fail_count += 1
+            print("Error - could not set pc to function")
+        breakpoint.delete()
+
+## Stepping removed as a workaround for a GDB bug. Launchpad issue tracking this is here:
+## https://bugs.launchpad.net/gcc-arm-embedded/+bug/1700595
+#
+#        # Test the speed of the different step types
+#        test_result["step_time_si"] = test_step_type("si")
+#        test_result["step_time_s"] = test_step_type("s")
+#        test_result["step_time_n"] = test_step_type("n")
+        test_result["step_time_si"] = -1
+        test_result["step_time_s"] = -1
+        test_result["step_time_n"] = -1
+        # TODO,c1728p9 - test speed getting stack trace
+        # TODO,c1728p9 - test speed with cache turned on
+        # TODO,c1728p9 - check speed vs breakpoints
+
+        # Let target run to initialize variables
+        gdb.execute("c&")
+        event = yield(0.1)
+        if not is_event_signal(event, "SIGINT"):
+            fail_count += 1
+            print("Error - target not interrupted as expected")
+
+        # Check number of supported breakpoints, along
+        # with graceful handling of a request using
+        # more than the supported number of breakpoints
+        break_list = []
+        for i in range(MAX_BKPT):
+            addr = rom_start + i * 4
+            breakpoint = gdb.Breakpoint("*0x%x" % addr)
+            break_list.append(breakpoint)
+        while True:
+            try:
+                gdb.execute("c&")
+                yield(0.1)
+                break
+            except gdb.error:
+                bkpt = break_list.pop()
+                bkpt.delete()
+        test_result["breakpoint_count"] = len(break_list)
+        for bkpt in break_list:
+            bkpt.delete()
+
+        # Check number of supported watchpoints, along
+        # with graceful handling of a request using
+        # more than the supported number of watchpoints
+        watch_list = []
+        for i in range(MAX_BKPT):
+            addr = rom_start + i * 4
+            breakpoint = gdb.Breakpoint("*0x%x" % addr,
+                                        gdb.BP_WATCHPOINT, gdb.WP_ACCESS)
+            watch_list.append(breakpoint)
+        while True:
+            try:
+                gdb.execute("c&")
+                yield(0.1)
+                break
+            except gdb.error:
+                bkpt = watch_list.pop()
+                bkpt.delete()
+        test_result["watchpoint_count"] = len(watch_list)
+        for bkpt in watch_list:
+            bkpt.delete()
+
+        # Make sure breakpoint is hit as expected
+        rmt_func = "breakpoint_test"
+        gdb.execute("set var run_breakpoint_test = 1")
+        breakpoint = gdb.Breakpoint(rmt_func)
+        gdb.execute("c&")
+        event = yield(DEFAULT_TIMEOUT)
+        if not is_event_breakpoint(event, breakpoint):
+            fail_count += 1
+            print("Error - breakpoint 1 test failed")
+        func_name = gdb.selected_frame().function().name
+        if rmt_func != func_name:
+            fail_count += 1
+            print("ERROR - break occurred at wrong function %s" % func_name)
+        breakpoint.delete()
+        gdb.execute("set var run_breakpoint_test = 0")
+
+        # Let target run, make sure breakpoint isn't hit
+        gdb.execute("set var run_breakpoint_test = 1")
+        gdb.execute("c&")
+        event = yield(0.1)
+        if not is_event_signal(event, "SIGINT"):
+            fail_count += 1
+            print("Error - target not interrupted as expected")
+        gdb.execute("set var run_breakpoint_test = 0")
+
+        # Make sure hardware breakpoint is hit as expected
+        rmt_func = "breakpoint_test"
+        gdb.execute("set var run_breakpoint_test = 1")
+        gdb.execute("hbreak %s" % rmt_func)
+        gdb.execute("c&")
+        event = yield(DEFAULT_TIMEOUT)
+# TODO, c1728p9 - determine why there isn't a breakpoint event returned
+#         if not is_event_breakpoint(event):
+#             fail_count += 1
+#             print("Error - breakpoint 2 test failed")
+        func_name = gdb.selected_frame().function().name
+        if rmt_func != func_name and not ignore_hw_bkpt_result:
+            fail_count += 1
+            print("ERROR - break occurred at wrong function %s" % func_name)
+        gdb.execute("clear %s" % rmt_func)
+        gdb.execute("set var run_breakpoint_test = 0")
+
+        # Test valid memory write
+        addr_value_list = [(test_ram_addr + i * 4,
+                           randrange(1, 50)) for i in range(4)]
+        for addr, value in addr_value_list:
+            gdb.execute("set *((int *) 0x%x) = 0x%x" % (addr, value))
+
+        # Test invalid memory write
+        invalid_addr_list = [invalid_addr + i * 4 for i in range(4)]
+        for addr in invalid_addr_list:
+            try:
+                gdb.execute("x 0x%x" % addr)
+                if error_on_invalid_access:
+                    fail_count += 1
+            except gdb.MemoryError:
+                pass
+
+        # Test valid memory read
+        for addr, value in addr_value_list:
+            val_read = gdb.parse_and_eval("*((int *) 0x%x)" % addr)
+            val_read = int(val_read)
+            assert value == val_read
+
+        # Test invalid memory read
+        for addr in invalid_addr_list:
+            try:
+                gdb.execute("x 0x%x" % addr)
+                if error_on_invalid_access:
+                    fail_count += 1
+            except gdb.MemoryError:
+                pass
+
+        # Test watchpoints
+        access_addr = long(gdb.parse_and_eval("&watchpoint_write_buffer[1]"))
+        bkpt_sizes = [1, 2, 4]
+        bkpt_accesses = ["read", "write", "read_write"]
+        # use "range(-4, 8, 1)" for extended testing
+        bkpt_addresses = [access_addr + offset for offset in range(0, 4, 1)]
+        sizes = [1, 2, 4]
+        accesses = ["read", "write", "read_write"]
+        addresses = [access_addr]
+        generator = product(bkpt_sizes, bkpt_accesses, bkpt_addresses,
+                            sizes, accesses, addresses)
+        for bkpt_size, bkpt_access, bkpt_addr, size, access, addr in generator:
+            gdb_size = size_to_type(bkpt_size)
+            gdb_access = to_gdb_access(bkpt_access)
+            gdb.execute("set var watchpoint_write = %i" %
+                        (1 if has_write(access) else 0))
+            gdb.execute("set var watchpoint_read = %i" %
+                        (1 if has_read(access) else 0))
+            gdb.execute("set var watchpoint_size = %i" % size)
+            gdb.execute("set var write_address = %i" % addr)
+            breakpoint = gdb.Breakpoint("*(%s)0x%x" % (gdb_size, bkpt_addr),
+                                        gdb.BP_WATCHPOINT, gdb_access)
+
+            # Run until breakpoint is hit
+            gdb.execute("c&")
+            event = yield(0.1)
+            bkpt_hit = not is_event_signal(event, "SIGINT")
+
+            # Compare against expected result
+            should_break = should_trigger_break(bkpt_size, bkpt_access,
+                                                bkpt_addr, size, access, addr)
+            valid = valid_watchpoint(bkpt_size, bkpt_access, bkpt_addr)
+
+            if valid and bkpt_hit != should_break:
+                fail_count += 1
+                print("Error - watchpoint problem:")
+                print("  Watchpoint was hit %s" % bkpt_hit)
+                print("  Watchpoint should be hit %s" % should_break)
+                print("  bkpt_size %s, bkpt_access %s, bkpt_address 0x%x, "
+                      "size %s, access %s, addr 0x%x" %
+                      (bkpt_size, bkpt_access, bkpt_addr, size, access, addr))
+                print()
+
+            breakpoint.delete()
+
+        # TODO,c1728p9 - test reading/writing registers
+
+        # TODO,c1728p9 - test stepping into interrupts
+
+        # TODO,c1728p9 - test vector catch
+            # -test hard fault handling
+            # -test reset catch
+        # TODO,c1728p9 - test signals/hard fault
+
+        if fail_count:
+            print("Test completed with %i errors" % fail_count)
+        else:
+            print("Test completed successfully")
+    except:
+        print("Main Error:")
+        traceback.print_exc()
+        fail_count += 1
+    finally:
+        test_result["fail_count"] = fail_count
+        with open(TEST_RESULT_FILE, "wb") as f:
+            f.write(json.dumps(test_result))
+        gdb.execute("detach")
+        gdb.execute("quit %i" % fail_count)
+
+
+ignore_events = True
+interrupt_timer = None
+interrupt_arg = None
+generator = run_test()
+
+
+# Post task to halt the processor
+def post_interrupt_task(interrupt_arg):
+    # Halt the target by interrupting it
+    # This must only run on GDB's queue
+    def interrupt_task():
+        if not interrupt_arg["aborted"]:
+            gdb.execute("interrupt")
+    gdb.post_event(interrupt_task)
+
+
+# Run the main test by repreatedly calling the generator
+# This must only run on GDB's queue
+def run_generator(event):
+    global ignore_events
+    global interrupt_timer
+    global interrupt_arg
+    ignore_events = True
+    if interrupt_timer is not None:
+        interrupt_timer.cancel()
+        interrupt_arg["aborted"] = True
+    interrupt_arg = None
+    stop_delay = 0
+    try:
+        stop_delay = generator.send(event)
+    except:
+        print("Error")
+        traceback.print_exc()
+    interrupt_arg = {"aborted": False}
+    interrupt_timer = Timer(stop_delay, post_interrupt_task, [interrupt_arg])
+    interrupt_timer.start()
+    ignore_events = False
+
+
+# Runs on stop events and posts run_generator to the
+# main queue so it can continue execution
+def stop_handler(event):
+    if ignore_events:
+        return
+    bound_run_generator = partial(run_generator, event)
+    gdb.post_event(bound_run_generator)
+gdb.events.stop.connect(stop_handler)
+
+# Start testing
+bound_run_generator = partial(run_generator, None)
+gdb.post_event(bound_run_generator)
```

### Comparing `pyOCD-0.8.1a1/test/gdb_server_json_test.py` & `pyOCD-0.9.0/test/gdb_server_json_test.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,191 +1,191 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-import argparse, os, sys
-from time import sleep, time
-from random import randrange
-import math
-import argparse
-import subprocess
-import json
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-sys.path.insert(0, parentdir)
-
-import pyOCD
-from pyOCD import __version__
-from pyOCD.board import MbedBoard
-from pyOCD.utility.conversion import float32beToU32be
-from pyOCD.pyDAPAccess import DAPAccess
-from test_util import Test, TestResult
-import logging
-from random import randrange
-
-class GdbServerJsonTestResult(TestResult):
-    def __init__(self):
-        super(GdbServerJsonTestResult, self).__init__(None, None, None)
-
-class GdbServerJsonTest(Test):
-    def __init__(self):
-        super(GdbServerJsonTest, self).__init__("Gdb Server Json Test", gdb_server_json_test)
-
-    def print_perf_info(self, result_list, output_file=None):
-        pass
-
-    def run(self, board):
-        try:
-            result = self.test_function(board.getUniqueID())
-        except Exception as e:
-            result = GdbServerJsonTestResult()
-            result.passed = False
-            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
-        result.board = board
-        result.test = self
-        return result
-
-def gdb_server_json_test(board_id):
-
-    test_count = 0
-    test_pass_count = 0
-
-    def validate_basic_keys(data):
-        did_pass = True
-
-        print 'pyocd_version',
-        p = data.has_key('pyocd_version')
-        if p:
-            p = data['pyocd_version'] == __version__
-        if p:
-            print "PASSED"
-        else:
-            did_pass = False
-            print"FAILED"
-
-        print 'version',
-        p = data.has_key('version')
-        if p:
-            v = data['version']
-            p = v.has_key('major') and v.has_key('minor')
-        if p:
-            p = v['major'] == 1 and v['minor'] == 0
-        if p:
-            print "PASSED"
-        else:
-            did_pass = False
-            print"FAILED"
-
-        print 'status',
-        p = data.has_key('status')
-        if p:
-            p = data['status'] == 0
-        if p:
-            print "PASSED"
-        else:
-            did_pass = False
-            print"FAILED"
-
-        return did_pass
-
-    def validate_boards(data):
-        did_pass = True
-
-        print 'boards',
-        p = data.has_key('boards') and type(data['boards']) is list
-        if p:
-            b = data['boards']
-        if p:
-            print "PASSED"
-        else:
-            did_pass = False
-            print"FAILED"
-
-        try:
-            all_mbeds = MbedBoard.getAllConnectedBoards(close=True, blocking=False)
-            p = len(all_mbeds) == len(b)
-            matching_boards = 0
-            if p:
-                for mbed in all_mbeds:
-                    for brd in b:
-                        if mbed.unique_id == brd['unique_id']:
-                            matching_boards += 1
-                            p = brd.has_key('info') and brd.has_key('target') and brd.has_key('board_name')
-                            if not p:
-                                break
-                    if not p:
-                        break
-                p = matching_boards == len(all_mbeds)
-            if p:
-                print "PASSED"
-            else:
-                did_pass = False
-                print"FAILED"
-        except Exception:
-            print "FAILED"
-            did_pass = False
-
-        return did_pass
-
-    def validate_targets(data):
-        did_pass = True
-
-        print 'targets',
-        p = data.has_key('targets') and type(data['targets']) is list
-        if p:
-            targets = data['targets']
-            for t in targets:
-                p = t.has_key('name') and t.has_key('part_number')
-                if not p:
-                    break
-        if p:
-            print "PASSED"
-        else:
-            did_pass = False
-            print"FAILED"
-
-        return did_pass
-
-
-    result = GdbServerJsonTestResult()
-
-    print "\r\n\r\n----- TESTING BOARDS LIST -----"
-    out = subprocess.check_output(['pyocd-gdbserver', '--list', '--json'])
-    data = json.loads(out)
-    test_count += 2
-    if validate_basic_keys(data):
-        test_pass_count += 1
-    if validate_boards(data):
-        test_pass_count += 1
-
-    print "\r\n\r\n----- TESTING TARGETS LIST -----"
-    out = subprocess.check_output(['pyocd-gdbserver', '--list-targets', '--json'])
-    data = json.loads(out)
-    test_count += 2
-    if validate_basic_keys(data):
-        test_pass_count += 1
-    if validate_targets(data):
-        test_pass_count += 1
-
-    result.passed = test_count == test_pass_count
-    return result
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description='pyocd-gdbserver json output test')
-    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
-    args = parser.parse_args()
-    level = logging.DEBUG if args.debug else logging.INFO
-    logging.basicConfig(level=level)
-    gdb_server_json_test(None)
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+import argparse, os, sys
+from time import sleep, time
+from random import randrange
+import math
+import argparse
+import subprocess
+import json
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.insert(0, parentdir)
+
+import pyOCD
+from pyOCD import __version__
+from pyOCD.board import MbedBoard
+from pyOCD.utility.conversion import float32beToU32be
+from pyOCD.pyDAPAccess import DAPAccess
+from test_util import Test, TestResult
+import logging
+from random import randrange
+
+class GdbServerJsonTestResult(TestResult):
+    def __init__(self):
+        super(GdbServerJsonTestResult, self).__init__(None, None, None)
+
+class GdbServerJsonTest(Test):
+    def __init__(self):
+        super(GdbServerJsonTest, self).__init__("Gdb Server Json Test", gdb_server_json_test)
+
+    def print_perf_info(self, result_list, output_file=None):
+        pass
+
+    def run(self, board):
+        try:
+            result = self.test_function(board.getUniqueID())
+        except Exception as e:
+            result = GdbServerJsonTestResult()
+            result.passed = False
+            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
+        result.board = board
+        result.test = self
+        return result
+
+def gdb_server_json_test(board_id):
+
+    test_count = 0
+    test_pass_count = 0
+
+    def validate_basic_keys(data):
+        did_pass = True
+
+        print 'pyocd_version',
+        p = data.has_key('pyocd_version')
+        if p:
+            p = data['pyocd_version'] == __version__
+        if p:
+            print "PASSED"
+        else:
+            did_pass = False
+            print"FAILED"
+
+        print 'version',
+        p = data.has_key('version')
+        if p:
+            v = data['version']
+            p = v.has_key('major') and v.has_key('minor')
+        if p:
+            p = v['major'] == 1 and v['minor'] == 0
+        if p:
+            print "PASSED"
+        else:
+            did_pass = False
+            print"FAILED"
+
+        print 'status',
+        p = data.has_key('status')
+        if p:
+            p = data['status'] == 0
+        if p:
+            print "PASSED"
+        else:
+            did_pass = False
+            print"FAILED"
+
+        return did_pass
+
+    def validate_boards(data):
+        did_pass = True
+
+        print 'boards',
+        p = data.has_key('boards') and type(data['boards']) is list
+        if p:
+            b = data['boards']
+        if p:
+            print "PASSED"
+        else:
+            did_pass = False
+            print"FAILED"
+
+        try:
+            all_mbeds = MbedBoard.getAllConnectedBoards(close=True, blocking=False)
+            p = len(all_mbeds) == len(b)
+            matching_boards = 0
+            if p:
+                for mbed in all_mbeds:
+                    for brd in b:
+                        if mbed.unique_id == brd['unique_id']:
+                            matching_boards += 1
+                            p = brd.has_key('info') and brd.has_key('target') and brd.has_key('board_name')
+                            if not p:
+                                break
+                    if not p:
+                        break
+                p = matching_boards == len(all_mbeds)
+            if p:
+                print "PASSED"
+            else:
+                did_pass = False
+                print"FAILED"
+        except Exception:
+            print "FAILED"
+            did_pass = False
+
+        return did_pass
+
+    def validate_targets(data):
+        did_pass = True
+
+        print 'targets',
+        p = data.has_key('targets') and type(data['targets']) is list
+        if p:
+            targets = data['targets']
+            for t in targets:
+                p = t.has_key('name') and t.has_key('part_number')
+                if not p:
+                    break
+        if p:
+            print "PASSED"
+        else:
+            did_pass = False
+            print"FAILED"
+
+        return did_pass
+
+
+    result = GdbServerJsonTestResult()
+
+    print "\r\n\r\n----- TESTING BOARDS LIST -----"
+    out = subprocess.check_output(['pyocd-gdbserver', '--list', '--json'])
+    data = json.loads(out)
+    test_count += 2
+    if validate_basic_keys(data):
+        test_pass_count += 1
+    if validate_boards(data):
+        test_pass_count += 1
+
+    print "\r\n\r\n----- TESTING TARGETS LIST -----"
+    out = subprocess.check_output(['pyocd-gdbserver', '--list-targets', '--json'])
+    data = json.loads(out)
+    test_count += 2
+    if validate_basic_keys(data):
+        test_pass_count += 1
+    if validate_targets(data):
+        test_pass_count += 1
+
+    result.passed = test_count == test_pass_count
+    return result
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='pyocd-gdbserver json output test')
+    parser.add_argument('-d', '--debug', action="store_true", help='Enable debug logging')
+    args = parser.parse_args()
+    level = logging.DEBUG if args.debug else logging.INFO
+    logging.basicConfig(level=level)
+    gdb_server_json_test(None)
```

### Comparing `pyOCD-0.8.1a1/test/gdb_test.py` & `pyOCD-0.9.0/test/gdb_test.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,167 +1,158 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-
-# Note
-#  To run this script GNU Tools ARM Embedded must be installed,
-#  along with python for the same architecture.  The program
-#  "arm-none-eabi-gdb-py.exe" requires python for the same
-#  architecture (x86 or 64) to work correctly. Also, on windows
-#  the GNU Tools ARM Embedded bin directory needs to be added to
-#  your path.
-
-import os
-import json
-import sys
-from subprocess import Popen, STDOUT, PIPE
-
-from pyOCD.tools.gdb_server import GDBServerTool
-from pyOCD.board import MbedBoard
-from test_util import Test, TestResult
-
-# TODO, c1728p9 - run script several times with
-#       with different command line parameters
-
-TEST_PARAM_FILE = "test_params.txt"
-TEST_RESULT_FILE = "test_results.txt"
-PYTHON_GDB_FOR_OS = {
-    "linux": "arm-none-eabi-gdb",
-    "darwin": "arm-none-eabi-gdb-py",
-    "win": "arm-none-eabi-gdb-py",
-}
-PYTHON_GDB = None
-for prefix, program in PYTHON_GDB_FOR_OS.iteritems():
-    if sys.platform.startswith(prefix):
-        PYTHON_GDB = program
-        break
-
-
-parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-
-
-class GdbTestResult(TestResult):
-    def __init__(self):
-        super(self.__class__, self).__init__(None, None, None)
-
-
-class GdbTest(Test):
-    def __init__(self):
-        super(self.__class__, self).__init__("Gdb Test", test_gdb)
-
-    def print_perf_info(self, result_list, output_file=None):
-        pass
-
-    def run(self, board):
-        try:
-            result = self.test_function(board.getUniqueID())
-        except Exception as e:
-            result = GdbTestResult()
-            result.passed = False
-            print("Exception %s when testing board %s" %
-                  (e, board.getUniqueID()))
-        result.board = board
-        result.test = self
-        return result
-
-TEST_RESULT_KEYS = [
-    "breakpoint_count",
-    "watchpoint_count",
-    "step_time_si",
-    "step_time_s",
-    "step_time_n",
-    "fail_count",
-]
-
-
-def test_gdb(board_id=None):
-    result = GdbTestResult()
-    with MbedBoard.chooseBoard(board_id=board_id) as board:
-        memory_map = board.target.getMemoryMap()
-        ram_regions = [region for region in memory_map if region.type == 'ram']
-        ram_region = ram_regions[0]
-        rom_region = memory_map.getBootMemory()
-        target_type = board.getTargetType()
-        binary_file = os.path.join(parentdir, 'binaries',
-                                   board.getTestBinary())
-        if board_id is None:
-            board_id = board.getUniqueID()
-        test_clock = 10000000
-        test_port = 3334
-        error_on_invalid_access = True
-        # Hardware breakpoints are not supported above 0x20000000 on
-        # CortexM devices
-        ignore_hw_bkpt_result = 1 if ram_region.start >= 0x20000000 else 0
-        if target_type == "nrf51":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-            # Reading invalid ram returns 0 or nrf51
-            error_on_invalid_access = False
-        if target_type == "ncs36510":
-            # Override clock since 10MHz is too fast
-            test_clock = 1000000
-
-        # Program with initial test image
-        board.flash.flashBinary(binary_file, rom_region.start)
-        board.uninit(False)
-
-    # Write out the test configuration
-    test_params = {}
-    test_params["rom_start"] = rom_region.start
-    test_params["rom_length"] = rom_region.length
-    test_params["ram_start"] = ram_region.start
-    test_params["ram_length"] = ram_region.length
-    test_params["invalid_start"] = 0xffff0000
-    test_params["invalid_length"] = 0x1000
-    test_params["expect_error_on_invalid_access"] = error_on_invalid_access
-    test_params["ignore_hw_bkpt_result"] = ignore_hw_bkpt_result
-    with open(TEST_PARAM_FILE, "wb") as f:
-        f.write(json.dumps(test_params))
-
-    # Run the test
-    gdb = [PYTHON_GDB, "--command=gdb_script.py"]
-    with open("output.txt", "wb") as f:
-        program = Popen(gdb, stdin=PIPE, stdout=f, stderr=STDOUT)
-        args = ['-p=%i' % test_port, "-f=%i" % test_clock, "-b=%s" % board_id]
-        server = GDBServerTool()
-        server.run(args)
-        program.wait()
-
-    # Read back the result
-    with open(TEST_RESULT_FILE, "rb") as f:
-        test_result = json.loads(f.read())
-
-    # Print results
-    if set(TEST_RESULT_KEYS).issubset(test_result):
-        print("----------------Test Results----------------")
-        print("HW breakpoint count: %s" % test_result["breakpoint_count"])
-        print("Watchpoint count: %s" % test_result["watchpoint_count"])
-        print("Average instruction step time: %s" %
-              test_result["step_time_si"])
-        print("Average single step time: %s" % test_result["step_time_s"])
-        print("Average over step time: %s" % test_result["step_time_n"])
-        print("Failure count: %i" % test_result["fail_count"])
-        result.passed = test_result["fail_count"] == 0
-    else:
-        result.passed = False
-
-    # Cleanup
-    os.remove(TEST_RESULT_FILE)
-    os.remove(TEST_PARAM_FILE)
-
-    return result
-
-if __name__ == "__main__":
-    test_gdb()
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+
+# Note
+#  To run this script GNU Tools ARM Embedded must be installed,
+#  along with python for the same architecture.  The program
+#  "arm-none-eabi-gdb-py.exe" requires python for the same
+#  architecture (x86 or 64) to work correctly. Also, on windows
+#  the GNU Tools ARM Embedded bin directory needs to be added to
+#  your path.
+
+import os
+import json
+import sys
+from subprocess import Popen, STDOUT, PIPE
+
+from pyOCD.tools.gdb_server import GDBServerTool
+from pyOCD.board import MbedBoard
+from test_util import Test, TestResult
+
+# TODO, c1728p9 - run script several times with
+#       with different command line parameters
+
+TEST_PARAM_FILE = "test_params.txt"
+TEST_RESULT_FILE = "test_results.txt"
+PYTHON_GDB = "arm-none-eabi-gdb-py"
+
+
+parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+
+
+class GdbTestResult(TestResult):
+    def __init__(self):
+        super(self.__class__, self).__init__(None, None, None)
+
+
+class GdbTest(Test):
+    def __init__(self):
+        super(self.__class__, self).__init__("Gdb Test", test_gdb)
+
+    def print_perf_info(self, result_list, output_file=None):
+        pass
+
+    def run(self, board):
+        try:
+            result = self.test_function(board.getUniqueID())
+        except Exception as e:
+            result = GdbTestResult()
+            result.passed = False
+            print("Exception %s when testing board %s" %
+                  (e, board.getUniqueID()))
+        result.board = board
+        result.test = self
+        return result
+
+TEST_RESULT_KEYS = [
+    "breakpoint_count",
+    "watchpoint_count",
+    "step_time_si",
+    "step_time_s",
+    "step_time_n",
+    "fail_count",
+]
+
+
+def test_gdb(board_id=None):
+    result = GdbTestResult()
+    with MbedBoard.chooseBoard(board_id=board_id) as board:
+        memory_map = board.target.getMemoryMap()
+        ram_regions = [region for region in memory_map if region.type == 'ram']
+        ram_region = ram_regions[0]
+        rom_region = memory_map.getBootMemory()
+        target_type = board.getTargetType()
+        binary_file = os.path.join(parentdir, 'binaries',
+                                   board.getTestBinary())
+        if board_id is None:
+            board_id = board.getUniqueID()
+        test_clock = 10000000
+        test_port = 3334
+        error_on_invalid_access = True
+        # Hardware breakpoints are not supported above 0x20000000 on
+        # CortexM devices
+        ignore_hw_bkpt_result = 1 if ram_region.start >= 0x20000000 else 0
+        if target_type == "nrf51":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+            # Reading invalid ram returns 0 or nrf51
+            error_on_invalid_access = False
+        if target_type == "ncs36510":
+            # Override clock since 10MHz is too fast
+            test_clock = 1000000
+
+        # Program with initial test image
+        board.flash.flashBinary(binary_file, rom_region.start)
+        board.uninit(False)
+
+    # Write out the test configuration
+    test_params = {}
+    test_params["rom_start"] = rom_region.start
+    test_params["rom_length"] = rom_region.length
+    test_params["ram_start"] = ram_region.start
+    test_params["ram_length"] = ram_region.length
+    test_params["invalid_start"] = 0xffff0000
+    test_params["invalid_length"] = 0x1000
+    test_params["expect_error_on_invalid_access"] = error_on_invalid_access
+    test_params["ignore_hw_bkpt_result"] = ignore_hw_bkpt_result
+    with open(TEST_PARAM_FILE, "wb") as f:
+        f.write(json.dumps(test_params))
+
+    # Run the test
+    gdb = [PYTHON_GDB, "--command=gdb_script.py"]
+    with open("output.txt", "wb") as f:
+        program = Popen(gdb, stdin=PIPE, stdout=f, stderr=STDOUT)
+        args = ['-p=%i' % test_port, "-f=%i" % test_clock, "-b=%s" % board_id]
+        server = GDBServerTool()
+        server.run(args)
+        program.wait()
+
+    # Read back the result
+    with open(TEST_RESULT_FILE, "rb") as f:
+        test_result = json.loads(f.read())
+
+    # Print results
+    if set(TEST_RESULT_KEYS).issubset(test_result):
+        print("----------------Test Results----------------")
+        print("HW breakpoint count: %s" % test_result["breakpoint_count"])
+        print("Watchpoint count: %s" % test_result["watchpoint_count"])
+        print("Average instruction step time: %s" %
+              test_result["step_time_si"])
+        print("Average single step time: %s" % test_result["step_time_s"])
+        print("Average over step time: %s" % test_result["step_time_n"])
+        print("Failure count: %i" % test_result["fail_count"])
+        result.passed = test_result["fail_count"] == 0
+    else:
+        result.passed = False
+
+    # Cleanup
+    os.remove(TEST_RESULT_FILE)
+    os.remove(TEST_PARAM_FILE)
+
+    return result
+
+if __name__ == "__main__":
+    test_gdb()
```

### Comparing `pyOCD-0.8.1a1/test/gdb_test_program/gdb_test.elf` & `pyOCD-0.9.0/src/gdb_test_program/gdb_test.elf`

 * *Files identical despite different names*

### Comparing `pyOCD-0.8.1a1/test/gdb_test_program/linker_script.ld` & `pyOCD-0.9.0/src/analyzer/linker_script.ld`

 * *Files 26% similar despite different names*

```diff
@@ -1,54 +1,61 @@
-/*
- mbed CMSIS-DAP debugger
- Copyright (c) 2006-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-*/
-
-/* Memory regions */
-MEMORY
-{
-  /* Ram configurations are for smallest KL25 in family - 4K */
-  m_all        (rwx) : ORIGIN = 0x00000000, LENGTH = 0x600
-}
-
-/* Define output sections */
-SECTIONS
-{
-
-  .text :
-  {
-    . = ALIGN(4);
-
-    /* Entry point */
-    KEEP(*(.text.main))
-
-    *(.text)           /* .text sections (code) */
-    *(.text*)          /* .text* sections (code) */
-
-    . = ALIGN(4);
-    *(.data)           /* .data sections */
-    *(.data*)          /* .data* sections */
-    
-    . = ALIGN(4);
-    *(.bss)
-    *(.bss*)
-    *(COMMON)
-    
-    . = ALIGN(4);
-    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
-    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
-
-  } >m_all
-
-}
+/*
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2006-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+*/
+
+/* Memory regions */
+MEMORY
+{
+  /* Ram configurations are for smallest KL25 in family - 4K */
+  m_all        (rwx) : ORIGIN = 0x00000000, LENGTH = 0x600
+}
+
+/* Define output sections */
+SECTIONS
+{
+
+  .text :
+  {
+    . = ALIGN(4);
+
+    /* Entry point */
+    KEEP(*(.text.compute_crc))
+
+    *(.text)           /* .text sections (code) */
+    *(.text*)          /* .text* sections (code) */
+
+    . = ALIGN(4);
+    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
+
+  } >m_all
+
+  .data :
+  {
+    . = ALIGN(4);
+    *(.data)           /* .data sections */
+    *(.data*)          /* .data* sections */
+  } >m_all
+
+   /* Uninitialized data section */
+  .bss :
+  {
+    . = ALIGN(4);
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+  } > m_all
+
+}
```

### Comparing `pyOCD-0.8.1a1/test/parallel_test.py` & `pyOCD-0.9.0/test/parallel_test.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,156 +1,156 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2016 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from __future__ import print_function
-
-from pyOCD.board import MbedBoard
-from pyOCD.pyDAPAccess import DAPAccess
-import threading
-import multiprocessing
-
-
-def run_in_parallel(function, args_list):
-    """Create and run a thread in parallel for each element in args_list
-
-    Wait until all threads finish executing. Throw an exception if an exception
-    occurred on any of the threads.
-    """
-    def _thread_helper(idx, func, args):
-        """Run the function and set result to True if there was not error"""
-        func(*args)
-        result_list[idx] = True
-
-    result_list = [False] * len(args_list)
-    thread_list = []
-    for idx, args in enumerate(args_list):
-        thread = threading.Thread(target=_thread_helper,
-                                  args=(idx, function, args))
-        thread.start()
-        thread_list.append(thread)
-
-    for thread in thread_list:
-        thread.join()
-    for result in result_list:
-        if result is not True:
-            raise Exception("Running in thread failed")
-
-
-def run_in_processes(function, args_list):
-    """Create and run a processes in parallel for each element in args_list
-
-    Wait until all processes finish executing. Throw an exception if an
-    exception occurred on any of the processes.
-    """
-    process_list = []
-    for args in args_list:
-        process = multiprocessing.Process(target=function, args=args)
-        process.start()
-        process_list.append(process)
-
-    error_during_run = False
-    for process in process_list:
-        process.join()
-        if process.exitcode != 0:
-            error_during_run = True
-    if error_during_run:
-        raise Exception("Running in process failed")
-
-
-def list_boards(id_list):
-    """List all connected DAPLink boards repeatedly
-
-    Assert that they are the same as the id list passed in.
-    """
-    for _ in range(0, 20):
-        device_list = DAPAccess.get_connected_devices()
-        found_id_list = [device.get_unique_id() for device in device_list]
-        found_id_list.sort()
-        assert id_list == found_id_list, "Expected %s, got %s" % \
-            (id_list, found_id_list)
-
-
-def search_and_lock(board_id):
-    """Repeatedly lock a board with the given ID"""
-    for _ in range(0, 20):
-        device = DAPAccess.get_device(board_id)
-        device.open()
-        device.close()
-        with MbedBoard.chooseBoard(board_id=board_id):
-            pass
-
-
-def open_already_opened(board_id):
-    """Open a device that is already open to verify it gives an error"""
-    device = DAPAccess.get_device(board_id)
-    try:
-        device.open()
-        assert False
-    except DAPAccess.DeviceError:
-        pass
-
-
-def parallel_test():
-    """Test that devices can be found and opened in parallel"""
-    device_list = DAPAccess.get_connected_devices()
-    id_list = [device.get_unique_id() for device in device_list]
-    id_list.sort()
-
-    if len(id_list) < 2:
-        print("Need at least 2 boards to run the parallel test")
-        exit(-1)
-
-    # Goal of this file is to test that:
-    # -The process of listing available boards does not interfere
-    #  with other processes enumerating, opening, or using boards
-    # -Opening and using a board does not interfere with another process
-    #  processes which is enumerating, opening, or using boards as
-    # long as that is not the current board
-
-    print("Listing board from multiple threads at the same time")
-    args_list = [(id_list,) for _ in range(5)]
-    run_in_parallel(list_boards, args_list)
-
-    print("Listing board from multiple processes at the same time")
-    run_in_processes(list_boards, args_list)
-
-    print("Opening same board from multiple threads at the same time")
-    device = DAPAccess.get_device(id_list[0])
-    device.open()
-    open_already_opened(id_list[0])
-    args_list = [(id_list[0],) for _ in range(5)]
-    run_in_parallel(open_already_opened, args_list)
-    device.close()
-
-    print("Opening same board from multiple processes at the same time")
-    device = DAPAccess.get_device(id_list[0])
-    device.open()
-    open_already_opened(id_list[0])
-    args_list = [(id_list[0],) for _ in range(5)]
-    run_in_processes(open_already_opened, args_list)
-    device.close()
-
-    print("Opening different boards from different threads")
-    args_list = [(board_id,) for board_id in id_list]
-    run_in_parallel(search_and_lock, args_list)
-
-    print("Opening different boards from different processes")
-    run_in_processes(search_and_lock, args_list)
-
-    print("Test passed")
-
-
-if __name__ == "__main__":
-    parallel_test()
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2016 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from __future__ import print_function
+
+from pyOCD.board import MbedBoard
+from pyOCD.pyDAPAccess import DAPAccess
+import threading
+import multiprocessing
+
+
+def run_in_parallel(function, args_list):
+    """Create and run a thread in parallel for each element in args_list
+
+    Wait until all threads finish executing. Throw an exception if an exception
+    occurred on any of the threads.
+    """
+    def _thread_helper(idx, func, args):
+        """Run the function and set result to True if there was not error"""
+        func(*args)
+        result_list[idx] = True
+
+    result_list = [False] * len(args_list)
+    thread_list = []
+    for idx, args in enumerate(args_list):
+        thread = threading.Thread(target=_thread_helper,
+                                  args=(idx, function, args))
+        thread.start()
+        thread_list.append(thread)
+
+    for thread in thread_list:
+        thread.join()
+    for result in result_list:
+        if result is not True:
+            raise Exception("Running in thread failed")
+
+
+def run_in_processes(function, args_list):
+    """Create and run a processes in parallel for each element in args_list
+
+    Wait until all processes finish executing. Throw an exception if an
+    exception occurred on any of the processes.
+    """
+    process_list = []
+    for args in args_list:
+        process = multiprocessing.Process(target=function, args=args)
+        process.start()
+        process_list.append(process)
+
+    error_during_run = False
+    for process in process_list:
+        process.join()
+        if process.exitcode != 0:
+            error_during_run = True
+    if error_during_run:
+        raise Exception("Running in process failed")
+
+
+def list_boards(id_list):
+    """List all connected DAPLink boards repeatedly
+
+    Assert that they are the same as the id list passed in.
+    """
+    for _ in range(0, 20):
+        device_list = DAPAccess.get_connected_devices()
+        found_id_list = [device.get_unique_id() for device in device_list]
+        found_id_list.sort()
+        assert id_list == found_id_list, "Expected %s, got %s" % \
+            (id_list, found_id_list)
+
+
+def search_and_lock(board_id):
+    """Repeatedly lock a board with the given ID"""
+    for _ in range(0, 20):
+        device = DAPAccess.get_device(board_id)
+        device.open()
+        device.close()
+        with MbedBoard.chooseBoard(board_id=board_id):
+            pass
+
+
+def open_already_opened(board_id):
+    """Open a device that is already open to verify it gives an error"""
+    device = DAPAccess.get_device(board_id)
+    try:
+        device.open()
+        assert False
+    except DAPAccess.DeviceError:
+        pass
+
+
+def parallel_test():
+    """Test that devices can be found and opened in parallel"""
+    device_list = DAPAccess.get_connected_devices()
+    id_list = [device.get_unique_id() for device in device_list]
+    id_list.sort()
+
+    if len(id_list) < 2:
+        print("Need at least 2 boards to run the parallel test")
+        exit(-1)
+
+    # Goal of this file is to test that:
+    # -The process of listing available boards does not interfere
+    #  with other processes enumerating, opening, or using boards
+    # -Opening and using a board does not interfere with another process
+    #  processes which is enumerating, opening, or using boards as
+    # long as that is not the current board
+
+    print("Listing board from multiple threads at the same time")
+    args_list = [(id_list,) for _ in range(5)]
+    run_in_parallel(list_boards, args_list)
+
+    print("Listing board from multiple processes at the same time")
+    run_in_processes(list_boards, args_list)
+
+    print("Opening same board from multiple threads at the same time")
+    device = DAPAccess.get_device(id_list[0])
+    device.open()
+    open_already_opened(id_list[0])
+    args_list = [(id_list[0],) for _ in range(5)]
+    run_in_parallel(open_already_opened, args_list)
+    device.close()
+
+    print("Opening same board from multiple processes at the same time")
+    device = DAPAccess.get_device(id_list[0])
+    device.open()
+    open_already_opened(id_list[0])
+    args_list = [(id_list[0],) for _ in range(5)]
+    run_in_processes(open_already_opened, args_list)
+    device.close()
+
+    print("Opening different boards from different threads")
+    args_list = [(board_id,) for board_id in id_list]
+    run_in_parallel(search_and_lock, args_list)
+
+    print("Opening different boards from different processes")
+    run_in_processes(search_and_lock, args_list)
+
+    print("Test passed")
+
+
+if __name__ == "__main__":
+    parallel_test()
```

### Comparing `pyOCD-0.8.1a1/test/test_util.py` & `pyOCD-0.9.0/test/test_util.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,91 +1,91 @@
-"""
- mbed CMSIS-DAP debugger
- Copyright (c) 2015-2015 ARM Limited
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-"""
-from __future__ import print_function
-
-import pyOCD
-import logging, os, sys
-
-class Logger(object):
-    def __init__(self, filename="Default.log"):
-        self.terminal = sys.stdout
-        self.log = open(filename, "a")
-
-    def write(self, message):
-        self.terminal.write(message)
-        self.log.write(message)
-
-    def flush(self):
-        self.terminal.flush()
-        self.log.flush()
-
-class TestResult(object):
-
-    def __init__(self, test_board, test, result):
-        self.passed = result
-        self.board = test_board
-        self.test = test
-
-class Test(object):
-
-    def __init__(self, name, function):
-        self.name = name
-        self.test_function = function
-
-    def run(self, board):
-        """
-        Run test and return the result
-
-        Override this function to return a custom result
-        """
-        passed = False
-        try:
-            self.test_function(board.getUniqueID())
-            passed = True
-        except Exception as e:
-            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
-        return TestResult(board, self, passed)
-
-    def print_perf_info(self, result_list, output_file=None):
-        """
-        Print performance info if any
-        """
-        pass
-
-    @staticmethod
-    def print_results(result_list, output_file=None):
-        msg_format_str = "{:<15}{:<21}{:<15}{:<15}"
-        print("\r\n\r\n------ TEST RESULTS ------")
-        print(msg_format_str .format("Target", "Test", "Result", "Time"),
-              file=output_file)
-        print("", file=output_file)
-        for result in result_list:
-            status_str = "Pass" if result.passed else "Fail"
-            print(msg_format_str.format(result.board.target_type,
-                                        result.test.name,
-                                        status_str, result.time),
-                  file=output_file)
-
-    @staticmethod
-    def all_tests_pass(result_list):
-        passed = True
-        for result in result_list:
-            if not result.passed:
-                passed = False
-                break
-        if len(result_list) <= 0:
-            passed = False
-        return passed
+"""
+ mbed CMSIS-DAP debugger
+ Copyright (c) 2015-2015 ARM Limited
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+"""
+from __future__ import print_function
+
+import pyOCD
+import logging, os, sys
+
+class Logger(object):
+    def __init__(self, filename="Default.log"):
+        self.terminal = sys.stdout
+        self.log = open(filename, "a")
+
+    def write(self, message):
+        self.terminal.write(message)
+        self.log.write(message)
+
+    def flush(self):
+        self.terminal.flush()
+        self.log.flush()
+
+class TestResult(object):
+
+    def __init__(self, test_board, test, result):
+        self.passed = result
+        self.board = test_board
+        self.test = test
+
+class Test(object):
+
+    def __init__(self, name, function):
+        self.name = name
+        self.test_function = function
+
+    def run(self, board):
+        """
+        Run test and return the result
+
+        Override this function to return a custom result
+        """
+        passed = False
+        try:
+            self.test_function(board.getUniqueID())
+            passed = True
+        except Exception as e:
+            print("Exception %s when testing board %s" % (e, board.getUniqueID()))
+        return TestResult(board, self, passed)
+
+    def print_perf_info(self, result_list, output_file=None):
+        """
+        Print performance info if any
+        """
+        pass
+
+    @staticmethod
+    def print_results(result_list, output_file=None):
+        msg_format_str = "{:<15}{:<21}{:<15}{:<15}"
+        print("\r\n\r\n------ TEST RESULTS ------")
+        print(msg_format_str .format("Target", "Test", "Result", "Time"),
+              file=output_file)
+        print("", file=output_file)
+        for result in result_list:
+            status_str = "Pass" if result.passed else "Fail"
+            print(msg_format_str.format(result.board.target_type,
+                                        result.test.name,
+                                        status_str, result.time),
+                  file=output_file)
+
+    @staticmethod
+    def all_tests_pass(result_list):
+        passed = True
+        for result in result_list:
+            if not result.passed:
+                passed = False
+                break
+        if len(result_list) <= 0:
+            passed = False
+        return passed
```

