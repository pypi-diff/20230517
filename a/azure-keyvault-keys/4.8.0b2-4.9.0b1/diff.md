# Comparing `tmp/azure-keyvault-keys-4.8.0b2.zip` & `tmp/azure-keyvault-keys-4.9.0b1.zip`

## zipinfo {}

```diff
@@ -1,292 +1,294 @@
-Zip file size: 580443 bytes, number of entries: 290
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/samples/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/tests/
--rw-rw-r--  2.0 unx    43328 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/PKG-INFO
--rw-rw-r--  2.0 unx    20008 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/README.md
--rw-rw-r--  2.0 unx     1073 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/LICENSE
--rw-rw-r--  2.0 unx      187 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/MANIFEST.in
--rw-rw-r--  2.0 unx    22466 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/CHANGELOG.md
--rw-rw-r--  2.0 unx     2429 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/setup.py
--rw-rw-r--  2.0 unx    12820 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/migration_guide.md
--rw-rw-r--  2.0 unx      277 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/TROUBLESHOOTING.md
--rw-rw-r--  2.0 unx       38 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/setup.cfg
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/
--rw-rw-r--  2.0 unx      267 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/
--rw-rw-r--  2.0 unx      267 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/
--rw-rw-r--  2.0 unx     2528 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_enums.py
--rw-rw-r--  2.0 unx      231 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_sdk_moniker.py
--rw-rw-r--  2.0 unx        0 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/py.typed
--rw-rw-r--  2.0 unx    39722 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_client.py
--rw-rw-r--  2.0 unx    20735 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_models.py
--rw-rw-r--  2.0 unx      993 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/__init__.py
--rw-rw-r--  2.0 unx    67714 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated_models.py
--rw-rw-r--  2.0 unx      172 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_version.py
--rw-rw-r--  2.0 unx     2520 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge_cache.py
--rw-rw-r--  2.0 unx     2702 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling_async.py
--rw-rw-r--  2.0 unx     3697 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/client_base.py
--rw-rw-r--  2.0 unx     3471 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_client_base.py
--rw-rw-r--  2.0 unx     5796 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/challenge_auth_policy.py
--rw-rw-r--  2.0 unx     5015 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling.py
--rw-rw-r--  2.0 unx     4691 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge.py
--rw-rw-r--  2.0 unx     4991 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_challenge_auth_policy.py
--rw-rw-r--  2.0 unx     2568 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/__init__.py
--rw-rw-r--  2.0 unx     2146 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/exceptions.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/
--rw-rw-r--  2.0 unx     1827 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_enums.py
--rw-rw-r--  2.0 unx    24308 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_client.py
--rw-rw-r--  2.0 unx     1235 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_key_validity.py
--rw-rw-r--  2.0 unx     3980 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_models.py
--rw-rw-r--  2.0 unx      608 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/__init__.py
--rw-rw-r--  2.0 unx     1590 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/rsa.py
--rw-rw-r--  2.0 unx     1249 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/symmetric.py
--rw-rw-r--  2.0 unx     1417 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/__init__.py
--rw-rw-r--  2.0 unx     4979 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/local_provider.py
--rw-rw-r--  2.0 unx     1616 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/ec.py
--rw-rw-r--  2.0 unx    21830 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/_client.py
--rw-rw-r--  2.0 unx      492 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/
--rw-rw-r--  2.0 unx     3950 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/ec_key.py
--rw-rw-r--  2.0 unx     3219 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/_internal.py
--rw-rw-r--  2.0 unx     1403 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/transform.py
--rw-rw-r--  2.0 unx     7841 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/rsa_key.py
--rw-rw-r--  2.0 unx      932 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/__init__.py
--rw-rw-r--  2.0 unx     3089 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/key.py
--rw-rw-r--  2.0 unx     2028 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithm.py
--rw-rw-r--  2.0 unx     4663 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/symmetric_key.py
--rw-rw-r--  2.0 unx     2339 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py
--rw-rw-r--  2.0 unx     3978 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py
--rw-rw-r--  2.0 unx     2074 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py
--rw-rw-r--  2.0 unx     1730 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py
--rw-rw-r--  2.0 unx      989 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py
--rw-rw-r--  2.0 unx     1481 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py
--rw-rw-r--  2.0 unx     2359 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py
--rw-rw-r--  2.0 unx     4795 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py
--rw-rw-r--  2.0 unx    38706 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/_client.py
--rw-rw-r--  2.0 unx      207 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/
--rw-rw-r--  2.0 unx     2069 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_configuration.py
--rw-rw-r--  2.0 unx      380 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/models.py
--rw-rw-r--  2.0 unx      698 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/__init__.py
--rw-rw-r--  2.0 unx     7302 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_key_vault_client.py
--rw-rw-r--  2.0 unx    78750 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_serialization.py
--rw-rw-r--  2.0 unx   191822 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_operations_mixin.py
--rw-rw-r--  2.0 unx      344 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_version.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/__init__.py
--rw-rw-r--  2.0 unx     3156 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/__init__.py
--rw-rw-r--  2.0 unx   457038 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/__init__.py
--rw-rw-r--  2.0 unx     3198 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   377615 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_patch.py
--rw-rw-r--  2.0 unx     7707 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     8000 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/__init__.py
--rw-rw-r--  2.0 unx   155628 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/__init__.py
--rw-rw-r--  2.0 unx     3156 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/__init__.py
--rw-rw-r--  2.0 unx   130571 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/__init__.py
--rw-rw-r--  2.0 unx     3198 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   111071 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_patch.py
--rw-rw-r--  2.0 unx     6957 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     2660 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/__init__.py
--rw-rw-r--  2.0 unx    39003 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py
--rw-rw-r--  2.0 unx     2028 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_configuration.py
--rw-rw-r--  2.0 unx      543 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/__init__.py
--rw-rw-r--  2.0 unx     7357 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx   194128 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_operations_mixin.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/__init__.py
--rw-rw-r--  2.0 unx     3156 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/__init__.py
--rw-rw-r--  2.0 unx   130571 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/__init__.py
--rw-rw-r--  2.0 unx     3198 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   111071 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_patch.py
--rw-rw-r--  2.0 unx     7357 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     2660 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/__init__.py
--rw-rw-r--  2.0 unx    41500 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py
--rw-rw-r--  2.0 unx     2584 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/__init__.py
--rw-rw-r--  2.0 unx     3163 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py
--rw-rw-r--  2.0 unx   404242 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py
--rw-rw-r--  2.0 unx     2550 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py
--rw-rw-r--  2.0 unx     3205 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   335294 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py
--rw-rw-r--  2.0 unx     3872 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     7104 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py
--rw-rw-r--  2.0 unx   134325 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_vendor.py
--rw-rw-r--  2.0 unx     2593 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/__init__.py
--rw-rw-r--  2.0 unx     3166 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/__init__.py
--rw-rw-r--  2.0 unx   165082 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_vendor.py
--rw-rw-r--  2.0 unx     2559 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/__init__.py
--rw-rw-r--  2.0 unx     3208 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   139812 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_patch.py
--rw-rw-r--  2.0 unx     8383 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     3596 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/__init__.py
--rw-rw-r--  2.0 unx    60082 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/__init__.py
--rw-rw-r--  2.0 unx     3156 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/__init__.py
--rw-rw-r--  2.0 unx   162508 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/__init__.py
--rw-rw-r--  2.0 unx     3198 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py
--rw-rw-r--  2.0 unx      831 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py
--rw-rw-r--  2.0 unx   138045 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_patch.py
--rw-rw-r--  2.0 unx     7987 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     3596 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/__init__.py
--rw-rw-r--  2.0 unx    59088 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py
--rw-rw-r--  2.0 unx     4022 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/list_operations.py
--rw-rw-r--  2.0 unx     3185 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations.py
--rw-rw-r--  2.0 unx     5400 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/key_rotation.py
--rw-rw-r--  2.0 unx     3094 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations.py
--rw-rw-r--  2.0 unx     3909 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/hello_world.py
--rw-rw-r--  2.0 unx     5851 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/key_rotation_async.py
--rw-rw-r--  2.0 unx     3090 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations_async.py
--rw-rw-r--  2.0 unx     4327 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/hello_world_async.py
--rw-rw-r--  2.0 unx     4421 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/list_operations_async.py
--rw-rw-r--  2.0 unx     3376 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations_async.py
--rw-rw-r--  2.0 unx    43328 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        6 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/top_level.txt
--rw-rw-r--  2.0 unx      104 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/requires.txt
--rw-rw-r--  2.0 unx    11820 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/dependency_links.txt
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/tests/_shared/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/
--rw-rw-r--  2.0 unx    36782 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_key_client.py
--rw-rw-r--  2.0 unx     4943 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto_async.py
--rw-rw-r--  2.0 unx      670 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer.py
--rw-rw-r--  2.0 unx     1039 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_exceptions.py
--rw-rw-r--  2.0 unx     4533 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto.py
--rw-rw-r--  2.0 unx    37077 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_keys_async.py
--rw-rw-r--  2.0 unx    18068 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth_async.py
--rw-rw-r--  2.0 unx     9449 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_samples_keys_async.py
--rw-rw-r--  2.0 unx     1202 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_keys_test_case.py
--rw-rw-r--  2.0 unx    19284 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/keys.py
--rw-rw-r--  2.0 unx      628 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer_async.py
--rw-rw-r--  2.0 unx     2543 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/conftest.py
--rw-rw-r--  2.0 unx     8841 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_local_crypto.py
--rw-rw-r--  2.0 unx     9418 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_samples_keys.py
--rw-rw-r--  2.0 unx      837 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_multi_api.py
--rw-rw-r--  2.0 unx    45493 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_crypto_client.py
--rw-rw-r--  2.0 unx    48709 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_crypto_client_async.py
--rw-rw-r--  2.0 unx     4439 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_async_test_case.py
--rw-rw-r--  2.0 unx    19436 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth.py
--rw-rw-r--  2.0 unx     2796 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_parse_id.py
--rw-rw-r--  2.0 unx     4506 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_test_case.py
--rw-rw-r--  2.0 unx     1717 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_context_manager_async.py
--rw-rw-r--  2.0 unx     1517 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/test_context_manager.py
--rw-rw-r--  2.0 unx     1650 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/test_case.py
--rw-rw-r--  2.0 unx     1696 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/test_case_async.py
--rw-rw-r--  2.0 unx     1094 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/preparer.py
--rw-rw-r--  2.0 unx      656 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/preparer_async.py
--rw-rw-r--  2.0 unx      151 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/__init__.py
--rw-rw-r--  2.0 unx      578 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/json_attribute_matcher.py
--rw-rw-r--  2.0 unx     3935 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/helpers.py
--rw-rw-r--  2.0 unx     1407 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/_shared/helpers_async.py
--rw-rw-r--  2.0 unx     2886 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/decrypt.py
--rw-rw-r--  2.0 unx     2903 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/unwrap.py
--rw-rw-r--  2.0 unx     1875 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/get_key.py
--rw-rw-r--  2.0 unx        0 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/__init__.py
--rw-rw-r--  2.0 unx     2945 b- defN 22-Nov-16 09:23 azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/sign.py
-290 files, 4658804 bytes uncompressed, 515331 bytes compressed:  89.0%
+Zip file size: 595009 bytes, number of entries: 292
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/samples/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/tests/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/
+-rw-rw-r--  2.0 unx       38 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/setup.cfg
+-rw-rw-r--  2.0 unx    45665 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx       86 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/pyproject.toml
+-rw-rw-r--  2.0 unx      187 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx    20863 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/README.md
+-rw-rw-r--  2.0 unx    23897 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2471 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/setup.py
+-rw-rw-r--  2.0 unx      277 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/TROUBLESHOOTING.md
+-rw-rw-r--  2.0 unx     1073 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/LICENSE
+-rw-rw-r--  2.0 unx    12820 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/migration_guide.md
+-rw-rw-r--  2.0 unx     3040 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations_async.py
+-rw-rw-r--  2.0 unx     5791 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/key_rotation_async.py
+-rw-rw-r--  2.0 unx     3230 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/send_request.py
+-rw-rw-r--  2.0 unx     3328 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations_async.py
+-rw-rw-r--  2.0 unx     4300 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/list_operations_async.py
+-rw-rw-r--  2.0 unx     4190 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/hello_world_async.py
+-rw-rw-r--  2.0 unx     3044 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations.py
+-rw-rw-r--  2.0 unx     5554 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/key_rotation.py
+-rw-rw-r--  2.0 unx     3939 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/list_operations.py
+-rw-rw-r--  2.0 unx     3137 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations.py
+-rw-rw-r--  2.0 unx     3867 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/samples/hello_world.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/tests/_shared/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/
+-rw-rw-r--  2.0 unx    49110 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_crypto_client_async.py
+-rw-rw-r--  2.0 unx     4421 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_async_test_case.py
+-rw-rw-r--  2.0 unx     4496 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_test_case.py
+-rw-rw-r--  2.0 unx    45931 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_crypto_client.py
+-rw-rw-r--  2.0 unx      837 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_multi_api.py
+-rw-rw-r--  2.0 unx     2796 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_parse_id.py
+-rw-rw-r--  2.0 unx     8841 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_local_crypto.py
+-rw-rw-r--  2.0 unx     3055 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/conftest.py
+-rw-rw-r--  2.0 unx      628 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer_async.py
+-rw-rw-r--  2.0 unx     8802 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_samples_keys_async.py
+-rw-rw-r--  2.0 unx     1717 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_context_manager_async.py
+-rw-rw-r--  2.0 unx    37772 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_keys_async.py
+-rw-rw-r--  2.0 unx    20178 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth_async.py
+-rw-rw-r--  2.0 unx    19284 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/keys.py
+-rw-rw-r--  2.0 unx    37423 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_key_client.py
+-rw-rw-r--  2.0 unx     4533 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto.py
+-rw-rw-r--  2.0 unx    21334 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth.py
+-rw-rw-r--  2.0 unx     1039 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_exceptions.py
+-rw-rw-r--  2.0 unx     1202 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_keys_test_case.py
+-rw-rw-r--  2.0 unx     8819 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_samples_keys.py
+-rw-rw-r--  2.0 unx     4943 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto_async.py
+-rw-rw-r--  2.0 unx     1517 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/test_context_manager.py
+-rw-rw-r--  2.0 unx      670 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer.py
+-rw-rw-r--  2.0 unx     3935 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/helpers.py
+-rw-rw-r--  2.0 unx      578 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/json_attribute_matcher.py
+-rw-rw-r--  2.0 unx     1407 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/helpers_async.py
+-rw-rw-r--  2.0 unx     1094 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/preparer.py
+-rw-rw-r--  2.0 unx     1696 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/test_case_async.py
+-rw-rw-r--  2.0 unx     1650 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/test_case.py
+-rw-rw-r--  2.0 unx      656 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/preparer_async.py
+-rw-rw-r--  2.0 unx      151 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/_shared/__init__.py
+-rw-rw-r--  2.0 unx     2903 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/unwrap.py
+-rw-rw-r--  2.0 unx     2886 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/decrypt.py
+-rw-rw-r--  2.0 unx     2945 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/sign.py
+-rw-rw-r--  2.0 unx     1875 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/get_key.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/__init__.py
+-rw-rw-r--  2.0 unx        1 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    45665 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx    11659 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx      104 b- defN 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/requires.txt
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/
+-rw-rw-r--  2.0 unx      267 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/
+-rw-rw-r--  2.0 unx      267 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/
+-rw-rw-r--  2.0 unx    39191 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_client.py
+-rw-rw-r--  2.0 unx      172 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_version.py
+-rw-rw-r--  2.0 unx    20325 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_models.py
+-rw-rw-r--  2.0 unx     2301 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_enums.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/py.typed
+-rw-rw-r--  2.0 unx      223 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_sdk_moniker.py
+-rw-rw-r--  2.0 unx    67614 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated_models.py
+-rw-rw-r--  2.0 unx      993 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/__init__.py
+-rw-rw-r--  2.0 unx     4939 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge.py
+-rw-rw-r--  2.0 unx     4775 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling.py
+-rw-rw-r--  2.0 unx     2702 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling_async.py
+-rw-rw-r--  2.0 unx     2113 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/exceptions.py
+-rw-rw-r--  2.0 unx     6078 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/challenge_auth_policy.py
+-rw-rw-r--  2.0 unx     4968 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_client_base.py
+-rw-rw-r--  2.0 unx     2579 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge_cache.py
+-rw-rw-r--  2.0 unx     5307 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_challenge_auth_policy.py
+-rw-rw-r--  2.0 unx     2390 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/__init__.py
+-rw-rw-r--  2.0 unx     6247 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/client_base.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/
+-rw-rw-r--  2.0 unx   197531 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_operations_mixin.py
+-rw-rw-r--  2.0 unx     1993 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_configuration.py
+-rw-rw-r--  2.0 unx      344 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_version.py
+-rw-rw-r--  2.0 unx     7220 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_key_vault_client.py
+-rw-rw-r--  2.0 unx      380 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/models.py
+-rw-rw-r--  2.0 unx    78842 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_serialization.py
+-rw-rw-r--  2.0 unx      698 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_patch.py
+-rw-rw-r--  2.0 unx     3131 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_vendor.py
+-rw-rw-r--  2.0 unx   461426 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_patch.py
+-rw-rw-r--  2.0 unx     7788 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx   156906 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py
+-rw-rw-r--  2.0 unx     7985 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_patch.py
+-rw-rw-r--  2.0 unx     3236 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py
+-rw-rw-r--  2.0 unx   382727 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_patch.py
+-rw-rw-r--  2.0 unx     3131 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_vendor.py
+-rw-rw-r--  2.0 unx   131419 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_patch.py
+-rw-rw-r--  2.0 unx     7038 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    39322 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2645 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_patch.py
+-rw-rw-r--  2.0 unx     3236 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py
+-rw-rw-r--  2.0 unx   112100 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_patch.py
+-rw-rw-r--  2.0 unx     3131 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_vendor.py
+-rw-rw-r--  2.0 unx   131419 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_patch.py
+-rw-rw-r--  2.0 unx     7441 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    41923 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2645 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_patch.py
+-rw-rw-r--  2.0 unx     3236 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py
+-rw-rw-r--  2.0 unx   112100 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_patch.py
+-rw-rw-r--  2.0 unx     3131 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_vendor.py
+-rw-rw-r--  2.0 unx   163170 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_patch.py
+-rw-rw-r--  2.0 unx     8077 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    59668 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py
+-rw-rw-r--  2.0 unx     3581 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_patch.py
+-rw-rw-r--  2.0 unx     3236 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py
+-rw-rw-r--  2.0 unx   138943 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/
+-rw-rw-r--  2.0 unx     2532 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_patch.py
+-rw-rw-r--  2.0 unx     3138 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py
+-rw-rw-r--  2.0 unx   408005 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py
+-rw-rw-r--  2.0 unx     3896 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx   135465 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx     7089 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/
+-rw-rw-r--  2.0 unx     2542 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py
+-rw-rw-r--  2.0 unx     3243 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py
+-rw-rw-r--  2.0 unx   339680 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx   199837 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_operations_mixin.py
+-rw-rw-r--  2.0 unx     2020 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_configuration.py
+-rw-rw-r--  2.0 unx     7289 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      543 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_patch.py
+-rw-rw-r--  2.0 unx     3131 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_vendor.py
+-rw-rw-r--  2.0 unx   161646 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_patch.py
+-rw-rw-r--  2.0 unx     8077 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    59558 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_models_py3.py
+-rw-rw-r--  2.0 unx     3581 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_patch.py
+-rw-rw-r--  2.0 unx     3236 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_vendor.py
+-rw-rw-r--  2.0 unx   137419 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      816 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/
+-rw-rw-r--  2.0 unx    24214 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_client.py
+-rw-rw-r--  2.0 unx      880 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_key_validity.py
+-rw-rw-r--  2.0 unx     3910 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_models.py
+-rw-rw-r--  2.0 unx     1708 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_enums.py
+-rw-rw-r--  2.0 unx      608 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/
+-rw-rw-r--  2.0 unx     3209 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/_internal.py
+-rw-rw-r--  2.0 unx     3081 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/key.py
+-rw-rw-r--  2.0 unx     3942 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/ec_key.py
+-rw-rw-r--  2.0 unx     4663 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/symmetric_key.py
+-rw-rw-r--  2.0 unx     7833 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/rsa_key.py
+-rw-rw-r--  2.0 unx     1403 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/transform.py
+-rw-rw-r--  2.0 unx     2028 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithm.py
+-rw-rw-r--  2.0 unx      932 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/__init__.py
+-rw-rw-r--  2.0 unx     3974 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py
+-rw-rw-r--  2.0 unx     2359 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py
+-rw-rw-r--  2.0 unx     1481 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py
+-rw-rw-r--  2.0 unx     2339 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py
+-rw-rw-r--  2.0 unx     4795 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py
+-rw-rw-r--  2.0 unx     2074 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py
+-rw-rw-r--  2.0 unx     1728 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py
+-rw-rw-r--  2.0 unx      989 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py
+-rw-rw-r--  2.0 unx     4835 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/local_provider.py
+-rw-rw-r--  2.0 unx     1221 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/symmetric.py
+-rw-rw-r--  2.0 unx     1588 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/ec.py
+-rw-rw-r--  2.0 unx     1562 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/rsa.py
+-rw-rw-r--  2.0 unx     1281 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/__init__.py
+-rw-rw-r--  2.0 unx    21978 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/_client.py
+-rw-rw-r--  2.0 unx      492 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/__init__.py
+-rw-rw-r--  2.0 unx    38428 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/_client.py
+-rw-rw-r--  2.0 unx      207 b- defN 23-May-16 23:24 azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/__init__.py
+292 files, 4707502 bytes uncompressed, 530059 bytes compressed:  88.7%
```

## zipnote {}

```diff
@@ -1,871 +1,877 @@
-Filename: azure-keyvault-keys-4.8.0b2/
+Filename: azure-keyvault-keys-4.9.0b1/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/
+Filename: azure-keyvault-keys-4.9.0b1/samples/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/
+Filename: azure-keyvault-keys-4.9.0b1/tests/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/
+Filename: azure-keyvault-keys-4.9.0b1/azure/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/PKG-INFO
+Filename: azure-keyvault-keys-4.9.0b1/setup.cfg
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/README.md
+Filename: azure-keyvault-keys-4.9.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/LICENSE
+Filename: azure-keyvault-keys-4.9.0b1/pyproject.toml
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/MANIFEST.in
+Filename: azure-keyvault-keys-4.9.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/CHANGELOG.md
+Filename: azure-keyvault-keys-4.9.0b1/README.md
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/setup.py
+Filename: azure-keyvault-keys-4.9.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/migration_guide.md
+Filename: azure-keyvault-keys-4.9.0b1/setup.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/TROUBLESHOOTING.md
+Filename: azure-keyvault-keys-4.9.0b1/TROUBLESHOOTING.md
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/setup.cfg
+Filename: azure-keyvault-keys-4.9.0b1/LICENSE
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/
+Filename: azure-keyvault-keys-4.9.0b1/migration_guide.md
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/
+Filename: azure-keyvault-keys-4.9.0b1/samples/key_rotation_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/samples/send_request.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/
+Filename: azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/
+Filename: azure-keyvault-keys-4.9.0b1/samples/list_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/
+Filename: azure-keyvault-keys-4.9.0b1/samples/hello_world_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/
+Filename: azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/samples/key_rotation.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_sdk_moniker.py
+Filename: azure-keyvault-keys-4.9.0b1/samples/list_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/py.typed
+Filename: azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_client.py
+Filename: azure-keyvault-keys-4.9.0b1/samples/hello_world.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_models.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated_models.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_crypto_client_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_version.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_async_test_case.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge_cache.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_test_case.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling_async.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_crypto_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/client_base.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_multi_api.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_client_base.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_parse_id.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/challenge_auth_policy.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_local_crypto.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/conftest.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_challenge_auth_policy.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_samples_keys_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_context_manager_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/exceptions.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_keys_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/
+Filename: azure-keyvault-keys-4.9.0b1/tests/keys.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_key_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_client.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_key_validity.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_exceptions.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_models.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_keys_test_case.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_samples_keys.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/rsa.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/symmetric.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/test_context_manager.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/local_provider.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/helpers.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/ec.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/json_attribute_matcher.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/_client.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/helpers_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/preparer.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/test_case_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/ec_key.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/test_case.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/_internal.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/preparer_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/transform.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/_shared/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/rsa_key.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/unwrap.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/decrypt.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/key.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/sign.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithm.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/get_key.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/symmetric_key.py
+Filename: azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py
+Filename: azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/requires.txt
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_version.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_models.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/models.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/py.typed
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_sdk_moniker.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated_models.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_serialization.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_operations_mixin.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_version.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling_async.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/exceptions.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/challenge_auth_policy.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_client_base.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge_cache.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_challenge_auth_policy.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/client_base.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_operations_mixin.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_version.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/models.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_serialization.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_operations_mixin.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_key_vault_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_operations_mixin.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_patch.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/list_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/key_rotation.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/hello_world.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/key_rotation_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/hello_world_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/list_operations_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/PKG-INFO
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/top_level.txt
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/requires.txt
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/SOURCES.txt
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/not-zip-safe
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/dependency_links.txt
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_key_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_exceptions.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_keys_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_samples_keys_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_keys_test_case.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_key_validity.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/keys.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_models.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_enums.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/conftest.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_local_crypto.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_samples_keys.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/_internal.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_multi_api.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/key.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_crypto_client.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/ec_key.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_crypto_client_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/symmetric_key.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_async_test_case.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/rsa_key.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/transform.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_parse_id.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithm.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_test_case.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_context_manager_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/test_context_manager.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/test_case.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/test_case_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/preparer.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/preparer_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/json_attribute_matcher.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/helpers.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/local_provider.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/_shared/helpers_async.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/symmetric.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/decrypt.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/ec.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/unwrap.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/rsa.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/get_key.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/__init__.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/__init__.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/_client.py
 Comment: 
 
-Filename: azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/sign.py
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/__init__.py
+Comment: 
+
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/_client.py
+Comment: 
+
+Filename: azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-keyvault-keys-4.8.0b2/PKG-INFO` & `azure-keyvault-keys-4.9.0b1/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 Metadata-Version: 2.1
 Name: azure-keyvault-keys
-Version: 4.8.0b2
+Version: 4.9.0b1
 Summary: Microsoft Azure Key Vault Keys Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys
 Author: Microsoft Corporation
 Author-email: azurekeyvault@microsoft.com
 License: MIT License
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Azure Key Vault Keys client library for Python
 Azure Key Vault helps solve the following problems:
@@ -28,63 +29,76 @@
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 - Vault administration ([azure-keyvault-administration](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration)) - role-based access control (RBAC), and vault-level backup and restore options
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_keys] | [API reference documentation][reference_docs] | [Product documentation][azure_keyvault] | [Samples][key_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_keys]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][azure_keyvault]
+| [Samples][key_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_.
 
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
 ### Install the package
 Install [azure-keyvault-keys][pypi_package_keys] and
 [azure-identity][azure_identity_pypi] with [pip][pip]:
 ```Bash
 pip install azure-keyvault-keys azure-identity
 ```
-[azure-identity][azure_identity] is used for Azure Active Directory
-authentication as demonstrated below.
+[azure-identity][azure_identity] is used for Azure Active Directory authentication as demonstrated below.
 
 ### Prerequisites
 * An [Azure subscription][azure_sub]
 * Python 3.7 or later
 * An existing [Azure Key Vault][azure_keyvault]. If you need to create one, you can do so using the Azure CLI by following the steps in [this document][azure_keyvault_cli].
 * If using Managed HSM, an existing [Key Vault Managed HSM][managed_hsm]. If you need to create a Managed HSM, you can do so using the Azure CLI by following the steps in [this document][managed_hsm_cli].
 
 ### Authenticate the client
-In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as well as a **vault url** and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
+In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as
+well as a **vault URL** and a credential object. This document demonstrates using a
+[DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios. We recommend using a
+[managed identity][managed_identity] for authentication in production environments.
 
-See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
+See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their
+corresponding credential types.
 
 #### Create a client
-After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a key client (replacing the value of `vault_url` with your vault's URL):
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of
+authentication, you can do the following to create a key client (replacing the value of `VAULT_URL` with your vault's
+URL):
+
+<!-- SNIPPET:hello_world.create_a_key_client -->
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 
+VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
-
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+client = KeyClient(vault_url=VAULT_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.keys.aio`'s `KeyClient` instead.
 
 ## Key concepts
 ### Keys
-Azure Key Vault can create and store RSA and elliptic curve keys. Both can
-optionally be protected by hardware security modules (HSMs). Azure Key Vault
-can also perform cryptographic operations with them. For more information about
-keys and supported operations and algorithms, see the
+Azure Key Vault can create and store RSA and elliptic curve keys. Both can optionally be protected by hardware security
+modules (HSMs). Azure Key Vault can also perform cryptographic operations with them. For more information about keys
+and supported operations and algorithms, see the
 [Key Vault documentation](https://docs.microsoft.com/azure/key-vault/keys/about-keys).
 
 [KeyClient][key_client_docs] can create keys in the vault, get existing keys
 from the vault, update key metadata, and delete keys, as shown in the
 [examples](#examples) below.
 
 ## Examples
@@ -97,14 +111,16 @@
 * [List keys](#list-keys)
 * [Perform cryptographic operations](#cryptographic-operations)
 * [Async API](#async-api)
 * [Asynchronously create a key](#asynchronously-create-a-key)
 * [Asynchronously list keys](#asynchronously-list-keys)
 
 ### Create a key
+The [create_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_key) method can be
+used by a `KeyClient` to create a key of any type -- alternatively, specific helpers such as
 [create_rsa_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_rsa_key) and
 [create_ec_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_ec_key)
 create RSA and elliptic curve keys in the vault, respectively. If a key with the same name already exists, a new version
 of that key is created.
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -173,40 +189,47 @@
 deleted_key = key_client.begin_delete_key("key-name").result()
 
 print(deleted_key.name)
 print(deleted_key.deleted_date)
 ```
 
 ### Configure automatic key rotation
-[update_key_rotation_policy](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
-allows you to configure automatic key rotation for a key by specifying a rotation policy.
-In addition,
-[rotate_key](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.rotate_key)
-allows you to rotate a key on-demand by creating a new version of the given key.
+[update_key_rotation_policy](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
+can be used by a `KeyClient` to configure automatic key rotation for a key by specifying a rotation policy.
+
+<!-- SNIPPET:key_rotation.update_a_rotation_policy -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.keys import KeyClient, KeyRotationLifetimeAction, KeyRotationPolicyAction
+from azure.keyvault.keys import KeyRotationLifetimeAction, KeyRotationPolicy, KeyRotationPolicyAction
 
-credential = DefaultAzureCredential()
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+# Here we set the key's automated rotation policy to rotate the key two months after the key was created.
+# If you pass an empty KeyRotationPolicy() as the `policy` parameter, the rotation policy will be set to the
+# default policy. Any keyword arguments will update specified properties of the policy.
+actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.rotate, time_after_create="P2M")]
+updated_policy = client.update_key_rotation_policy(
+    "rotation-sample-key", policy=KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
+)
+assert updated_policy.expires_in == "P90D"
+```
 
-# Set the key's automated rotation policy to rotate the key 30 days before the key expires
-actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.ROTATE, time_before_expiry="P30D")]
-# You may also specify the duration after which the newly rotated key will expire
-# In this example, any new key versions will expire after 90 days
-updated_policy = key_client.update_key_rotation_policy("key-name", expires_in="P90D", lifetime_actions=actions)
+<!-- END SNIPPET -->
 
-# You can get the current rotation policy for a key with get_key_rotation_policy
-current_policy = key_client.get_key_rotation_policy("key-name")
+In addition,
+[rotate_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.rotate_key)
+allows you to rotate a key on-demand by creating a new version of the given key.
 
-# Finally, you can rotate a key on-demand by creating a new version of the key
-rotated_key = key_client.rotate_key("key-name")
+<!-- SNIPPET:key_rotation.rotate_key -->
+
+```python
+rotated_key = client.rotate_key("rotation-sample-key")
+print(f"Rotated the key on-demand; new version is {rotated_key.properties.version}")
 ```
 
+<!-- END SNIPPET -->
+
 ### List keys
 [list_properties_of_keys](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.list_properties_of_keys)
 lists the properties of all of the keys in the client's vault.
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
@@ -221,15 +244,15 @@
     print(key.name)
 ```
 
 ### Cryptographic operations
 [CryptographyClient](https://aka.ms/azsdk/python/keyvault-keys/crypto/docs#azure.keyvault.keys.crypto.CryptographyClient)
 enables cryptographic operations (encrypt/decrypt, wrap/unwrap, sign/verify) using a particular key.
 
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 from azure.keyvault.keys.crypto import CryptographyClient, EncryptionAlgorithm
 
 credential = DefaultAzureCredential()
 key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
 
@@ -252,15 +275,15 @@
 [azure-core documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/CLIENT_LIBRARY_DEVELOPER.md#transport)
 for more information.
 
 Async clients and credentials should be closed when they're no longer needed. These
 objects are async context managers and define async `close` methods. For
 example:
 
-```py
+```python
 from azure.identity.aio import DefaultAzureCredential
 from azure.keyvault.keys.aio import KeyClient
 
 credential = DefaultAzureCredential()
 
 # call close when the client and credential are no longer needed
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
@@ -344,15 +367,15 @@
 This library uses the standard
 [logging](https://docs.python.org/3/library/logging.html) library for logging.
 Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
 level.
 
 Detailed DEBUG level logging, including request/response bodies and unredacted
 headers, can be enabled on a client with the `logging_enable` argument:
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 import sys
 import logging
 
 # Create a logger for the 'azure' SDK
 logger = logging.getLogger('azure')
@@ -366,27 +389,29 @@
 
 # This client will log detailed information about its HTTP sessions, at DEBUG level
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential, logging_enable=True)
 ```
 
 Similarly, `logging_enable` can enable detailed logging for a single operation,
 even when it isn't enabled for the client:
-```py
+```python
 client.get_key("my-key", logging_enable=True)
 ```
 
 ## Next steps
 Several samples are available in the Azure SDK for Python GitHub repository.
 These provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [hello_world.py][hello_world_sample] ([async version][hello_world_async_sample]) | create/get/update/delete keys |
 | [list_operations.py][list_operations_sample] ([async version][list_operations_async_sample]) | basic list operations for keys |
 | [backup_restore_operations.py][backup_operations_sample] ([async version][backup_operations_async_sample]) | back up and recover keys |
 | [recover_purge_operations.py][recover_purge_sample] ([async version][recover_purge_async_sample]) | recover and purge keys |
+| [key_rotation.py][key_rotation_sample] ([async version][key_rotation_async_sample]) | create/update key rotation policies and rotate keys on-demand |
+| [send_request.py][send_request_sample] | use the `send_request` client method |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the
 [API reference documentation][reference_docs].
 
 ## Contributing
 This project welcomes contributions and suggestions. Most contributions require
@@ -421,14 +446,16 @@
 
 [default_cred_ref]: https://aka.ms/azsdk/python/identity/docs#azure.identity.DefaultAzureCredential
 
 [hello_world_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world.py
 [hello_world_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world_async.py
 
 [key_client_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient
+[key_rotation_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation.py
+[key_rotation_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation_async.py
 [key_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples
 
 [library_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/azure/keyvault/keys
 [list_operations_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations.py
 [list_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations_async.py
 
 [managed_hsm]: https://docs.microsoft.com/azure/key-vault/managed-hsm/overview
@@ -438,21 +465,51 @@
 [pip]: https://pypi.org/project/pip/
 [pypi_package_keys]: https://pypi.org/project/azure-keyvault-keys/
 
 [recover_purge_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations.py
 [recover_purge_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations_async.py
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs
 
+[send_request_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/send_request.py
 [soft_delete]: https://docs.microsoft.com/azure/key-vault/general/soft-delete-overview
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-keys%2FREADME.png)
 
 
 # Release History
 
+## 4.9.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.8.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.8.0b1) An attempt will be made to generate an IV if one isn't provided for local encryption
+  ([#25380](https://github.com/Azure/azure-sdk-for-python/pull/25380))
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.7.0. Only code written against a beta version such as 4.8.0b2 may be affected.
+- Removed support for octet key pair (OKP) keys and operations
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.8.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.8.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.8.0b1) Updated minimum `msrest` version to 0.7.1
+- (From 4.8.0b2) Dropped `msrest` requirement
+- (From 4.8.0b2) Dropped `six` requirement
+- (From 4.8.0b2) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.8.0b2) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.8.0b2 (2022-11-15)
 
 ### Features Added
 - Added support for service API version `7.4-preview.1`
 - `KeyClient` has a `create_okp_key` method to create an octet key pair (OKP) on Managed HSM
 - Added `eddsa` to `SignatureAlgorithm` enum to support signing and verifying using an
   Edwards-Curve Digital Signature Algorithm (EdDSA) on Managed HSM
```

## Comparing `azure-keyvault-keys-4.8.0b2/README.md` & `azure-keyvault-keys-4.9.0b1/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -7,63 +7,76 @@
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 - Vault administration ([azure-keyvault-administration](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration)) - role-based access control (RBAC), and vault-level backup and restore options
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_keys] | [API reference documentation][reference_docs] | [Product documentation][azure_keyvault] | [Samples][key_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_keys]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][azure_keyvault]
+| [Samples][key_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_.
 
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
 ### Install the package
 Install [azure-keyvault-keys][pypi_package_keys] and
 [azure-identity][azure_identity_pypi] with [pip][pip]:
 ```Bash
 pip install azure-keyvault-keys azure-identity
 ```
-[azure-identity][azure_identity] is used for Azure Active Directory
-authentication as demonstrated below.
+[azure-identity][azure_identity] is used for Azure Active Directory authentication as demonstrated below.
 
 ### Prerequisites
 * An [Azure subscription][azure_sub]
 * Python 3.7 or later
 * An existing [Azure Key Vault][azure_keyvault]. If you need to create one, you can do so using the Azure CLI by following the steps in [this document][azure_keyvault_cli].
 * If using Managed HSM, an existing [Key Vault Managed HSM][managed_hsm]. If you need to create a Managed HSM, you can do so using the Azure CLI by following the steps in [this document][managed_hsm_cli].
 
 ### Authenticate the client
-In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as well as a **vault url** and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
+In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as
+well as a **vault URL** and a credential object. This document demonstrates using a
+[DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios. We recommend using a
+[managed identity][managed_identity] for authentication in production environments.
 
-See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
+See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their
+corresponding credential types.
 
 #### Create a client
-After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a key client (replacing the value of `vault_url` with your vault's URL):
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of
+authentication, you can do the following to create a key client (replacing the value of `VAULT_URL` with your vault's
+URL):
+
+<!-- SNIPPET:hello_world.create_a_key_client -->
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 
+VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
-
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+client = KeyClient(vault_url=VAULT_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.keys.aio`'s `KeyClient` instead.
 
 ## Key concepts
 ### Keys
-Azure Key Vault can create and store RSA and elliptic curve keys. Both can
-optionally be protected by hardware security modules (HSMs). Azure Key Vault
-can also perform cryptographic operations with them. For more information about
-keys and supported operations and algorithms, see the
+Azure Key Vault can create and store RSA and elliptic curve keys. Both can optionally be protected by hardware security
+modules (HSMs). Azure Key Vault can also perform cryptographic operations with them. For more information about keys
+and supported operations and algorithms, see the
 [Key Vault documentation](https://docs.microsoft.com/azure/key-vault/keys/about-keys).
 
 [KeyClient][key_client_docs] can create keys in the vault, get existing keys
 from the vault, update key metadata, and delete keys, as shown in the
 [examples](#examples) below.
 
 ## Examples
@@ -76,14 +89,16 @@
 * [List keys](#list-keys)
 * [Perform cryptographic operations](#cryptographic-operations)
 * [Async API](#async-api)
 * [Asynchronously create a key](#asynchronously-create-a-key)
 * [Asynchronously list keys](#asynchronously-list-keys)
 
 ### Create a key
+The [create_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_key) method can be
+used by a `KeyClient` to create a key of any type -- alternatively, specific helpers such as
 [create_rsa_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_rsa_key) and
 [create_ec_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_ec_key)
 create RSA and elliptic curve keys in the vault, respectively. If a key with the same name already exists, a new version
 of that key is created.
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -152,40 +167,47 @@
 deleted_key = key_client.begin_delete_key("key-name").result()
 
 print(deleted_key.name)
 print(deleted_key.deleted_date)
 ```
 
 ### Configure automatic key rotation
-[update_key_rotation_policy](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
-allows you to configure automatic key rotation for a key by specifying a rotation policy.
-In addition,
-[rotate_key](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.rotate_key)
-allows you to rotate a key on-demand by creating a new version of the given key.
+[update_key_rotation_policy](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
+can be used by a `KeyClient` to configure automatic key rotation for a key by specifying a rotation policy.
+
+<!-- SNIPPET:key_rotation.update_a_rotation_policy -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.keys import KeyClient, KeyRotationLifetimeAction, KeyRotationPolicyAction
+from azure.keyvault.keys import KeyRotationLifetimeAction, KeyRotationPolicy, KeyRotationPolicyAction
 
-credential = DefaultAzureCredential()
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+# Here we set the key's automated rotation policy to rotate the key two months after the key was created.
+# If you pass an empty KeyRotationPolicy() as the `policy` parameter, the rotation policy will be set to the
+# default policy. Any keyword arguments will update specified properties of the policy.
+actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.rotate, time_after_create="P2M")]
+updated_policy = client.update_key_rotation_policy(
+    "rotation-sample-key", policy=KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
+)
+assert updated_policy.expires_in == "P90D"
+```
 
-# Set the key's automated rotation policy to rotate the key 30 days before the key expires
-actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.ROTATE, time_before_expiry="P30D")]
-# You may also specify the duration after which the newly rotated key will expire
-# In this example, any new key versions will expire after 90 days
-updated_policy = key_client.update_key_rotation_policy("key-name", expires_in="P90D", lifetime_actions=actions)
+<!-- END SNIPPET -->
 
-# You can get the current rotation policy for a key with get_key_rotation_policy
-current_policy = key_client.get_key_rotation_policy("key-name")
+In addition,
+[rotate_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.rotate_key)
+allows you to rotate a key on-demand by creating a new version of the given key.
 
-# Finally, you can rotate a key on-demand by creating a new version of the key
-rotated_key = key_client.rotate_key("key-name")
+<!-- SNIPPET:key_rotation.rotate_key -->
+
+```python
+rotated_key = client.rotate_key("rotation-sample-key")
+print(f"Rotated the key on-demand; new version is {rotated_key.properties.version}")
 ```
 
+<!-- END SNIPPET -->
+
 ### List keys
 [list_properties_of_keys](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.list_properties_of_keys)
 lists the properties of all of the keys in the client's vault.
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
@@ -200,15 +222,15 @@
     print(key.name)
 ```
 
 ### Cryptographic operations
 [CryptographyClient](https://aka.ms/azsdk/python/keyvault-keys/crypto/docs#azure.keyvault.keys.crypto.CryptographyClient)
 enables cryptographic operations (encrypt/decrypt, wrap/unwrap, sign/verify) using a particular key.
 
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 from azure.keyvault.keys.crypto import CryptographyClient, EncryptionAlgorithm
 
 credential = DefaultAzureCredential()
 key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
 
@@ -231,15 +253,15 @@
 [azure-core documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/CLIENT_LIBRARY_DEVELOPER.md#transport)
 for more information.
 
 Async clients and credentials should be closed when they're no longer needed. These
 objects are async context managers and define async `close` methods. For
 example:
 
-```py
+```python
 from azure.identity.aio import DefaultAzureCredential
 from azure.keyvault.keys.aio import KeyClient
 
 credential = DefaultAzureCredential()
 
 # call close when the client and credential are no longer needed
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
@@ -323,15 +345,15 @@
 This library uses the standard
 [logging](https://docs.python.org/3/library/logging.html) library for logging.
 Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
 level.
 
 Detailed DEBUG level logging, including request/response bodies and unredacted
 headers, can be enabled on a client with the `logging_enable` argument:
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 import sys
 import logging
 
 # Create a logger for the 'azure' SDK
 logger = logging.getLogger('azure')
@@ -345,27 +367,29 @@
 
 # This client will log detailed information about its HTTP sessions, at DEBUG level
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential, logging_enable=True)
 ```
 
 Similarly, `logging_enable` can enable detailed logging for a single operation,
 even when it isn't enabled for the client:
-```py
+```python
 client.get_key("my-key", logging_enable=True)
 ```
 
 ## Next steps
 Several samples are available in the Azure SDK for Python GitHub repository.
 These provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [hello_world.py][hello_world_sample] ([async version][hello_world_async_sample]) | create/get/update/delete keys |
 | [list_operations.py][list_operations_sample] ([async version][list_operations_async_sample]) | basic list operations for keys |
 | [backup_restore_operations.py][backup_operations_sample] ([async version][backup_operations_async_sample]) | back up and recover keys |
 | [recover_purge_operations.py][recover_purge_sample] ([async version][recover_purge_async_sample]) | recover and purge keys |
+| [key_rotation.py][key_rotation_sample] ([async version][key_rotation_async_sample]) | create/update key rotation policies and rotate keys on-demand |
+| [send_request.py][send_request_sample] | use the `send_request` client method |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the
 [API reference documentation][reference_docs].
 
 ## Contributing
 This project welcomes contributions and suggestions. Most contributions require
@@ -400,14 +424,16 @@
 
 [default_cred_ref]: https://aka.ms/azsdk/python/identity/docs#azure.identity.DefaultAzureCredential
 
 [hello_world_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world.py
 [hello_world_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world_async.py
 
 [key_client_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient
+[key_rotation_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation.py
+[key_rotation_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation_async.py
 [key_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples
 
 [library_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/azure/keyvault/keys
 [list_operations_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations.py
 [list_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations_async.py
 
 [managed_hsm]: https://docs.microsoft.com/azure/key-vault/managed-hsm/overview
@@ -417,10 +443,11 @@
 [pip]: https://pypi.org/project/pip/
 [pypi_package_keys]: https://pypi.org/project/azure-keyvault-keys/
 
 [recover_purge_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations.py
 [recover_purge_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations_async.py
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs
 
+[send_request_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/send_request.py
 [soft_delete]: https://docs.microsoft.com/azure/key-vault/general/soft-delete-overview
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-keys%2FREADME.png)
```

## Comparing `azure-keyvault-keys-4.8.0b2/LICENSE` & `azure-keyvault-keys-4.9.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/CHANGELOG.md` & `azure-keyvault-keys-4.9.0b1/CHANGELOG.md`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,38 @@
 # Release History
 
+## 4.9.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.8.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.8.0b1) An attempt will be made to generate an IV if one isn't provided for local encryption
+  ([#25380](https://github.com/Azure/azure-sdk-for-python/pull/25380))
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.7.0. Only code written against a beta version such as 4.8.0b2 may be affected.
+- Removed support for octet key pair (OKP) keys and operations
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.8.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.8.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.8.0b1) Updated minimum `msrest` version to 0.7.1
+- (From 4.8.0b2) Dropped `msrest` requirement
+- (From 4.8.0b2) Dropped `six` requirement
+- (From 4.8.0b2) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.8.0b2) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.8.0b2 (2022-11-15)
 
 ### Features Added
 - Added support for service API version `7.4-preview.1`
 - `KeyClient` has a `create_okp_key` method to create an octet key pair (OKP) on Managed HSM
 - Added `eddsa` to `SignatureAlgorithm` enum to support signing and verifying using an
   Edwards-Curve Digital Signature Algorithm (EdDSA) on Managed HSM
```

## Comparing `azure-keyvault-keys-4.8.0b2/setup.py` & `azure-keyvault-keys-4.9.0b1/setup.py`

 * *Files 4% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 with open("CHANGELOG.md", encoding="utf-8") as f:
     CHANGELOG = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=VERSION,
     include_package_data=True,
-    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    description=f"Microsoft Azure {PACKAGE_PPRINT_NAME} Client Library for Python",
     long_description=README + "\n\n" + CHANGELOG,
     long_description_content_type="text/markdown",
     license="MIT License",
     author="Microsoft Corporation",
     author_email="azurekeyvault@microsoft.com",
     url="https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys",
     classifiers=[
@@ -48,14 +48,15 @@
         "Programming Language :: Python",
         "Programming Language :: Python :: 3 :: Only",
         "Programming Language :: Python :: 3",
         "Programming Language :: Python :: 3.7",
         "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
         "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
     packages=find_packages(
         exclude=[
             "samples",
             "tests",
```

## Comparing `azure-keyvault-keys-4.8.0b2/migration_guide.md` & `azure-keyvault-keys-4.9.0b1/migration_guide.md`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_enums.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 class KeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported elliptic curves"""
 
     p_256 = "P-256"  #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     p_384 = "P-384"  #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
     p_521 = "P-521"  #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
     p_256_k = "P-256K"  #: The SECG SECP256K1 elliptic curve.
-    ed25519 = "Ed25519"  #: The Ed25519 Edwards curve.
 
 
 class KeyExportEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported algorithms for protecting exported key material"""
 
     ckm_rsa_aes_key_wrap = "CKM_RSA_AES_KEY_WRAP"
     rsa_aes_key_wrap_256 = "RSA_AES_KEY_WRAP_256"
@@ -53,16 +52,14 @@
 
     ec = "EC"  #: Elliptic Curve
     ec_hsm = "EC-HSM"  #: Elliptic Curve with a private key which is not exportable from the HSM
     rsa = "RSA"  #: RSA (https://tools.ietf.org/html/rfc3447)
     rsa_hsm = "RSA-HSM"  #: RSA with a private key which is not exportable from the HSM
     oct = "oct"  #: Octet sequence (used to represent symmetric keys)
     oct_hsm = "oct-HSM"  #: Octet sequence with a private key which is not exportable from the HSM
-    okp = "OKP"  #: Octet key pair (https://tools.ietf.org/html/rfc8037)
-    okp_hsm = "OKP-HSM"  #: Octet key pair with a private key which is not exportable from the HSM
 
     @classmethod
     def _missing_(cls, value):
         for member in cls:
             if member.value.lower() == value.lower():
                 return member
         raise ValueError(f"{value} is not a valid KeyType")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,23 +14,25 @@
 try:
     from typing import TYPE_CHECKING
 except ImportError:
     TYPE_CHECKING = False
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import
-    from typing import Any, Optional, Union
+    from datetime import datetime
+    from typing import Optional, Union
     from azure.core.paging import ItemPaged
     from azure.core.polling import LROPoller
+    from ._enums import KeyType
+    from ._generated_models import KeyAttributes
     from ._models import JsonWebKey
-    from ._enums import KeyCurveName, KeyType
 
 
 def _get_key_id(vault_url, key_name, version=None):
-    without_version = "{}/keys/{}".format(vault_url, key_name)
+    without_version = f"{vault_url}/keys/{key_name}"
     return without_version + "/" + version if version else without_version
 
 
 class KeyClient(KeyVaultClientBase):
     """A high-level interface for managing a vault's keys.
 
     :param str vault_url: URL of the vault the client will access. This is also called the vault's "DNS Name".
@@ -52,24 +54,29 @@
             :language: python
             :caption: Create a new ``KeyClient``
             :dedent: 4
     """
 
     # pylint:disable=protected-access, too-many-public-methods
 
-    def _get_attributes(self, enabled, not_before, expires_on, exportable=None):
+    def _get_attributes(
+        self,
+        enabled: "Optional[bool]",
+        not_before: "Optional[datetime]",
+        expires_on: "Optional[datetime]",
+        exportable: "Optional[bool]" = None,
+    ) -> "Optional[KeyAttributes]":
         """Return a KeyAttributes object if none-None attributes are provided, or None otherwise"""
         if enabled is not None or not_before is not None or expires_on is not None or exportable is not None:
             return self._models.KeyAttributes(
                 enabled=enabled, not_before=not_before, expires=expires_on, exportable=exportable
             )
         return None
 
-    def get_cryptography_client(self, key_name, **kwargs):
-        # type: (str, **Any) -> CryptographyClient
+    def get_cryptography_client(self, key_name: str, **kwargs) -> CryptographyClient:
         """Gets a :class:`~azure.keyvault.keys.crypto.CryptographyClient` for the given key.
 
         :param str key_name: The name of the key used to perform cryptographic operations.
 
         :keyword str key_version: Optional version of the key used to perform cryptographic operations.
 
         :returns: A :class:`~azure.keyvault.keys.crypto.CryptographyClient` using the same options, credentials, and
@@ -80,43 +87,49 @@
 
         # We provide a fake credential because the generated client already has the KeyClient's real credential
         return CryptographyClient(
             key_id, object(), generated_client=self._client, generated_models=self._models  # type: ignore
         )
 
     @distributed_trace
-    def create_key(self, name, key_type, **kwargs):
-        # type: (str, Union[str, KeyType], **Any) -> KeyVaultKey
+    def create_key(self, name: str, key_type: "Union[str, KeyType]", **kwargs) -> KeyVaultKey:
         """Create a key or, if ``name`` is already in use, create a new version of the key.
 
         Requires keys/create permission.
 
         :param str name: The name of the new key.
         :param key_type: The type of key to create
         :type key_type: ~azure.keyvault.keys.KeyType or str
 
-        :keyword int size: Key size in bits. Applies only to RSA and symmetric keys. Consider using
-         :func:`create_rsa_key` or :func:`create_oct_key` instead.
+        :keyword size: Key size in bits. Applies only to RSA and symmetric keys. Consider using
+            :func:`create_rsa_key` or :func:`create_oct_key` instead.
+        :paramtype size: int or None
         :keyword curve: Elliptic curve name. Applies only to elliptic curve keys. Defaults to the NIST P-256
-         elliptic curve. To create an elliptic curve key, consider using :func:`create_ec_key` instead.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
-        :keyword int public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+            elliptic curve. To create an elliptic curve key, consider using :func:`create_ec_key` instead.
+        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str or None
+        :keyword public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+        :paramtype public_exponent: int or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START create_key]
                 :end-before: [END create_key]
                 :language: python
@@ -149,113 +162,130 @@
 
         bundle = self._client.create_key(
             vault_base_url=self.vault_url, key_name=name, parameters=parameters, error_map=_error_map, **kwargs
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def create_rsa_key(self, name, **kwargs):
-        # type: (str, **Any) -> KeyVaultKey
+    def create_rsa_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new RSA key or, if ``name`` is already in use, create a new version of the key
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
-        :keyword int size: Key size in bits, for example 2048, 3072, or 4096.
-        :keyword int public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
+        :keyword size: Key size in bits, for example 2048, 3072, or 4096.
+        :paramtype size: int or None
+        :keyword public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+        :paramtype public_exponent: int or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START create_rsa_key]
                 :end-before: [END create_rsa_key]
                 :language: python
                 :caption: Create RSA key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return self.create_key(name, key_type="RSA-HSM" if hsm else "RSA", **kwargs)
 
     @distributed_trace
-    def create_ec_key(self, name, **kwargs):
-        # type: (str, **Any) -> KeyVaultKey
+    def create_ec_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new elliptic curve key or, if ``name`` is already in use, create a new version of the key.
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
         :keyword curve: Elliptic curve name. Defaults to the NIST P-256 elliptic curve.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
+        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START create_ec_key]
                 :end-before: [END create_ec_key]
                 :language: python
                 :caption: Create an elliptic curve key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return self.create_key(name, key_type="EC-HSM" if hsm else "EC", **kwargs)
 
     @distributed_trace
-    def create_oct_key(self, name, **kwargs):
-        # type: (str, **Any) -> KeyVaultKey
+    def create_oct_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new octet sequence (symmetric) key or, if ``name`` is in use, create a new version of the key.
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
-        :keyword int size: Key size in bits, for example 128, 192, or 256.
+        :keyword size: Key size in bits, for example 128, 192, or 256.
+        :paramtype size: int or None
         :keyword key_operations: Allowed key operations.
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
@@ -265,68 +295,30 @@
                 :caption: Create an octet sequence (symmetric) key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return self.create_key(name, key_type="oct-HSM" if hsm else "oct", **kwargs)
 
     @distributed_trace
-    def create_okp_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
-        """Create a new octet key pair or, if ``name`` is in use, create a new version of the key.
-
-        Requires the keys/create permission.
-
-        :param str name: The name for the new key.
-
-        :keyword curve: Elliptic curve name.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
-        :keyword key_operations: Allowed key operations.
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-            Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
-        :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the key can be exported.
-        :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
-
-        :returns: The created key
-        :rtype: ~azure.keyvault.keys.KeyVaultKey
-        :raises: :class:`~azure.core.exceptions.HttpResponseError`
-
-        Example:
-            .. literalinclude:: ../tests/test_samples_keys.py
-                :start-after: [START create_okp_key]
-                :end-before: [END create_okp_key]
-                :language: python
-                :caption: Create an octet key pair (OKP)
-                :dedent: 8
-        """
-        hsm = kwargs.pop("hardware_protected", False)
-        return self.create_key(name, key_type="OKP-HSM" if hsm else "OKP", **kwargs)
-
-    @distributed_trace
-    def begin_delete_key(self, name, **kwargs):
-        # type: (str, **Any) -> LROPoller
+    def begin_delete_key(self, name: str, **kwargs) -> "LROPoller[DeletedKey]":
         """Delete all versions of a key and its cryptographic material.
 
         Requires keys/delete permission. When this method returns Key Vault has begun deleting the key. Deletion may
         take several seconds in a vault with soft-delete enabled. This method therefore returns a poller enabling you to
         wait for deletion to complete.
 
         :param str name: The name of the key to delete.
 
         :returns: A poller for the delete key operation. The poller's `result` method returns the
-         :class:`~azure.keyvault.keys.DeletedKey` without waiting for deletion to complete. If the vault has
-         soft-delete enabled and you want to permanently delete the key with :func:`purge_deleted_key`, call the
-         poller's `wait` method first. It will block until the deletion is complete. The `wait` method requires
-         keys/get permission.
+            :class:`~azure.keyvault.keys.DeletedKey` without waiting for deletion to complete. If the vault has
+            soft-delete enabled and you want to permanently delete the key with :func:`purge_deleted_key`, call the
+            poller's `wait` method first. It will block until the deletion is complete. The `wait` method requires
+            keys/get permission.
         :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.keys.DeletedKey]
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START delete_key]
@@ -349,25 +341,26 @@
             command=command,
             final_resource=deleted_key,
             interval=polling_interval,
         )
         return KeyVaultOperationPoller(polling_method)
 
     @distributed_trace
-    def get_key(self, name, version=None, **kwargs):
-        # type: (str, Optional[str], **Any) -> KeyVaultKey
+    def get_key(self, name: str, version: "Optional[str]" = None, **kwargs) -> KeyVaultKey:
         """Get a key's attributes and, if it's an asymmetric key, its public material.
 
         Requires keys/get permission.
 
         :param str name: The name of the key to get.
-        :param str version: (optional) A specific version of the key to get. If not specified, gets the latest version
+        :param version: (optional) A specific version of the key to get. If not specified, gets the latest version
             of the key.
+        :type version: str or None
 
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START get_key]
@@ -376,24 +369,24 @@
                 :caption: Get a key
                 :dedent: 8
         """
         bundle = self._client.get_key(self.vault_url, name, key_version=version or "", error_map=_error_map, **kwargs)
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def get_deleted_key(self, name, **kwargs):
-        # type: (str, **Any) -> DeletedKey
+    def get_deleted_key(self, name: str, **kwargs) -> DeletedKey:
         """Get a deleted key. Possible only in a vault with soft-delete enabled.
 
         Requires keys/get permission.
 
         :param str name: The name of the key
 
         :returns: The deleted key
         :rtype: ~azure.keyvault.keys.DeletedKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START get_deleted_key]
@@ -402,16 +395,15 @@
                 :caption: Get a deleted key
                 :dedent: 8
         """
         bundle = self._client.get_deleted_key(self.vault_url, name, error_map=_error_map, **kwargs)
         return DeletedKey._from_deleted_key_bundle(bundle)
 
     @distributed_trace
-    def list_deleted_keys(self, **kwargs):
-        # type: (**Any) -> ItemPaged[DeletedKey]
+    def list_deleted_keys(self, **kwargs) -> "ItemPaged[DeletedKey]":
         """List all deleted keys, including the public part of each. Possible only in a vault with soft-delete enabled.
 
         Requires keys/list permission.
 
         :returns: An iterator of deleted keys
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.keys.DeletedKey]
 
@@ -428,16 +420,15 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [DeletedKey._from_deleted_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs
         )
 
     @distributed_trace
-    def list_properties_of_keys(self, **kwargs):
-        # type: (**Any) -> ItemPaged[KeyProperties]
+    def list_properties_of_keys(self, **kwargs) -> "ItemPaged[KeyProperties]":
         """List identifiers and properties of all keys in the vault.
 
         Requires keys/list permission.
 
         :returns: An iterator of keys without their cryptographic material or version information
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.keys.KeyProperties]
 
@@ -454,16 +445,15 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [KeyProperties._from_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs
         )
 
     @distributed_trace
-    def list_properties_of_key_versions(self, name, **kwargs):
-        # type: (str, **Any) -> ItemPaged[KeyProperties]
+    def list_properties_of_key_versions(self, name: str, **kwargs) -> "ItemPaged[KeyProperties]":
         """List the identifiers and properties of a key's versions.
 
         Requires keys/list permission.
 
         :param str name: The name of the key
 
         :returns: An iterator of keys without their cryptographic material
@@ -483,59 +473,58 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [KeyProperties._from_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs
         )
 
     @distributed_trace
-    def purge_deleted_key(self, name, **kwargs):
-        # type: (str, **Any) -> None
+    def purge_deleted_key(self, name: str, **kwargs) -> None:
         """Permanently deletes a deleted key. Only possible in a vault with soft-delete enabled.
 
-        Performs an irreversible deletion of the specified key, without
-        possibility for recovery. The operation is not available if the
-        :py:attr:`~azure.keyvault.keys.KeyProperties.recovery_level` does not specify 'Purgeable'.
+        Performs an irreversible deletion of the specified key, without possibility for recovery. The operation is not
+        available if the :py:attr:`~azure.keyvault.keys.KeyProperties.recovery_level` does not specify 'Purgeable'.
         This method is only necessary for purging a key before its
         :py:attr:`~azure.keyvault.keys.DeletedKey.scheduled_purge_date`.
 
         Requires keys/purge permission.
 
         :param str name: The name of the deleted key to purge
 
         :returns: None
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. code-block:: python
 
                 # if the vault has soft-delete enabled, purge permanently deletes a deleted key
                 # (with soft-delete disabled, begin_delete_key is permanent)
                 key_client.purge_deleted_key("key-name")
 
         """
         self._client.purge_deleted_key(vault_base_url=self.vault_url, key_name=name, error_map=_error_map, **kwargs)
 
     @distributed_trace
-    def begin_recover_deleted_key(self, name, **kwargs):
-        # type: (str, **Any) -> LROPoller
+    def begin_recover_deleted_key(self, name: str, **kwargs) -> "LROPoller[KeyVaultKey]":
         """Recover a deleted key to its latest version. Possible only in a vault with soft-delete enabled.
 
         Requires keys/recover permission.
 
         When this method returns Key Vault has begun recovering the key. Recovery may take several seconds. This
         method therefore returns a poller enabling you to wait for recovery to complete. Waiting is only necessary when
         you want to use the recovered key in another operation immediately.
 
         :param str name: The name of the deleted key to recover
 
         :returns: A poller for the recovery operation. The poller's `result` method returns the recovered
-         :class:`~azure.keyvault.keys.KeyVaultKey` without waiting for recovery to complete. If you want to use the
-         recovered key immediately, call the poller's `wait` method, which blocks until the key is ready to use. The
-         `wait` method requires keys/get permission.
+            :class:`~azure.keyvault.keys.KeyVaultKey` without waiting for recovery to complete. If you want to use the
+            recovered key immediately, call the poller's `wait` method, which blocks until the key is ready to use. The
+            `wait` method requires keys/get permission.
         :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.keys.KeyVaultKey]
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START recover_deleted_key]
                 :end-before: [END recover_deleted_key]
                 :language: python
@@ -557,35 +546,39 @@
             final_resource=recovered_key,
             interval=polling_interval,
         )
 
         return KeyVaultOperationPoller(polling_method)
 
     @distributed_trace
-    def update_key_properties(self, name, version=None, **kwargs):
-        # type: (str, Optional[str], **Any) -> KeyVaultKey
+    def update_key_properties(self, name: str, version: "Optional[str]" = None, **kwargs) -> KeyVaultKey:
         """Change a key's properties (not its cryptographic material).
 
         Requires keys/update permission.
 
         :param str name: The name of key to update
-        :param str version: (optional) The version of the key to update. If unspecified, the latest version is updated.
+        :param version: (optional) The version of the key to update. If unspecified, the latest version is updated.
+        :type version: str or None
 
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The updated key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START update_key]
@@ -613,27 +606,27 @@
 
         bundle = self._client.update_key(
             self.vault_url, name, key_version=version or "", parameters=parameters, error_map=_error_map, **kwargs
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def backup_key(self, name, **kwargs):
-        # type: (str, **Any) -> bytes
+    def backup_key(self, name: str, **kwargs) -> bytes:
         """Back up a key in a protected form useable only by Azure Key Vault.
 
         Requires keys/backup permission.
 
         This is intended to allow copying a key from one vault to another. Both vaults must be owned by the same Azure
         subscription. Also, backup / restore cannot be performed across geopolitical boundaries. For example, a backup
         from a vault in a USA region cannot be restored to a vault in an EU region.
 
         :param str name: The name of the key to back up
 
         :rtype: bytes
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START backup_key]
@@ -642,28 +635,28 @@
                 :caption: Get a key backup
                 :dedent: 8
         """
         backup_result = self._client.backup_key(self.vault_url, name, error_map=_error_map, **kwargs)
         return backup_result.value
 
     @distributed_trace
-    def restore_key_backup(self, backup, **kwargs):
-        # type: (bytes, **Any) -> KeyVaultKey
+    def restore_key_backup(self, backup: bytes, **kwargs) -> KeyVaultKey:
         """Restore a key backup to the vault.
 
         Requires keys/restore permission.
 
         This imports all versions of the key, with its name, attributes, and access control policies. If the key's name
         is already in use, restoring it will fail. Also, the target vault must be owned by the same Microsoft Azure
         subscription as the source vault.
 
         :param bytes backup: A key backup as returned by :func:`backup_key`
 
         :returns: The restored key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceExistsError` if the backed up key's name is already in use,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys.py
                 :start-after: [START restore_key_backup]
@@ -677,36 +670,41 @@
             parameters=self._models.KeyRestoreParameters(key_bundle_backup=backup),
             error_map=_error_map,
             **kwargs
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def import_key(self, name, key, **kwargs):
-        # type: (str, JsonWebKey, **Any) -> KeyVaultKey
+    def import_key(self, name: str, key: "JsonWebKey", **kwargs) -> KeyVaultKey:
         """Import a key created externally.
 
         Requires keys/import permission. If ``name`` is already in use, the key will be imported as a new version.
 
         :param str name: Name for the imported key
         :param key: The JSON web key to import
         :type key: ~azure.keyvault.keys.JsonWebKey
 
-        :keyword bool hardware_protected: Whether the key should be backed by a hardware security module
-        :keyword bool enabled: Whether the key is enabled for use.
+        :keyword hardware_protected: Whether the key should be backed by a hardware security module
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The imported key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         enabled = kwargs.pop("enabled", None)
         not_before = kwargs.pop("not_before", None)
         expires_on = kwargs.pop("expires_on", None)
         exportable = kwargs.pop("exportable", None)
         attributes = self._get_attributes(
@@ -726,56 +724,58 @@
             release_policy=policy,
         )
 
         bundle = self._client.import_key(self.vault_url, name, parameters=parameters, error_map=_error_map, **kwargs)
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def release_key(self, name, target_attestation_token, **kwargs):
-        # type: (str, str, **Any) -> ReleaseKeyResult
+    def release_key(self, name: str, target_attestation_token: str, **kwargs) -> ReleaseKeyResult:
         """Releases a key.
 
         The release key operation is applicable to all key types. The target key must be marked
         exportable. This operation requires the keys/release permission.
 
         :param str name: The name of the key to get.
         :param str target_attestation_token: The attestation assertion for the target of the key release.
 
-        :keyword str version: A specific version of the key to release. If unspecified, the latest version is released.
+        :keyword version: A specific version of the key to release. If unspecified, the latest version is released.
+        :paramtype version: str or None
         :keyword algorithm: The encryption algorithm to use to protect the released key material.
-        :paramtype algorithm: Union[str, ~azure.keyvault.keys.KeyExportEncryptionAlgorithm]
-        :keyword str nonce: A client-provided nonce for freshness.
+        :paramtype algorithm: str or ~azure.keyvault.keys.KeyExportEncryptionAlgorithm or None
+        :keyword nonce: A client-provided nonce for freshness.
+        :paramtype nonce: str or None
 
         :return: The result of the key release.
         :rtype: ~azure.keyvault.keys.ReleaseKeyResult
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
-        version = kwargs.pop("version", "")
+        version = kwargs.pop("version", None)
         result = self._client.release(
             vault_base_url=self._vault_url,
             key_name=name,
-            key_version=version,
+            key_version=version or "",
             parameters=self._models.KeyReleaseParameters(
                 target_attestation_token=target_attestation_token,
                 nonce=kwargs.pop("nonce", None),
                 enc=kwargs.pop("algorithm", None),
             ),
             **kwargs
         )
         return ReleaseKeyResult(result.value)
 
     @distributed_trace
-    def get_random_bytes(self, count, **kwargs):
-        # type: (int, **Any) -> bytes
+    def get_random_bytes(self, count: int, **kwargs) -> bytes:
         """Get the requested number of random bytes from a managed HSM.
 
         :param int count: The requested number of random bytes.
 
         :return: The random bytes.
         :rtype: bytes
+
         :raises:
             :class:`ValueError` if less than one random byte is requested,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_key_client.py
                 :start-after: [START get_random_bytes]
@@ -787,64 +787,66 @@
         if count < 1:
             raise ValueError("At least one random byte must be requested")
         parameters = self._models.GetRandomBytesRequest(count=count)
         result = self._client.get_random_bytes(vault_base_url=self._vault_url, parameters=parameters, **kwargs)
         return result.value
 
     @distributed_trace
-    def get_key_rotation_policy(self, key_name, **kwargs):
-        # type: (str, **Any) -> KeyRotationPolicy
+    def get_key_rotation_policy(self, key_name: str, **kwargs) -> KeyRotationPolicy:
         """Get the rotation policy of a Key Vault key.
 
         :param str key_name: The name of the key.
 
         :return: The key rotation policy.
         :rtype: ~azure.keyvault.keys.KeyRotationPolicy
+
         :raises: :class: `~azure.core.exceptions.HttpResponseError`
         """
         policy = self._client.get_key_rotation_policy(vault_base_url=self._vault_url, key_name=key_name, **kwargs)
         return KeyRotationPolicy._from_generated(policy)
 
     @distributed_trace
-    def rotate_key(self, name, **kwargs):
-        # type: (str, **Any) -> KeyVaultKey
+    def rotate_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Rotate the key based on the key policy by generating a new version of the key.
 
         This operation requires the keys/rotate permission.
 
         :param str name: The name of the key to rotate.
 
         :return: The new version of the rotated key.
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         bundle = self._client.rotate_key(vault_base_url=self._vault_url, key_name=name, **kwargs)
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace
-    def update_key_rotation_policy(self, key_name, policy, **kwargs):
-        # type: (str, KeyRotationPolicy, **Any) -> KeyRotationPolicy
+    def update_key_rotation_policy(
+        self, key_name: str, policy: KeyRotationPolicy, **kwargs
+    ) -> KeyRotationPolicy:
         """Updates the rotation policy of a Key Vault key.
 
         This operation requires the keys/update permission.
 
         :param str key_name: The name of the key in the given vault.
         :param policy: The new rotation policy for the key.
         :type policy: ~azure.keyvault.keys.KeyRotationPolicy
 
         :keyword lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a key. This will
             override the lifetime actions of the provided ``policy``.
-        :paramtype lifetime_actions: List[~azure.keyvault.keys.KeyRotationLifetimeAction]
+        :paramtype lifetime_actions: list[~azure.keyvault.keys.KeyRotationLifetimeAction]
         :keyword str expires_in: The expiry time of the policy that will be applied on new key versions, defined as an
             ISO 8601 duration. For example: 90 days is "P90D", 3 months is "P3M", and 48 hours is "PT48H". See
             `Wikipedia <https://wikipedia.org/wiki/ISO_8601#Durations>`_ for more information on ISO 8601 durations.
             This will override the expiry time of the provided ``policy``.
 
         :return: The updated rotation policy.
         :rtype: ~azure.keyvault.keys.KeyRotationPolicy
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         lifetime_actions = kwargs.pop("lifetime_actions", policy.lifetime_actions)
         if lifetime_actions:
             lifetime_actions = [
                 self._models.LifetimeActions(
                     action=self._models.LifetimeActionsType(type=action.action),
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_models.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_models.py`

 * *Files 12% similar despite different names*

```diff
@@ -44,46 +44,41 @@
     :type crv: ~azure.keyvault.keys.KeyCurveName or str
     :param bytes x: X component of an EC public key.
     :param bytes y: Y component of an EC public key.
     """
 
     _FIELDS = ("kid", "kty", "key_ops", "n", "e", "d", "dp", "dq", "qi", "p", "q", "k", "t", "crv", "x", "y")
 
-    def __init__(self, **kwargs):
-        # type: (**Any) -> None
+    def __init__(self, **kwargs) -> None:
         for field in self._FIELDS:
             setattr(self, field, kwargs.get(field))
 
-    def _to_generated_model(self):
-        # type: () -> _JsonWebKey
+    def _to_generated_model(self) -> _JsonWebKey:
         jwk = _JsonWebKey()
         for field in self._FIELDS:
             setattr(jwk, field, getattr(self, field))
         return jwk
 
 
 class KeyProperties(object):
     """A key's id and attributes."""
 
-    def __init__(self, key_id, attributes=None, **kwargs):
-        # type: (str, Optional[_models.KeyAttributes], **Any) -> None
+    def __init__(self, key_id: str, attributes: "Optional[_models.KeyAttributes]" = None, **kwargs) -> None:
         self._attributes = attributes
         self._id = key_id
         self._vault_id = KeyVaultKeyIdentifier(key_id)
         self._managed = kwargs.get("managed", None)
         self._tags = kwargs.get("tags", None)
         self._release_policy = kwargs.pop("release_policy", None)
 
-    def __repr__(self):
-        # type () -> str
-        return "<KeyProperties [{}]>".format(self.id)[:1024]
+    def __repr__(self) -> str:
+        return f"<KeyProperties [{self.id}]>"[:1024]
 
     @classmethod
-    def _from_key_bundle(cls, key_bundle):
-        # type: (_models.KeyBundle) -> KeyProperties
+    def _from_key_bundle(cls, key_bundle: "_models.KeyBundle") -> "KeyProperties":
         """Construct a KeyProperties from an autorest-generated KeyBundle"""
         # pylint:disable=line-too-long
         # release_policy was added in 7.3-preview
         release_policy = None
         if (
             hasattr(key_bundle, "release_policy") and key_bundle.release_policy is not None  # type: ignore[attr-defined]
         ):
@@ -98,159 +93,143 @@
             attributes=key_bundle.attributes,
             managed=key_bundle.managed,
             tags=key_bundle.tags,
             release_policy=release_policy,
         )
 
     @classmethod
-    def _from_key_item(cls, key_item):
-        # type: (_models.KeyItem) -> KeyProperties
+    def _from_key_item(cls, key_item: "_models.KeyItem") -> "KeyProperties":
         """Construct a KeyProperties from an autorest-generated KeyItem"""
         return cls(
             key_id=key_item.kid,  # type: ignore
             attributes=key_item.attributes,
             managed=key_item.managed,
             tags=key_item.tags,
         )
 
     @property
-    def id(self):
-        # type: () -> str
+    def id(self) -> str:
         """The key's id
 
         :rtype: str
         """
         return self._id
 
     @property
-    def name(self):
-        # type: () -> str
+    def name(self) -> str:
         """The key's name
 
         :rtype: str
         """
         return self._vault_id.name
 
     @property
-    def version(self):
-        # type: () -> Optional[str]
+    def version(self) -> "Optional[str]":
         """The key's version
 
         :rtype: str or None
         """
         return self._vault_id.version
 
     @property
-    def enabled(self):
-        # type: () -> Optional[bool]
+    def enabled(self) -> "Optional[bool]":
         """Whether the key is enabled for use
 
         :rtype: bool or None
         """
         return self._attributes.enabled if self._attributes else None
 
     @property
-    def not_before(self):
-        # type: () -> Optional[datetime]
+    def not_before(self) -> "Optional[datetime]":
         """The time before which the key can not be used, in UTC
 
         :rtype: ~datetime.datetime or None
         """
         return self._attributes.not_before if self._attributes else None
 
     @property
-    def expires_on(self):
-        # type: () -> Optional[datetime]
+    def expires_on(self) -> "Optional[datetime]":
         """When the key will expire, in UTC
 
         :rtype: ~datetime.datetime or None
         """
         return self._attributes.expires if self._attributes else None
 
     @property
-    def created_on(self):
-        # type: () -> Optional[datetime]
+    def created_on(self) -> "Optional[datetime]":
         """When the key was created, in UTC
 
         :rtype: ~datetime.datetime or None
         """
         return self._attributes.created if self._attributes else None
 
     @property
-    def updated_on(self):
-        # type: () -> Optional[datetime]
+    def updated_on(self) -> "Optional[datetime]":
         """When the key was last updated, in UTC
 
         :rtype: ~datetime.datetime or None
         """
         return self._attributes.updated if self._attributes else None
 
     @property
-    def vault_url(self):
-        # type: () -> str
+    def vault_url(self) -> str:
         """URL of the vault containing the key
 
         :rtype: str
         """
         return self._vault_id.vault_url
 
     @property
-    def recoverable_days(self):
-        # type: () -> Optional[int]
+    def recoverable_days(self) -> "Optional[int]":
         """The number of days the key is retained before being deleted from a soft-delete enabled Key Vault.
 
         :rtype: int or None
         """
         # recoverable_days was added in 7.1-preview
         if self._attributes:
             return getattr(self._attributes, "recoverable_days", None)
         return None
 
     @property
-    def recovery_level(self):
-        # type: () -> Optional[str]
+    def recovery_level(self) -> "Optional[str]":
         """The vault's deletion recovery level for keys
 
         :rtype: str or None
         """
         return self._attributes.recovery_level if self._attributes else None
 
     @property
-    def tags(self):
-        # type: () -> Dict[str, str]
+    def tags(self) -> "Dict[str, str]":
         """Application specific metadata in the form of key-value pairs
 
         :rtype: dict[str, str]
         """
         return self._tags
 
     @property
-    def managed(self):
-        # type: () -> Optional[bool]
+    def managed(self) -> "Optional[bool]":
         """Whether the key's lifetime is managed by Key Vault. If the key backs a certificate, this will be true.
 
         :rtype: bool or None
         """
         return self._managed
 
     @property
-    def exportable(self):
-        # type: () -> Optional[bool]
+    def exportable(self) -> "Optional[bool]":
         """Whether the private key can be exported
 
         :rtype: bool or None
         """
         # exportable was added in 7.3-preview
         if self._attributes:
             return getattr(self._attributes, "exportable", None)
         return None
 
     @property
-    def release_policy(self):
-        # type: () -> Optional[KeyReleasePolicy]
+    def release_policy(self) -> "Optional[KeyReleasePolicy]":
         """The :class:`~azure.keyvault.keys.KeyReleasePolicy` specifying the rules under which the key can be exported.
 
         :rtype: ~azure.keyvault.keys.KeyReleasePolicy or None
         """
         return self._release_policy
 
 
@@ -263,92 +242,90 @@
 
     :keyword str content_type: Content type and version of the release policy. Defaults to "application/json;
         charset=utf-8" if omitted.
     :keyword bool immutable: Marks a release policy as immutable. An immutable release policy cannot be changed or
         updated after being marked immutable. Release policies are mutable by default.
     """
 
-    def __init__(self, encoded_policy, **kwargs):
-        # type: (bytes, **Any) -> None
+    def __init__(self, encoded_policy: bytes, **kwargs) -> None:
         self.encoded_policy = encoded_policy
         self.content_type = kwargs.get("content_type", None)
         self.immutable = kwargs.get("immutable", None)
 
 
 class ReleaseKeyResult(object):
     """The result of a key release operation.
 
     :ivar str value: A signed token containing the released key.
     """
 
-    def __init__(self, value):
-        # type: (str) -> None
+    def __init__(self, value: str) -> None:
         self.value = value
 
 
 class KeyRotationLifetimeAction(object):
     """An action and its corresponding trigger that will be performed by Key Vault over the lifetime of a key.
 
     :param action: The action that will be executed.
     :type action: ~azure.keyvault.keys.KeyRotationPolicyAction or str
 
     :keyword time_after_create: Time after creation to attempt the specified action, as an ISO 8601 duration.
         For example, 90 days is "P90D". See `Wikipedia <https://wikipedia.org/wiki/ISO_8601#Durations>`_ for more
         information on ISO 8601 durations.
-    :paramtype time_after_create: Optional[str]
+    :paramtype time_after_create: str or None
     :keyword time_before_expiry: Time before expiry to attempt the specified action, as an ISO 8601 duration.
         For example, 90 days is "P90D". See `Wikipedia <https://wikipedia.org/wiki/ISO_8601#Durations>`_ for more
         information on ISO 8601 durations.
-    :paramtype time_before_expiry: Optional[str]
+    :paramtype time_before_expiry: str or None
     """
 
-    def __init__(self, action, **kwargs):
-        # type: (KeyRotationPolicyAction, **Any) -> None
+    def __init__(self, action: "Union[KeyRotationPolicyAction, str]", **kwargs) -> None:
         self.action = action
-        self.time_after_create = kwargs.get("time_after_create", None)
-        self.time_before_expiry = kwargs.get("time_before_expiry", None)
+        self.time_after_create = kwargs.get("time_after_create", None)  # type: Optional[str]
+        self.time_before_expiry = kwargs.get("time_before_expiry", None)  # type: Optional[str]
 
     @classmethod
-    def _from_generated(cls, lifetime_action):
-        if lifetime_action.trigger:
-            return cls(
-                action=lifetime_action.action.type,
-                time_after_create=lifetime_action.trigger.time_after_create,
-                time_before_expiry=lifetime_action.trigger.time_before_expiry,
-            )
-        return cls(action=lifetime_action.action)
+    def _from_generated(cls, lifetime_action: "_models.LifetimeActions") -> "KeyRotationLifetimeAction":
+        if lifetime_action.action:
+            if lifetime_action.trigger:
+                return cls(
+                    action=lifetime_action.action.type,  # type: ignore
+                    time_after_create=lifetime_action.trigger.time_after_create,
+                    time_before_expiry=lifetime_action.trigger.time_before_expiry,
+                )
+            return cls(action=lifetime_action.action)  # type: ignore
+        raise ValueError("Provided LifetimeActions model is missing a required lifetime action property.")
 
 
 class KeyRotationPolicy(object):
     """The key rotation policy that belongs to a key.
 
     :ivar id: The identifier of the key rotation policy.
-    :vartype id: Optional[str]
+    :vartype id: str or None
     :ivar lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a key.
-    :vartype lifetime_actions: List[~azure.keyvault.keys.KeyRotationLifetimeAction]
+    :vartype lifetime_actions: list[~azure.keyvault.keys.KeyRotationLifetimeAction]
     :ivar expires_in: The expiry time of the policy that will be applied on new key versions, defined as an ISO 8601
         duration. For example, 90 days is "P90D".  See `Wikipedia <https://wikipedia.org/wiki/ISO_8601#Durations>`_ for
         more information on ISO 8601 durations.
-    :vartype expires_in: Optional[str]
+    :vartype expires_in: str or None
     :ivar created_on: When the policy was created, in UTC
-    :vartype created_on: Optional[~datetime.datetime]
+    :vartype created_on: ~datetime.datetime or None
     :ivar updated_on: When the policy was last updated, in UTC
-    :vartype updated_on: Optional[~datetime.datetime]
+    :vartype updated_on: ~datetime.datetime or None
     """
 
-    def __init__(self, **kwargs):
-        # type: (**Any) -> None
+    def __init__(self, **kwargs) -> None:
         self.id = kwargs.get("policy_id", None)
-        self.lifetime_actions = kwargs.get("lifetime_actions", [])
+        self.lifetime_actions = kwargs.get("lifetime_actions", [])  # type: List[KeyRotationLifetimeAction]
         self.expires_in = kwargs.get("expires_in", None)
         self.created_on = kwargs.get("created_on", None)
         self.updated_on = kwargs.get("updated_on", None)
 
     @classmethod
-    def _from_generated(cls, policy):
+    def _from_generated(cls, policy: "_models.KeyRotationPolicy") -> "KeyRotationPolicy":
         lifetime_actions = (
             []
             if policy.lifetime_actions is None
             else [KeyRotationLifetimeAction._from_generated(action) for action in policy.lifetime_actions]  # pylint:disable=protected-access
         )
         if policy.attributes:
             return cls(
@@ -360,19 +337,20 @@
             )
         return cls(policy_id=policy.id, lifetime_actions=lifetime_actions)
 
 
 class KeyVaultKey(object):
     """A key's attributes and cryptographic material.
 
-    :param str key_id:
-        Key Vault's identifier for the key. Typically a URI, e.g. https://myvault.vault.azure.net/keys/my-key/version
-    :param jwk:
-        The key's cryptographic material as a JSON Web Key (https://tools.ietf.org/html/rfc7517). This may be provided
-        as a dictionary or keyword arguments. See :class:`~azure.keyvault.keys.models.JsonWebKey` for field names.
+    :param str key_id: Key Vault's identifier for the key. Typically a URI, e.g.
+        https://myvault.vault.azure.net/keys/my-key/version
+    :param jwk: The key's cryptographic material as a JSON Web Key (https://tools.ietf.org/html/rfc7517). This may be
+        provided as a dictionary or keyword arguments. See :class:`~azure.keyvault.keys.models.JsonWebKey` for field
+        names.
+    :type jwk: Dict[str, Any]
 
     Providing cryptographic material as keyword arguments:
 
     .. code-block:: python
 
         from azure.keyvault.keys.models import KeyVaultKey
 
@@ -389,204 +367,187 @@
         key_id = 'https://myvault.vault.azure.net/keys/my-key/my-key-version'
         key_bytes = os.urandom(32)
         jwk = {'k': key_bytes, 'kty': 'oct', 'key_ops': ['unwrapKey', 'wrapKey']}
         key = KeyVaultKey(key_id, jwk=jwk)
 
     """
 
-    def __init__(self, key_id, jwk=None, **kwargs):
-        # type: (str, Optional[dict], **Any) -> None
-        self._properties = kwargs.pop("properties", None) or KeyProperties(key_id, **kwargs)
+    def __init__(self, key_id: str, jwk: "Optional[Dict[str, Any]]" = None, **kwargs) -> None:
+        self._properties = kwargs.pop("properties", None) or KeyProperties(key_id, **kwargs)  # type: KeyProperties
         if isinstance(jwk, dict):
             if any(field in kwargs for field in JsonWebKey._FIELDS):  # pylint:disable=protected-access
                 raise ValueError(
                     "Individual keyword arguments for key material and the 'jwk' argument are mutually exclusive."
                 )
             self._key_material = JsonWebKey(**jwk)
         else:
             self._key_material = JsonWebKey(**kwargs)
 
-    def __repr__(self):
-        # type () -> str
-        return "<KeyVaultKey [{}]>".format(self.id)[:1024]
+    def __repr__(self) -> str:
+        return f"<KeyVaultKey [{self.id}]>"[:1024]
 
     @classmethod
-    def _from_key_bundle(cls, key_bundle):
-        # type: (_models.KeyBundle) -> KeyVaultKey
+    def _from_key_bundle(cls, key_bundle: "_models.KeyBundle") -> "KeyVaultKey":
         """Construct a KeyVaultKey from an autorest-generated KeyBundle"""
         # pylint:disable=protected-access
         return cls(
             key_id=key_bundle.key.kid,  # type: ignore
             jwk={field: getattr(key_bundle.key, field, None) for field in JsonWebKey._FIELDS},
             properties=KeyProperties._from_key_bundle(key_bundle),
         )
 
     @property
-    def id(self):
-        # type: () -> str
+    def id(self) -> str:
         """The key's id
 
         :rtype: str
         """
         return self._properties.id
 
     @property
-    def name(self):
-        # type: () -> str
+    def name(self) -> str:
         """The key's name
 
         :rtype: str
         """
         return self._properties.name
 
     @property
-    def properties(self):
-        # type: () -> KeyProperties
+    def properties(self) -> KeyProperties:
         """The key's properties
 
         :rtype: ~azure.keyvault.keys.KeyProperties
         """
         return self._properties
 
     @property
-    def key(self):
-        # type: () -> JsonWebKey
+    def key(self) -> JsonWebKey:
         """The JSON web key
 
         :rtype: ~azure.keyvault.keys.JsonWebKey
         """
         return self._key_material
 
     @property
-    def key_type(self):
-        # type: () -> Union[str, KeyType]
+    def key_type(self) -> "Union[str, KeyType]":
         """The key's type. See :class:`~azure.keyvault.keys.KeyType` for possible values.
 
         :rtype: ~azure.keyvault.keys.KeyType or str
         """
         # pylint:disable=no-member
         return self._key_material.kty  # type: ignore[attr-defined]
 
     @property
-    def key_operations(self):
-        # type: () -> List[Union[str, KeyOperation]]
+    def key_operations(self) -> "List[Union[str, KeyOperation]]":
         """Permitted operations. See :class:`~azure.keyvault.keys.KeyOperation` for possible values.
 
         :rtype: List[~azure.keyvault.keys.KeyOperation or str]
         """
         # pylint:disable=no-member
         return self._key_material.key_ops  # type: ignore[attr-defined]
 
 
 class KeyVaultKeyIdentifier(object):
     """Information about a KeyVaultKey parsed from a key ID.
 
-    :param str source_id: the full original identifier of a key
+    :param str source_id: The full original identifier of a key
+
     :raises ValueError: if the key ID is improperly formatted
+
     Example:
         .. literalinclude:: ../tests/test_parse_id.py
             :start-after: [START parse_key_vault_key_id]
             :end-before: [END parse_key_vault_key_id]
             :language: python
             :caption: Parse a key's ID
             :dedent: 8
     """
 
-    def __init__(self, source_id):
-        # type: (str) -> None
+    def __init__(self, source_id: str) -> None:
         self._resource_id = parse_key_vault_id(source_id)
 
     @property
-    def source_id(self):
-        # type: () -> str
+    def source_id(self) -> str:
         return self._resource_id.source_id
 
     @property
-    def vault_url(self):
-        # type: () -> str
+    def vault_url(self) -> str:
         return self._resource_id.vault_url
 
     @property
-    def name(self):
-        # type: () -> str
+    def name(self) -> str:
         return self._resource_id.name
 
     @property
-    def version(self):
-        # type: () -> Optional[str]
+    def version(self) -> "Optional[str]":
         return self._resource_id.version
 
 
 class DeletedKey(KeyVaultKey):
-    """A deleted key's properties, cryptographic material and its deletion information. If soft-delete
-    is enabled, returns information about its recovery as well."""
+    """A deleted key's properties, cryptographic material and its deletion information.
+
+    If soft-delete is enabled, returns information about its recovery as well.
+    """
 
     def __init__(
         self,
-        properties,  # type: KeyProperties
-        deleted_date=None,  # type: Optional[datetime]
-        recovery_id=None,  # type: Optional[str]
-        scheduled_purge_date=None,  # type: Optional[datetime]
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+        properties: KeyProperties,
+        deleted_date: "Optional[datetime]" = None,
+        recovery_id: "Optional[str]" = None,
+        scheduled_purge_date: "Optional[datetime]" = None,
+        **kwargs,
+    ) -> None:
         super(DeletedKey, self).__init__(properties=properties, **kwargs)
         self._deleted_date = deleted_date
         self._recovery_id = recovery_id
         self._scheduled_purge_date = scheduled_purge_date
 
-    def __repr__(self):
-        # type () -> str
-        return "<DeletedKey [{}]>".format(self.id)[:1024]
+    def __repr__(self) -> str:
+        return f"<DeletedKey [{self.id}]>"[:1024]
 
     @classmethod
-    def _from_deleted_key_bundle(cls, deleted_key_bundle):
-        # type: (_models.DeletedKeyBundle) -> DeletedKey
+    def _from_deleted_key_bundle(cls, deleted_key_bundle: "_models.DeletedKeyBundle") -> "DeletedKey":
         """Construct a DeletedKey from an autorest-generated DeletedKeyBundle"""
         # pylint:disable=protected-access
         return cls(
             properties=KeyProperties._from_key_bundle(deleted_key_bundle),
             key_id=deleted_key_bundle.key.kid,  # type: ignore
             jwk={field: getattr(deleted_key_bundle.key, field, None) for field in JsonWebKey._FIELDS},
             deleted_date=deleted_key_bundle.deleted_date,
             recovery_id=deleted_key_bundle.recovery_id,
             scheduled_purge_date=deleted_key_bundle.scheduled_purge_date,
         )
 
     @classmethod
-    def _from_deleted_key_item(cls, deleted_key_item):
-        # type: (_models.DeletedKeyItem) -> DeletedKey
+    def _from_deleted_key_item(cls, deleted_key_item: "_models.DeletedKeyItem") -> "DeletedKey":
         """Construct a DeletedKey from an autorest-generated DeletedKeyItem"""
         return cls(
             properties=KeyProperties._from_key_item(deleted_key_item),  # pylint: disable=protected-access
             key_id=deleted_key_item.kid,
             deleted_date=deleted_key_item.deleted_date,
             recovery_id=deleted_key_item.recovery_id,
             scheduled_purge_date=deleted_key_item.scheduled_purge_date,
         )
 
     @property
-    def deleted_date(self):
-        # type: () -> Optional[datetime]
+    def deleted_date(self) -> "Optional[datetime]":
         """When the key was deleted, in UTC
 
         :rtype: ~datetime.datetime or None
         """
         return self._deleted_date
 
     @property
-    def recovery_id(self):
-        # type: () -> Optional[str]
+    def recovery_id(self) -> "Optional[str]":
         """An identifier used to recover the deleted key. Returns ``None`` if soft-delete is disabled.
 
         :rtype: str or None
         """
         return self._recovery_id
 
     @property
-    def scheduled_purge_date(self):
-        # type: () -> Optional[datetime]
+    def scheduled_purge_date(self) -> "Optional[datetime]":
         """When the key is scheduled to be purged, in UTC. Returns ``None`` if soft-delete is disabled.
 
         :rtype: ~datetime.datetime or None
         """
         return self._scheduled_purge_date
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated_models.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated_models.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from enum import Enum
 import datetime
-from typing import Dict, List, Optional, Union
+from enum import Enum
+from typing import Any, Dict, List, Optional, Union
 
 from azure.core import CaseInsensitiveEnumMeta
 
 from ._generated import _serialization
 
 
 class Attributes(_serialization.Model):
@@ -48,16 +48,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -83,15 +83,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyBundle(_serialization.Model):
     """A KeyBundle consisting of a WebKey plus its attributes.
@@ -126,16 +126,16 @@
     def __init__(
         self,
         *,
         key: Optional["JsonWebKey"] = None,
         attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.keys._generated_models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -196,16 +196,16 @@
         self,
         *,
         key: Optional["JsonWebKey"] = None,
         attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["KeyReleasePolicy"] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.keys._generated_models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -250,16 +250,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -313,16 +313,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -354,15 +354,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -386,15 +386,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -411,15 +411,15 @@
         "count": {"required": True, "maximum": 128, "minimum": 1},
     }
 
     _attribute_map = {
         "count": {"key": "count", "type": "int"},
     }
 
-    def __init__(self, *, count: int, **kwargs):
+    def __init__(self, *, count: int, **kwargs: Any) -> None:
         """
         :keyword count: The requested number of random bytes. Required.
         :paramtype count: int
         """
         super().__init__(**kwargs)
         self.count = count
 
@@ -427,23 +427,23 @@
 class JsonWebKey(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18.
 
     :ivar kid: Key identifier.
     :vartype kid: str
     :ivar kty: JsonWebKey Key Type (kty), as defined in
      https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
-     "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+     "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
     :vartype kty: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
     :ivar key_ops:
     :vartype key_ops: list[str]
     :ivar n: RSA modulus.
     :vartype n: bytes
     :ivar e: RSA public exponent.
     :vartype e: bytes
-    :ivar d: RSA private exponent, or the D component of an EC or OKP private key.
+    :ivar d: RSA private exponent, or the D component of an EC private key.
     :vartype d: bytes
     :ivar dp: RSA private key parameter.
     :vartype dp: bytes
     :ivar dq: RSA private key parameter.
     :vartype dq: bytes
     :ivar qi: RSA private key parameter.
     :vartype qi: bytes
@@ -452,17 +452,17 @@
     :ivar q: RSA secret prime, with p < q.
     :vartype q: bytes
     :ivar k: Symmetric key.
     :vartype k: bytes
     :ivar t: Protected Key, used with 'Bring Your Own Key'.
     :vartype t: bytes
     :ivar crv: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+     "P-256", "P-384", "P-521", and "P-256K".
     :vartype crv: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
-    :ivar x: X component of an EC or OKP public key.
+    :ivar x: X component of an EC public key.
     :vartype x: bytes
     :ivar y: Y component of an EC public key.
     :vartype y: bytes
     """
 
     _attribute_map = {
         "kid": {"key": "kid", "type": "str"},
@@ -498,30 +498,30 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
-         "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+         "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
         :keyword key_ops:
         :paramtype key_ops: list[str]
         :keyword n: RSA modulus.
         :paramtype n: bytes
         :keyword e: RSA public exponent.
         :paramtype e: bytes
-        :keyword d: RSA private exponent, or the D component of an EC or OKP private key.
+        :keyword d: RSA private exponent, or the D component of an EC private key.
         :paramtype d: bytes
         :keyword dp: RSA private key parameter.
         :paramtype dp: bytes
         :keyword dq: RSA private key parameter.
         :paramtype dq: bytes
         :keyword qi: RSA private key parameter.
         :paramtype qi: bytes
@@ -530,17 +530,17 @@
         :keyword q: RSA secret prime, with p < q.
         :paramtype q: bytes
         :keyword k: Symmetric key.
         :paramtype k: bytes
         :keyword t: Protected Key, used with 'Bring Your Own Key'.
         :paramtype t: bytes
         :keyword crv: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-         "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+         "P-256", "P-384", "P-521", and "P-256K".
         :paramtype crv: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
-        :keyword x: X component of an EC or OKP public key.
+        :keyword x: X component of an EC public key.
         :paramtype x: bytes
         :keyword y: Y component of an EC public key.
         :paramtype y: bytes
         """
         super().__init__(**kwargs)
         self.kid = kid
         self.kty = kty
@@ -611,16 +611,16 @@
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
         exportable: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -636,28 +636,28 @@
 
 class KeyCreateParameters(_serialization.Model):
     """The key create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
-     values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+     values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
     :vartype kty: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
     :ivar public_exponent: The public exponent for a RSA key.
     :vartype public_exponent: int
     :ivar key_ops:
     :vartype key_ops: list[str or ~azure.keyvault.keys._generated_models.JsonWebKeyOperation]
     :ivar key_attributes: The attributes of a key managed by the key vault service.
     :vartype key_attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+     "P-256", "P-384", "P-521", and "P-256K".
     :vartype curve: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
     :ivar release_policy: The policy rules under which the key can be exported.
     :vartype release_policy: ~azure.keyvault.keys._generated_models.KeyReleasePolicy
     """
 
     _validation = {
         "kty": {"required": True},
@@ -681,32 +681,32 @@
         key_size: Optional[int] = None,
         public_exponent: Optional[int] = None,
         key_ops: Optional[List[Union[str, "JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "JsonWebKeyCurveName"]] = None,
         release_policy: Optional["KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
-         values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+         values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword public_exponent: The public exponent for a RSA key.
         :paramtype public_exponent: int
         :keyword key_ops:
         :paramtype key_ops: list[str or ~azure.keyvault.keys._generated_models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values
-         are: "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+         are: "P-256", "P-384", "P-521", and "P-256K".
         :paramtype curve: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
         :keyword release_policy: The policy rules under which the key can be exported.
         :paramtype release_policy: ~azure.keyvault.keys._generated_models.KeyReleasePolicy
         """
         super().__init__(**kwargs)
         self.kty = kty
         self.key_size = key_size
@@ -740,16 +740,16 @@
 
     def __init__(
         self,
         *,
         wrapping_key: Optional["JsonWebKey"] = None,
         wrapping_kid: Optional[str] = None,
         enc: Optional[Union[str, "KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword wrapping_key: The export key encryption Json web key. This key MUST be a RSA key that
          supports encryption.
         :paramtype wrapping_key: ~azure.keyvault.keys._generated_models.JsonWebKey
         :keyword wrapping_kid: The export key encryption key identifier. This key MUST be a RSA key
          that supports encryption.
         :paramtype wrapping_kid: str
@@ -796,16 +796,16 @@
         self,
         *,
         key: "JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.keys._generated_models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
@@ -840,15 +840,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -880,15 +880,15 @@
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
         "iv": {"key": "iv", "type": "base64"},
         "authentication_tag": {"key": "tag", "type": "base64"},
         "additional_authenticated_data": {"key": "aad", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
         self.iv = None
         self.authentication_tag = None
         self.additional_authenticated_data = None
@@ -932,22 +932,21 @@
         self,
         *,
         algorithm: Union[str, "JsonWebKeyEncryptionAlgorithm"],
         value: bytes,
         iv: Optional[bytes] = None,
         aad: Optional[bytes] = None,
         tag: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW", "A192KW", "A256KW",
          "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD", and "A256CBCPAD".
-        :paramtype algorithm: str or
-         ~azure.keyvault.keys._generated_models.JsonWebKeyEncryptionAlgorithm
+        :paramtype algorithm: str or ~azure.keyvault.keys._generated_models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         :keyword iv: Cryptographically random, non-repeating initialization vector for symmetric
          algorithms.
         :paramtype iv: bytes
         :keyword aad: Additional data to authenticate but not encrypt/decrypt when using authenticated
          crypto algorithms.
@@ -967,22 +966,22 @@
 class KeyProperties(_serialization.Model):
     """Properties of the key pair backing a certificate.
 
     :ivar exportable: Indicates if the private key can be exported. Release policy must be provided
      when creating the first version of an exportable key.
     :vartype exportable: bool
     :ivar key_type: The type of key pair to be used for the certificate. Known values are: "EC",
-     "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+     "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
     :vartype key_type: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
     :ivar reuse_key: Indicates if the same key pair will be used on certificate renewal.
     :vartype reuse_key: bool
     :ivar curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+     "P-256", "P-384", "P-521", and "P-256K".
     :vartype curve: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
     """
 
     _attribute_map = {
         "exportable": {"key": "exportable", "type": "bool"},
         "key_type": {"key": "kty", "type": "str"},
         "key_size": {"key": "key_size", "type": "int"},
@@ -994,29 +993,29 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Indicates if the private key can be exported. Release policy must be
          provided when creating the first version of an exportable key.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
-         "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
+         "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype key_type: str or ~azure.keyvault.keys._generated_models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword reuse_key: Indicates if the same key pair will be used on certificate renewal.
         :paramtype reuse_key: bool
         :keyword curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values
-         are: "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
+         are: "P-256", "P-384", "P-521", and "P-256K".
         :paramtype curve: str or ~azure.keyvault.keys._generated_models.JsonWebKeyCurveName
         """
         super().__init__(**kwargs)
         self.exportable = exportable
         self.key_type = key_type
         self.key_size = key_size
         self.reuse_key = reuse_key
@@ -1050,16 +1049,16 @@
 
     def __init__(
         self,
         *,
         target_attestation_token: str,
         nonce: Optional[str] = None,
         enc: Optional[Union[str, "KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword target_attestation_token: The attestation assertion for the target of the key release.
          Required.
         :paramtype target_attestation_token: str
         :keyword nonce: A client provided nonce for freshness.
         :paramtype nonce: str
         :keyword enc: The encryption algorithm to use to protected the exported key material. Known
@@ -1093,16 +1092,16 @@
 
     def __init__(
         self,
         *,
         content_type: str = "application/json; charset=utf-8",
         immutable: Optional[bool] = None,
         encoded_policy: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword content_type: Content type and version of key release policy.
         :paramtype content_type: str
         :keyword immutable: Defines the mutability state of the policy. Once marked immutable, this
          flag cannot be reset and the policy cannot be changed under any circumstances.
         :paramtype immutable: bool
         :keyword encoded_policy: Blob encoding the policy rules under which the key can be released.
@@ -1128,15 +1127,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyRestoreParameters(_serialization.Model):
     """The key restore parameters.
@@ -1151,15 +1150,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -1190,16 +1189,16 @@
     }
 
     def __init__(
         self,
         *,
         lifetime_actions: Optional[List["LifetimeActions"]] = None,
         attributes: Optional["KeyRotationPolicyAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a
          key. For preview, lifetimeActions can only have two items at maximum: one for rotate, one for
          notify. Notification time would be default to 30 days before expiry and it is not configurable.
         :paramtype lifetime_actions: list[~azure.keyvault.keys._generated_models.LifetimeActions]
         :keyword attributes: The key rotation policy attributes.
         :paramtype attributes: ~azure.keyvault.keys._generated_models.KeyRotationPolicyAttributes
@@ -1232,15 +1231,15 @@
 
     _attribute_map = {
         "expiry_time": {"key": "expiryTime", "type": "str"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs):
+    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword expiry_time: The expiryTime will be applied on the new key version. It should be at
          least 28 days. It will be in ISO 8601 Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours:
          PT48H, 1 year and 10 days: P1Y10D.
         :paramtype expiry_time: str
         """
         super().__init__(**kwargs)
@@ -1252,16 +1251,16 @@
 class KeySignParameters(_serialization.Model):
     """The key operations parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar algorithm: The signing/verification algorithm identifier. For more information on
      possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
-     "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512",
-     "ES256K", and "EdDSA".
+     "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
+     "ES256K".
     :vartype algorithm: str or ~azure.keyvault.keys._generated_models.JsonWebKeySignatureAlgorithm
     :ivar value: Required.
     :vartype value: bytes
     """
 
     _validation = {
         "algorithm": {"required": True},
@@ -1269,20 +1268,22 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
-         "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512",
-         "ES256K", and "EdDSA".
+         "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
+         "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.keys._generated_models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         """
         super().__init__(**kwargs)
         self.algorithm = algorithm
         self.value = value
@@ -1312,16 +1313,16 @@
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.keys._generated_models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.keys._generated_models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -1349,28 +1350,28 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar algorithm: The signing/verification algorithm. For more information on possible algorithm
      types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256", "PS384", "PS512",
-     "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", "ES256K", and "EdDSA".
+     "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
     :vartype algorithm: str or ~azure.keyvault.keys._generated_models.JsonWebKeySignatureAlgorithm
     :ivar digest: The digest used for signing. Required.
     :vartype digest: bytes
     :ivar signature: The signature to be verified. Required.
     :vartype signature: bytes
     """
 
@@ -1388,21 +1389,20 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
-         "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", "ES256K", and
-         "EdDSA".
+         "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.keys._generated_models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
         :keyword signature: The signature to be verified. Required.
         :paramtype signature: bytes
         """
         super().__init__(**kwargs)
@@ -1424,15 +1424,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class LifetimeActions(_serialization.Model):
     """Action and its trigger that will be performed by Key Vault over the lifetime of a key.
@@ -1449,16 +1449,16 @@
     }
 
     def __init__(
         self,
         *,
         trigger: Optional["LifetimeActionsTrigger"] = None,
         action: Optional["LifetimeActionsType"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword trigger: The condition that will execute the action.
         :paramtype trigger: ~azure.keyvault.keys._generated_models.LifetimeActionsTrigger
         :keyword action: The action that will be executed.
         :paramtype action: ~azure.keyvault.keys._generated_models.LifetimeActionsType
         """
         super().__init__(**kwargs)
@@ -1478,15 +1478,17 @@
     """
 
     _attribute_map = {
         "time_after_create": {"key": "timeAfterCreate", "type": "str"},
         "time_before_expiry": {"key": "timeBeforeExpiry", "type": "str"},
     }
 
-    def __init__(self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword time_after_create: Time after creation to attempt to rotate. It only applies to
          rotate. It will be in ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_after_create: str
         :keyword time_before_expiry: Time before expiry to attempt to rotate or notify. It will be in
          ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_before_expiry: str
@@ -1503,15 +1505,15 @@
     :vartype type: str or ~azure.keyvault.keys._generated_models.ActionType
     """
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, type: Optional[Union[str, "ActionType"]] = None, **kwargs):
+    def __init__(self, *, type: Optional[Union[str, "ActionType"]] = None, **kwargs: Any) -> None:
         """
         :keyword type: The type of the action. Known values are: "rotate" and "notify".
         :paramtype type: str or ~azure.keyvault.keys._generated_models.ActionType
         """
         super().__init__(**kwargs)
         self.type = type
 
@@ -1529,90 +1531,88 @@
         "value": {"required": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, value: bytes, **kwargs):
+    def __init__(self, *, value: bytes, **kwargs: Any) -> None:
         """
         :keyword value: The bytes encoded as a base64url string. Required.
         :paramtype value: bytes
         """
         super().__init__(**kwargs)
         self.value = value
 
 
 class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of the action."""
 
-    #: Rotate the key based on the key policy.
     ROTATE = "rotate"
-    #: Trigger event grid events. For preview, the notification time is not configurable and it is
-    #: default to 30 days before expiry.
+    """Rotate the key based on the key policy."""
     NOTIFY = "notify"
+    """Trigger event grid events. For preview, the notification time is not configurable and it is
+    #: default to 30 days before expiry."""
 
 
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
-    #: The Ed25519 Edwards curve.
-    ED25519 = "Ed25519"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
@@ -1645,65 +1645,58 @@
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
-    #: Edwards-Curve Digital Signature Algorithm, as described in https://tools.ietf.org/html/rfc8032.
-    ED_DSA = "EdDSA"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is stored in the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is stored in the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is stored in the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is stored in the HSM."""
     OCT = "oct"
-    #: Octet sequence (used to represent symmetric keys) which is stored the HSM.
+    """Octet sequence (used to represent symmetric keys)"""
     OCT_HSM = "oct-HSM"
-    #: Octet key pair (https://tools.ietf.org/html/rfc8037)
-    OKP = "OKP"
-    #: Octet key pair (https://tools.ietf.org/html/rfc8037) with a private key which is stored in the
-    #: HSM.
-    OKP_HSM = "OKP-HSM"
+    """Octet sequence (used to represent symmetric keys) which is stored the HSM."""
 
 
 class KeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The encryption algorithm to use to protected the exported key material."""
 
     CKM_RSA_AES_KEY_WRAP = "CKM_RSA_AES_KEY_WRAP"
     RSA_AES_KEY_WRAP256 = "RSA_AES_KEY_WRAP_256"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge_cache.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge_cache.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,89 +1,91 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import threading
-
-try:
-    import urllib.parse as parse
-except ImportError:
-    import urlparse as parse  # type: ignore
+from urllib import parse
 
 try:
     from typing import TYPE_CHECKING
 except ImportError:
     TYPE_CHECKING = False
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import
-    from typing import Dict
+    from typing import Dict, Optional
     from .http_challenge import HttpChallenge
 
 
 _cache = {}  # type: Dict[str, HttpChallenge]
 _lock = threading.Lock()
 
 
-def get_challenge_for_url(url):
-    """ Gets the challenge for the cached URL.
-    :param url: the URL the challenge is cached for.
-    :rtype: HttpBearerChallenge """
+def get_challenge_for_url(url: str) -> "Optional[HttpChallenge]":
+    """Gets the challenge for the cached URL.
+
+    :param str url: the URL the challenge is cached for.
+    """
 
     if not url:
         raise ValueError("URL cannot be None")
 
     key = _get_cache_key(url)
 
     with _lock:
         return _cache.get(key)
 
 
-def _get_cache_key(url):
+def _get_cache_key(url: str) -> str:
     """Use the URL's netloc as cache key except when the URL specifies the default port for its scheme. In that case
     use the netloc without the port. That is to say, https://foo.bar and https://foo.bar:443 are considered equivalent.
 
     This equivalency prevents an unnecessary challenge when using Key Vault's paging API. The Key Vault client doesn't
     specify ports, but Key Vault's next page links do, so a redundant challenge would otherwise be executed when the
     client requests the next page."""
 
     parsed = parse.urlparse(url)
     if parsed.scheme == "https" and parsed.port == 443:
         return parsed.netloc[:-4]
     return parsed.netloc
 
 
-def remove_challenge_for_url(url):
-    """ Removes the cached challenge for the specified URL.
-    :param url: the URL for which to remove the cached challenge """
+def remove_challenge_for_url(url: str) -> None:
+    """Removes the cached challenge for the specified URL.
+
+    :param str url: the URL for which to remove the cached challenge
+    """
     if not url:
         raise ValueError("URL cannot be empty")
 
-    url = parse.urlparse(url)
+    parsed = parse.urlparse(url)
 
     with _lock:
-        del _cache[url.netloc]
+        del _cache[parsed.netloc]
+
 
+def set_challenge_for_url(url: str, challenge: "HttpChallenge") -> None:
+    """Caches the challenge for the specified URL.
 
-def set_challenge_for_url(url, challenge):
-    """ Caches the challenge for the specified URL.
-    :param url: the URL for which to cache the challenge
-    :param challenge: the challenge to cache """
+    :param str url: the URL for which to cache the challenge
+    :param challenge: the challenge to cache
+    :type challenge: HttpChallenge
+    """
     if not url:
         raise ValueError("URL cannot be empty")
 
     if not challenge:
         raise ValueError("Challenge cannot be empty")
 
     src_url = parse.urlparse(url)
     if src_url.netloc != challenge.source_authority:
         raise ValueError("Source URL and Challenge URL do not match")
 
     with _lock:
         _cache[src_url.netloc] = challenge
 
 
-def clear():
-    """ Clears the cache. """
+def clear() -> None:
+    """Clears the cache."""
 
     with _lock:
         _cache.clear()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling_async.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/client_base.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_client_base.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,48 +1,34 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 from typing import TYPE_CHECKING
-from enum import Enum
 
-from azure.core import CaseInsensitiveEnumMeta
 from azure.core.pipeline.policies import HttpLoggingPolicy
+from azure.core.tracing.decorator_async import distributed_trace_async
 
-from . import ChallengeAuthPolicy
-from .._generated import KeyVaultClient as _KeyVaultClient
+from . import AsyncChallengeAuthPolicy
+from .client_base import ApiVersion, DEFAULT_VERSION, _format_api_version, _SERIALIZER
 from .._sdk_moniker import SDK_MONIKER
+from .._generated.aio import KeyVaultClient as _KeyVaultClient
 
 if TYPE_CHECKING:
-    # pylint:disable=unused-import,ungrouped-imports
-    from typing import Any
-    from azure.core.credentials import TokenCredential
+    # pylint:disable=unused-import
+    from typing import Any, Awaitable
+    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.rest import AsyncHttpResponse, HttpRequest
 
 
-class ApiVersion(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Key Vault API versions supported by this package"""
-
-    #: this is the default version
-    V7_4_PREVIEW_1 = "7.4-preview.1"
-    V7_3 = "7.3"
-    V7_2 = "7.2"
-    V7_1 = "7.1"
-    V7_0 = "7.0"
-    V2016_10_01 = "2016-10-01"
-
-
-DEFAULT_VERSION = ApiVersion.V7_4_PREVIEW_1
-
-
-class KeyVaultClientBase(object):
-    def __init__(self, vault_url, credential, **kwargs):
-        # type: (str, TokenCredential, **Any) -> None
+class AsyncKeyVaultClientBase(object):
+    # pylint:disable=protected-access
+    def __init__(self, vault_url: str, credential: "AsyncTokenCredential", **kwargs) -> None:
         if not credential:
             raise ValueError(
-                "credential should be an object supporting the TokenCredential protocol, "
+                "credential should be an object supporting the AsyncTokenCredential protocol, "
                 "such as a credential from azure-identity"
             )
         if not vault_url:
             raise ValueError("vault_url must be the URL of an Azure Key Vault")
 
         try:
             self.api_version = kwargs.pop("api_version", DEFAULT_VERSION)
@@ -63,40 +49,60 @@
             http_logging_policy.allowed_header_names.update(
                 {"x-ms-keyvault-network-info", "x-ms-keyvault-region", "x-ms-keyvault-service-version"}
             )
 
             verify_challenge = kwargs.pop("verify_challenge_resource", True)
             self._client = _KeyVaultClient(
                 api_version=self.api_version,
-                authentication_policy=ChallengeAuthPolicy(credential, verify_challenge_resource=verify_challenge),
+                authentication_policy=AsyncChallengeAuthPolicy(credential, verify_challenge_resource=verify_challenge),
                 sdk_moniker=SDK_MONIKER,
                 http_logging_policy=http_logging_policy,
                 **kwargs
             )
             self._models = _KeyVaultClient.models(api_version=self.api_version)
         except ValueError:
             raise NotImplementedError(
-                "This package doesn't support API version '{}'. ".format(self.api_version)
-                + "Supported versions: {}".format(", ".join(v.value for v in ApiVersion))
+                f"This package doesn't support API version '{self.api_version}'. "
+                + f"Supported versions: {', '.join(v.value for v in ApiVersion)}"
             )
 
     @property
-    def vault_url(self):
-        # type: () -> str
+    def vault_url(self) -> str:
         return self._vault_url
 
-    def __enter__(self):
-        # type: () -> KeyVaultClientBase
-        self._client.__enter__()
+    async def __aenter__(self) -> "AsyncKeyVaultClientBase":
+        await self._client.__aenter__()
         return self
 
-    def __exit__(self, *args):
-        # type: (*Any) -> None
-        self._client.__exit__(*args)
+    async def __aexit__(self, *args: "Any") -> None:
+        await self._client.__aexit__(*args)
 
-    def close(self):
-        # type: () -> None
+    async def close(self) -> None:
         """Close sockets opened by the client.
 
         Calling this method is unnecessary when using the client as a context manager.
         """
-        self._client.close()
+        await self._client.close()
+
+    @distributed_trace_async
+    def send_request(self, request: "HttpRequest", *, stream: bool = False, **kwargs) -> "Awaitable[AsyncHttpResponse]":
+        """Runs a network request using the client's existing pipeline.
+
+        The request URL can be relative to the vault URL. The service API version used for the request is the same as
+        the client's unless otherwise specified. This method does not raise if the response is an error; to raise an
+        exception, call `raise_for_status()` on the returned response object. For more information about how to send
+        custom requests with this method, see https://aka.ms/azsdk/dpcodegen/python/send_request.
+
+        :param request: The network request you want to make.
+        :type request: ~azure.core.rest.HttpRequest
+
+        :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
+
+        :return: The response of your network call. Does not do error handling on your response.
+        :rtype: ~azure.core.rest.AsyncHttpResponse
+        """
+        request_copy = _format_api_version(request, self.api_version)
+        path_format_arguments = {
+            "vaultBaseUrl": _SERIALIZER.url("vault_base_url", self._vault_url, "str", skip_quote=True),
+        }
+        request_copy.url = self._client._client.format_url(request_copy.url, **path_format_arguments)
+        return self._client._client.send_request(request_copy, stream=stream, **kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_client_base.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,83 +1,70 @@
-# ------------------------------------
-# Copyright (c) Microsoft Corporation.
-# Licensed under the MIT License.
-# ------------------------------------
-from typing import TYPE_CHECKING
-from azure.core.pipeline.policies import HttpLoggingPolicy
-from . import AsyncChallengeAuthPolicy
-from .client_base import ApiVersion, DEFAULT_VERSION
-from .._sdk_moniker import SDK_MONIKER
-from .._generated.aio import KeyVaultClient as _KeyVaultClient
-
-if TYPE_CHECKING:
-    try:
-        # pylint:disable=unused-import
-        from typing import Any
-        from azure.core.credentials_async import AsyncTokenCredential
-    except ImportError:
-        # AsyncTokenCredential is a typing_extensions.Protocol; we don't depend on that package
-        pass
-
-
-class AsyncKeyVaultClientBase(object):
-    def __init__(self, vault_url: str, credential: "AsyncTokenCredential", **kwargs: "Any") -> None:
-        if not credential:
-            raise ValueError(
-                "credential should be an object supporting the AsyncTokenCredential protocol, "
-                "such as a credential from azure-identity"
-            )
-        if not vault_url:
-            raise ValueError("vault_url must be the URL of an Azure Key Vault")
-
-        try:
-            self.api_version = kwargs.pop("api_version", DEFAULT_VERSION)
-            # If API version was provided as an enum value, need to make a plain string for 3.11 compatibility
-            if hasattr(self.api_version, "value"):
-                self.api_version = self.api_version.value
-            self._vault_url = vault_url.strip(" /")
-
-            client = kwargs.get("generated_client")
-            if client:
-                # caller provided a configured client -> only models left to initialize
-                self._client = client
-                models = kwargs.get("generated_models")
-                self._models = models or _KeyVaultClient.models(api_version=self.api_version)
-                return
-
-            http_logging_policy = HttpLoggingPolicy(**kwargs)
-            http_logging_policy.allowed_header_names.update(
-                {"x-ms-keyvault-network-info", "x-ms-keyvault-region", "x-ms-keyvault-service-version"}
-            )
-
-            verify_challenge = kwargs.pop("verify_challenge_resource", True)
-            self._client = _KeyVaultClient(
-                api_version=self.api_version,
-                authentication_policy=AsyncChallengeAuthPolicy(credential, verify_challenge_resource=verify_challenge),
-                sdk_moniker=SDK_MONIKER,
-                http_logging_policy=http_logging_policy,
-                **kwargs
-            )
-            self._models = _KeyVaultClient.models(api_version=self.api_version)
-        except ValueError:
-            raise NotImplementedError(
-                "This package doesn't support API version '{}'. ".format(self.api_version)
-                + "Supported versions: {}".format(", ".join(v.value for v in ApiVersion))
-            )
-
-    @property
-    def vault_url(self) -> str:
-        return self._vault_url
-
-    async def __aenter__(self) -> "AsyncKeyVaultClientBase":
-        await self._client.__aenter__()
-        return self
+# coding=utf-8
+# --------------------------------------------------------------------------
+# Copyright (c) Microsoft Corporation. All rights reserved.
+# Licensed under the MIT License. See License.txt in the project root for license information.
+# Code generated by Microsoft (R) AutoRest Code Generator.
+# Changes may cause incorrect behavior and will be lost if the code is regenerated.
+# --------------------------------------------------------------------------
+
+from copy import deepcopy
+from typing import Any, Awaitable
+
+from azure.core import AsyncPipelineClient
+from azure.core.rest import AsyncHttpResponse, HttpRequest
+
+from .. import models as _models
+from ..._serialization import Deserializer, Serializer
+from ._configuration import KeyVaultClientConfiguration
+from .operations import KeyVaultClientOperationsMixin
+
+
+class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
+    """The key vault client performs cryptographic key operations and vault operations against the Key
+    Vault service.
+
+    :keyword api_version: Api Version. Default value is "7.0". Note that overriding this default
+     value may result in unsupported behavior.
+    :paramtype api_version: str
+    """
+
+    def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
+        _endpoint = "{vaultBaseUrl}"
+        self._config = KeyVaultClientConfiguration(**kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
+        self._serialize = Serializer(client_models)
+        self._deserialize = Deserializer(client_models)
+        self._serialize.client_side_validation = False
+
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
+        """Runs the network request through the client's chained policies.
+
+        >>> from azure.core.rest import HttpRequest
+        >>> request = HttpRequest("GET", "https://www.example.org/")
+        <HttpRequest [GET], url: 'https://www.example.org/'>
+        >>> response = await client._send_request(request)
+        <AsyncHttpResponse: 200 OK>
+
+        For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request
+
+        :param request: The network request you want to make. Required.
+        :type request: ~azure.core.rest.HttpRequest
+        :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
+        :return: The response of your network call. Does not do error handling on your response.
+        :rtype: ~azure.core.rest.AsyncHttpResponse
+        """
 
-    async def __aexit__(self, *args: "Any") -> None:
-        await self._client.__aexit__(*args)
+        request_copy = deepcopy(request)
+        request_copy.url = self._client.format_url(request_copy.url)
+        return self._client.send_request(request_copy, **kwargs)
 
     async def close(self) -> None:
-        """Close sockets opened by the client.
-
-        Calling this method is unnecessary when using the client as a context manager.
-        """
         await self._client.close()
+
+    async def __aenter__(self) -> "KeyVaultClient":
+        await self._client.__aenter__()
+        return self
+
+    async def __aexit__(self, *exc_details: Any) -> None:
+        await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/challenge_auth_policy.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/challenge_auth_policy.py`

 * *Files 5% similar despite different names*

```diff
@@ -31,71 +31,66 @@
 
 if TYPE_CHECKING:
     from typing import Any, Optional
     from azure.core.credentials import AccessToken, TokenCredential
     from azure.core.pipeline import PipelineResponse
 
 
-def _enforce_tls(request):
-    # type: (PipelineRequest) -> None
+def _enforce_tls(request: PipelineRequest) -> None:
     if not request.http_request.url.lower().startswith("https"):
         raise ServiceRequestError(
             "Bearer token authentication is not permitted for non-TLS protected (non-https) URLs."
         )
 
 
-def _update_challenge(request, challenger):
-    # type: (PipelineRequest, PipelineResponse) -> HttpChallenge
-    """parse challenge from challenger, cache it, return it"""
+def _update_challenge(request: PipelineRequest, challenger: "PipelineResponse") -> HttpChallenge:
+    """Parse challenge from challenger, cache it, return it"""
 
     challenge = HttpChallenge(
         request.http_request.url,
         challenger.http_response.headers.get("WWW-Authenticate"),
         response_headers=challenger.http_response.headers,
     )
     ChallengeCache.set_challenge_for_url(request.http_request.url, challenge)
     return challenge
 
 
 class ChallengeAuthPolicy(BearerTokenCredentialPolicy):
-    """policy for handling HTTP authentication challenges"""
+    """Policy for handling HTTP authentication challenges"""
 
-    def __init__(self, credential, *scopes, **kwargs):
-        # type: (TokenCredential, *str, **Any) -> None
+    def __init__(self, credential: "TokenCredential", *scopes: str, **kwargs) -> None:
         super(ChallengeAuthPolicy, self).__init__(credential, *scopes, **kwargs)
         self._credential = credential
         self._token = None  # type: Optional[AccessToken]
         self._verify_challenge_resource = kwargs.pop("verify_challenge_resource", True)
 
-    def on_request(self, request):
-        # type: (PipelineRequest) -> None
+    def on_request(self, request: PipelineRequest) -> None:
         _enforce_tls(request)
         challenge = ChallengeCache.get_challenge_for_url(request.http_request.url)
         if challenge:
             # Note that if the vault has moved to a new tenant since our last request for it, this request will fail.
             if self._need_new_token:
                 # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
                 scope = challenge.get_scope() or challenge.get_resource() + "/.default"
                 self._token = self._credential.get_token(scope, tenant_id=challenge.tenant_id)
 
             # ignore mypy's warning -- although self._token is Optional, get_token raises when it fails to get a token
-            request.http_request.headers["Authorization"] = "Bearer {}".format(self._token.token)  # type: ignore
+            request.http_request.headers["Authorization"] = f"Bearer {self._token.token}"  # type: ignore
             return
 
         # else: discover authentication information by eliciting a challenge from Key Vault. Remove any request data,
         # saving it for later. Key Vault will reject the request as unauthorized and respond with a challenge.
         # on_challenge will parse that challenge, reattach any body removed here, authorize the request, and tell
         # super to send it again.
         if request.http_request.body:
             request.context["key_vault_request_data"] = request.http_request.body
             request.http_request.set_json_body(None)
             request.http_request.headers["Content-Length"] = "0"
 
-    def on_challenge(self, request, response):
-        # type: (PipelineRequest, PipelineResponse) -> bool
+    def on_challenge(self, request: PipelineRequest, response: "PipelineResponse") -> bool:
         try:
             challenge = _update_challenge(request, response)
             # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
             scope = challenge.get_scope() or challenge.get_resource() + "/.default"
         except ValueError:
             return False
 
@@ -110,15 +105,20 @@
                     f"The challenge resource '{resource_domain}' does not match the requested domain. Pass "
                     "`verify_challenge_resource=False` to your client's constructor to disable this verification. "
                     "See https://aka.ms/azsdk/blog/vault-uri for more information."
                 )
 
         body = request.context.pop("key_vault_request_data", None)
         request.http_request.set_text_body(body)  # no-op when text is None
-        self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        # The tenant parsed from AD FS challenges is "adfs"; we don't actually need a tenant for AD FS authentication
+        # For AD FS we skip cross-tenant authentication per https://github.com/Azure/azure-sdk-for-python/issues/28648
+        if challenge.tenant_id and challenge.tenant_id.lower().endswith("adfs"):
+            self.authorize_request(request, scope)
+        else:
+            self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
 
         return True
 
     @property
-    def _need_new_token(self):
-        # type: () -> bool
+    def _need_new_token(self) -> bool:
         return not self._token or self._token.expires_on - time.time() < 300
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/_polling.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/_polling.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,65 +7,58 @@
 import threading
 import uuid
 from typing import TYPE_CHECKING
 
 from azure.core.polling import PollingMethod, LROPoller, NoPolling
 from azure.core.exceptions import ResourceNotFoundError, HttpResponseError
 
-try:
-    from urlparse import urlparse  # type: ignore # pylint: disable=unused-import
-except ImportError:
-    from urllib.parse import urlparse
-
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.common import with_current_context
 
 if TYPE_CHECKING:
     # pylint: disable=ungrouped-imports
-    from typing import Any, Callable, Union, List, Optional
+    from typing import Any, Callable, Optional
 
 logger = logging.getLogger(__name__)
 
 
 class KeyVaultOperationPoller(LROPoller):
     """Poller for long running operations where calling result() doesn't wait for operation to complete.
     """
 
     # pylint: disable=arguments-differ
-    def __init__(self, polling_method):
-        # type: (PollingMethod) -> None
+    def __init__(self, polling_method: PollingMethod) -> None:
         super(KeyVaultOperationPoller, self).__init__(None, None, lambda *_: None, NoPolling())
         self._polling_method = polling_method
 
     # pylint: disable=arguments-differ
-    def result(self):  # type: ignore
-        # type: () -> Any
+    def result(self) -> "Any":  # type: ignore
         """Returns a representation of the final resource without waiting for the operation to complete.
 
         :returns: The deserialized resource of the long running operation
+
         :raises ~azure.core.exceptions.HttpResponseError: Server problem with the query.
         """
         return self._polling_method.resource()
 
     @distributed_trace
-    def wait(self, timeout=None):
-        # type: (Optional[float]) -> None
+    def wait(self, timeout: "Optional[float]" = None) -> None:
         """Wait on the long running operation for a number of seconds.
 
         You can check if this call has ended with timeout with the "done()" method.
 
-        :param float timeout: Period of time to wait for the long running
-         operation to complete (in seconds).
+        :param float timeout: Period of time to wait for the long running operation to complete (in seconds).
+
         :raises ~azure.core.exceptions.HttpResponseError: Server problem with the query.
         """
 
         if not self._polling_method.finished():
             self._done = threading.Event()
             self._thread = threading.Thread(
-                target=with_current_context(self._start), name="KeyVaultOperationPoller({})".format(uuid.uuid4())
+                target=with_current_context(self._start), name=f"KeyVaultOperationPoller({uuid.uuid4()})"
             )
             self._thread.daemon = True
             self._thread.start()
 
         if self._thread is None:
             return
         self._thread.join(timeout=timeout)
@@ -83,53 +76,48 @@
     immediately removes it from its collection. However, the resource will not immediately appear in the deleted
     collection. Key Vault will therefore respond 404 to GET requests for the deleted resource; when it responds 2xx,
     the resource exists in the deleted collection i.e. its deletion is complete.
 
     Similarly, while recovering a deleted resource, Key Vault will respond 404 to GET requests for the non-deleted
     resource; when it responds 2xx, the resource exists in the non-deleted collection, i.e. its recovery is complete.
     """
-    def __init__(self, command, final_resource, finished, interval=2):
+    def __init__(self, command: "Callable", final_resource: "Any", finished: bool, interval: int = 2) -> None:
         self._command = command
         self._resource = final_resource
         self._polling_interval = interval
         self._finished = finished
 
-    def _update_status(self):
-        # type: () -> None
+    def _update_status(self) -> None:
         try:
             self._command()
             self._finished = True
         except ResourceNotFoundError:
             pass
         except HttpResponseError as e:
             # If we are polling on get_deleted_* and we don't have get permissions, we will get
             # ResourceNotFoundError until the resource is recovered, at which point we'll get a 403.
             if e.status_code == 403:
                 self._finished = True
             else:
                 raise
 
-    def initialize(self, client, initial_response, deserialization_callback):
+    def initialize(self, client: "Any", initial_response: "Any", deserialization_callback: "Callable") -> None:
         pass
 
-    def run(self):
-        # type: () -> None
+    def run(self) -> None:
         try:
             while not self.finished():
                 self._update_status()
                 if not self.finished():
                     time.sleep(self._polling_interval)
         except Exception as e:
             logger.warning(str(e))
             raise
 
-    def finished(self):
-        # type: () -> bool
+    def finished(self) -> bool:
         return self._finished
 
-    def resource(self):
-        # type: () -> Any
+    def resource(self) -> "Any":
         return self._resource
 
-    def status(self):
-        # type: () -> str
+    def status(self) -> str:
         return "finished" if self._finished else "polling"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/http_challenge.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/http_challenge.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,26 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-try:
-    import urllib.parse as parse
-except ImportError:
-    import urlparse as parse  # type: ignore
+from typing import TYPE_CHECKING
+from urllib import parse
+
+if TYPE_CHECKING:
+    from typing import Dict, MutableMapping, Optional
 
 
 class HttpChallenge(object):
-    def __init__(self, request_uri, challenge, response_headers=None):
-        """ Parses an HTTP WWW-Authentication Bearer challenge from a server. """
+    def __init__(
+        self, request_uri: str, challenge: str, response_headers: "Optional[MutableMapping[str, str]]" = None
+    ) -> None:
+        """Parses an HTTP WWW-Authentication Bearer challenge from a server."""
         self.source_authority = self._validate_request_uri(request_uri)
         self.source_uri = request_uri
-        self._parameters = {}
+        self._parameters = {}  # type: Dict[str, str]
 
         # get the scheme of the challenge and remove from the challenge string
         trimmed_challenge = self._validate_challenge(challenge)
         split_challenge = trimmed_challenge.split(" ", 1)
         self.scheme = split_challenge[0]
         trimmed_challenge = split_challenge[1]
 
@@ -38,82 +41,81 @@
 
         # must specify authorization or authorization_uri
         if "authorization" not in self._parameters and "authorization_uri" not in self._parameters:
             raise ValueError("Invalid challenge parameters")
 
         authorization_uri = self.get_authorization_server()
         # the authorization server URI should look something like https://login.windows.net/tenant-id
-        uri_path = parse.urlparse(authorization_uri).path.lstrip("/")
+        raw_uri_path = str(parse.urlparse(authorization_uri).path)
+        uri_path = raw_uri_path.lstrip("/")
         self.tenant_id = uri_path.split("/")[0] or None
 
         # if the response headers were supplied
         if response_headers:
             # get the message signing key and message key encryption key from the headers
             self.server_signature_key = response_headers.get("x-ms-message-signing-key", None)
             self.server_encryption_key = response_headers.get("x-ms-message-encryption-key", None)
 
-    def is_bearer_challenge(self):
-        """ Tests whether the HttpChallenge a Bearer challenge.
-        rtype: bool """
+    def is_bearer_challenge(self) -> bool:
+        """Tests whether the HttpChallenge a Bearer challenge."""
         if not self.scheme:
             return False
 
         return self.scheme.lower() == "bearer"
 
-    def is_pop_challenge(self):
-        """ Tests whether the HttpChallenge is a proof of possession challenge.
-        rtype: bool """
+    def is_pop_challenge(self) -> bool:
+        """Tests whether the HttpChallenge is a proof of possession challenge."""
         if not self.scheme:
             return False
 
         return self.scheme.lower() == "pop"
 
-    def get_value(self, key):
+    def get_value(self, key: str) -> "Optional[str]":
         return self._parameters.get(key)
 
-    def get_authorization_server(self):
-        """ Returns the URI for the authorization server if present, otherwise empty string. """
+    def get_authorization_server(self) -> "Optional[str]":
+        """Returns the URI for the authorization server if present, otherwise empty string."""
         value = ""
         for key in ["authorization_uri", "authorization"]:
             value = self.get_value(key) or ""
             if value:
                 break
         return value
 
-    def get_resource(self):
-        """ Returns the resource if present, otherwise empty string. """
+    def get_resource(self) -> str:
+        """Returns the resource if present, otherwise empty string."""
         return self.get_value("resource") or ""
 
-    def get_scope(self):
-        """ Returns the scope if present, otherwise empty string. """
+    def get_scope(self) -> str:
+        """Returns the scope if present, otherwise empty string."""
         return self.get_value("scope") or ""
 
-    def supports_pop(self):
-        """ Returns True if challenge supports pop token auth else False """
+    def supports_pop(self) -> bool:
+        """Returns True if challenge supports pop token auth else False."""
         return self._parameters.get("supportspop", "").lower() == "true"
 
-    def supports_message_protection(self):
-        """ Returns True if challenge vault supports message protection """
-        return self.supports_pop() and self.server_encryption_key and self.server_signature_key
+    def supports_message_protection(self) -> bool:
+        """Returns True if challenge vault supports message protection."""
+        return self.supports_pop() and self.server_encryption_key and self.server_signature_key  # type: ignore
 
     # pylint:disable=no-self-use
-    def _validate_challenge(self, challenge):
-        """ Verifies that the challenge is a valid auth challenge and returns the key=value pairs. """
+    def _validate_challenge(self, challenge: str) -> str:
+        """Verifies that the challenge is a valid auth challenge and returns the key=value pairs."""
         if not challenge:
             raise ValueError("Challenge cannot be empty")
 
         return challenge.strip()
 
     # pylint:disable=no-self-use
-    def _validate_request_uri(self, uri):
-        """ Extracts the host authority from the given URI. """
+    def _validate_request_uri(self, uri: str) -> str:
+        """Extracts the host authority from the given URI."""
         if not uri:
             raise ValueError("request_uri cannot be empty")
 
-        uri = parse.urlparse(uri)
-        if not uri.netloc:
+        parsed = parse.urlparse(uri)
+        if not parsed.netloc:
             raise ValueError("request_uri must be an absolute URI")
 
-        if uri.scheme.lower() not in ["http", "https"]:
+        if parsed.scheme.lower() not in ["http", "https"]:
             raise ValueError("request_uri must be HTTP or HTTPS")
 
-        return uri.netloc
+        return parsed.netloc
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/async_challenge_auth_policy.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/async_challenge_auth_policy.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,32 +29,32 @@
     from azure.core.credentials_async import AsyncTokenCredential
     from azure.core.pipeline import PipelineRequest, PipelineResponse
 
 
 class AsyncChallengeAuthPolicy(AsyncBearerTokenCredentialPolicy):
     """policy for handling HTTP authentication challenges"""
 
-    def __init__(self, credential: "AsyncTokenCredential", *scopes: str, **kwargs: "Any") -> None:
+    def __init__(self, credential: "AsyncTokenCredential", *scopes: str, **kwargs) -> None:
         super().__init__(credential, *scopes, **kwargs)
         self._credential = credential
         self._token = None  # type: Optional[AccessToken]
         self._verify_challenge_resource = kwargs.pop("verify_challenge_resource", True)
 
     async def on_request(self, request: "PipelineRequest") -> None:
         _enforce_tls(request)
         challenge = ChallengeCache.get_challenge_for_url(request.http_request.url)
         if challenge:
             # Note that if the vault has moved to a new tenant since our last request for it, this request will fail.
-            if self._need_new_token:
+            if self._need_new_token():
                 # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
                 scope = challenge.get_scope() or challenge.get_resource() + "/.default"
                 self._token = await self._credential.get_token(scope, tenant_id=challenge.tenant_id)
 
             # ignore mypy's warning -- although self._token is Optional, get_token raises when it fails to get a token
-            request.http_request.headers["Authorization"] = "Bearer {}".format(self._token.token)  # type: ignore
+            request.http_request.headers["Authorization"] = f"Bearer {self._token.token}"  # type: ignore
             return
 
         # else: discover authentication information by eliciting a challenge from Key Vault. Remove any request data,
         # saving it for later. Key Vault will reject the request as unauthorized and respond with a challenge.
         # on_challenge will parse that challenge, reattach any body removed here, authorize the request, and tell
         # super to send it again.
         if request.http_request.body:
@@ -82,15 +82,19 @@
                     f"The challenge resource '{resource_domain}' does not match the requested domain. Pass "
                     "`verify_challenge_resource=False` to your client's constructor to disable this verification. "
                     "See https://aka.ms/azsdk/blog/vault-uri for more information."
                 )
 
         body = request.context.pop("key_vault_request_data", None)
         request.http_request.set_text_body(body)  # no-op when text is None
-        await self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        # The tenant parsed from AD FS challenges is "adfs"; we don't actually need a tenant for AD FS authentication
+        # For AD FS we skip cross-tenant authentication per https://github.com/Azure/azure-sdk-for-python/issues/28648
+        if challenge.tenant_id and challenge.tenant_id.lower().endswith("adfs"):
+            await self.authorize_request(request, scope)
+        else:
+            await self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
 
         return True
 
-    @property
     def _need_new_token(self) -> bool:
-        # pylint:disable=invalid-overridden-method
         return not self._token or self._token.expires_on - time.time() < 300
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,18 +1,14 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-try:
-    import urllib.parse as parse
-except ImportError:
-    # pylint:disable=import-error
-    import urlparse as parse  # type: ignore
-
 from typing import TYPE_CHECKING
+from urllib import parse
+
 from .challenge_auth_policy import ChallengeAuthPolicy
 from .client_base import KeyVaultClientBase
 from .http_challenge import HttpChallenge
 from . import http_challenge_cache
 
 HttpChallengeCache = http_challenge_cache  # to avoid aliasing pylint error (C4745)
 
@@ -35,40 +31,39 @@
     :param str vault_url: The vault URL
     :param str name: The name extracted from the ID
     :param str version: The version extracted from the ID
     """
 
     def __init__(
         self,
-        source_id,  # type: str
-        vault_url,  # type: str
-        name,  # type: str
-        version=None  # type: Optional[str]
-    ):
+        source_id: str,
+        vault_url: str,
+        name: str,
+        version: "Optional[str]" = None,
+    ) -> None:
         self.source_id = source_id
         self.vault_url = vault_url
         self.name = name
         self.version = version
 
 
-def parse_key_vault_id(source_id):
-    # type: (str) -> KeyVaultResourceId
+def parse_key_vault_id(source_id: str) -> KeyVaultResourceId:
     try:
         parsed_uri = parse.urlparse(source_id)
     except Exception:  # pylint: disable=broad-except
-        raise ValueError("'{}' is not a valid ID".format(source_id))
+        raise ValueError(f"'{source_id}' is not a valid ID")
     if not (parsed_uri.scheme and parsed_uri.hostname):
-        raise ValueError("'{}' is not a valid ID".format(source_id))
+        raise ValueError(f"'{source_id}' is not a valid ID")
 
     path = list(filter(None, parsed_uri.path.split("/")))
 
     if len(path) < 2 or len(path) > 3:
-        raise ValueError("'{}' is not a valid ID".format(source_id))
+        raise ValueError(f"'{source_id}' is not a valid ID")
 
-    vault_url = "{}://{}".format(parsed_uri.scheme, parsed_uri.hostname)
+    vault_url = f"{parsed_uri.scheme}://{parsed_uri.hostname}"
     if parsed_uri.port:
         vault_url += f":{parsed_uri.port}"
 
     return KeyVaultResourceId(
         source_id=source_id,
         vault_url=vault_url,
         name=path[1],
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_shared/exceptions.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_shared/exceptions.py`

 * *Files 14% similar despite different names*

```diff
@@ -8,24 +8,23 @@
 
 from azure.core.exceptions import DecodeError, HttpResponseError, ResourceExistsError, ResourceNotFoundError
 from azure.core.pipeline.policies import ContentDecodePolicy
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import,ungrouped-imports
     from typing import Optional, Type
-    from azure.core.pipeline.transport import HttpResponse
+    from azure.core.rest import HttpResponse
 
 
-def _get_exception_for_key_vault_error(cls, response):
-    # type: (Type[HttpResponseError], HttpResponse) -> HttpResponseError
+def _get_exception_for_key_vault_error(cls: "Type[HttpResponseError]", response: "HttpResponse") -> HttpResponseError:
     """Construct cls (HttpResponseError or subclass thereof) with Key Vault's error message."""
 
     try:
         body = ContentDecodePolicy.deserialize_from_http_generics(response)
-        message = "({}) {}".format(body["error"]["code"], body["error"]["message"])  # type: Optional[str]
+        message = f"({body['error']['code']}) {body['error']['message']}"  # type: Optional[str]
     except (DecodeError, KeyError):
         # Key Vault error response bodies should have the expected shape and be de-serializable.
         # If we somehow land here, we'll take HttpResponse's default message.
         message = None
 
     return cls(message=message, response=response)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_enums.py`

 * *Files 8% similar despite different names*

```diff
@@ -43,8 +43,7 @@
     rs256 = "RS256"  #: RSASSA-PKCS1-v1_5 using SHA-256
     rs384 = "RS384"  #: RSASSA-PKCS1-v1_5 using SHA-384
     rs512 = "RS512"  #: RSASSA-PKCS1-v1_5 using SHA-512
     es256 = "ES256"  #: ECDSA using P-256 and SHA-256
     es384 = "ES384"  #: ECDSA using P-384 and SHA-384
     es512 = "ES512"  #: ECDSA using P-521 and SHA-512
     es256_k = "ES256K"  #: ECDSA using P-256K and SHA-256
-    eddsa = "EdDSA"  #: Edwards-Curve Digital Signature Algorithm, as described in https://tools.ietf.org/html/rfc8032
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,81 +14,79 @@
 from .. import KeyOperation
 from .._models import JsonWebKey, KeyVaultKey
 from .._shared import KeyVaultClientBase, parse_key_vault_id
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import,ungrouped-imports
     from datetime import datetime
-    from typing import Any, Optional, Union
+    from typing import Any, Dict, Optional, Union
     from azure.core.credentials import TokenCredential
     from . import KeyWrapAlgorithm, SignatureAlgorithm
     from .._shared import KeyVaultResourceId
 
 _LOGGER = logging.getLogger(__name__)
 
 
-def _validate_arguments(operation, algorithm, **kwargs):
-    # type: (KeyOperation, EncryptionAlgorithm, **Any) -> None
+def _validate_arguments(operation: KeyOperation, algorithm: EncryptionAlgorithm, **kwargs) -> None:
     """Validates the arguments passed to perform an operation with a provided algorithm.
 
     :param KeyOperation operation: the type of operation being requested
     :param EncryptionAlgorithm algorithm: the encryption algorithm to use for the operation
+
     :keyword bytes iv: initialization vector
     :keyword bytes authentication_tag: authentication tag returned from an encryption
     :keyword bytes additional_authenticated_data: data that is authenticated but not encrypted
+
     :raises ValueError: if parameters that are incompatible with the specified algorithm are provided.
     """
     iv = kwargs.pop("iv", None)
     tag = kwargs.pop("tag", None)
     aad = kwargs.pop("aad", None)
 
     if operation == KeyOperation.encrypt:
         if iv and "CBC" not in algorithm:
             raise ValueError(
-                "iv should only be provided with AES-CBC algorithms; {} does not accept an iv".format(algorithm)
+                f"iv should only be provided with AES-CBC algorithms; {algorithm} does not accept an iv"
             )
         if iv is None and "CBC" in algorithm:
             raise ValueError("iv is a required parameter for encryption with AES-CBC algorithms.")
         if aad and not ("CBC" in algorithm or "GCM" in algorithm):
             raise ValueError(
-                "additional_authenticated_data should only be provided with AES algorithms; {} does not accept "
-                "additional authenticated data".format(algorithm)
+                f"additional_authenticated_data should only be provided with AES algorithms; {algorithm} does not "
+                "accept additional authenticated data"
             )
 
     if operation == KeyOperation.decrypt:
         if iv and not ("CBC" in algorithm or "GCM" in algorithm):
             raise ValueError(
-                "iv should only be provided with AES algorithms; {} does not accept an iv".format(algorithm)
+                f"iv should only be provided with AES algorithms; {algorithm} does not accept an iv"
             )
         if iv is None and ("CBC" in algorithm or "GCM" in algorithm):
             raise ValueError("iv is a required parameter for decryption with AES algorithms.")
         if tag and "GCM" not in algorithm:
             raise ValueError(
-                "authentication_tag should only be provided with AES-GCM algorithms; {} does not accept a tag".format(
-                    algorithm
-                )
+                f"authentication_tag should only be provided with AES-GCM algorithms; {algorithm} does not accept a tag"
             )
         if tag is None and "GCM" in algorithm:
             raise ValueError("authentication_tag is a required parameter for AES-GCM decryption.")
         if aad and not ("CBC" in algorithm or "GCM" in algorithm):
             raise ValueError(
-                "additional_authenticated_data should only be provided with AES algorithms; {} does not accept "
-                "additional authenticated data".format(algorithm)
+                f"additional_authenticated_data should only be provided with AES algorithms; {algorithm} does not "
+                "accept additional authenticated data"
             )
 
 
 class CryptographyClient(KeyVaultClientBase):
     """Performs cryptographic operations using Azure Key Vault keys.
 
     This client will perform operations locally when it's intialized with the necessary key material or is able to get
     that material from Key Vault. When the required key material is unavailable, cryptographic operations are performed
     by the Key Vault service.
 
-    :param key:
-        Either a :class:`~azure.keyvault.keys.KeyVaultKey` instance as returned by
+    :param key: Either a :class:`~azure.keyvault.keys.KeyVaultKey` instance as returned by
         :func:`~azure.keyvault.keys.KeyClient.get_key`, or a string.
         If a string, the value must be the identifier of an Azure Key Vault key. Including a version is recommended.
     :type key: str or :class:`~azure.keyvault.keys.KeyVaultKey`
     :param credential: An object which can provide an access token for the vault, such as a credential from
         :mod:`azure.identity`
     :type credential: :class:`~azure.core.credentials.TokenCredential`
 
@@ -101,25 +99,26 @@
         :start-after: [START create_client]
         :end-before: [END create_client]
         :caption: Create a CryptographyClient
         :language: python
         :dedent: 8
     """
 
-    def __init__(self, key, credential, **kwargs):
-        # type: (Union[KeyVaultKey, str], TokenCredential, **Any) -> None
+    # pylint:disable=protected-access
+
+    def __init__(self, key: "Union[KeyVaultKey, str]", credential: "TokenCredential", **kwargs) -> None:
         self._jwk = kwargs.pop("_jwk", False)
         self._not_before = None  # type: Optional[datetime]
         self._expires_on = None  # type: Optional[datetime]
         self._key_id = None  # type: Optional[KeyVaultResourceId]
 
         if isinstance(key, KeyVaultKey):
             self._key = key.key  # type: Union[JsonWebKey, KeyVaultKey, str, None]
             self._key_id = parse_key_vault_id(key.id)
-            if key.properties._attributes:  # pylint:disable=protected-access
+            if key.properties._attributes:
                 self._not_before = key.properties.not_before
                 self._expires_on = key.properties.expires_on
         elif isinstance(key, str):
             self._key = None
             self._key_id = parse_key_vault_id(key)
             if self._key_id.version is None:
                 self._key_id.version = ""  # to avoid an error and get the latest version when getting the key
@@ -141,66 +140,63 @@
 
         self._vault_url = None if (self._jwk or self._key_id is None) else self._key_id.vault_url  # type: ignore
         super(CryptographyClient, self).__init__(
             vault_url=self._vault_url or "vault_url", credential=credential, **kwargs
         )
 
     @property
-    def key_id(self):
-        # type: () -> Optional[str]
+    def key_id(self) -> "Optional[str]":
         """The full identifier of the client's key.
 
         This property may be None when a client is constructed with :func:`from_jwk`.
 
         :rtype: str or None
         """
         if not self._jwk:
             return self._key_id.source_id if self._key_id else None
         return cast(JsonWebKey, self._key).kid  # type: ignore[attr-defined]
 
     @property
-    def vault_url(self):  # type: ignore
-        # type: () -> Optional[str]
+    def vault_url(self) -> "Optional[str]":  # type: ignore
         """The base vault URL of the client's key.
 
         This property may be None when a client is constructed with :func:`from_jwk`.
 
         :rtype: str or None
         """
         return self._vault_url
 
     @classmethod
-    def from_jwk(cls, jwk):
-        # type: (Union[JsonWebKey, dict]) -> CryptographyClient
+    def from_jwk(cls, jwk: "Union[JsonWebKey, Dict[str, Any]]") -> "CryptographyClient":
         """Creates a client that can only perform cryptographic operations locally.
 
         :param jwk: the key's cryptographic material, as a JsonWebKey or dictionary.
-        :type jwk: JsonWebKey or dict
+        :type jwk: JsonWebKey or Dict[str, Any]
+
         :rtype: CryptographyClient
         """
         if not isinstance(jwk, JsonWebKey):
             jwk = JsonWebKey(**jwk)
         return cls(jwk, object(), _jwk=True)  # type: ignore
 
     @distributed_trace
-    def _initialize(self, **kwargs):
-        # type: (**Any) -> None
+    def _initialize(self, **kwargs) -> None:
         if self._initialized:
             return
 
         # try to get the key material, if we don't have it and aren't forbidden to do so
         if not (self._key or self._keys_get_forbidden):
             try:
                 key_bundle = self._client.get_key(
                     self._key_id.vault_url if self._key_id else None,
                     self._key_id.name if self._key_id else None,
                     self._key_id.version if self._key_id else None,
                     **kwargs
                 )
-                key = KeyVaultKey._from_key_bundle(key_bundle)  # pylint:disable=protected-access
+                key = KeyVaultKey._from_key_bundle(key_bundle)
                 self._key = key.key
                 self._key_id = parse_key_vault_id(key.id)  # update the key ID in case we didn't have the version before
             except HttpResponseError as ex:
                 # if we got a 403, we don't have keys/get permission and won't try to get the key again
                 # (other errors may be transient)
                 self._keys_get_forbidden = ex.status_code == 403
 
@@ -209,31 +205,35 @@
             self._local_provider = get_local_cryptography_provider(cast(JsonWebKey, self._key))
             self._initialized = True
         else:
             # try to get the key again next time unless we know we're forbidden to do so
             self._initialized = self._keys_get_forbidden
 
     @distributed_trace
-    def encrypt(self, algorithm, plaintext, **kwargs):
-        # type: (EncryptionAlgorithm, bytes, **Any) -> EncryptResult
+    def encrypt(self, algorithm: "EncryptionAlgorithm", plaintext: bytes, **kwargs) -> EncryptResult:
         """Encrypt bytes using the client's key.
 
         Requires the keys/encrypt permission. This method encrypts only a single block of data, whose size depends on
         the key and encryption algorithm.
 
         :param algorithm: Encryption algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.EncryptionAlgorithm`
         :param bytes plaintext: Bytes to encrypt
-        :keyword bytes iv: Initialization vector. Required for only AES-CBC(PAD) encryption. If you pass your own IV,
+
+        :keyword iv: Initialization vector. Required for only AES-CBC(PAD) encryption. If you pass your own IV,
             make sure you use a cryptographically random, non-repeating IV. If omitted, an attempt will be made to
             generate an IV via `os.urandom <https://docs.python.org/library/os.html#os.urandom>`_ for local
             cryptography; for remote cryptography, Key Vault will generate an IV.
-        :keyword bytes additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
+        :paramtype iv: bytes or None
+        :keyword additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
             with AES-GCM encryption.
+        :paramtype additional_authenticated_data: bytes or None
+
         :rtype: :class:`~azure.keyvault.keys.crypto.EncryptResult`
+
         :raises ValueError: if parameters that are incompatible with the specified algorithm are provided, or if
             generating an IV fails on the current platform.
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START encrypt]
             :end-before: [END encrypt]
             :caption: Encrypt bytes
@@ -280,32 +280,37 @@
             ciphertext=operation_result.result,
             iv=result_iv,
             authentication_tag=result_tag,
             additional_authenticated_data=result_aad,
         )
 
     @distributed_trace
-    def decrypt(self, algorithm, ciphertext, **kwargs):
-        # type: (EncryptionAlgorithm, bytes, **Any) -> DecryptResult
+    def decrypt(self, algorithm: "EncryptionAlgorithm", ciphertext: bytes, **kwargs) -> DecryptResult:
         """Decrypt a single block of encrypted data using the client's key.
 
         Requires the keys/decrypt permission. This method decrypts only a single block of data, whose size depends on
         the key and encryption algorithm.
 
         :param algorithm: Encryption algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.EncryptionAlgorithm`
         :param bytes ciphertext: Encrypted bytes to decrypt. Microsoft recommends you not use CBC without first ensuring
             the integrity of the ciphertext using, for example, an HMAC. See
             https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.
-        :keyword bytes iv: The initialization vector used during encryption. Required for AES decryption.
-        :keyword bytes authentication_tag: The authentication tag generated during encryption. Required for only AES-GCM
+
+        :keyword iv: The initialization vector used during encryption. Required for AES decryption.
+        :paramtype iv: bytes or None
+        :keyword authentication_tag: The authentication tag generated during encryption. Required for only AES-GCM
             decryption.
-        :keyword bytes additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
+        :paramtype authentication_tag: bytes or None
+        :keyword additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
             with AES-GCM decryption.
+        :paramtype additional_authenticated_data: bytes or None
+
         :rtype: :class:`~azure.keyvault.keys.crypto.DecryptResult`
+
         :raises ValueError: If parameters that are incompatible with the specified algorithm are provided.
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START decrypt]
             :end-before: [END decrypt]
             :caption: Decrypt bytes
             :language: python
@@ -338,23 +343,23 @@
             ),
             **kwargs
         )
 
         return DecryptResult(key_id=self.key_id, algorithm=algorithm, plaintext=operation_result.result)
 
     @distributed_trace
-    def wrap_key(self, algorithm, key, **kwargs):
-        # type: (KeyWrapAlgorithm, bytes, **Any) -> WrapResult
+    def wrap_key(self, algorithm: "KeyWrapAlgorithm", key: bytes, **kwargs) -> WrapResult:
         """Wrap a key with the client's key.
 
         Requires the keys/wrapKey permission.
 
         :param algorithm: wrapping algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.KeyWrapAlgorithm`
         :param bytes key: key to wrap
+
         :rtype: :class:`~azure.keyvault.keys.crypto.WrapResult`
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START wrap_key]
             :end-before: [END wrap_key]
             :caption: Wrap a key
             :language: python
@@ -381,23 +386,23 @@
             parameters=self._models.KeyOperationsParameters(algorithm=algorithm, value=key),
             **kwargs
         )
 
         return WrapResult(key_id=self.key_id, algorithm=algorithm, encrypted_key=operation_result.result)
 
     @distributed_trace
-    def unwrap_key(self, algorithm, encrypted_key, **kwargs):
-        # type: (KeyWrapAlgorithm, bytes, **Any) -> UnwrapResult
+    def unwrap_key(self, algorithm: "KeyWrapAlgorithm", encrypted_key: bytes, **kwargs) -> UnwrapResult:
         """Unwrap a key previously wrapped with the client's key.
 
         Requires the keys/unwrapKey permission.
 
         :param algorithm: wrapping algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.KeyWrapAlgorithm`
         :param bytes encrypted_key: the wrapped key
+
         :rtype: :class:`~azure.keyvault.keys.crypto.UnwrapResult`
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START unwrap_key]
             :end-before: [END unwrap_key]
             :caption: Unwrap a key
             :language: python
@@ -422,23 +427,23 @@
             key_version=self._key_id.version if self._key_id else None,
             parameters=self._models.KeyOperationsParameters(algorithm=algorithm, value=encrypted_key),
             **kwargs
         )
         return UnwrapResult(key_id=self.key_id, algorithm=algorithm, key=operation_result.result)
 
     @distributed_trace
-    def sign(self, algorithm, digest, **kwargs):
-        # type: (SignatureAlgorithm, bytes, **Any) -> SignResult
+    def sign(self, algorithm: "SignatureAlgorithm", digest: bytes, **kwargs) -> SignResult:
         """Create a signature from a digest using the client's key.
 
         Requires the keys/sign permission.
 
         :param algorithm: signing algorithm
         :type algorithm: :class:`~azure.keyvault.keys.crypto.SignatureAlgorithm`
         :param bytes digest: hashed bytes to sign
+
         :rtype: :class:`~azure.keyvault.keys.crypto.SignResult`
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START sign]
             :end-before: [END sign]
             :caption: Sign bytes
             :language: python
@@ -465,25 +470,25 @@
             parameters=self._models.KeySignParameters(algorithm=algorithm, value=digest),
             **kwargs
         )
 
         return SignResult(key_id=self.key_id, algorithm=algorithm, signature=operation_result.result)
 
     @distributed_trace
-    def verify(self, algorithm, digest, signature, **kwargs):
-        # type: (SignatureAlgorithm, bytes, bytes, **Any) -> VerifyResult
+    def verify(self, algorithm: "SignatureAlgorithm", digest: bytes, signature: bytes, **kwargs) -> VerifyResult:
         """Verify a signature using the client's key.
 
         Requires the keys/verify permission.
 
         :param algorithm: verification algorithm
         :type algorithm: :class:`~azure.keyvault.keys.crypto.SignatureAlgorithm`
         :param bytes digest: Pre-hashed digest corresponding to **signature**. The hash algorithm used must be
-          compatible with **algorithm**.
+            compatible with ``algorithm``.
         :param bytes signature: signature to verify
+
         :rtype: :class:`~azure.keyvault.keys.crypto.VerifyResult`
 
         .. literalinclude:: ../tests/test_examples_crypto.py
             :start-after: [START verify]
             :end-before: [END verify]
             :caption: Verify a signature
             :language: python
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_models.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_models.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,37 +14,38 @@
 
     :param str key_id: The encryption key's Key Vault identifier
     :param algorithm: The encryption algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.EncryptionAlgorithm
     :param bytes plaintext: The decrypted bytes
     """
 
-    def __init__(self, key_id, algorithm, plaintext):
-        # type: (Optional[str], EncryptionAlgorithm, bytes) -> None
+    def __init__(self, key_id: "Optional[str]", algorithm: "EncryptionAlgorithm", plaintext: bytes) -> None:
         self.key_id = key_id
         self.algorithm = algorithm
         self.plaintext = plaintext
 
 
 class EncryptResult:
     """The result of an encrypt operation.
 
     :param str key_id: The encryption key's Key Vault identifier
     :param algorithm: The encryption algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.EncryptionAlgorithm
     :param bytes ciphertext: The encrypted bytes
+
     :keyword bytes iv: Initialization vector for symmetric algorithms
     :keyword bytes authentication_tag: The tag to authenticate when performing decryption with an authenticated
         algorithm
     :keyword bytes additional_authenticated_data: Additional data to authenticate but not encrypt/decrypt when using an
         authenticated algorithm
     """
 
-    def __init__(self, key_id, algorithm, ciphertext, **kwargs):
-        # type: (Optional[str], EncryptionAlgorithm, bytes, **Any) -> None
+    def __init__(
+        self, key_id: "Optional[str]", algorithm: "EncryptionAlgorithm", ciphertext: bytes, **kwargs
+    ) -> None:
         self.key_id = key_id
         self.algorithm = algorithm
         self.ciphertext = ciphertext
         self.iv = kwargs.pop("iv", None)
         self.tag = kwargs.pop("authentication_tag", None)
         self.aad = kwargs.pop("additional_authenticated_data", None)
 
@@ -54,60 +55,56 @@
 
     :param str key_id: The signing key's Key Vault identifier
     :param algorithm: The signature algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.SignatureAlgorithm
     :param bytes signature:
     """
 
-    def __init__(self, key_id, algorithm, signature):
-        # type: (Optional[str], SignatureAlgorithm, bytes) -> None
+    def __init__(self, key_id: "Optional[str]", algorithm: "SignatureAlgorithm", signature: bytes) -> None:
         self.key_id = key_id
         self.algorithm = algorithm
         self.signature = signature
 
 
 class VerifyResult:
     """The result of a verify operation.
 
     :param str key_id: The signing key's Key Vault identifier
     :param bool is_valid: Whether the signature is valid
     :param algorithm: The signature algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.SignatureAlgorithm
     """
 
-    def __init__(self, key_id, is_valid, algorithm):
-        # type: (Optional[str], bool, SignatureAlgorithm) -> None
+    def __init__(self, key_id: "Optional[str]", is_valid: bool, algorithm: "SignatureAlgorithm") -> None:
         self.key_id = key_id
         self.is_valid = is_valid
         self.algorithm = algorithm
 
 
 class UnwrapResult:
     """The result of an unwrap key operation.
 
     :param str key_id: Key encryption key's Key Vault identifier
     :param algorithm: The key wrap algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.KeyWrapAlgorithm
     :param bytes key: The unwrapped key
     """
 
-    def __init__(self, key_id, algorithm, key):
-        # type: (Optional[str], KeyWrapAlgorithm, bytes) -> None
+    def __init__(self, key_id: "Optional[str]", algorithm: "KeyWrapAlgorithm", key: bytes) -> None:
         self.key_id = key_id
         self.algorithm = algorithm
         self.key = key
 
 
 class WrapResult:
     """The result of a wrap key operation.
 
     :param str key_id: The wrapping key's Key Vault identifier
     :param algorithm: The key wrap algorithm used
     :type algorithm: ~azure.keyvault.keys.crypto.KeyWrapAlgorithm
     :param bytes encrypted_key: The encrypted key bytes
     """
 
-    def __init__(self, key_id, algorithm, encrypted_key):
-        # type: (Optional[str], KeyWrapAlgorithm, bytes) -> None
+    def __init__(self, key_id: "Optional[str]", algorithm: "KeyWrapAlgorithm", encrypted_key: bytes) -> None:
         self.key_id = key_id
         self.algorithm = algorithm
         self.encrypted_key = encrypted_key
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/rsa.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/rsa.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,22 +14,20 @@
     from .._internal import Key
     from ... import JsonWebKey
 
 _PRIVATE_KEY_OPERATIONS = frozenset((KeyOperation.decrypt, KeyOperation.sign, KeyOperation.unwrap_key))
 
 
 class RsaCryptographyProvider(LocalCryptographyProvider):
-    def _get_internal_key(self, key):
-        # type: (JsonWebKey) -> Key
+    def _get_internal_key(self, key: "JsonWebKey") -> "Key":
         if key.kty not in (KeyType.rsa, KeyType.rsa_hsm):  # type: ignore[attr-defined]
             raise ValueError('"key" must be an RSA or RSA-HSM key')
         return RsaKey.from_jwk(key)
 
-    def supports(self, operation, algorithm):
-        # type: (KeyOperation, Algorithm) -> bool
+    def supports(self, operation: KeyOperation, algorithm: "Algorithm") -> bool:
         if operation in _PRIVATE_KEY_OPERATIONS and not self._internal_key.is_private_key():
             return False
         if operation in (KeyOperation.decrypt, KeyOperation.encrypt):
             return algorithm in self._internal_key.supported_encryption_algorithms
         if operation in (KeyOperation.unwrap_key, KeyOperation.wrap_key):
             return algorithm in self._internal_key.supported_key_wrap_algorithms
         if operation in (KeyOperation.sign, KeyOperation.verify):
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/symmetric.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/symmetric.py`

 * *Files 10% similar despite different names*

```diff
@@ -12,20 +12,18 @@
     # pylint:disable=unused-import
     from .local_provider import Algorithm
     from .._internal import Key
     from ... import JsonWebKey
 
 
 class SymmetricCryptographyProvider(LocalCryptographyProvider):
-    def _get_internal_key(self, key):
-        # type: (JsonWebKey) -> Key
+    def _get_internal_key(self, key: "JsonWebKey") -> "Key":
         if key.kty not in (KeyType.oct, KeyType.oct_hsm):  # type: ignore[attr-defined]
             raise ValueError('"key" must be an oct or oct-HSM (symmetric) key')
         return SymmetricKey.from_jwk(key)
 
-    def supports(self, operation, algorithm):
-        # type: (KeyOperation, Algorithm) -> bool
+    def supports(self, operation: KeyOperation, algorithm: "Algorithm") -> bool:
         if operation in (KeyOperation.decrypt, KeyOperation.encrypt):
             return algorithm in self._internal_key.supported_encryption_algorithms
         if operation in (KeyOperation.unwrap_key, KeyOperation.wrap_key):
             return algorithm in self._internal_key.supported_key_wrap_algorithms
         return False
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,26 +10,23 @@
 from .symmetric import SymmetricCryptographyProvider
 from ... import KeyType
 
 if TYPE_CHECKING:
     from ... import JsonWebKey
 
 
-def get_local_cryptography_provider(key):
-    # type: (JsonWebKey) -> LocalCryptographyProvider
+def get_local_cryptography_provider(key: "JsonWebKey") -> LocalCryptographyProvider:
     if key.kty in (KeyType.ec, KeyType.ec_hsm):  # type: ignore[attr-defined]
         return EllipticCurveCryptographyProvider(key)
     if key.kty in (KeyType.rsa, KeyType.rsa_hsm):  # type: ignore[attr-defined]
         return RsaCryptographyProvider(key)
     if key.kty in (KeyType.oct, KeyType.oct_hsm):  # type: ignore[attr-defined]
         return SymmetricCryptographyProvider(key)
-    if key.kty in (KeyType.okp, KeyType.okp_hsm):  # type: ignore[attr-defined]
-        return NoLocalCryptography()
 
-    raise ValueError('Unsupported key type "{}"'.format(key.kty))  # type: ignore[attr-defined]
+    raise ValueError(f'Unsupported key type "{key.kty}"')  # type: ignore[attr-defined]
 
 
 class NoLocalCryptography(LocalCryptographyProvider):
     def __init__(self):  # pylint:disable=super-init-not-called
         return
 
     def supports(self, operation, algorithm):
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/local_provider.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/local_provider.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,59 +14,55 @@
 try:
     ABC = abc.ABC
 except AttributeError:  # Python 2.7
     ABC = abc.ABCMeta("ABC", (object,), {"__slots__": ()})  # type: ignore
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import
-    from typing import Any, Optional, Union
+    from typing import Optional, Union
     from .._internal.key import Key
     from .. import EncryptionAlgorithm, KeyWrapAlgorithm, SignatureAlgorithm
     from ... import JsonWebKey
 
     Algorithm = Union[EncryptionAlgorithm, KeyWrapAlgorithm, SignatureAlgorithm]
 
 
 class LocalCryptographyProvider(ABC):
-    def __init__(self, key):
-        # type: (JsonWebKey) -> None
+    def __init__(self, key: "JsonWebKey") -> None:
         self._allowed_ops = frozenset(key.key_ops or [])  # type: ignore[attr-defined]
         self._internal_key = self._get_internal_key(key)
         self._key = key
 
     @abc.abstractmethod
-    def _get_internal_key(self, key):
-        # type: (JsonWebKey) -> Key
+    def _get_internal_key(self, key: "JsonWebKey") -> "Key":
         pass
 
     @abc.abstractmethod
-    def supports(self, operation, algorithm):
-        # type: (KeyOperation, Algorithm) -> bool
+    def supports(self, operation: KeyOperation, algorithm: "Algorithm") -> bool:
         pass
 
     @property
-    def key_id(self):
-        # type: () -> Optional[str]
+    def key_id(self) -> "Optional[str]":
         """The full identifier of the provider's key.
 
         :rtype: str or None
         """
         return self._key.kid  # type: ignore[attr-defined]
 
-    def _raise_if_unsupported(self, operation, algorithm):
-        # type: (KeyOperation, Algorithm) -> None
+    def _raise_if_unsupported(self, operation: KeyOperation, algorithm: "Algorithm") -> None:
         if not self.supports(operation, algorithm):
             raise NotImplementedError(
-                'This key does not support the "{}" operation with algorithm "{}"'.format(operation, algorithm)
+                f'This key does not support the "{operation}" operation with algorithm "{algorithm}"'
             )
         if operation not in self._allowed_ops:
-            raise AzureError('This key does not allow the "{}" operation'.format(operation))
+            raise AzureError(f'This key does not allow the "{operation}" operation')
 
-    def encrypt(self, algorithm, plaintext, iv=None):
-        # type: (EncryptionAlgorithm, bytes, Optional[bytes]) -> EncryptResult
+    def encrypt(
+        self, algorithm: "EncryptionAlgorithm", plaintext: bytes, iv: "Optional[bytes]" = None
+    ) -> EncryptResult:
         self._raise_if_unsupported(KeyOperation.encrypt, algorithm)
 
         # If an IV isn't provided with AES-CBCPAD encryption, try to create one
         if iv is None and algorithm.value.endswith("CBCPAD"):
             try:
                 iv = os.urandom(16)
             except NotImplementedError as ex:
@@ -76,40 +72,37 @@
                 ) from ex
 
         ciphertext = self._internal_key.encrypt(plaintext, algorithm=algorithm.value, iv=iv)
         return EncryptResult(
             key_id=self._key.kid, algorithm=algorithm, ciphertext=ciphertext, iv=iv  # type: ignore[attr-defined]
         )
 
-    def decrypt(self, algorithm, ciphertext, iv=None):
-        # type: (EncryptionAlgorithm, bytes, Optional[bytes]) -> DecryptResult
+    def decrypt(
+        self, algorithm: "EncryptionAlgorithm", ciphertext: bytes, iv: "Optional[bytes]" = None
+    ) -> DecryptResult:
         self._raise_if_unsupported(KeyOperation.decrypt, algorithm)
         plaintext = self._internal_key.decrypt(ciphertext, iv=iv, algorithm=algorithm.value)
         return DecryptResult(
             key_id=self._key.kid, algorithm=algorithm, plaintext=plaintext  # type: ignore[attr-defined]
         )
 
-    def wrap_key(self, algorithm, key):
-        # type: (KeyWrapAlgorithm, bytes) -> WrapResult
+    def wrap_key(self, algorithm: "KeyWrapAlgorithm", key: bytes) -> "WrapResult":
         self._raise_if_unsupported(KeyOperation.wrap_key, algorithm)
         encrypted_key = self._internal_key.wrap_key(key, algorithm=algorithm.value)
         return WrapResult(
             key_id=self._key.kid, algorithm=algorithm, encrypted_key=encrypted_key  # type: ignore[attr-defined]
         )
 
-    def unwrap_key(self, algorithm, encrypted_key):
-        # type: (KeyWrapAlgorithm, bytes) -> UnwrapResult
+    def unwrap_key(self, algorithm: "KeyWrapAlgorithm", encrypted_key: bytes) -> "UnwrapResult":
         self._raise_if_unsupported(KeyOperation.unwrap_key, algorithm)
         unwrapped_key = self._internal_key.unwrap_key(encrypted_key, algorithm=algorithm.value)
         return UnwrapResult(key_id=self._key.kid, algorithm=algorithm, key=unwrapped_key)  # type: ignore[attr-defined]
 
-    def sign(self, algorithm, digest):
-        # type: (SignatureAlgorithm, bytes) -> SignResult
+    def sign(self, algorithm: "SignatureAlgorithm", digest: bytes) -> "SignResult":
         self._raise_if_unsupported(KeyOperation.sign, algorithm)
         signature = self._internal_key.sign(digest, algorithm=algorithm.value)
         return SignResult(key_id=self._key.kid, algorithm=algorithm, signature=signature)  # type: ignore[attr-defined]
 
-    def verify(self, algorithm, digest, signature):
-        # type: (SignatureAlgorithm, bytes, bytes) -> VerifyResult
+    def verify(self, algorithm: "SignatureAlgorithm", digest: bytes, signature: bytes) -> "VerifyResult":
         self._raise_if_unsupported(KeyOperation.verify, algorithm)
         is_valid = self._internal_key.verify(digest, signature, algorithm=algorithm.value)
         return VerifyResult(key_id=self._key.kid, algorithm=algorithm, is_valid=is_valid)  # type: ignore[attr-defined]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_providers/ec.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_providers/ec.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,22 +14,20 @@
     from .._internal import Key
     from ... import JsonWebKey
 
 _PRIVATE_KEY_OPERATIONS = frozenset((KeyOperation.decrypt, KeyOperation.sign, KeyOperation.unwrap_key))
 
 
 class EllipticCurveCryptographyProvider(LocalCryptographyProvider):
-    def _get_internal_key(self, key):
-        # type: (JsonWebKey) -> Key
+    def _get_internal_key(self, key: "JsonWebKey") -> "Key":
         if key.kty not in (KeyType.ec, KeyType.ec_hsm):  # type: ignore[attr-defined]
             raise ValueError('"key" must be an EC or EC-HSM key')
         return EllipticCurveKey.from_jwk(key)
 
-    def supports(self, operation, algorithm):
-        # type: (KeyOperation, Algorithm) -> bool
+    def supports(self, operation: KeyOperation, algorithm: "Algorithm") -> bool:
         if operation in _PRIVATE_KEY_OPERATIONS and not self._internal_key.is_private_key():
             return False
         if operation in (KeyOperation.decrypt, KeyOperation.encrypt):
             return algorithm in self._internal_key.supported_encryption_algorithms
         if operation in (KeyOperation.unwrap_key, KeyOperation.wrap_key):
             return algorithm in self._internal_key.supported_key_wrap_algorithms
         if operation in (KeyOperation.sign, KeyOperation.verify):
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/aio/_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/aio/_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,31 +15,30 @@
 from ... import KeyOperation
 from ..._models import JsonWebKey, KeyVaultKey
 from ..._shared import AsyncKeyVaultClientBase, parse_key_vault_id
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import,ungrouped-imports
     from datetime import datetime
-    from typing import Any, Optional, Union
+    from typing import Any, Dict, Optional, Union
     from azure.core.credentials_async import AsyncTokenCredential
     from .. import KeyWrapAlgorithm, SignatureAlgorithm
     from ..._shared import KeyVaultResourceId
 
 _LOGGER = logging.getLogger(__name__)
 
 
 class CryptographyClient(AsyncKeyVaultClientBase):
     """Performs cryptographic operations using Azure Key Vault keys.
 
     This client will perform operations locally when it's intialized with the necessary key material or is able to get
     that material from Key Vault. When the required key material is unavailable, cryptographic operations are performed
     by the Key Vault service.
 
-    :param key:
-        Either a :class:`~azure.keyvault.keys.KeyVaultKey` instance as returned by
+    :param key: Either a :class:`~azure.keyvault.keys.KeyVaultKey` instance as returned by
         :func:`~azure.keyvault.keys.aio.KeyClient.get_key`, or a string.
         If a string, the value must be the identifier of an Azure Key Vault key. Including a version is recommended.
     :type key: str or :class:`~azure.keyvault.keys.KeyVaultKey`
     :param credential: An object which can provide an access token for the vault, such as a credential from
         :mod:`azure.identity.aio`
     :type credential: :class:`~azure.core.credentials_async.AsyncTokenCredential`
 
@@ -52,24 +51,26 @@
         :start-after: [START create_client]
         :end-before: [END create_client]
         :caption: Create a CryptographyClient
         :language: python
         :dedent: 8
     """
 
-    def __init__(self, key: "Union[KeyVaultKey, str]", credential: "AsyncTokenCredential", **kwargs: "Any") -> None:
+    # pylint:disable=protected-access
+
+    def __init__(self, key: "Union[KeyVaultKey, str]", credential: "AsyncTokenCredential", **kwargs) -> None:
         self._jwk = kwargs.pop("_jwk", False)
         self._not_before = None  # type: Optional[datetime]
         self._expires_on = None  # type: Optional[datetime]
         self._key_id = None  # type: Optional[KeyVaultResourceId]
 
         if isinstance(key, KeyVaultKey):
             self._key = key.key  # type: Union[JsonWebKey, KeyVaultKey, str, None]
             self._key_id = parse_key_vault_id(key.id)
-            if key.properties._attributes:  # pylint:disable=protected-access
+            if key.properties._attributes:
                 self._not_before = key.properties.not_before
                 self._expires_on = key.properties.expires_on
         elif isinstance(key, str):
             self._key = None
             self._key_id = parse_key_vault_id(key)
             if self._key_id.version is None:
                 self._key_id.version = ""  # to avoid an error and get the latest version when getting the key
@@ -111,41 +112,41 @@
         This property may be None when a client is constructed with :func:`from_jwk`.
 
         :rtype: str or None
         """
         return self._vault_url
 
     @classmethod
-    def from_jwk(cls, jwk: "Union[JsonWebKey, dict]") -> "CryptographyClient":
+    def from_jwk(cls, jwk: "Union[JsonWebKey, Dict[str, Any]]") -> "CryptographyClient":
         """Creates a client that can only perform cryptographic operations locally.
 
         :param jwk: the key's cryptographic material, as a JsonWebKey or dictionary.
-        :type jwk: JsonWebKey or dict
+        :type jwk: JsonWebKey or Dict[str, Any]
+
         :rtype: CryptographyClient
         """
         if not isinstance(jwk, JsonWebKey):
             jwk = JsonWebKey(**jwk)
         return cls(jwk, object(), _jwk=True)  # type: ignore
 
     @distributed_trace_async
-    async def _initialize(self, **kwargs):
-        # type: (**Any) -> None
+    async def _initialize(self, **kwargs) -> None:
         if self._initialized:
             return
 
         # try to get the key material, if we don't have it and aren't forbidden to do so
         if not (self._key or self._keys_get_forbidden):
             try:
                 key_bundle = await self._client.get_key(
                     self._key_id.vault_url if self._key_id else None,
                     self._key_id.name if self._key_id else None,
                     self._key_id.version if self._key_id else None,
                     **kwargs
                 )
-                key = KeyVaultKey._from_key_bundle(key_bundle)  # pylint:disable=protected-access
+                key = KeyVaultKey._from_key_bundle(key_bundle)
                 self._key = key.key
                 self._key_id = parse_key_vault_id(key.id)  # update the key ID in case we didn't have the version before
             except HttpResponseError as ex:
                 # if we got a 403, we don't have keys/get permission and won't try to get the key again
                 # (other errors may be transient)
                 self._keys_get_forbidden = ex.status_code == 403
 
@@ -154,30 +155,35 @@
             self._local_provider = get_local_cryptography_provider(cast(JsonWebKey, self._key))
             self._initialized = True
         else:
             # try to get the key again next time unless we know we're forbidden to do so
             self._initialized = self._keys_get_forbidden
 
     @distributed_trace_async
-    async def encrypt(self, algorithm: "EncryptionAlgorithm", plaintext: bytes, **kwargs: "Any") -> EncryptResult:
+    async def encrypt(self, algorithm: EncryptionAlgorithm, plaintext: bytes, **kwargs) -> EncryptResult:
         """Encrypt bytes using the client's key.
 
         Requires the keys/encrypt permission. This method encrypts only a single block of data, whose size depends on
         the key and encryption algorithm.
 
         :param algorithm: Encryption algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.EncryptionAlgorithm`
         :param bytes plaintext: Bytes to encrypt
-        :keyword bytes iv: Initialization vector. Required for only AES-CBC(PAD) encryption. If you pass your own IV,
+
+        :keyword iv: Initialization vector. Required for only AES-CBC(PAD) encryption. If you pass your own IV,
             make sure you use a cryptographically random, non-repeating IV. If omitted, an attempt will be made to
             generate an IV via `os.urandom <https://docs.python.org/library/os.html#os.urandom>`_ for local
             cryptography; for remote cryptography, Key Vault will generate an IV.
-        :keyword bytes additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
+        :paramtype iv: bytes or None
+        :keyword additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
             with AES-GCM encryption.
+        :paramtype additional_authenticated_data: bytes or None
+
         :rtype: :class:`~azure.keyvault.keys.crypto.EncryptResult`
+
         :raises ValueError: if parameters that are incompatible with the specified algorithm are provided, or if
             generating an IV fails on the current platform.
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START encrypt]
             :end-before: [END encrypt]
             :caption: Encrypt bytes
@@ -224,31 +230,37 @@
             ciphertext=operation_result.result,
             iv=result_iv,
             authentication_tag=result_tag,
             additional_authenticated_data=result_aad,
         )
 
     @distributed_trace_async
-    async def decrypt(self, algorithm: "EncryptionAlgorithm", ciphertext: bytes, **kwargs: "Any") -> DecryptResult:
+    async def decrypt(self, algorithm: EncryptionAlgorithm, ciphertext: bytes, **kwargs) -> DecryptResult:
         """Decrypt a single block of encrypted data using the client's key.
 
         Requires the keys/decrypt permission. This method decrypts only a single block of data, whose size depends on
         the key and encryption algorithm.
 
         :param algorithm: Encryption algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.EncryptionAlgorithm`
         :param bytes ciphertext: Encrypted bytes to decrypt. Microsoft recommends you not use CBC without first ensuring
             the integrity of the ciphertext using, for example, an HMAC. See
             https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.
-        :keyword bytes iv: The initialization vector used during encryption. Required for AES decryption.
-        :keyword bytes authentication_tag: The authentication tag generated during encryption. Required for only AES-GCM
+
+        :keyword iv: The initialization vector used during encryption. Required for AES decryption.
+        :paramtype iv: bytes or None
+        :keyword authentication_tag: The authentication tag generated during encryption. Required for only AES-GCM
             decryption.
-        :keyword bytes additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
+        :paramtype authentication_tag: bytes or None
+        :keyword additional_authenticated_data: Optional data that is authenticated but not encrypted. For use
             with AES-GCM decryption.
+        :paramtype additional_authenticated_data: bytes or None
+
         :rtype: :class:`~azure.keyvault.keys.crypto.DecryptResult`
+
         :raises ValueError: If parameters that are incompatible with the specified algorithm are provided.
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START decrypt]
             :end-before: [END decrypt]
             :caption: Decrypt bytes
             :language: python
@@ -281,22 +293,23 @@
             ),
             **kwargs
         )
 
         return DecryptResult(key_id=self.key_id, algorithm=algorithm, plaintext=operation_result.result)
 
     @distributed_trace_async
-    async def wrap_key(self, algorithm: "KeyWrapAlgorithm", key: bytes, **kwargs: "Any") -> WrapResult:
+    async def wrap_key(self, algorithm: "KeyWrapAlgorithm", key: bytes, **kwargs) -> WrapResult:
         """Wrap a key with the client's key.
 
         Requires the keys/wrapKey permission.
 
         :param algorithm: wrapping algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.KeyWrapAlgorithm`
         :param bytes key: key to wrap
+
         :rtype: :class:`~azure.keyvault.keys.crypto.WrapResult`
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START wrap_key]
             :end-before: [END wrap_key]
             :caption: Wrap a key
             :language: python
@@ -323,22 +336,23 @@
             parameters=self._models.KeyOperationsParameters(algorithm=algorithm, value=key),
             **kwargs
         )
 
         return WrapResult(key_id=self.key_id, algorithm=algorithm, encrypted_key=operation_result.result)
 
     @distributed_trace_async
-    async def unwrap_key(self, algorithm: "KeyWrapAlgorithm", encrypted_key: bytes, **kwargs: "Any") -> UnwrapResult:
+    async def unwrap_key(self, algorithm: "KeyWrapAlgorithm", encrypted_key: bytes, **kwargs) -> UnwrapResult:
         """Unwrap a key previously wrapped with the client's key.
 
         Requires the keys/unwrapKey permission.
 
         :param algorithm: wrapping algorithm to use
         :type algorithm: :class:`~azure.keyvault.keys.crypto.KeyWrapAlgorithm`
         :param bytes encrypted_key: the wrapped key
+
         :rtype: :class:`~azure.keyvault.keys.crypto.UnwrapResult`
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START unwrap_key]
             :end-before: [END unwrap_key]
             :caption: Unwrap a key
             :language: python
@@ -364,22 +378,23 @@
             parameters=self._models.KeyOperationsParameters(algorithm=algorithm, value=encrypted_key),
             **kwargs
         )
 
         return UnwrapResult(key_id=self.key_id, algorithm=algorithm, key=operation_result.result)
 
     @distributed_trace_async
-    async def sign(self, algorithm: "SignatureAlgorithm", digest: bytes, **kwargs: "Any") -> SignResult:
+    async def sign(self, algorithm: "SignatureAlgorithm", digest: bytes, **kwargs) -> SignResult:
         """Create a signature from a digest using the client's key.
 
         Requires the keys/sign permission.
 
         :param algorithm: signing algorithm
         :type algorithm: :class:`~azure.keyvault.keys.crypto.SignatureAlgorithm`
         :param bytes digest: hashed bytes to sign
+
         :rtype: :class:`~azure.keyvault.keys.crypto.SignResult`
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START sign]
             :end-before: [END sign]
             :caption: Sign bytes
             :language: python
@@ -407,25 +422,26 @@
             **kwargs
         )
 
         return SignResult(key_id=self.key_id, algorithm=algorithm, signature=operation_result.result)
 
     @distributed_trace_async
     async def verify(
-        self, algorithm: "SignatureAlgorithm", digest: bytes, signature: bytes, **kwargs: "Any"
+        self, algorithm: "SignatureAlgorithm", digest: bytes, signature: bytes, **kwargs
     ) -> VerifyResult:
         """Verify a signature using the client's key.
 
         Requires the keys/verify permission.
 
         :param algorithm: verification algorithm
         :type algorithm: :class:`~azure.keyvault.keys.crypto.SignatureAlgorithm`
         :param bytes digest: Pre-hashed digest corresponding to **signature**. The hash algorithm used must be
-          compatible with **algorithm**.
+            compatible with ``algorithm``.
         :param bytes signature: signature to verify
+
         :rtype: :class:`~azure.keyvault.keys.crypto.VerifyResult`
 
         .. literalinclude:: ../tests/test_examples_crypto_async.py
             :start-after: [START verify]
             :end-before: [END verify]
             :caption: Verify a signature
             :language: python
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/ec_key.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/ec_key.py`

 * *Files 3% similar despite different names*

```diff
@@ -58,15 +58,15 @@
         self._private_key = None
         if d is not None:
             private_numbers = EllipticCurvePrivateNumbers(d, public_numbers)
             self._private_key = private_numbers.private_key(default_backend())
 
     @classmethod
     def from_jwk(cls, jwk):
-        if jwk.kty != "EC" and jwk.kty != "EC-HSM":
+        if jwk.kty not in ("EC", "EC-HSM"):
             raise ValueError("The specified key must be of type 'EC' or 'EC-HSM'")
 
         if not jwk.x or not jwk.y:
             raise ValueError("jwk must have values for 'x' and 'y'")
 
         x = _bytes_to_int(jwk.x)
         y = _bytes_to_int(jwk.y)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/_internal.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/_internal.py`

 * *Files 8% similar despite different names*

```diff
@@ -68,15 +68,15 @@
 
 def _int_to_fixed_length_bigendian_bytes(i, length):
     """Convert an integer to a bigendian byte string left-padded with zeroes to a fixed length."""
 
     b = _int_to_bytes(i)
 
     if len(b) > length:
-        raise ValueError("{} is too large to be represented by {} bytes".format(i, length))
+        raise ValueError(f"{i} is too large to be represented by {length} bytes")
 
     if len(b) < length:
         b = (b"\0" * (length - len(b))) + b
 
     return b
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/transform.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/transform.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/rsa_key.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/rsa_key.py`

 * *Files 2% similar despite different names*

```diff
@@ -95,15 +95,15 @@
         key.key_ops = RsaKey.PRIVATE_KEY_DEFAULT_OPS
         # pylint:disable=protected-access
         key._rsa_impl = generate_private_key(public_exponent=e, key_size=size, backend=default_backend())
         return key
 
     @classmethod
     def from_jwk(cls, jwk):
-        if jwk.kty != "RSA" and jwk.kty != "RSA-HSM":
+        if jwk.kty not in ("RSA", "RSA-HSM"):
             raise ValueError('The specified jwk must have a key type of "RSA" or "RSA-HSM"')
 
         if not jwk.n or not jwk.e:
             raise ValueError("Invalid RSA jwk, both n and e must be have values")
 
         rsa_key = cls(kid=jwk.kid)
         rsa_key.kty = jwk.kty
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/key.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/key.py`

 * *Files 4% similar despite different names*

```diff
@@ -91,10 +91,10 @@
 
         algorithm = kwargs.get("algorithm", default_algorithm)
 
         if not isinstance(algorithm, Algorithm):
             algorithm = Algorithm.resolve(algorithm)
 
         if not algorithm or not supported_algorithms or algorithm.name() not in supported_algorithms:
-            raise ValueError("unsupported algorithm '{}'".format(algorithm))
+            raise ValueError(f"unsupported algorithm '{algorithm}'")
 
         return algorithm
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithm.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithm.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/symmetric_key.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/symmetric_key.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_signing.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc.py`

 * *Files 2% similar despite different names*

```diff
@@ -81,20 +81,20 @@
 
         return _AesCbcDecryptor(key, iv, padding.PKCS7(self._block_size))
 
     def _validate_input(self, key, iv):
         if not key:
             raise ValueError("A key is required for AES-CBC and AES-CBCPAD encryption and decryption")
         if len(key) < self.key_size_in_bytes():
-            raise ValueError("key must be at least %d bits" % self.key_size)
+            raise ValueError(f"key must be at least {self.key_size} bits")
 
         if not iv:
             raise ValueError("A 16-byte iv is required for AES-CBC and AES-CBCPAD encryption and decryption")
         if not len(iv) == self.block_size_in_bytes():
-            raise ValueError("iv must be %d bits" % self.block_size)
+            raise ValueError(f"iv must be {self.block_size} bits")
 
         return key[: self.key_size_in_bytes()], iv
 
 
 class _AesCbcPad(_AesCbc):
     def create_encryptor(self, key, iv):
         key, iv = self._validate_input(key, iv)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/ecdsa.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_kw.py`

 * *Files 2% similar despite different names*

```diff
@@ -39,15 +39,15 @@
         key = self._validate_input(key)
         return _AesKeyUnwrapTransform(key)
 
     def _validate_input(self, key):
         if not key:
             raise ValueError("key")
         if len(key) < self.key_size_in_bytes:
-            raise ValueError("key must be at least %d bits" % self.key_size)
+            raise ValueError(f"key must be at least {self.key_size} bits")
 
         return key[: self.key_size_in_bytes]
 
 
 class AesKw128(_AesKeyWrap):
     _key_size = 128
     _name = "A128KW"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/sha_2.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/rsa_encryption.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/crypto/_internal/algorithms/aes_cbc_hmac.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/aio/_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/aio/_client.py`

 * *Files 13% similar despite different names*

```diff
@@ -20,17 +20,19 @@
     KeyRotationPolicy,
     KeyVaultKey,
     ReleaseKeyResult,
 )
 
 if TYPE_CHECKING:
     # pylint:disable=ungrouped-imports
+    from datetime import datetime
+    from typing import Optional, Union
     from azure.core.async_paging import AsyncItemPaged
-    from typing import Any, List, Optional, Union
     from .. import KeyType
+    from .._generated_models import KeyAttributes
 
 
 class KeyClient(AsyncKeyVaultClientBase):
     """A high-level asynchronous interface for managing a vault's keys.
 
     :param str vault_url: URL of the vault the client will access. This is also called the vault's "DNS Name".
         You should validate that this URL references a valid Key Vault or Managed HSM resource.
@@ -51,24 +53,29 @@
             :language: python
             :caption: Create a new ``KeyClient``
             :dedent: 4
     """
 
     # pylint:disable=protected-access, too-many-public-methods
 
-    def _get_attributes(self, enabled, not_before, expires_on, exportable=None):
+    def _get_attributes(
+        self,
+        enabled: "Optional[bool]",
+        not_before: "Optional[datetime]",
+        expires_on: "Optional[datetime]",
+        exportable: "Optional[bool]" = None,
+    ) -> "Optional[KeyAttributes]":
         """Return a KeyAttributes object if none-None attributes are provided, or None otherwise"""
         if enabled is not None or not_before is not None or expires_on is not None or exportable is not None:
             return self._models.KeyAttributes(
                 enabled=enabled, not_before=not_before, expires=expires_on, exportable=exportable
             )
         return None
 
-    def get_cryptography_client(self, key_name, **kwargs):
-        # type: (str, **Any) -> CryptographyClient
+    def get_cryptography_client(self, key_name: str, **kwargs) -> CryptographyClient:
         """Gets a :class:`~azure.keyvault.keys.crypto.aio.CryptographyClient` for the given key.
 
         :param str key_name: The name of the key used to perform cryptographic operations.
 
         :keyword str key_version: Optional version of the key used to perform cryptographic operations.
 
         :returns: A :class:`~azure.keyvault.keys.crypto.aio.CryptographyClient` using the same options, credentials, and
@@ -79,42 +86,49 @@
 
         # We provide a fake credential because the generated client already has the KeyClient's real credential
         return CryptographyClient(
             key_id, object(), generated_client=self._client, generated_models=self._models  # type: ignore
         )
 
     @distributed_trace_async
-    async def create_key(self, name: str, key_type: "Union[str, KeyType]", **kwargs: "Any") -> KeyVaultKey:
+    async def create_key(self, name: str, key_type: "Union[str, KeyType]", **kwargs) -> KeyVaultKey:
         """Create a key or, if ``name`` is already in use, create a new version of the key.
 
         Requires keys/create permission.
 
         :param str name: The name of the new key.
         :param key_type: The type of key to create
         :type key_type: ~azure.keyvault.keys.KeyType or str
 
-        :keyword int size: Key size in bits. Applies only to RSA and symmetric keys. Consider using
-         :func:`create_rsa_key` or :func:`create_oct_key` instead.
+        :keyword size: Key size in bits. Applies only to RSA and symmetric keys. Consider using
+            :func:`create_rsa_key` or :func:`create_oct_key` instead.
+        :paramtype size: int or None
         :keyword curve: Elliptic curve name. Applies only to elliptic curve keys. Defaults to the NIST P-256
-         elliptic curve. To create an elliptic curve key, consider using :func:`create_ec_key` instead.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
-        :keyword int public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+            elliptic curve. To create an elliptic curve key, consider using :func:`create_ec_key` instead.
+        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str or None
+        :keyword public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+        :paramtype public_exponent: int or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START create_key]
                 :end-before: [END create_key]
                 :language: python
@@ -151,175 +165,159 @@
             parameters=parameters,
             error_map=_error_map,
             **kwargs,
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
-    async def create_rsa_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
+    async def create_rsa_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new RSA key or, if ``name`` is already in use, create a new version of the key
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
-        :keyword int size: Key size in bits, for example 2048, 3072, or 4096.
-        :keyword int public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
+        :keyword size: Key size in bits, for example 2048, 3072, or 4096.
+        :paramtype size: int or None
+        :keyword public_exponent: The RSA public exponent to use. Applies only to RSA keys created in a Managed HSM.
+        :paramtype public_exponent: int or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START create_rsa_key]
                 :end-before: [END create_rsa_key]
                 :language: python
                 :caption: Create RSA key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return await self.create_key(name, key_type="RSA-HSM" if hsm else "RSA", **kwargs)
 
     @distributed_trace_async
-    async def create_ec_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
+    async def create_ec_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new elliptic curve key or, if ``name`` is already in use, create a new version of the key.
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
         :keyword curve: Elliptic curve name. Defaults to the NIST P-256 elliptic curve.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
+        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str or None
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START create_ec_key]
                 :end-before: [END create_ec_key]
                 :language: python
                 :caption: Create an elliptic curve key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return await self.create_key(name, key_type="EC-HSM" if hsm else "EC", **kwargs)
 
     @distributed_trace_async
-    async def create_oct_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
+    async def create_oct_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Create a new octet sequence (symmetric) key or, if ``name`` is in use, create a new version of the key.
 
         Requires the keys/create permission.
 
         :param str name: The name for the new key.
 
-        :keyword int size: Key size in bits, for example 128, 192, or 256.
+        :keyword size: Key size in bits, for example 128, 192, or 256.
+        :paramtype size: int or None
         :keyword key_operations: Allowed key operations.
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-         Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword hardware_protected: Whether the key should be created in a hardware security module.
+            Defaults to ``False``.
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The created key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START create_oct_key]
                 :end-before: [END create_oct_key]
                 :language: python
                 :caption: Create an octet sequence (symmetric) key
                 :dedent: 8
         """
         hsm = kwargs.pop("hardware_protected", False)
         return await self.create_key(name, key_type="oct-HSM" if hsm else "oct", **kwargs)
 
     @distributed_trace_async
-    async def create_okp_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
-        """Create a new octet key pair or, if ``name`` is in use, create a new version of the key.
-
-        Requires the keys/create permission.
-
-        :param str name: The name for the new key.
-
-        :keyword curve: Elliptic curve name.
-        :paramtype curve: ~azure.keyvault.keys.KeyCurveName or str
-        :keyword key_operations: Allowed key operations.
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool hardware_protected: Whether the key should be created in a hardware security module.
-            Defaults to ``False``.
-        :keyword bool enabled: Whether the key is enabled for use.
-        :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the key can be exported.
-        :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
-
-        :returns: The created key
-        :rtype: ~azure.keyvault.keys.KeyVaultKey
-        :raises: :class:`~azure.core.exceptions.HttpResponseError`
-
-        Example:
-            .. literalinclude:: ../tests/test_samples_keys_async.py
-                :start-after: [START create_okp_key]
-                :end-before: [END create_okp_key]
-                :language: python
-                :caption: Create an octet key pair (OKP)
-                :dedent: 8
-        """
-        hsm = kwargs.pop("hardware_protected", False)
-        return await self.create_key(name, key_type="OKP-HSM" if hsm else "OKP", **kwargs)
-
-    @distributed_trace_async
-    async def delete_key(self, name: str, **kwargs: "Any") -> DeletedKey:
+    async def delete_key(self, name: str, **kwargs) -> DeletedKey:
         """Delete all versions of a key and its cryptographic material.
 
         Requires keys/delete permission. If the vault has soft-delete enabled, deletion may take several seconds to
         complete.
 
         :param str name: The name of the key to delete
 
         :returns: The deleted key
         :rtype: ~azure.keyvault.keys.DeletedKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START delete_key]
@@ -343,24 +341,26 @@
             interval=polling_interval,
         )
         await polling_method.run()
 
         return polling_method.resource()
 
     @distributed_trace_async
-    async def get_key(self, name: str, version: "Optional[str]" = None, **kwargs: "Any") -> KeyVaultKey:
+    async def get_key(self, name: str, version: "Optional[str]" = None, **kwargs) -> KeyVaultKey:
         """Get a key's attributes and, if it's an asymmetric key, its public material.
 
         Requires keys/get permission.
 
         :param str name: The name of the key to get.
-        :param str version: (optional) A specific version of the key to get. If not specified, gets the latest version
+        :param version: (optional) A specific version of the key to get. If not specified, gets the latest version
             of the key.
+        :type version: str or None
 
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START get_key]
@@ -372,23 +372,24 @@
         if version is None:
             version = ""
 
         bundle = await self._client.get_key(self.vault_url, name, version, error_map=_error_map, **kwargs)
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
-    async def get_deleted_key(self, name: str, **kwargs: "Any") -> DeletedKey:
+    async def get_deleted_key(self, name: str, **kwargs) -> DeletedKey:
         """Get a deleted key. Possible only in a vault with soft-delete enabled.
 
         Requires keys/get permission.
 
         :param str name: The name of the key
 
         :returns: The deleted key
         :rtype: ~azure.keyvault.keys.DeletedKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START get_deleted_key]
@@ -397,15 +398,15 @@
                 :caption: Get a deleted key
                 :dedent: 8
         """
         bundle = await self._client.get_deleted_key(self.vault_url, name, error_map=_error_map, **kwargs)
         return DeletedKey._from_deleted_key_bundle(bundle)
 
     @distributed_trace
-    def list_deleted_keys(self, **kwargs: "Any") -> "AsyncItemPaged[DeletedKey]":
+    def list_deleted_keys(self, **kwargs) -> "AsyncItemPaged[DeletedKey]":
         """List all deleted keys, including the public part of each. Possible only in a vault with soft-delete enabled.
 
         Requires keys/list permission.
 
         :returns: An iterator of deleted keys
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.keys.DeletedKey]
 
@@ -422,15 +423,15 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [DeletedKey._from_deleted_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs,
         )
 
     @distributed_trace
-    def list_properties_of_keys(self, **kwargs: "Any") -> "AsyncItemPaged[KeyProperties]":
+    def list_properties_of_keys(self, **kwargs) -> "AsyncItemPaged[KeyProperties]":
         """List identifiers and properties of all keys in the vault.
 
         Requires keys/list permission.
 
         :returns: An iterator of keys without their cryptographic material or version information
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.keys.KeyProperties]
 
@@ -447,15 +448,15 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [KeyProperties._from_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs,
         )
 
     @distributed_trace
-    def list_properties_of_key_versions(self, name: str, **kwargs: "Any") -> "AsyncItemPaged[KeyProperties]":
+    def list_properties_of_key_versions(self, name: str, **kwargs) -> "AsyncItemPaged[KeyProperties]":
         """List the identifiers and properties of a key's versions.
 
         Requires keys/list permission.
 
         :param str name: The name of the key
 
         :returns: An iterator of keys without their cryptographic material
@@ -475,52 +476,53 @@
             maxresults=kwargs.pop("max_page_size", None),
             cls=lambda objs: [KeyProperties._from_key_item(x) for x in objs],
             error_map=_error_map,
             **kwargs,
         )
 
     @distributed_trace_async
-    async def purge_deleted_key(self, name: str, **kwargs: "Any") -> None:
+    async def purge_deleted_key(self, name: str, **kwargs) -> None:
         """Permanently deletes a deleted key. Only possible in a vault with soft-delete enabled.
 
-        Performs an irreversible deletion of the specified key, without
-        possibility for recovery. The operation is not available if the
-        :py:attr:`~azure.keyvault.keys.KeyProperties.recovery_level` does not specify 'Purgeable'.
+        Performs an irreversible deletion of the specified key, without possibility for recovery. The operation is not
+        available if the :py:attr:`~azure.keyvault.keys.KeyProperties.recovery_level` does not specify 'Purgeable'.
         This method is only necessary for purging a key before its
         :py:attr:`~azure.keyvault.keys.DeletedKey.scheduled_purge_date`.
 
         Requires keys/purge permission.
 
         :param str name: The name of the deleted key to purge
 
         :returns: None
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. code-block:: python
 
                 # if the vault has soft-delete enabled, purge permanently deletes a deleted key
                 # (with soft-delete disabled, delete_key is permanent)
                 await key_client.purge_deleted_key("key-name")
 
         """
         await self._client.purge_deleted_key(self.vault_url, name, error_map=_error_map, **kwargs)
 
     @distributed_trace_async
-    async def recover_deleted_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
+    async def recover_deleted_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Recover a deleted key to its latest version. Possible only in a vault with soft-delete enabled.
 
         Requires keys/recover permission. If the vault does not have soft-delete enabled, :func:`delete_key` is
         permanent, and this method will raise an error. Attempting to recover a non-deleted key will also raise an
         error.
 
         :param str name: The name of the deleted key
 
         :returns: The recovered key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START recover_deleted_key]
                 :end-before: [END recover_deleted_key]
                 :language: python
@@ -539,34 +541,39 @@
             command=command, final_resource=recovered_key, finished=False, interval=polling_interval
         )
         await polling_method.run()
 
         return polling_method.resource()
 
     @distributed_trace_async
-    async def update_key_properties(self, name: str, version: "Optional[str]" = None, **kwargs: "Any") -> KeyVaultKey:
+    async def update_key_properties(self, name: str, version: "Optional[str]" = None, **kwargs) -> KeyVaultKey:
         """Change a key's properties (not its cryptographic material).
 
         Requires keys/update permission.
 
         :param str name: The name of key to update
-        :param str version: (optional) The version of the key to update. If unspecified, the latest version is updated.
+        :param version: (optional) The version of the key to update. If unspecified, the latest version is updated.
+        :type version: str or None
 
         :keyword key_operations: Allowed key operations
-        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str]
-        :keyword bool enabled: Whether the key is enabled for use.
+        :paramtype key_operations: list[~azure.keyvault.keys.KeyOperation or str] or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The updated key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START update_key]
@@ -599,26 +606,25 @@
             parameters=parameters,
             error_map=_error_map,
             **kwargs,
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
-    async def backup_key(self, name: str, **kwargs: "Any") -> bytes:
+    async def backup_key(self, name: str, **kwargs) -> bytes:
         """Back up a key in a protected form useable only by Azure Key Vault.
 
-        Requires key/backup permission.
-
-        This is intended to allow copying a key from one vault to another. Both vaults must be owned by the same Azure
-        subscription. Also, backup / restore cannot be performed across geopolitical boundaries. For example, a backup
-        from a vault in a USA region cannot be restored to a vault in an EU region.
+        Requires key/backup permission. This is intended to allow copying a key from one vault to another. Both vaults
+        must be owned by the same Azure subscription. Also, backup / restore cannot be performed across geopolitical
+        boundaries. For example, a backup from a vault in a USA region cannot be restored to a vault in an EU region.
 
         :param str name: The name of the key to back up
 
         :rtype: bytes
+
         :raises:
             :class:`~azure.core.exceptions.ResourceNotFoundError` if the key doesn't exist,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START backup_key]
@@ -627,27 +633,26 @@
                 :caption: Get a key backup
                 :dedent: 8
         """
         backup_result = await self._client.backup_key(self.vault_url, name, error_map=_error_map, **kwargs)
         return backup_result.value
 
     @distributed_trace_async
-    async def restore_key_backup(self, backup: bytes, **kwargs: "Any") -> KeyVaultKey:
+    async def restore_key_backup(self, backup: bytes, **kwargs) -> KeyVaultKey:
         """Restore a key backup to the vault.
 
-        Requires keys/restore permission.
-
-        This imports all versions of the key, with its name, attributes, and access control policies. If the key's name
-        is already in use, restoring it will fail. Also, the target vault must be owned by the same Microsoft Azure
-        subscription as the source vault.
+        Requires keys/restore permission. This imports all versions of the key, with its name, attributes, and access
+        control policies. If the key's name is already in use, restoring it will fail. Also, the target vault must be
+        owned by the same Microsoft Azure subscription as the source vault.
 
         :param bytes backup: A key backup as returned by :func:`backup_key`
 
         :returns: The restored key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises:
             :class:`~azure.core.exceptions.ResourceExistsError` if the backed up key's name is already in use,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_samples_keys_async.py
                 :start-after: [START restore_key_backup]
@@ -661,35 +666,41 @@
             parameters=self._models.KeyRestoreParameters(key_bundle_backup=backup),
             error_map=_error_map,
             **kwargs,
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
-    async def import_key(self, name: str, key: JsonWebKey, **kwargs: "Any") -> KeyVaultKey:
+    async def import_key(self, name: str, key: JsonWebKey, **kwargs) -> KeyVaultKey:
         """Import a key created externally.
 
         Requires keys/import permission. If ``name`` is already in use, the key will be imported as a new version.
 
         :param str name: Name for the imported key
         :param key: The JSON web key to import
         :type key: ~azure.keyvault.keys.JsonWebKey
 
-        :keyword bool hardware_protected: Whether the key should be backed by a hardware security module
-        :keyword bool enabled: Whether the key is enabled for use.
+        :keyword hardware_protected: Whether the key should be backed by a hardware security module
+        :paramtype hardware_protected: bool or None
+        :keyword enabled: Whether the key is enabled for use.
+        :paramtype enabled: bool or None
         :keyword tags: Application specific metadata in the form of key-value pairs.
-        :paramtype tags: dict[str, str]
-        :keyword ~datetime.datetime not_before: Not before date of the key in UTC
-        :keyword ~datetime.datetime expires_on: Expiry date of the key in UTC
-        :keyword bool exportable: Whether the private key can be exported.
+        :paramtype tags: dict[str, str] or None
+        :keyword not_before: Not before date of the key in UTC
+        :paramtype not_before: ~datetime.datetime or None
+        :keyword expires_on: Expiry date of the key in UTC
+        :paramtype expires_on: ~datetime.datetime or None
+        :keyword exportable: Whether the private key can be exported.
+        :paramtype exportable: bool or None
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.keys.KeyReleasePolicy or None
 
         :returns: The imported key
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         enabled = kwargs.pop("enabled", None)
         not_before = kwargs.pop("not_before", None)
         expires_on = kwargs.pop("expires_on", None)
         exportable = kwargs.pop("exportable", None)
         attributes = self._get_attributes(
@@ -711,54 +722,58 @@
 
         bundle = await self._client.import_key(
             self.vault_url, name, parameters=parameters, error_map=_error_map, **kwargs
         )
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
-    async def release_key(self, name: str, target_attestation_token: str, **kwargs: "Any") -> ReleaseKeyResult:
+    async def release_key(self, name: str, target_attestation_token: str, **kwargs) -> ReleaseKeyResult:
         """Releases a key.
 
         The release key operation is applicable to all key types. The target key must be marked
         exportable. This operation requires the keys/release permission.
 
         :param str name: The name of the key to get.
         :param str target_attestation_token: The attestation assertion for the target of the key release.
 
-        :keyword str version: A specific version of the key to release. If unspecified, the latest version is released.
+        :keyword version: A specific version of the key to release. If unspecified, the latest version is released.
+        :paramtype version: str or None
         :keyword algorithm: The encryption algorithm to use to protect the released key material.
-        :paramtype algorithm: Union[str, ~azure.keyvault.keys.KeyExportEncryptionAlgorithm]
-        :keyword str nonce: A client-provided nonce for freshness.
+        :paramtype algorithm: str or ~azure.keyvault.keys.KeyExportEncryptionAlgorithm or None
+        :keyword nonce: A client-provided nonce for freshness.
+        :paramtype nonce: str or None
 
         :return: The result of the key release.
         :rtype: ~azure.keyvault.keys.ReleaseKeyResult
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
-        version = kwargs.pop("version", "")
+        version = kwargs.pop("version", None)
         result = await self._client.release(
             vault_base_url=self._vault_url,
             key_name=name,
-            key_version=version,
+            key_version=version or "",
             parameters=self._models.KeyReleaseParameters(
                 target_attestation_token=target_attestation_token,
                 nonce=kwargs.pop("nonce", None),
                 enc=kwargs.pop("algorithm", None),
             ),
             **kwargs,
         )
         return ReleaseKeyResult(result.value)
 
     @distributed_trace_async
-    async def get_random_bytes(self, count: int, **kwargs: "Any") -> bytes:
+    async def get_random_bytes(self, count: int, **kwargs) -> bytes:
         """Get the requested number of random bytes from a managed HSM.
 
         :param int count: The requested number of random bytes.
 
         :return: The random bytes.
         :rtype: bytes
+
         :raises:
             :class:`ValueError` if less than one random byte is requested,
             :class:`~azure.core.exceptions.HttpResponseError` for other errors
 
         Example:
             .. literalinclude:: ../tests/test_keys_async.py
                 :start-after: [START get_random_bytes]
@@ -770,63 +785,66 @@
         if count < 1:
             raise ValueError("At least one random byte must be requested")
         parameters = self._models.GetRandomBytesRequest(count=count)
         result = await self._client.get_random_bytes(vault_base_url=self._vault_url, parameters=parameters, **kwargs)
         return result.value
 
     @distributed_trace_async
-    async def get_key_rotation_policy(self, key_name: str, **kwargs: "Any") -> "KeyRotationPolicy":
+    async def get_key_rotation_policy(self, key_name: str, **kwargs) -> "KeyRotationPolicy":
         """Get the rotation policy of a Key Vault key.
 
         :param str key_name: The name of the key.
 
         :return: The key rotation policy.
         :rtype: ~azure.keyvault.keys.KeyRotationPolicy
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         policy = await self._client.get_key_rotation_policy(vault_base_url=self._vault_url, key_name=key_name, **kwargs)
         return KeyRotationPolicy._from_generated(policy)
 
     @distributed_trace_async
-    async def rotate_key(self, name: str, **kwargs: "Any") -> KeyVaultKey:
+    async def rotate_key(self, name: str, **kwargs) -> KeyVaultKey:
         """Rotate the key based on the key policy by generating a new version of the key.
 
         This operation requires the keys/rotate permission.
 
         :param str name: The name of the key to rotate.
 
         :return: The new version of the rotated key.
         :rtype: ~azure.keyvault.keys.KeyVaultKey
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         bundle = await self._client.rotate_key(vault_base_url=self._vault_url, key_name=name, **kwargs)
         return KeyVaultKey._from_key_bundle(bundle)
 
     @distributed_trace_async
     async def update_key_rotation_policy(
-        self, key_name: str, policy: KeyRotationPolicy, **kwargs: "Any"
+        self, key_name: str, policy: KeyRotationPolicy, **kwargs
     ) -> KeyRotationPolicy:
         """Updates the rotation policy of a Key Vault key.
 
         This operation requires the keys/update permission.
 
         :param str key_name: The name of the key in the given vault.
         :param policy: The new rotation policy for the key.
         :type policy: ~azure.keyvault.keys.KeyRotationPolicy
 
         :keyword lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a key. This will
             override the lifetime actions of the provided ``policy``.
-        :paramtype lifetime_actions: List[~azure.keyvault.keys.KeyRotationLifetimeAction]
+        :paramtype lifetime_actions: list[~azure.keyvault.keys.KeyRotationLifetimeAction]
         :keyword str expires_in: The expiry time of the policy that will be applied on new key versions, defined as an
             ISO 8601 duration. For example: 90 days is "P90D", 3 months is "P3M", and 48 hours is "PT48H". See
             `Wikipedia <https://wikipedia.org/wiki/ISO_8601#Durations>`_ for more information on ISO 8601 durations.
             This will override the expiry time of the provided ``policy``.
 
         :return: The updated rotation policy.
         :rtype: ~azure.keyvault.keys.KeyRotationPolicy
+
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
         lifetime_actions = kwargs.pop("lifetime_actions", policy.lifetime_actions)
         if lifetime_actions:
             lifetime_actions = [
                 self._models.LifetimeActions(
                     action=self._models.LifetimeActionsType(type=action.action),
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,40 +9,38 @@
 # regenerated.
 # --------------------------------------------------------------------------
 from typing import Any
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from ._version import VERSION
+from .._version import VERSION
 
 class KeyVaultClientConfiguration(Configuration):
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
     """
 
     def __init__(
         self,
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+        **kwargs: Any
+    ) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
 
         kwargs.setdefault('sdk_moniker', 'azure-keyvault/{}'.format(VERSION))
         self._configure(**kwargs)
 
     def _configure(
         self,
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+        **kwargs: Any
+    ) -> None:
         self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get('http_logging_policy') or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get('retry_policy') or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get('redirect_policy') or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get('authentication_policy')
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is
 # regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, Optional
 
-from azure.core import PipelineClient
+from azure.core import AsyncPipelineClient
 from azure.profiles import KnownProfiles, ProfileDefinition
 from azure.profiles.multiapiclient import MultiApiClientMixin
 
+from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from ._operations_mixin import KeyVaultClientOperationsMixin
-from ._serialization import Deserializer, Serializer
 
 class _SDKClient(object):
     def __init__(self, *args, **kwargs):
         """This is a fake class to support current implemetation of MultiApiClientMixin."
         Will be removed in final version of multiapi azure-core based client
         """
         pass
@@ -38,15 +38,15 @@
     group is not described in the profile.
     :param api_version: API version to use if no profile is provided, or if missing in profile.
     :type api_version: str
     :param profile: A profile definition, from KnownProfiles to dict.
     :type profile: azure.profiles.KnownProfiles
     """
 
-    DEFAULT_API_VERSION = '7.3'
+    DEFAULT_API_VERSION = '7.4'
     _PROFILE_TAG = "azure.keyvault.KeyVaultClient"
     LATEST_PROFILE = ProfileDefinition({
         _PROFILE_TAG: {
             None: DEFAULT_API_VERSION,
             'backup_certificate': '7.0',
             'backup_secret': '7.0',
             'backup_storage_account': '7.0',
@@ -108,24 +108,24 @@
             'update_storage_account': '7.0',
         }},
         _PROFILE_TAG + " latest"
     )
 
     def __init__(
         self,
-        api_version=None, # type: Optional[str]
-        profile=KnownProfiles.default, # type: KnownProfiles
-        **kwargs  # type: Any
-    ):
-        if api_version == '2016-10-01' or api_version == '7.0' or api_version == '7.1' or api_version == '7.2' or api_version == '7.3' or api_version == '7.4-preview.1':
+        api_version: Optional[str] = None,
+        profile: KnownProfiles = KnownProfiles.default,
+        **kwargs: Any
+    ) -> None:
+        if api_version == '2016-10-01' or api_version == '7.0' or api_version == '7.1' or api_version == '7.2' or api_version == '7.3' or api_version == '7.4':
             base_url = '{vaultBaseUrl}'
         else:
             raise ValueError("API version {} is not available".format(api_version))
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncPipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(KeyVaultClient, self).__init__(
             api_version=api_version,
             profile=profile
         )
 
     @classmethod
     def _models_dict(cls, api_version):
@@ -136,36 +136,36 @@
         """Module depends on the API version:
 
            * 2016-10-01: :mod:`v2016_10_01.models<azure.keyvault.v2016_10_01.models>`
            * 7.0: :mod:`v7_0.models<azure.keyvault.v7_0.models>`
            * 7.1: :mod:`v7_1.models<azure.keyvault.v7_1.models>`
            * 7.2: :mod:`v7_2.models<azure.keyvault.v7_2.models>`
            * 7.3: :mod:`v7_3.models<azure.keyvault.v7_3.models>`
-           * 7.4-preview.1: :mod:`v7_4_preview_1.models<azure.keyvault.v7_4_preview_1.models>`
+           * 7.4: :mod:`v7_4.models<azure.keyvault.v7_4.models>`
         """
         if api_version == '2016-10-01':
-            from .v2016_10_01 import models
+            from ..v2016_10_01 import models
             return models
         elif api_version == '7.0':
-            from .v7_0 import models
+            from ..v7_0 import models
             return models
         elif api_version == '7.1':
-            from .v7_1 import models
+            from ..v7_1 import models
             return models
         elif api_version == '7.2':
-            from .v7_2 import models
+            from ..v7_2 import models
             return models
         elif api_version == '7.3':
-            from .v7_3 import models
+            from ..v7_3 import models
             return models
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1 import models
+        elif api_version == '7.4':
+            from ..v7_4 import models
             return models
         raise ValueError("API version {} is not available".format(api_version))
 
-    def close(self):
-        self._client.close()
-    def __enter__(self):
-        self._client.__enter__()
+    async def close(self):
+        await self._client.close()
+    async def __aenter__(self):
+        await self._client.__aenter__()
         return self
-    def __exit__(self, *exc_details):
-        self._client.__exit__(*exc_details)
+    async def __aexit__(self, *exc_details):
+        await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_serialization.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_serialization.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,70 +21,87 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 #
 # --------------------------------------------------------------------------
 
 # pylint: skip-file
+# pyright: reportUnnecessaryTypeIgnoreComment=false
 
 from base64 import b64decode, b64encode
 import calendar
 import datetime
 import decimal
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
+
 try:
     from urllib import quote  # type: ignore
 except ImportError:
-    from urllib.parse import quote  # type: ignore
+    from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
-import isodate
-
-from typing import Dict, Any, cast, TYPE_CHECKING
+import isodate  # type: ignore
 
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
-_BOM = codecs.BOM_UTF8.decode(encoding='utf-8')
+_BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
+
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
 
-if TYPE_CHECKING:
-    from typing import Optional, Union, AnyStr, IO, Mapping
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
-    JSON_REGEXP = re.compile(r'^(application|text)/([a-z+.]+\+)?json$')
+    JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
     CONTEXT_NAME = "deserialized_data"
 
     @classmethod
-    def deserialize_from_text(cls, data, content_type=None):
-        # type: (Optional[Union[AnyStr, IO]], Optional[str]) -> Any
+    def deserialize_from_text(cls, data: Optional[Union[AnyStr, IO]], content_type: Optional[str] = None) -> Any:
         """Decode data according to content-type.
 
         Accept a stream of data as well, but will be load at once in memory for now.
 
         If no content-type, will return the string version (not bytes, not stream)
 
         :param data: Input, could be bytes or stream (will be decoded with UTF8) or text
         :type data: str or bytes or IO
         :param str content_type: The content type.
         """
-        if hasattr(data, 'read'):
+        if hasattr(data, "read"):
             # Assume a stream
             data = cast(IO, data).read()
 
         if isinstance(data, bytes):
-            data_as_str = data.decode(encoding='utf-8-sig')
+            data_as_str = data.decode(encoding="utf-8-sig")
         else:
             # Explain to mypy the correct type.
             data_as_str = cast(str, data)
 
             # Remove Byte Order Mark if present in string
             data_as_str = data_as_str.lstrip(_BOM)
 
@@ -112,64 +129,66 @@
                 # content-type XML....
                 # So let's try a JSON load, and if it's still broken
                 # let's flow the initial exception
                 def _json_attemp(data):
                     try:
                         return True, json.loads(data)
                     except ValueError:
-                        return False, None # Don't care about this one
+                        return False, None  # Don't care about this one
+
                 success, json_result = _json_attemp(data)
                 if success:
                     return json_result
                 # If i'm here, it's not JSON, it's not XML, let's scream
                 # and raise the last context in this block (the XML exception)
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
                 raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
-    def deserialize_from_http_generics(cls, body_bytes, headers):
-        # type: (Optional[Union[AnyStr, IO]], Mapping) -> Any
+    def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
         specific implementation.
         Headers will tested for "content-type"
         """
         # Try to use content-type from headers if available
         content_type = None
-        if 'content-type' in headers:
-            content_type = headers['content-type'].split(";")[0].strip().lower()
+        if "content-type" in headers:
+            content_type = headers["content-type"].split(";")[0].strip().lower()
         # Ouch, this server did not declare what it sent...
         # Let's guess it's JSON...
         # Also, since Autorest was considering that an empty body was a valid JSON,
         # need that test as well....
         else:
             content_type = "application/json"
 
         if body_bytes:
             return cls.deserialize_from_text(body_bytes, content_type)
         return None
 
+
 try:
     basestring  # type: ignore
     unicode_str = unicode  # type: ignore
 except NameError:
-    basestring = str  # type: ignore
-    unicode_str = str  # type: ignore
+    basestring = str
+    unicode_str = str
 
 _LOGGER = logging.getLogger(__name__)
 
 try:
-    _long_type = long   # type: ignore
+    _long_type = long  # type: ignore
 except NameError:
     _long_type = int
 
+
 class UTC(datetime.tzinfo):
     """Time Zone info for handling UTC"""
 
     def utcoffset(self, dt):
         """UTF offset for UTC is 0."""
         return datetime.timedelta(0)
 
@@ -177,165 +196,176 @@
         """Timestamp representation."""
         return "Z"
 
     def dst(self, dt):
         """No daylight saving for UTC."""
         return datetime.timedelta(hours=1)
 
+
 try:
-    from datetime import timezone as _FixedOffset
+    from datetime import timezone as _FixedOffset  # type: ignore
 except ImportError:  # Python 2.7
+
     class _FixedOffset(datetime.tzinfo):  # type: ignore
         """Fixed offset in minutes east from UTC.
         Copy/pasted from Python doc
         :param datetime.timedelta offset: offset in timedelta format
         """
 
         def __init__(self, offset):
             self.__offset = offset
 
         def utcoffset(self, dt):
             return self.__offset
 
         def tzname(self, dt):
-            return str(self.__offset.total_seconds()/3600)
+            return str(self.__offset.total_seconds() / 3600)
 
         def __repr__(self):
             return "<FixedOffset {}>".format(self.tzname(None))
 
         def dst(self, dt):
             return datetime.timedelta(0)
 
         def __getinitargs__(self):
             return (self.__offset,)
 
+
 try:
     from datetime import timezone
-    TZ_UTC = timezone.utc  # type: ignore
+
+    TZ_UTC = timezone.utc
 except ImportError:
     TZ_UTC = UTC()  # type: ignore
 
 _FLATTEN = re.compile(r"(?<!\\)\.")
 
+
 def attribute_transformer(key, attr_desc, value):
     """A key transformer that returns the Python attribute.
 
     :param str key: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: A key using attribute name
     """
     return (key, value)
 
+
 def full_restapi_key_transformer(key, attr_desc, value):
     """A key transformer that returns the full RestAPI key path.
 
     :param str _: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: A list of keys using RestAPI syntax.
     """
-    keys = _FLATTEN.split(attr_desc['key'])
+    keys = _FLATTEN.split(attr_desc["key"])
     return ([_decode_attribute_map_key(k) for k in keys], value)
 
+
 def last_restapi_key_transformer(key, attr_desc, value):
     """A key transformer that returns the last RestAPI key.
 
     :param str key: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: The last RestAPI key.
     """
     key, value = full_restapi_key_transformer(key, attr_desc, value)
     return (key[-1], value)
 
+
 def _create_xml_node(tag, prefix=None, ns=None):
     """Create a XML node."""
     if prefix and ns:
         ET.register_namespace(prefix, ns)
     if ns:
-        return ET.Element("{"+ns+"}"+tag)
+        return ET.Element("{" + ns + "}" + tag)
     else:
         return ET.Element(tag)
 
+
 class Model(object):
     """Mixin for all client request body/response body models to support
     serialization and deserialization.
     """
 
-    _subtype_map = {}  # type: Dict[str, Dict[str, Any]]
-    _attribute_map = {}  # type: Dict[str, Dict[str, Any]]
-    _validation = {}  # type: Dict[str, Dict[str, Any]]
+    _subtype_map: Dict[str, Dict[str, Any]] = {}
+    _attribute_map: Dict[str, Dict[str, Any]] = {}
+    _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
-        cls._attribute_map['additional_properties'] = {'key': '', 'type': '{object}'}
+    def enable_additional_properties_sending(cls) -> None:
+        cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
-            cls._xml_map
+            cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
     def _create_xml_node(cls):
-        """Create XML node.
-        """
+        """Create XML node."""
         try:
-            xml_map = cls._xml_map
+            xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
-        return _create_xml_node(
-            xml_map.get('name', cls.__name__),
-            xml_map.get("prefix", None),
-            xml_map.get("ns", None)
-        )
+        return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[
+            [str, Dict[str, Any], Any], Any
+        ] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -363,169 +393,181 @@
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)
 
     @classmethod
     def _infer_class_models(cls):
         try:
-            str_models = cls.__module__.rsplit('.', 1)[0]
+            str_models = cls.__module__.rsplit(".", 1)[0]
             models = sys.modules[str_models]
             client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
             if cls.__name__ not in client_models:
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = [
-            attribute_key_case_insensitive_extractor,
-            rest_key_case_insensitive_extractor,
-            last_rest_key_case_insensitive_extractor
-        ] if key_extractors is None else key_extractors
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
+                attribute_key_case_insensitive_extractor,
+                rest_key_case_insensitive_extractor,
+                last_rest_key_case_insensitive_extractor,
+            ]
+            if key_extractors is None
+            else key_extractors
+        )
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
     def _flatten_subtype(cls, key, objects):
-        if '_subtype_map' not in cls.__dict__:
+        if "_subtype_map" not in cls.__dict__:
             return {}
         result = dict(cls._subtype_map[key])
         for valuetype in cls._subtype_map[key].values():
             result.update(objects[valuetype]._flatten_subtype(key, objects))
         return result
 
     @classmethod
     def _classify(cls, response, objects):
         """Check the class _subtype_map for any child classes.
         We want to ignore any inherited _subtype_maps.
         Remove the polymorphic key from the initial data.
         """
-        for subtype_key in cls.__dict__.get('_subtype_map', {}).keys():
+        for subtype_key in cls.__dict__.get("_subtype_map", {}).keys():
             subtype_value = None
 
             if not isinstance(response, ET.Element):
                 rest_api_response_key = cls._get_rest_key_parts(subtype_key)[-1]
                 subtype_value = response.pop(rest_api_response_key, None) or response.pop(subtype_key, None)
             else:
-                subtype_value = xml_key_extractor(
-                    subtype_key,
-                    cls._attribute_map[subtype_key],
-                    response
-                )
+                subtype_value = xml_key_extractor(subtype_key, cls._attribute_map[subtype_key], response)
             if subtype_value:
                 # Try to match base class. Can be class name only
                 # (bug to fix in Autorest to support x-ms-discriminator-name)
                 if cls.__name__ == subtype_value:
                     return cls
                 flatten_mapping_type = cls._flatten_subtype(subtype_key, objects)
                 try:
-                    return objects[flatten_mapping_type[subtype_value]]
+                    return objects[flatten_mapping_type[subtype_value]]  # type: ignore
                 except KeyError:
                     _LOGGER.warning(
                         "Subtype value %s has no mapping, use base class %s.",
                         subtype_value,
                         cls.__name__,
                     )
                     break
             else:
-                _LOGGER.warning(
-                    "Discriminator %s is absent or null, use base class %s.",
-                    subtype_key,
-                    cls.__name__
-                )
+                _LOGGER.warning("Discriminator %s is absent or null, use base class %s.", subtype_key, cls.__name__)
                 break
         return cls
 
     @classmethod
     def _get_rest_key_parts(cls, attr_key):
         """Get the RestAPI key of this attr, split it and decode part
         :param str attr_key: Attribute key must be in attribute_map.
         :returns: A list of RestAPI part
         :rtype: list
         """
-        rest_split_key = _FLATTEN.split(cls._attribute_map[attr_key]['key'])
+        rest_split_key = _FLATTEN.split(cls._attribute_map[attr_key]["key"])
         return [_decode_attribute_map_key(key_part) for key_part in rest_split_key]
 
 
 def _decode_attribute_map_key(key):
     """This decode a key in an _attribute_map to the actual key we want to look at
-       inside the received data.
+    inside the received data.
 
-       :param str key: A key string from the generated code
+    :param str key: A key string from the generated code
     """
-    return key.replace('\\.', '.')
+    return key.replace("\\.", ".")
 
 
 class Serializer(object):
     """Request object model serializer."""
 
-    basic_types = {str: 'str', int: 'int', bool: 'bool', float: 'float'}
+    basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
-    _xml_basic_types_serializers = {'bool': lambda x:str(x).lower()}
-    days = {0: "Mon", 1: "Tue", 2: "Wed", 3: "Thu",
-            4: "Fri", 5: "Sat", 6: "Sun"}
-    months = {1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun",
-              7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
+    _xml_basic_types_serializers = {"bool": lambda x: str(x).lower()}
+    days = {0: "Mon", 1: "Tue", 2: "Wed", 3: "Thu", 4: "Fri", 5: "Sat", 6: "Sun"}
+    months = {
+        1: "Jan",
+        2: "Feb",
+        3: "Mar",
+        4: "Apr",
+        5: "May",
+        6: "Jun",
+        7: "Jul",
+        8: "Aug",
+        9: "Sep",
+        10: "Oct",
+        11: "Nov",
+        12: "Dec",
+    }
     validation = {
         "min_length": lambda x, y: len(x) < y,
         "max_length": lambda x, y: len(x) > y,
         "minimum": lambda x, y: x < y,
         "maximum": lambda x, y: x > y,
         "minimum_ex": lambda x, y: x <= y,
         "maximum_ex": lambda x, y: x >= y,
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
-        "multiple": lambda x, y: x % y != 0
-        }
+        "multiple": lambda x, y: x % y != 0,
+    }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]]=None):
         self.serialize_type = {
-            'iso-8601': Serializer.serialize_iso,
-            'rfc-1123': Serializer.serialize_rfc,
-            'unix-time': Serializer.serialize_unix,
-            'duration': Serializer.serialize_duration,
-            'date': Serializer.serialize_date,
-            'time': Serializer.serialize_time,
-            'decimal': Serializer.serialize_decimal,
-            'long': Serializer.serialize_long,
-            'bytearray': Serializer.serialize_bytearray,
-            'base64': Serializer.serialize_base64,
-            'object': self.serialize_object,
-            '[]': self.serialize_iter,
-            '{}': self.serialize_dict
-            }
-        self.dependencies = dict(classes) if classes else {}
+            "iso-8601": Serializer.serialize_iso,
+            "rfc-1123": Serializer.serialize_rfc,
+            "unix-time": Serializer.serialize_unix,
+            "duration": Serializer.serialize_duration,
+            "date": Serializer.serialize_date,
+            "time": Serializer.serialize_time,
+            "decimal": Serializer.serialize_decimal,
+            "long": Serializer.serialize_long,
+            "bytearray": Serializer.serialize_bytearray,
+            "base64": Serializer.serialize_base64,
+            "object": self.serialize_object,
+            "[]": self.serialize_iter,
+            "{}": self.serialize_dict,
+        }
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -538,109 +580,99 @@
         if target_obj is None:
             return None
 
         attr_name = None
         class_name = target_obj.__class__.__name__
 
         if data_type:
-            return self.serialize_data(
-                target_obj, data_type, **kwargs)
+            return self.serialize_data(target_obj, data_type, **kwargs)
 
         if not hasattr(target_obj, "_attribute_map"):
             data_type = type(target_obj).__name__
             if data_type in self.basic_types.values():
-                return self.serialize_data(
-                    target_obj, data_type, **kwargs)
+                return self.serialize_data(target_obj, data_type, **kwargs)
 
         # Force "is_xml" kwargs if we detect a XML model
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             is_xml_model_serialization = kwargs.setdefault("is_xml", target_obj.is_xml_model())
 
         serialized = {}
         if is_xml_model_serialization:
             serialized = target_obj._create_xml_node()
         try:
             attributes = target_obj._attribute_map
             for attr, attr_desc in attributes.items():
                 attr_name = attr
-                if not keep_readonly and target_obj._validation.get(attr_name, {}).get('readonly', False):
+                if not keep_readonly and target_obj._validation.get(attr_name, {}).get("readonly", False):
                     continue
 
-                if attr_name == "additional_properties" and attr_desc["key"] == '':
+                if attr_name == "additional_properties" and attr_desc["key"] == "":
                     if target_obj.additional_properties is not None:
                         serialized.update(target_obj.additional_properties)
                     continue
                 try:
 
                     orig_attr = getattr(target_obj, attr)
                     if is_xml_model_serialization:
-                        pass # Don't provide "transformer" for XML for now. Keep "orig_attr"
-                    else: # JSON
+                        pass  # Don't provide "transformer" for XML for now. Keep "orig_attr"
+                    else:  # JSON
                         keys, orig_attr = key_transformer(attr, attr_desc.copy(), orig_attr)
                         keys = keys if isinstance(keys, list) else [keys]
 
-
                     kwargs["serialization_ctxt"] = attr_desc
-                    new_attr = self.serialize_data(orig_attr, attr_desc['type'], **kwargs)
-
+                    new_attr = self.serialize_data(orig_attr, attr_desc["type"], **kwargs)
 
                     if is_xml_model_serialization:
-                        xml_desc = attr_desc.get('xml', {})
-                        xml_name = xml_desc.get('name', attr_desc['key'])
-                        xml_prefix = xml_desc.get('prefix', None)
-                        xml_ns = xml_desc.get('ns', None)
+                        xml_desc = attr_desc.get("xml", {})
+                        xml_name = xml_desc.get("name", attr_desc["key"])
+                        xml_prefix = xml_desc.get("prefix", None)
+                        xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
                                 xml_name = "{}{}".format(xml_ns, xml_name)
-                            serialized.set(xml_name, new_attr)
+                            serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
-                            serialized.text = new_attr
+                            serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
-                            serialized.extend(new_attr)
+                            serialized.extend(new_attr)  # type: ignore
                         elif isinstance(new_attr, ET.Element):
                             # If the down XML has no XML/Name, we MUST replace the tag with the local tag. But keeping the namespaces.
-                            if 'name' not in getattr(orig_attr, '_xml_map', {}):
+                            if "name" not in getattr(orig_attr, "_xml_map", {}):
                                 splitted_tag = new_attr.tag.split("}")
-                                if len(splitted_tag) == 2: # Namespace
+                                if len(splitted_tag) == 2:  # Namespace
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
-                            serialized.append(new_attr)
+                            serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
-                            local_node = _create_xml_node(
-                                xml_name,
-                                xml_prefix,
-                                xml_ns
-                            )
+                            local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
-                            serialized.append(local_node)
-                    else: # JSON
-                        for k in reversed(keys):
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            serialized.append(local_node)  # type: ignore
+                    else:  # JSON
+                        for k in reversed(keys):  # type: ignore
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
-                        for k in keys:
+                        for k in keys:  # type: ignore
                             if k not in _serialized:
-                                _serialized.update(_new_attr)
-                            _new_attr = _new_attr[k]
+                                _serialized.update(_new_attr)  # type: ignore
+                            _new_attr = _new_attr[k]  # type: ignore
                             _serialized = _serialized[k]
                 except ValueError:
                     continue
 
         except (AttributeError, KeyError, TypeError) as err:
-            msg = "Attribute {} in object {} cannot be serialized.\n{}".format(
-                attr_name, class_name, str(target_obj))
+            msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
             raise_with_traceback(SerializationError, msg, err)
         else:
             return serialized
 
     def body(self, data, data_type, **kwargs):
         """Serialize data intended for a request body.
 
@@ -648,64 +680,63 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip('[]{}')
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
         if internal_data_type and not isinstance(internal_data_type, Enum):
             try:
                 deserializer = Deserializer(self.dependencies)
                 # Since it's on serialization, it's almost sure that format is not JSON REST
                 # We're not able to deal with additional properties for now.
                 deserializer.additional_properties_detection = False
                 if is_xml_model_serialization:
-                    deserializer.key_extractors = [
+                    deserializer.key_extractors = [  # type: ignore
                         attribute_key_case_insensitive_extractor,
                     ]
                 else:
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
-                        last_rest_key_case_insensitive_extractor
+                        last_rest_key_case_insensitive_extractor,
                     ]
                 data = deserializer._deserialize(data_type, data)
             except DeserializationError as err:
-                raise_with_traceback(
-                    SerializationError, "Unable to build a model: "+str(err), err)
+                raise_with_traceback(SerializationError, "Unable to build a model: " + str(err), err)
 
         return self._serialize(data, data_type, **kwargs)
 
     def url(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL path.
 
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :rtype: str
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
 
-            if kwargs.get('skip_quote') is True:
+            if kwargs.get("skip_quote") is True:
                 output = str(output)
             else:
-                output = quote(str(output), safe='')
+                output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return output
 
     def query(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL query.
@@ -716,35 +747,27 @@
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             # Treat the list aside, since we don't want to encode the div separator
             if data_type.startswith("["):
                 internal_data_type = data_type[1:-1]
-                data = [
-                    self.serialize_data(d, internal_data_type, **kwargs) if d is not None else ""
-                    for d
-                    in data
-                ]
-                if not kwargs.get('skip_quote', False):
-                    data = [
-                        quote(str(d), safe='')
-                        for d
-                        in data
-                    ]
+                data = [self.serialize_data(d, internal_data_type, **kwargs) if d is not None else "" for d in data]
+                if not kwargs.get("skip_quote", False):
+                    data = [quote(str(d), safe="") for d in data]
                 return str(self.serialize_iter(data, internal_data_type, **kwargs))
 
             # Not a list, regular serialization
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
-            if kwargs.get('skip_quote') is True:
+            if kwargs.get("skip_quote") is True:
                 output = str(output)
             else:
-                output = quote(str(output), safe='')
+                output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return str(output)
 
     def header(self, name, data, data_type, **kwargs):
         """Serialize data intended for a request header.
@@ -752,19 +775,19 @@
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :rtype: str
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
-            if data_type in ['[str]']:
+            if data_type in ["[str]"]:
                 data = ["" if d is None else d for d in data]
 
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return str(output)
 
     def serialize_data(self, data, data_type, **kwargs):
@@ -778,35 +801,35 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
             # It has to be a subclass of Enum anyway
             enum_type = self.dependencies.get(data_type, data.__class__)
             if issubclass(enum_type, Enum):
                 return Serializer.serialize_enum(data, enum_obj=enum_type)
 
             iter_type = data_type[0] + data_type[-1]
             if iter_type in self.serialize_type:
-                return self.serialize_type[iter_type](
-                    data, data_type[1:-1], **kwargs)
+                return self.serialize_type[iter_type](data, data_type[1:-1], **kwargs)
 
         except (ValueError, TypeError) as err:
             msg = "Unable to serialize value: {!r} as type: {!r}."
-            raise_with_traceback(
-                SerializationError, msg.format(data, data_type), err)
+            raise_with_traceback(SerializationError, msg.format(data, data_type), err)
         else:
             return self._serialize(data, **kwargs)
 
     @classmethod
     def _get_custom_serializers(cls, data_type, **kwargs):
         custom_serializer = kwargs.get("basic_types_serializers", {}).get(data_type)
         if custom_serializer:
@@ -825,15 +848,15 @@
 
         :param data: Object to be serialized.
         :param str data_type: Type of object in the iterable.
         """
         custom_serializer = cls._get_custom_serializers(data_type, **kwargs)
         if custom_serializer:
             return custom_serializer(data)
-        if data_type == 'str':
+        if data_type == "str":
             return cls.serialize_unicode(data)
         return eval(data_type)(data)  # nosec
 
     @classmethod
     def serialize_unicode(cls, data):
         """Special handling for serializing unicode strings in Py2.
         Encode to UTF-8 if unicode, otherwise handle as a str.
@@ -843,15 +866,15 @@
         """
         try:  # If I received an enum, return its value
             return data.value
         except AttributeError:
             pass
 
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 # Don't change it, JSON and XML ElementTree are totally able
                 # to serialize correctly u'' strings
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
@@ -882,45 +905,37 @@
         for d in data:
             try:
                 serialized.append(self.serialize_data(d, iter_type, **kwargs))
             except ValueError:
                 serialized.append(None)
 
         if div:
-            serialized = ['' if s is None else str(s) for s in serialized]
+            serialized = ["" if s is None else str(s) for s in serialized]
             serialized = div.join(serialized)
 
-        if 'xml' in serialization_ctxt or is_xml:
+        if "xml" in serialization_ctxt or is_xml:
             # XML serialization is more complicated
-            xml_desc = serialization_ctxt.get('xml', {})
-            xml_name = xml_desc.get('name')
+            xml_desc = serialization_ctxt.get("xml", {})
+            xml_name = xml_desc.get("name")
             if not xml_name:
-                xml_name = serialization_ctxt['key']
+                xml_name = serialization_ctxt["key"]
 
             # Create a wrap node if necessary (use the fact that Element and list have "append")
             is_wrapped = xml_desc.get("wrapped", False)
             node_name = xml_desc.get("itemsName", xml_name)
             if is_wrapped:
-                final_result = _create_xml_node(
-                    xml_name,
-                    xml_desc.get('prefix', None),
-                    xml_desc.get('ns', None)
-                )
+                final_result = _create_xml_node(xml_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
             else:
                 final_result = []
             # All list elements to "local_node"
             for el in serialized:
                 if isinstance(el, ET.Element):
                     el_node = el
                 else:
-                    el_node = _create_xml_node(
-                        node_name,
-                        xml_desc.get('prefix', None),
-                        xml_desc.get('ns', None)
-                    )
+                    el_node = _create_xml_node(node_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
                     if el is not None:  # Otherwise it writes "None" :-p
                         el_node.text = str(el)
                 final_result.append(el_node)
             return final_result
         return serialized
 
     def serialize_dict(self, attr, dict_type, **kwargs):
@@ -932,29 +947,24 @@
          not be None or empty.
         :rtype: dict
         """
         serialization_ctxt = kwargs.get("serialization_ctxt", {})
         serialized = {}
         for key, value in attr.items():
             try:
-                serialized[self.serialize_unicode(key)] = self.serialize_data(
-                    value, dict_type, **kwargs)
+                serialized[self.serialize_unicode(key)] = self.serialize_data(value, dict_type, **kwargs)
             except ValueError:
                 serialized[self.serialize_unicode(key)] = None
 
-        if 'xml' in serialization_ctxt:
+        if "xml" in serialization_ctxt:
             # XML serialization is more complicated
-            xml_desc = serialization_ctxt['xml']
-            xml_name = xml_desc['name']
+            xml_desc = serialization_ctxt["xml"]
+            xml_name = xml_desc["name"]
 
-            final_result = _create_xml_node(
-                xml_name,
-                xml_desc.get('prefix', None),
-                xml_desc.get('ns', None)
-            )
+            final_result = _create_xml_node(xml_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
             for key, value in serialized.items():
                 ET.SubElement(final_result, key).text = value
             return final_result
 
         return serialized
 
     def serialize_object(self, attr, **kwargs):
@@ -992,42 +1002,40 @@
         elif obj_type in self.dependencies.values() or isinstance(attr, Model):
             return self._serialize(attr)
 
         if obj_type == dict:
             serialized = {}
             for key, value in attr.items():
                 try:
-                    serialized[self.serialize_unicode(key)] = self.serialize_object(
-                        value, **kwargs)
+                    serialized[self.serialize_unicode(key)] = self.serialize_object(value, **kwargs)
                 except ValueError:
                     serialized[self.serialize_unicode(key)] = None
             return serialized
 
         if obj_type == list:
             serialized = []
             for obj in attr:
                 try:
-                    serialized.append(self.serialize_object(
-                        obj, **kwargs))
+                    serialized.append(self.serialize_object(obj, **kwargs))
                 except ValueError:
                     pass
             return serialized
         return str(attr)
 
     @staticmethod
     def serialize_enum(attr, enum_obj=None):
         try:
             result = attr.value
         except AttributeError:
             result = attr
         try:
-            enum_obj(result)
+            enum_obj(result)  # type: ignore
             return result
         except ValueError:
-            for enum_value in enum_obj:
+            for enum_value in enum_obj:  # type: ignore
                 if enum_value.value.lower() == str(attr).lower():
                     return enum_value.value
             error = "{!r} is not valid value for enum {!r}"
             raise SerializationError(error.format(attr, enum_obj))
 
     @staticmethod
     def serialize_bytearray(attr, **kwargs):
@@ -1041,16 +1049,16 @@
     @staticmethod
     def serialize_base64(attr, **kwargs):
         """Serialize str into base-64 string.
 
         :param attr: Object to be serialized.
         :rtype: str
         """
-        encoded = b64encode(attr).decode('ascii')
-        return encoded.strip('=').replace('+', '-').replace('/', '_')
+        encoded = b64encode(attr).decode("ascii")
+        return encoded.strip("=").replace("+", "-").replace("/", "_")
 
     @staticmethod
     def serialize_decimal(attr, **kwargs):
         """Serialize Decimal object to float.
 
         :param attr: Object to be serialized.
         :rtype: float
@@ -1109,50 +1117,53 @@
 
         :param Datetime attr: Object to be serialized.
         :rtype: str
         :raises: TypeError if format invalid.
         """
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             utc = attr.utctimetuple()
         except AttributeError:
             raise TypeError("RFC1123 object must be valid Datetime object.")
 
         return "{}, {:02} {} {:04} {:02}:{:02}:{:02} GMT".format(
-            Serializer.days[utc.tm_wday], utc.tm_mday,
-            Serializer.months[utc.tm_mon], utc.tm_year,
-            utc.tm_hour, utc.tm_min, utc.tm_sec)
+            Serializer.days[utc.tm_wday],
+            utc.tm_mday,
+            Serializer.months[utc.tm_mon],
+            utc.tm_year,
+            utc.tm_hour,
+            utc.tm_min,
+            utc.tm_sec,
+        )
 
     @staticmethod
     def serialize_iso(attr, **kwargs):
         """Serialize Datetime object into ISO-8601 formatted string.
 
         :param Datetime attr: Object to be serialized.
         :rtype: str
         :raises: SerializationError if format invalid.
         """
         if isinstance(attr, str):
             attr = isodate.parse_datetime(attr)
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             utc = attr.utctimetuple()
             if utc.tm_year > 9999 or utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
 
-            microseconds = str(attr.microsecond).rjust(6,'0').rstrip('0').ljust(3, '0')
+            microseconds = str(attr.microsecond).rjust(6, "0").rstrip("0").ljust(3, "0")
             if microseconds:
-                microseconds = '.'+microseconds
+                microseconds = "." + microseconds
             date = "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}".format(
-                utc.tm_year, utc.tm_mon, utc.tm_mday,
-                utc.tm_hour, utc.tm_min, utc.tm_sec)
-            return date + microseconds + 'Z'
+                utc.tm_year, utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec
+            )
+            return date + microseconds + "Z"
         except (ValueError, OverflowError) as err:
             msg = "Unable to serialize datetime object."
             raise_with_traceback(SerializationError, msg, err)
         except AttributeError as err:
             msg = "ISO-8601 object must be valid Datetime object."
             raise_with_traceback(TypeError, msg, err)
 
@@ -1165,124 +1176,130 @@
         :rtype: int
         :raises: SerializationError if format invalid
         """
         if isinstance(attr, int):
             return attr
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             return int(calendar.timegm(attr.utctimetuple()))
         except AttributeError:
             raise TypeError("Unix time object must be valid Datetime object.")
 
+
 def rest_key_extractor(attr, attr_desc, data):
-    key = attr_desc['key']
+    key = attr_desc["key"]
     working_data = data
 
-    while '.' in key:
-        dict_keys = _FLATTEN.split(key)
+    while "." in key:
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
             # https://github.com/Azure/msrest-for-python/issues/197
             return None
-        key = '.'.join(dict_keys[1:])
+        key = ".".join(dict_keys[1:])
 
     return working_data.get(key)
 
+
 def rest_key_case_insensitive_extractor(attr, attr_desc, data):
-    key = attr_desc['key']
+    key = attr_desc["key"]
     working_data = data
 
-    while '.' in key:
+    while "." in key:
         dict_keys = _FLATTEN.split(key)
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = attribute_key_case_insensitive_extractor(working_key, None, working_data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
             # https://github.com/Azure/msrest-for-python/issues/197
             return None
-        key = '.'.join(dict_keys[1:])
+        key = ".".join(dict_keys[1:])
 
     if working_data:
         return attribute_key_case_insensitive_extractor(key, None, working_data)
 
+
 def last_rest_key_extractor(attr, attr_desc, data):
-    """Extract the attribute in "data" based on the last part of the JSON path key.
-    """
-    key = attr_desc['key']
+    """Extract the attribute in "data" based on the last part of the JSON path key."""
+    key = attr_desc["key"]
     dict_keys = _FLATTEN.split(key)
     return attribute_key_extractor(dict_keys[-1], None, data)
 
+
 def last_rest_key_case_insensitive_extractor(attr, attr_desc, data):
     """Extract the attribute in "data" based on the last part of the JSON path key.
 
     This is the case insensitive version of "last_rest_key_extractor"
     """
-    key = attr_desc['key']
+    key = attr_desc["key"]
     dict_keys = _FLATTEN.split(key)
     return attribute_key_case_insensitive_extractor(dict_keys[-1], None, data)
 
+
 def attribute_key_extractor(attr, _, data):
     return data.get(attr)
 
+
 def attribute_key_case_insensitive_extractor(attr, _, data):
     found_key = None
     lower_attr = attr.lower()
     for key in data:
         if lower_attr == key.lower():
             found_key = key
             break
 
     return data.get(found_key)
 
+
 def _extract_name_from_internal_type(internal_type):
     """Given an internal type XML description, extract correct XML name with namespace.
 
     :param dict internal_type: An model type
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
-    xml_name = internal_type_xml_map.get('name', internal_type.__name__)
+    xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
         xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
     # Test if this model is XML ready first
     if not isinstance(data, ET.Element):
         return None
 
-    xml_desc = attr_desc.get('xml', {})
-    xml_name = xml_desc.get('name', attr_desc['key'])
+    xml_desc = attr_desc.get("xml", {})
+    xml_name = xml_desc.get("name", attr_desc["key"])
 
     # Look for a children
-    is_iter_type = attr_desc['type'].startswith("[")
+    is_iter_type = attr_desc["type"].startswith("[")
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
-    xml_ns = xml_desc.get('ns', internal_type_xml_map.get("ns", None))
+    xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
         xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
@@ -1290,91 +1307,88 @@
     if xml_desc.get("text", False):
         return data.text
 
     # Scenario where I take the local name:
     # - Wrapped node
     # - Internal type is an enum (considered basic types)
     # - Internal type has no XML/Name node
-    if is_wrapped or (internal_type and (issubclass(internal_type, Enum) or 'name' not in internal_type_xml_map)):
+    if is_wrapped or (internal_type and (issubclass(internal_type, Enum) or "name" not in internal_type_xml_map)):
         children = data.findall(xml_name)
     # If internal type has a local name and it's not a list, I use that name
-    elif not is_iter_type and internal_type and 'name' in internal_type_xml_map:
+    elif not is_iter_type and internal_type and "name" in internal_type_xml_map:
         xml_name = _extract_name_from_internal_type(internal_type)
         children = data.findall(xml_name)
     # That's an array
     else:
-        if internal_type: # Complex type, ignore itemsName and use the complex type name
+        if internal_type:  # Complex type, ignore itemsName and use the complex type name
             items_name = _extract_name_from_internal_type(internal_type)
         else:
             items_name = xml_desc.get("itemsName", xml_name)
         children = data.findall(items_name)
 
     if len(children) == 0:
         if is_iter_type:
             if is_wrapped:
-                return None # is_wrapped no node, we want None
+                return None  # is_wrapped no node, we want None
             else:
-                return [] # not wrapped, assume empty list
+                return []  # not wrapped, assume empty list
         return None  # Assume it's not there, maybe an optional node.
 
     # If is_iter_type and not wrapped, return all found children
     if is_iter_type:
         if not is_wrapped:
             return children
-        else: # Iter and wrapped, should have found one node only (the wrap one)
+        else:  # Iter and wrapped, should have found one node only (the wrap one)
             if len(children) != 1:
                 raise DeserializationError(
                     "Tried to deserialize an array not wrapped, and found several nodes '{}'. Maybe you should declare this array as wrapped?".format(
                         xml_name
-                    ))
+                    )
+                )
             return list(children[0])  # Might be empty list and that's ok.
 
     # Here it's not a itertype, we should have found one element only or empty
     if len(children) > 1:
         raise DeserializationError("Find several XML '{}' where it was not expected".format(xml_name))
     return children[0]
 
+
 class Deserializer(object):
     """Response object model deserializer.
 
     :param dict classes: Class type dictionary for deserializing complex types.
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
-    basic_types = {str: 'str', int: 'int', bool: 'bool', float: 'float'}
+    basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
-    valid_date = re.compile(
-        r'\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}'
-        r'\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?')
+    valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]]=None):
         self.deserialize_type = {
-            'iso-8601': Deserializer.deserialize_iso,
-            'rfc-1123': Deserializer.deserialize_rfc,
-            'unix-time': Deserializer.deserialize_unix,
-            'duration': Deserializer.deserialize_duration,
-            'date': Deserializer.deserialize_date,
-            'time': Deserializer.deserialize_time,
-            'decimal': Deserializer.deserialize_decimal,
-            'long': Deserializer.deserialize_long,
-            'bytearray': Deserializer.deserialize_bytearray,
-            'base64': Deserializer.deserialize_base64,
-            'object': self.deserialize_object,
-            '[]': self.deserialize_iter,
-            '{}': self.deserialize_dict
-            }
+            "iso-8601": Deserializer.deserialize_iso,
+            "rfc-1123": Deserializer.deserialize_rfc,
+            "unix-time": Deserializer.deserialize_unix,
+            "duration": Deserializer.deserialize_duration,
+            "date": Deserializer.deserialize_date,
+            "time": Deserializer.deserialize_time,
+            "decimal": Deserializer.deserialize_decimal,
+            "long": Deserializer.deserialize_long,
+            "bytearray": Deserializer.deserialize_bytearray,
+            "base64": Deserializer.deserialize_base64,
+            "object": self.deserialize_object,
+            "[]": self.deserialize_iter,
+            "{}": self.deserialize_dict,
+        }
         self.deserialize_expected_types = {
-            'duration': (isodate.Duration, datetime.timedelta),
-            'iso-8601': (datetime.datetime)
+            "duration": (isodate.Duration, datetime.timedelta),
+            "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
-        self.key_extractors = [
-            rest_key_extractor,
-            xml_key_extractor
-        ]
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
         self.additional_properties_detection = True
@@ -1399,138 +1413,132 @@
         :param str target_obj: Target data type to deserialize to.
         :param object data: Object to deserialize.
         :raises: DeserializationError if deserialization fails.
         :return: Deserialized object.
         """
         # This is already a model, go recursive just in case
         if hasattr(data, "_attribute_map"):
-            constants = [name for name, config in getattr(data, '_validation', {}).items()
-                         if config.get('constant')]
+            constants = [name for name, config in getattr(data, "_validation", {}).items() if config.get("constant")]
             try:
                 for attr, mapconfig in data._attribute_map.items():
                     if attr in constants:
                         continue
                     value = getattr(data, attr)
                     if value is None:
                         continue
-                    local_type = mapconfig['type']
-                    internal_data_type = local_type.strip('[]{}')
+                    local_type = mapconfig["type"]
+                    internal_data_type = local_type.strip("[]{}")
                     if internal_data_type not in self.dependencies or isinstance(internal_data_type, Enum):
                         continue
-                    setattr(
-                        data,
-                        attr,
-                        self._deserialize(local_type, value)
-                    )
+                    setattr(data, attr, self._deserialize(local_type, value))
                 return data
             except AttributeError:
                 return
 
         response, class_name = self._classify_target(target_obj, data)
 
         if isinstance(response, basestring):
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
-            attributes = response._attribute_map
+            attributes = response._attribute_map  # type: ignore
             d_attrs = {}
             for attr, attr_desc in attributes.items():
                 # Check empty string. If it's not empty, someone has a real "additionalProperties"...
-                if attr == "additional_properties" and attr_desc["key"] == '':
+                if attr == "additional_properties" and attr_desc["key"] == "":
                     continue
                 raw_value = None
                 # Enhance attr_desc with some dynamic data
-                attr_desc = attr_desc.copy() # Do a copy, do not change the real one
-                internal_data_type = attr_desc["type"].strip('[]{}')
+                attr_desc = attr_desc.copy()  # Do a copy, do not change the real one
+                internal_data_type = attr_desc["type"].strip("[]{}")
                 if internal_data_type in self.dependencies:
                     attr_desc["internalType"] = self.dependencies[internal_data_type]
 
                 for key_extractor in self.key_extractors:
                     found_value = key_extractor(attr, attr_desc, data)
                     if found_value is not None:
                         if raw_value is not None and raw_value != found_value:
-                            msg = ("Ignoring extracted value '%s' from %s for key '%s'"
-                                   " (duplicate extraction, follow extractors order)" )
-                            _LOGGER.warning(
-                                msg,
-                                found_value,
-                                key_extractor,
-                                attr
+                            msg = (
+                                "Ignoring extracted value '%s' from %s for key '%s'"
+                                " (duplicate extraction, follow extractors order)"
                             )
+                            _LOGGER.warning(msg, found_value, key_extractor, attr)
                             continue
                         raw_value = found_value
 
-                value = self.deserialize_data(raw_value, attr_desc['type'])
+                value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
-            msg = "Unable to deserialize to object: " + class_name
+            msg = "Unable to deserialize to object: " + class_name  # type: ignore
             raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
             return None
-        if "additional_properties" in attribute_map and attribute_map.get("additional_properties", {}).get("key") != '':
+        if "additional_properties" in attribute_map and attribute_map.get("additional_properties", {}).get("key") != "":
             # Check empty string. If it's not empty, someone has a real "additionalProperties"
             return None
         if isinstance(data, ET.Element):
             data = {el.tag: el.text for el in data}
 
-        known_keys = {_decode_attribute_map_key(_FLATTEN.split(desc['key'])[0])
-                      for desc in attribute_map.values() if desc['key'] != ''}
+        known_keys = {
+            _decode_attribute_map_key(_FLATTEN.split(desc["key"])[0])
+            for desc in attribute_map.values()
+            if desc["key"] != ""
+        }
         present_keys = set(data.keys())
         missing_keys = present_keys - known_keys
         return {key: data[key] for key in missing_keys}
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
-                "Ran into a deserialization error. Ignoring since this is failsafe deserialization",
-				exc_info=True
+                "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
             )
             return None
 
     @staticmethod
     def _unpack_content(raw_data, content_type=None):
         """Extract the correct structure for deserialization.
 
@@ -1550,56 +1558,46 @@
         # Assume this is enough to detect a Pipeline Response without importing it
         context = getattr(raw_data, "context", {})
         if context:
             if RawDeserializer.CONTEXT_NAME in context:
                 return context[RawDeserializer.CONTEXT_NAME]
             raise ValueError("This pipeline didn't have the RawDeserializer policy; can't deserialize")
 
-        #Assume this is enough to recognize universal_http.ClientResponse without importing it
+        # Assume this is enough to recognize universal_http.ClientResponse without importing it
         if hasattr(raw_data, "body"):
-            return RawDeserializer.deserialize_from_http_generics(
-                raw_data.text(),
-                raw_data.headers
-            )
+            return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
-        if hasattr(raw_data, '_content_consumed'):
-            return RawDeserializer.deserialize_from_http_generics(
-                raw_data.text,
-                raw_data.headers
-            )
+        if hasattr(raw_data, "_content_consumed"):
+            return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
-        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, 'read'):
-            return RawDeserializer.deserialize_from_text(raw_data, content_type)
+        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
+            return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
         :param d_attrs: The deserialized response attributes.
         """
         if callable(response):
-            subtype = getattr(response, '_subtype_map', {})
+            subtype = getattr(response, "_subtype_map", {})
             try:
-                readonly = [k for k, v in response._validation.items()
-                            if v.get('readonly')]
-                const = [k for k, v in response._validation.items()
-                         if v.get('constant')]
-                kwargs = {k: v for k, v in attrs.items()
-                          if k not in subtype and k not in readonly + const}
+                readonly = [k for k, v in response._validation.items() if v.get("readonly")]
+                const = [k for k, v in response._validation.items() if v.get("constant")]
+                kwargs = {k: v for k, v in attrs.items() if k not in subtype and k not in readonly + const}
                 response_obj = response(**kwargs)
                 for attr in readonly:
                     setattr(response_obj, attr, attrs.get(attr))
                 if additional_properties:
                     response_obj.additional_properties = additional_properties
                 return response_obj
             except TypeError as err:
-                msg = "Unable to deserialize {} into model {}. ".format(
-                    kwargs, response)
+                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)  # type: ignore
                 raise DeserializationError(msg + str(err))
         else:
             try:
                 for attr, value in attrs.items():
                     setattr(response, attr, value)
                 return response
             except Exception as exp:
@@ -1655,33 +1653,30 @@
 
         :param list attr: Iterable to be deserialized.
         :param str iter_type: The type of object in the iterable.
         :rtype: list
         """
         if attr is None:
             return None
-        if isinstance(attr, ET.Element): # If I receive an element here, get the children
+        if isinstance(attr, ET.Element):  # If I receive an element here, get the children
             attr = list(attr)
         if not isinstance(attr, (list, set)):
-            raise DeserializationError("Cannot deserialize as [{}] an object of type {}".format(
-                iter_type,
-                type(attr)
-            ))
+            raise DeserializationError("Cannot deserialize as [{}] an object of type {}".format(iter_type, type(attr)))
         return [self.deserialize_data(a, iter_type) for a in attr]
 
     def deserialize_dict(self, attr, dict_type):
         """Deserialize a dictionary.
 
         :param dict/list attr: Dictionary to be deserialized. Also accepts
          a list of key, value pairs.
         :param str dict_type: The object type of the items in the dictionary.
         :rtype: dict
         """
         if isinstance(attr, list):
-            return {x['key']: self.deserialize_data(x['value'], dict_type) for x in attr}
+            return {x["key"]: self.deserialize_data(x["value"], dict_type) for x in attr}
 
         if isinstance(attr, ET.Element):
             # Transform <Key>value</Key> into {"Key": "value"}
             attr = {el.tag: el.text for el in attr}
         return {k: self.deserialize_data(v, dict_type) for k, v in attr.items()}
 
     def deserialize_object(self, attr, **kwargs):
@@ -1694,37 +1689,35 @@
         """
         if attr is None:
             return None
         if isinstance(attr, ET.Element):
             # Do no recurse on XML, just return the tree as-is
             return attr
         if isinstance(attr, basestring):
-            return self.deserialize_basic(attr, 'str')
+            return self.deserialize_basic(attr, "str")
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.deserialize_basic(attr, self.basic_types[obj_type])
         if obj_type is _long_type:
             return self.deserialize_long(attr)
 
         if obj_type == dict:
             deserialized = {}
             for key, value in attr.items():
                 try:
-                    deserialized[key] = self.deserialize_object(
-                        value, **kwargs)
+                    deserialized[key] = self.deserialize_object(value, **kwargs)
                 except ValueError:
                     deserialized[key] = None
             return deserialized
 
         if obj_type == list:
             deserialized = []
             for obj in attr:
                 try:
-                    deserialized.append(self.deserialize_object(
-                        obj, **kwargs))
+                    deserialized.append(self.deserialize_object(obj, **kwargs))
                 except ValueError:
                     pass
             return deserialized
 
         else:
             error = "Cannot deserialize generic object with type: "
             raise TypeError(error + str(obj_type))
@@ -1743,31 +1736,31 @@
         # If we're here, data is supposed to be a basic type.
         # If it's still an XML node, take the text
         if isinstance(attr, ET.Element):
             attr = attr.text
             if not attr:
                 if data_type == "str":
                     # None or '', node <a/> is empty string.
-                    return ''
+                    return ""
                 else:
                     # None or '', node <a/> with a strong type is None.
                     # Don't try to model "empty bool" or "empty int"
                     return None
 
-        if data_type == 'bool':
+        if data_type == "bool":
             if attr in [True, False, 1, 0]:
                 return bool(attr)
             elif isinstance(attr, basestring):
-                if attr.lower() in ['true', '1']:
+                if attr.lower() in ["true", "1"]:
                     return True
-                elif attr.lower() in ['false', '0']:
+                elif attr.lower() in ["false", "0"]:
                     return False
             raise TypeError("Invalid boolean value: {}".format(attr))
 
-        if data_type == 'str':
+        if data_type == "str":
             return self.deserialize_unicode(attr)
         return eval(data_type)(attr)  # nosec
 
     @staticmethod
     def deserialize_unicode(data):
         """Preserve unicode objects in Python 2, otherwise return data
         as a string.
@@ -1778,15 +1771,15 @@
         # We might be here because we have an enum modeled as string,
         # and we try to deserialize a partial dict with enum inside
         if isinstance(data, Enum):
             return data
 
         # Consider this is real string
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
 
     @staticmethod
@@ -1829,72 +1822,72 @@
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return bytearray(b64decode(attr))
+        return bytearray(b64decode(attr))  # type: ignore
 
     @staticmethod
     def deserialize_base64(attr):
         """Deserialize base64 encoded string into string.
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        padding = '=' * (3 - (len(attr) + 3) % 4)
-        attr = attr + padding
-        encoded = attr.replace('-', '+').replace('_', '/')
+        padding = "=" * (3 - (len(attr) + 3) % 4)  # type: ignore
+        attr = attr + padding  # type: ignore
+        encoded = attr.replace("-", "+").replace("_", "/")
         return b64decode(encoded)
 
     @staticmethod
     def deserialize_decimal(attr):
         """Deserialize string into Decimal object.
 
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)
+            return decimal.Decimal(attr)  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
             raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
         :raises: ValueError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return _long_type(attr)
+        return _long_type(attr)  # type: ignore
 
     @staticmethod
     def deserialize_duration(attr):
         """Deserialize ISO-8601 formatted string into TimeDelta object.
 
         :param str attr: response string to be deserialized.
         :rtype: TimeDelta
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
             duration = isodate.parse_duration(attr)
-        except(ValueError, OverflowError, AttributeError) as err:
+        except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize duration object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return duration
 
     @staticmethod
     def deserialize_date(attr):
@@ -1902,48 +1895,47 @@
 
         :param str attr: response string to be deserialized.
         :rtype: Date
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
         return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         return isodate.parse_time(attr)
 
     @staticmethod
     def deserialize_rfc(attr):
         """Deserialize RFC-1123 formatted string into Datetime object.
 
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            parsed_date = email.utils.parsedate_tz(attr)
+            parsed_date = email.utils.parsedate_tz(attr)  # type: ignore
             date_obj = datetime.datetime(
-                *parsed_date[:6],
-                tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0)/60))
+                *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
@@ -1956,35 +1948,35 @@
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            attr = attr.upper()
+            attr = attr.upper()  # type: ignore
             match = Deserializer.valid_date.match(attr)
             if not match:
                 raise ValueError("Invalid datetime string: " + attr)
 
-            check_decimal = attr.split('.')
+            check_decimal = attr.split(".")
             if len(check_decimal) > 1:
                 decimal_str = ""
                 for digit in check_decimal[1]:
                     if digit.isdigit():
                         decimal_str += digit
                     else:
                         break
                 if len(decimal_str) > 6:
                     attr = attr.replace(decimal_str, decimal_str[0:6])
 
             date_obj = isodate.parse_datetime(attr)
             test_utc = date_obj.utctimetuple()
             if test_utc.tm_year > 9999 or test_utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
-        except(ValueError, OverflowError, AttributeError) as err:
+        except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
 
     @staticmethod
     def deserialize_unix(attr):
@@ -1992,15 +1984,15 @@
         This is represented as seconds.
 
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
-            attr = int(attr.text)
+            attr = int(attr.text)  # type: ignore
         try:
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/_operations_mixin.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_operations_mixin.py`

 * *Files 2% similar despite different names*

```diff
@@ -75,30 +75,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupKeyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.BackupKeyResult
+        :rtype: ~azure.keyvault.v7_4.models.BackupKeyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('backup_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'backup_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -188,16 +188,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateOperation
@@ -235,38 +235,38 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters or IO
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('create_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'create_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -296,38 +296,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('decrypt')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'decrypt'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -493,30 +493,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to delete. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('delete_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'delete_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -651,38 +651,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('encrypt')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'encrypt'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -809,16 +809,21 @@
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -922,16 +927,21 @@
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_certificate_versions')
@@ -959,16 +969,21 @@
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_certificates')
@@ -1035,16 +1050,21 @@
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1078,30 +1098,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_deleted_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1126,30 +1146,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.DeletedKeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_deleted_keys')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_deleted_keys'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1206,16 +1226,21 @@
         The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSasDefinitionItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedSasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1278,16 +1303,21 @@
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_deleted_secrets')
@@ -1349,16 +1379,21 @@
         """Lists deleted storage accounts for the specified vault.
 
         The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedStorageAccountItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedStorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1394,30 +1429,30 @@
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key. This
          URI fragment is optional. If not specified, the latest version of the key is returned.
          Required.
         :type key_version: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1438,22 +1473,22 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in a given key vault. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key_rotation_policy')
         if api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key_rotation_policy'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1478,30 +1513,30 @@
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key_versions')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key_versions'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1525,30 +1560,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_keys')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_keys'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1564,30 +1599,30 @@
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest or IO
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_random_bytes')
         if api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_random_bytes'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1642,16 +1677,21 @@
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_sas_definitions')
@@ -1721,16 +1761,21 @@
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_secret_versions')
@@ -1759,16 +1804,21 @@
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_secrets')
@@ -1828,16 +1878,21 @@
         **kwargs: Any
     ) -> Iterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_storage_accounts')
@@ -1870,16 +1925,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -1917,38 +1972,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters or IO
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('import_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'import_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1969,16 +2024,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -2065,16 +2120,16 @@
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'purge_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2207,30 +2262,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the deleted key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('recover_deleted_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'recover_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2357,16 +2412,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -2404,30 +2459,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters or IO
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('release')
         if api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'release'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2444,16 +2499,16 @@
         """Restores a backed up certificate to a vault.
 
         Restores a backed up certificate, and all its versions, to a vault. This operation requires the
         certificates/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to restore the certificate. Is either a
+         CertificateRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -2490,38 +2545,38 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters or IO
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('restore_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'restore_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2538,16 +2593,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2578,16 +2633,16 @@
         """Restores a backed up storage account to a vault.
 
         Restores a backed up storage account to a vault. This operation requires the storage/restore
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the storage account. Is either a model type or a
-         IO type. Required.
+        :param parameters: The parameters to restore the storage account. Is either a
+         StorageRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -2622,22 +2677,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to be rotated. The system will generate a new version in the
          specified key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('rotate_key')
         if api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'rotate_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2654,15 +2709,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v2016_10_01.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -2697,16 +2752,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -2741,16 +2796,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -2785,16 +2840,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2825,16 +2880,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -2872,38 +2927,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters or IO
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('sign')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'sign'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2928,38 +2983,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('unwrap_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'unwrap_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2983,16 +3038,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -3026,16 +3081,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -3069,16 +3124,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation:
          ~azure.keyvault.v2016_10_01.models.CertificateOperationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -3113,16 +3168,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
@@ -3161,38 +3216,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters or IO
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('update_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'update_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3212,30 +3267,30 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy or IO
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('update_key_rotation_policy')
         if api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'update_key_rotation_policy'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3256,16 +3311,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -3303,16 +3358,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -3344,16 +3399,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -3393,38 +3448,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters or IO
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('verify')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'verify'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3451,38 +3506,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('wrap_key')
         if api_version == '2016-10-01':
             from .v2016_10_01.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from .v7_0.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from .v7_1.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'wrap_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,26 +29,23 @@
     :keyword api_version: Api Version. Default value is "7.0". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.0")  # type: Literal["7.0"]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", "7.0")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_key_vault_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -26,17 +26,17 @@
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -67,25 +67,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -94,50 +94,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -146,49 +146,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -197,15 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -218,40 +218,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -264,26 +264,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -292,26 +292,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -320,26 +320,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -348,26 +348,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -376,26 +376,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -404,26 +404,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -432,15 +432,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -453,97 +453,97 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -552,50 +552,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/{secret-version}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
         "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -604,40 +604,40 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/{secret-version}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
         "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets")
 
     # Construct parameters
     if maxresults is not None:
@@ -652,24 +652,24 @@
 
 def build_get_secret_versions_request(
     secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/versions")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -678,15 +678,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets")
 
     # Construct parameters
     if maxresults is not None:
@@ -699,112 +699,112 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}/recover")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/backup")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_secret_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -819,15 +819,15 @@
 
 def build_get_certificates_request(
     *, maxresults: Optional[int] = None, include_pending: Optional[bool] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates")
 
     # Construct parameters
     if maxresults is not None:
@@ -842,40 +842,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -888,15 +888,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -907,15 +907,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -926,15 +926,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_issuers_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers")
 
     # Construct parameters
     if maxresults is not None:
@@ -947,25 +947,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -974,25 +974,25 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1001,73 +1001,73 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/create")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1076,25 +1076,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/import")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1105,24 +1105,24 @@
 
 def build_get_certificate_versions_request(
     certificate_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/versions")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -1131,49 +1131,49 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/policy")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/policy")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1182,26 +1182,26 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_request(certificate_name: str, certificate_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/{certificate-version}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
         "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1210,50 +1210,50 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_request(certificate_name: str, certificate_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/{certificate-version}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
         "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1262,73 +1262,73 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_merge_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending/merge")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1337,40 +1337,40 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/backup")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_certificate_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -1385,15 +1385,15 @@
 
 def build_get_deleted_certificates_request(
     *, maxresults: Optional[int] = None, include_pending: Optional[bool] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates")
 
     # Construct parameters
     if maxresults is not None:
@@ -1408,87 +1408,87 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}/recover")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_storage_accounts_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage")
 
     # Construct parameters
     if maxresults is not None:
@@ -1501,15 +1501,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_storage_accounts_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage")
 
     # Construct parameters
     if maxresults is not None:
@@ -1522,118 +1522,118 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}/recover")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/backup")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url("storage_account_name", storage_account_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_storage_account_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -1646,79 +1646,79 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1727,27 +1727,27 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1756,27 +1756,27 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_regenerate_storage_account_key_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/regeneratekey")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1787,26 +1787,26 @@
 
 def build_get_sas_definitions_request(
     storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -1817,26 +1817,26 @@
 
 def build_get_deleted_sas_definitions_request(
     storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}/sas")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -1847,29 +1847,29 @@
 
 def build_get_deleted_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -1878,29 +1878,29 @@
 
 def build_recover_deleted_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -1909,88 +1909,88 @@
 
 def build_delete_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_sas_definition_request(storage_account_name: str, sas_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_sas_definition_request(storage_account_name: str, sas_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -2001,30 +2001,30 @@
 
 def build_update_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -2109,16 +2109,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -2131,17 +2131,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2157,17 +2157,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2177,15 +2177,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -2258,16 +2258,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -2280,17 +2280,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2306,17 +2306,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2326,15 +2326,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -2357,31 +2357,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2391,15 +2391,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2485,16 +2485,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -2507,17 +2507,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2534,17 +2534,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2554,15 +2554,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -2587,32 +2587,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2622,42 +2622,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2674,15 +2679,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2693,70 +2698,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2772,15 +2782,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2791,43 +2801,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -2857,31 +2867,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2891,15 +2901,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -2977,16 +2987,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -2999,17 +3009,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3024,17 +3034,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3044,15 +3054,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3150,16 +3160,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -3172,17 +3182,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3199,17 +3209,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3219,15 +3229,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3319,16 +3329,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -3341,17 +3351,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3368,17 +3378,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3388,15 +3398,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3479,16 +3489,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -3501,17 +3511,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3528,17 +3538,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3548,15 +3558,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3645,16 +3655,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyVerifyResult
@@ -3667,17 +3677,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3694,17 +3704,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3714,15 +3724,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3814,16 +3824,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -3836,17 +3846,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3863,17 +3873,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3883,15 +3893,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3977,16 +3987,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -3999,17 +4009,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4026,17 +4036,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4046,15 +4056,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -4062,27 +4072,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4098,15 +4113,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4117,43 +4132,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -4175,31 +4190,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4209,15 +4224,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -4241,45 +4256,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -4302,31 +4317,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4336,15 +4351,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @overload
     def set_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         parameters: _models.SecretSetParameters,
@@ -4414,16 +4429,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -4436,17 +4451,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4462,17 +4477,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4482,15 +4497,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    set_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @distributed_trace
     def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Deletes a secret from a specified key vault.
 
         The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
         to an individual version of a secret. This operation requires the secrets/delete permission.
@@ -4511,31 +4526,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_delete_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.delete_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4545,15 +4560,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    delete_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @overload
     def update_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         secret_version: str,
@@ -4636,16 +4651,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -4658,17 +4673,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4685,17 +4700,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4705,15 +4720,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secret(
         self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Get a specified secret from a given key vault.
 
@@ -4739,32 +4754,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_secret_request(
             secret_name=secret_name,
             secret_version=secret_version,
             api_version=api_version,
             template_url=self.get_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4774,41 +4789,46 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SecretItem"]:
         """List secrets in a specified key vault.
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4824,15 +4844,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4843,70 +4863,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_secrets.metadata = {"url": "/secrets"}  # type: ignore
+    get_secrets.metadata = {"url": "/secrets"}
 
     @distributed_trace
     def get_secret_versions(
         self, vault_base_url: str, secret_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SecretItem"]:
         """List all versions of the specified secret.
 
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4923,15 +4948,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4942,68 +4967,73 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}  # type: ignore
+    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}
 
     @distributed_trace
     def get_deleted_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedSecretItem"]:
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5019,15 +5049,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5038,43 +5068,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}  # type: ignore
+    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}
 
     @distributed_trace
     def get_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Gets the specified deleted secret.
 
         The Get Deleted Secret operation returns the specified deleted secret along with its
         attributes. This operation requires the secrets/get permission.
@@ -5095,31 +5125,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.get_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5129,15 +5159,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace
     def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified secret.
 
@@ -5161,45 +5191,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.purge_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace
     def recover_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.SecretBundle:
         """Recovers the deleted secret to the latest version.
 
         Recovers the deleted secret in the specified vault. This operation can only be performed on a
         soft-delete enabled vault. This operation requires the secrets/recover permission.
@@ -5220,31 +5250,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.recover_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5254,15 +5284,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}  # type: ignore
+    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}
 
     @distributed_trace
     def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.BackupSecretResult:
         """Backs up the specified secret.
 
         Requests that a backup of the specified secret be downloaded to the client. All versions of the
         secret will be downloaded. This operation requires the secrets/backup permission.
@@ -5283,31 +5313,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupSecretResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupSecretResult] = kwargs.pop("cls", None)
 
         request = build_backup_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.backup_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5317,15 +5347,15 @@
         deserialized = self._deserialize("BackupSecretResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}  # type: ignore
+    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}
 
     @overload
     def restore_secret(
         self,
         vault_base_url: str,
         parameters: _models.SecretRestoreParameters,
         *,
@@ -5379,16 +5409,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -5401,17 +5431,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5426,17 +5456,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5446,15 +5476,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_secret.metadata = {"url": "/secrets/restore"}  # type: ignore
+    restore_secret.metadata = {"url": "/secrets/restore"}
 
     @distributed_trace
     def get_certificates(
         self,
         vault_base_url: str,
         maxresults: Optional[int] = None,
         include_pending: Optional[bool] = None,
@@ -5463,30 +5493,35 @@
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :param include_pending: Specifies whether to include certificates which are not completely
          provisioned. Default value is None.
         :type include_pending: bool
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5503,15 +5538,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5522,43 +5557,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificates.metadata = {"url": "/certificates"}  # type: ignore
+    get_certificates.metadata = {"url": "/certificates"}
 
     @distributed_trace
     def delete_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Deletes a certificate from a specified key vault.
 
@@ -5582,31 +5617,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5616,15 +5651,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}  # type: ignore
+    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}
 
     @overload
     def set_certificate_contacts(
         self, vault_base_url: str, contacts: _models.Contacts, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Contacts:
         """Sets the certificate contacts for the specified key vault.
 
@@ -5673,15 +5708,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v7_0.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -5695,17 +5730,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(contacts, (IO, bytes)):
             _content = contacts
         else:
@@ -5720,17 +5755,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5740,15 +5775,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Lists the certificate contacts for a specified key vault.
 
         The GetCertificateContacts operation returns the set of certificate contact resources in the
         specified key vault. This operation requires the certificates/managecontacts permission.
@@ -5767,30 +5802,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_get_certificate_contacts_request(
             api_version=api_version,
             template_url=self.get_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5800,15 +5835,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def delete_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Deletes the certificate contacts for a specified key vault.
 
         Deletes the certificate contacts for a specified key vault certificate. This operation requires
         the certificates/managecontacts permission.
@@ -5827,30 +5862,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_contacts_request(
             api_version=api_version,
             template_url=self.delete_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5860,42 +5895,47 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_issuers(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.CertificateIssuerItem"]:
         """List certificate issuers for a specified key vault.
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateIssuerListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateIssuerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5911,15 +5951,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5930,43 +5970,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateIssuerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}  # type: ignore
+    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}
 
     @overload
     def set_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerSetParameters,
@@ -6037,16 +6077,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v7_0.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.IssuerBundle
@@ -6059,17 +6099,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -6085,17 +6125,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6105,15 +6145,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     def update_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerUpdateParameters,
@@ -6184,16 +6224,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v7_0.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.IssuerBundle
@@ -6206,17 +6246,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -6232,17 +6272,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6252,15 +6292,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace
     def get_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> _models.IssuerBundle:
         """Lists the specified certificate issuer.
 
         The GetCertificateIssuer operation returns the specified certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
@@ -6282,31 +6322,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.get_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6316,15 +6356,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace
     def delete_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> _models.IssuerBundle:
         """Deletes the specified certificate issuer.
 
         The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from
         the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
@@ -6345,31 +6385,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.delete_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6379,15 +6419,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     def create_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateCreateParameters,
@@ -6458,16 +6498,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateOperation
@@ -6480,17 +6520,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6506,17 +6546,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6526,15 +6566,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}  # type: ignore
+    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}
 
     @overload
     def import_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateImportParameters,
@@ -6611,16 +6651,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -6633,17 +6673,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6659,17 +6699,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6679,42 +6719,47 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}  # type: ignore
+    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}
 
     @distributed_trace
     def get_certificate_versions(
         self, vault_base_url: str, certificate_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.CertificateItem"]:
         """List the versions of a certificate.
 
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6731,15 +6776,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6750,43 +6795,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}  # type: ignore
+    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}
 
     @distributed_trace
     def get_certificate_policy(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificatePolicy:
         """Lists the policy for a certificate.
 
@@ -6809,31 +6854,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         request = build_get_certificate_policy_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6843,15 +6888,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     def update_certificate_policy(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_policy: _models.CertificatePolicy,
@@ -6922,16 +6967,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v7_0.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificatePolicy
@@ -6944,17 +6989,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_policy, (IO, bytes)):
             _content = certificate_policy
         else:
@@ -6970,17 +7015,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6990,15 +7035,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     def update_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_version: str,
@@ -7081,16 +7126,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -7103,17 +7148,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7130,17 +7175,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7150,15 +7195,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @distributed_trace
     def get_certificate(
         self, vault_base_url: str, certificate_name: str, certificate_version: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Gets information about a certificate.
 
@@ -7184,32 +7229,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_request(
             certificate_name=certificate_name,
             certificate_version=certificate_version,
             api_version=api_version,
             template_url=self.get_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7219,15 +7264,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @overload
     def update_certificate_operation(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_operation: _models.CertificateOperationUpdateParameter,
@@ -7298,16 +7343,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation: ~azure.keyvault.v7_0.models.CertificateOperationUpdateParameter or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -7321,17 +7366,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_operation, (IO, bytes)):
             _content = certificate_operation
         else:
@@ -7347,17 +7392,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7367,15 +7412,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace
     def get_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Gets the creation operation of a certificate.
 
@@ -7398,31 +7443,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_get_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7432,15 +7477,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace
     def delete_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Deletes the creation operation for a specific certificate.
 
@@ -7464,31 +7509,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7498,15 +7543,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @overload
     def merge_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateMergeParameters,
@@ -7580,16 +7625,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -7602,17 +7647,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7628,17 +7673,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7648,15 +7693,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}  # type: ignore
+    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}
 
     @distributed_trace
     def backup_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.BackupCertificateResult:
         """Backs up the specified certificate.
 
@@ -7680,31 +7725,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupCertificateResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupCertificateResult] = kwargs.pop("cls", None)
 
         request = build_backup_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.backup_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7714,15 +7759,15 @@
         deserialized = self._deserialize("BackupCertificateResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_certificate.metadata = {"url": "/certificates/{certificate-name}/backup"}  # type: ignore
+    backup_certificate.metadata = {"url": "/certificates/{certificate-name}/backup"}
 
     @overload
     def restore_certificate(
         self,
         vault_base_url: str,
         parameters: _models.CertificateRestoreParameters,
         *,
@@ -7776,16 +7821,16 @@
         """Restores a backed up certificate to a vault.
 
         Restores a backed up certificate, and all its versions, to a vault. This operation requires the
         certificates/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to restore the certificate. Is either a
+         CertificateRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -7798,17 +7843,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7823,17 +7868,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7843,15 +7888,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_certificate.metadata = {"url": "/certificates/restore"}  # type: ignore
+    restore_certificate.metadata = {"url": "/certificates/restore"}
 
     @distributed_trace
     def get_deleted_certificates(
         self,
         vault_base_url: str,
         maxresults: Optional[int] = None,
         include_pending: Optional[bool] = None,
@@ -7862,31 +7907,36 @@
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :param include_pending: Specifies whether to include certificates which are not completely
          provisioned. Default value is None.
         :type include_pending: bool
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -7903,15 +7953,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -7922,43 +7972,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedCertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}  # type: ignore
+    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}
 
     @distributed_trace
     def get_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Retrieves information about the specified deleted certificate.
 
@@ -7982,31 +8032,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8016,15 +8066,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace
     def purge_deleted_certificate(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified deleted certificate.
 
@@ -8048,45 +8098,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.purge_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace
     def recover_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Recovers the deleted certificate back to its current version under /certificates.
 
@@ -8111,31 +8161,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.recover_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8145,38 +8195,43 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}  # type: ignore
+    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}
 
     @distributed_trace
     def get_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -8192,15 +8247,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -8211,69 +8266,74 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("StorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_storage_accounts.metadata = {"url": "/storage"}  # type: ignore
+    get_storage_accounts.metadata = {"url": "/storage"}
 
     @distributed_trace
     def get_deleted_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedStorageAccountItem"]:
         """Lists deleted storage accounts for the specified vault.
 
         The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedStorageAccountItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedStorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -8289,15 +8349,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -8308,43 +8368,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedStorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_storage_accounts.metadata = {"url": "/deletedstorage"}  # type: ignore
+    get_deleted_storage_accounts.metadata = {"url": "/deletedstorage"}
 
     @distributed_trace
     def get_deleted_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.DeletedStorageBundle:
         """Gets the specified deleted storage account.
 
@@ -8367,31 +8427,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8401,15 +8461,15 @@
         deserialized = self._deserialize("DeletedStorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}  # type: ignore
+    get_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}
 
     @distributed_trace
     def purge_deleted_storage_account(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified storage account.
 
@@ -8433,45 +8493,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.purge_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}  # type: ignore
+    purge_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}
 
     @distributed_trace
     def recover_deleted_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Recovers the deleted storage account.
 
@@ -8495,31 +8555,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.recover_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8529,15 +8589,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}/recover"}  # type: ignore
+    recover_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}/recover"}
 
     @distributed_trace
     def backup_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.BackupStorageResult:
         """Backs up the specified storage account.
 
@@ -8560,31 +8620,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupStorageResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupStorageResult] = kwargs.pop("cls", None)
 
         request = build_backup_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.backup_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8594,15 +8654,15 @@
         deserialized = self._deserialize("BackupStorageResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_storage_account.metadata = {"url": "/storage/{storage-account-name}/backup"}  # type: ignore
+    backup_storage_account.metadata = {"url": "/storage/{storage-account-name}/backup"}
 
     @overload
     def restore_storage_account(
         self,
         vault_base_url: str,
         parameters: _models.StorageRestoreParameters,
         *,
@@ -8656,16 +8716,16 @@
         """Restores a backed up storage account to a vault.
 
         Restores a backed up storage account to a vault. This operation requires the storage/restore
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the storage account. Is either a model type or a
-         IO type. Required.
+        :param parameters: The parameters to restore the storage account. Is either a
+         StorageRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -8678,17 +8738,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8703,17 +8763,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8723,15 +8783,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_storage_account.metadata = {"url": "/storage/restore"}  # type: ignore
+    restore_storage_account.metadata = {"url": "/storage/restore"}
 
     @distributed_trace
     def delete_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.DeletedStorageBundle:
         """Deletes a storage account. This operation requires the storage/delete permission.
 
@@ -8751,31 +8811,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageBundle] = kwargs.pop("cls", None)
 
         request = build_delete_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.delete_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8785,15 +8845,15 @@
         deserialized = self._deserialize("DeletedStorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @distributed_trace
     def get_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Gets information about a specified storage account. This operation requires the storage/get
         permission.
@@ -8814,31 +8874,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8848,15 +8908,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def set_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountCreateParameters,
@@ -8918,16 +8978,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -8940,17 +9000,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8966,17 +9026,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8986,15 +9046,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def update_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountUpdateParameters,
@@ -9059,16 +9119,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -9081,17 +9141,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -9107,17 +9167,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9127,15 +9187,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def regenerate_storage_account_key(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountRegenerteKeyParameters,
@@ -9200,16 +9260,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -9222,17 +9282,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -9248,17 +9308,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9268,40 +9328,45 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}  # type: ignore
+    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}
 
     @distributed_trace
     def get_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SasDefinitionItem"]:
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -9318,15 +9383,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -9337,71 +9402,76 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}  # type: ignore
+    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}
 
     @distributed_trace
     def get_deleted_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedSasDefinitionItem"]:
         """Lists deleted SAS definitions for the specified vault and storage account.
 
         The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSasDefinitionItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_0.models.DeletedSasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -9418,15 +9488,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -9437,43 +9507,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_sas_definitions.metadata = {"url": "/deletedstorage/{storage-account-name}/sas"}  # type: ignore
+    get_deleted_sas_definitions.metadata = {"url": "/deletedstorage/{storage-account-name}/sas"}
 
     @distributed_trace
     def get_deleted_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.DeletedSasDefinitionBundle:
         """Gets the specified deleted sas definition.
 
@@ -9498,32 +9568,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_deleted_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9533,15 +9603,15 @@
         deserialized = self._deserialize("DeletedSasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace
     def recover_deleted_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Recovers the deleted SAS definition.
 
@@ -9567,32 +9637,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.recover_deleted_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9602,15 +9672,17 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"}  # type: ignore
+    recover_deleted_sas_definition.metadata = {
+        "url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
+    }
 
     @distributed_trace
     def delete_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.DeletedSasDefinitionBundle:
         """Deletes a SAS definition from a specified storage account. This operation requires the
         storage/deletesas permission.
@@ -9633,32 +9705,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_delete_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.delete_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9668,15 +9740,15 @@
         deserialized = self._deserialize("DeletedSasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace
     def get_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Gets information about a SAS definition for the specified storage account. This operation
         requires the storage/getsas permission.
@@ -9699,32 +9771,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9734,15 +9806,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     def set_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -9816,16 +9888,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SasDefinitionBundle
@@ -9838,17 +9910,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -9865,17 +9937,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -9885,15 +9957,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     def update_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -9967,16 +10039,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SasDefinitionBundle
@@ -9989,17 +10061,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -10016,17 +10088,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -10036,8 +10108,8 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,22 +22,22 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.0". Note that overriding this default
-     value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2016-10-01". Note that overriding this
+     default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.0")  # type: Literal["7.0"]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", "2016-10-01")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_key_vault_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.0". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
@@ -62,9 +62,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_key_vault_client_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -194,16 +194,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -216,17 +216,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -242,17 +242,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -262,15 +262,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -343,16 +343,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -365,17 +365,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -391,17 +391,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -411,15 +411,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -442,31 +442,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -476,15 +476,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -570,16 +570,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -592,17 +592,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -619,17 +619,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -639,15 +639,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -672,32 +672,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -707,42 +707,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -759,15 +764,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -778,70 +783,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -857,15 +867,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -876,43 +886,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -942,31 +952,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -976,15 +986,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1062,16 +1072,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyBundle
@@ -1084,17 +1094,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1109,17 +1119,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1129,15 +1139,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1235,16 +1245,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -1257,17 +1267,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1284,17 +1294,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1304,15 +1314,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1404,16 +1414,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -1426,17 +1436,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1453,17 +1463,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1473,15 +1483,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1564,16 +1574,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -1586,17 +1596,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1613,17 +1623,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1633,15 +1643,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1730,16 +1740,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyVerifyResult
@@ -1752,17 +1762,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1779,17 +1789,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1799,15 +1809,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1899,16 +1909,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -1921,17 +1931,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1948,17 +1958,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1968,15 +1978,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2062,16 +2072,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.KeyOperationResult
@@ -2084,17 +2094,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2111,17 +2121,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2131,15 +2141,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2147,27 +2157,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2183,15 +2198,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2202,43 +2217,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2260,31 +2275,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2294,15 +2309,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2326,45 +2341,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2387,31 +2402,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2421,15 +2436,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @overload
     async def set_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         parameters: _models.SecretSetParameters,
@@ -2499,16 +2514,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -2521,17 +2536,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2547,17 +2562,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2567,15 +2582,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    set_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @distributed_trace_async
     async def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Deletes a secret from a specified key vault.
 
         The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
         to an individual version of a secret. This operation requires the secrets/delete permission.
@@ -2596,31 +2611,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_delete_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.delete_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2630,15 +2645,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    delete_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @overload
     async def update_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         secret_version: str,
@@ -2721,16 +2736,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -2743,17 +2758,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2770,17 +2785,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2790,15 +2805,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace_async
     async def get_secret(
         self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Get a specified secret from a given key vault.
 
@@ -2824,32 +2839,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_secret_request(
             secret_name=secret_name,
             secret_version=secret_version,
             api_version=api_version,
             template_url=self.get_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2859,41 +2874,46 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SecretItem"]:
         """List secrets in a specified key vault.
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2909,15 +2929,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2928,70 +2948,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_secrets.metadata = {"url": "/secrets"}  # type: ignore
+    get_secrets.metadata = {"url": "/secrets"}
 
     @distributed_trace
     def get_secret_versions(
         self, vault_base_url: str, secret_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SecretItem"]:
         """List all versions of the specified secret.
 
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3008,15 +3033,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3027,68 +3052,73 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}  # type: ignore
+    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}
 
     @distributed_trace
     def get_deleted_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedSecretItem"]:
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3104,15 +3134,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3123,43 +3153,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}  # type: ignore
+    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}
 
     @distributed_trace_async
     async def get_deleted_secret(
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> _models.DeletedSecretBundle:
         """Gets the specified deleted secret.
 
@@ -3182,31 +3212,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.get_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3216,15 +3246,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace_async
     async def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified secret.
 
@@ -3248,45 +3278,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.purge_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace_async
     async def recover_deleted_secret(
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Recovers the deleted secret to the latest version.
 
@@ -3309,31 +3339,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.recover_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3343,15 +3373,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}  # type: ignore
+    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}
 
     @distributed_trace_async
     async def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.BackupSecretResult:
         """Backs up the specified secret.
 
         Requests that a backup of the specified secret be downloaded to the client. All versions of the
         secret will be downloaded. This operation requires the secrets/backup permission.
@@ -3372,31 +3402,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupSecretResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupSecretResult] = kwargs.pop("cls", None)
 
         request = build_backup_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.backup_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3406,15 +3436,15 @@
         deserialized = self._deserialize("BackupSecretResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}  # type: ignore
+    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}
 
     @overload
     async def restore_secret(
         self,
         vault_base_url: str,
         parameters: _models.SecretRestoreParameters,
         *,
@@ -3468,16 +3498,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SecretBundle
@@ -3490,17 +3520,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3515,17 +3545,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3535,15 +3565,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_secret.metadata = {"url": "/secrets/restore"}  # type: ignore
+    restore_secret.metadata = {"url": "/secrets/restore"}
 
     @distributed_trace
     def get_certificates(
         self,
         vault_base_url: str,
         maxresults: Optional[int] = None,
         include_pending: Optional[bool] = None,
@@ -3552,30 +3582,35 @@
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :param include_pending: Specifies whether to include certificates which are not completely
          provisioned. Default value is None.
         :type include_pending: bool
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3592,15 +3627,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3611,43 +3646,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificates.metadata = {"url": "/certificates"}  # type: ignore
+    get_certificates.metadata = {"url": "/certificates"}
 
     @distributed_trace_async
     async def delete_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Deletes a certificate from a specified key vault.
 
@@ -3671,31 +3706,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3705,15 +3740,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}  # type: ignore
+    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}
 
     @overload
     async def set_certificate_contacts(
         self, vault_base_url: str, contacts: _models.Contacts, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Contacts:
         """Sets the certificate contacts for the specified key vault.
 
@@ -3762,15 +3797,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v7_0.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -3784,17 +3819,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(contacts, (IO, bytes)):
             _content = contacts
         else:
@@ -3809,17 +3844,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3829,15 +3864,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace_async
     async def get_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Lists the certificate contacts for a specified key vault.
 
         The GetCertificateContacts operation returns the set of certificate contact resources in the
         specified key vault. This operation requires the certificates/managecontacts permission.
@@ -3856,30 +3891,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_get_certificate_contacts_request(
             api_version=api_version,
             template_url=self.get_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3889,15 +3924,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace_async
     async def delete_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Deletes the certificate contacts for a specified key vault.
 
         Deletes the certificate contacts for a specified key vault certificate. This operation requires
         the certificates/managecontacts permission.
@@ -3916,30 +3951,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_contacts_request(
             api_version=api_version,
             template_url=self.delete_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3949,43 +3984,48 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_issuers(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.CertificateIssuerItem"]:
         """List certificate issuers for a specified key vault.
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateIssuerListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateIssuerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4001,15 +4041,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4020,43 +4060,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateIssuerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}  # type: ignore
+    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}
 
     @overload
     async def set_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerSetParameters,
@@ -4127,16 +4167,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v7_0.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.IssuerBundle
@@ -4149,17 +4189,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -4175,17 +4215,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4195,15 +4235,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     async def update_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerUpdateParameters,
@@ -4274,16 +4314,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v7_0.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.IssuerBundle
@@ -4296,17 +4336,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -4322,17 +4362,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4342,15 +4382,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace_async
     async def get_certificate_issuer(
         self, vault_base_url: str, issuer_name: str, **kwargs: Any
     ) -> _models.IssuerBundle:
         """Lists the specified certificate issuer.
 
@@ -4374,31 +4414,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.get_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4408,15 +4448,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace_async
     async def delete_certificate_issuer(
         self, vault_base_url: str, issuer_name: str, **kwargs: Any
     ) -> _models.IssuerBundle:
         """Deletes the specified certificate issuer.
 
@@ -4439,31 +4479,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.delete_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4473,15 +4513,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     async def create_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateCreateParameters,
@@ -4552,16 +4592,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateOperation
@@ -4574,17 +4614,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4600,17 +4640,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4620,15 +4660,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}  # type: ignore
+    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}
 
     @overload
     async def import_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateImportParameters,
@@ -4705,16 +4745,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -4727,17 +4767,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4753,17 +4793,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4773,42 +4813,47 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}  # type: ignore
+    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}
 
     @distributed_trace
     def get_certificate_versions(
         self, vault_base_url: str, certificate_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.CertificateItem"]:
         """List the versions of a certificate.
 
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4825,15 +4870,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4844,43 +4889,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}  # type: ignore
+    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}
 
     @distributed_trace_async
     async def get_certificate_policy(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificatePolicy:
         """Lists the policy for a certificate.
 
@@ -4903,31 +4948,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         request = build_get_certificate_policy_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4937,15 +4982,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     async def update_certificate_policy(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_policy: _models.CertificatePolicy,
@@ -5016,16 +5061,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v7_0.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificatePolicy
@@ -5038,17 +5083,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_policy, (IO, bytes)):
             _content = certificate_policy
         else:
@@ -5064,17 +5109,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5084,15 +5129,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     async def update_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_version: str,
@@ -5175,16 +5220,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -5197,17 +5242,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5224,17 +5269,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5244,15 +5289,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @distributed_trace_async
     async def get_certificate(
         self, vault_base_url: str, certificate_name: str, certificate_version: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Gets information about a certificate.
 
@@ -5278,32 +5323,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_request(
             certificate_name=certificate_name,
             certificate_version=certificate_version,
             api_version=api_version,
             template_url=self.get_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5313,15 +5358,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @overload
     async def update_certificate_operation(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_operation: _models.CertificateOperationUpdateParameter,
@@ -5392,16 +5437,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation: ~azure.keyvault.v7_0.models.CertificateOperationUpdateParameter or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -5415,17 +5460,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_operation, (IO, bytes)):
             _content = certificate_operation
         else:
@@ -5441,17 +5486,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5461,15 +5506,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace_async
     async def get_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Gets the creation operation of a certificate.
 
@@ -5492,31 +5537,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_get_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5526,15 +5571,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace_async
     async def delete_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Deletes the creation operation for a specific certificate.
 
@@ -5558,31 +5603,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5592,15 +5637,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @overload
     async def merge_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateMergeParameters,
@@ -5674,16 +5719,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -5696,17 +5741,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5722,17 +5767,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5742,15 +5787,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}  # type: ignore
+    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}
 
     @distributed_trace_async
     async def backup_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.BackupCertificateResult:
         """Backs up the specified certificate.
 
@@ -5774,31 +5819,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupCertificateResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupCertificateResult] = kwargs.pop("cls", None)
 
         request = build_backup_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.backup_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5808,15 +5853,15 @@
         deserialized = self._deserialize("BackupCertificateResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_certificate.metadata = {"url": "/certificates/{certificate-name}/backup"}  # type: ignore
+    backup_certificate.metadata = {"url": "/certificates/{certificate-name}/backup"}
 
     @overload
     async def restore_certificate(
         self,
         vault_base_url: str,
         parameters: _models.CertificateRestoreParameters,
         *,
@@ -5870,16 +5915,16 @@
         """Restores a backed up certificate to a vault.
 
         Restores a backed up certificate, and all its versions, to a vault. This operation requires the
         certificates/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to restore the certificate. Is either a
+         CertificateRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -5892,17 +5937,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5917,17 +5962,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5937,15 +5982,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_certificate.metadata = {"url": "/certificates/restore"}  # type: ignore
+    restore_certificate.metadata = {"url": "/certificates/restore"}
 
     @distributed_trace
     def get_deleted_certificates(
         self,
         vault_base_url: str,
         maxresults: Optional[int] = None,
         include_pending: Optional[bool] = None,
@@ -5956,32 +6001,37 @@
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :param include_pending: Specifies whether to include certificates which are not completely
          provisioned. Default value is None.
         :type include_pending: bool
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5998,15 +6048,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6017,43 +6067,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedCertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}  # type: ignore
+    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}
 
     @distributed_trace_async
     async def get_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Retrieves information about the specified deleted certificate.
 
@@ -6077,31 +6127,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6111,15 +6161,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace_async
     async def purge_deleted_certificate(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified deleted certificate.
 
@@ -6143,45 +6193,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.purge_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace_async
     async def recover_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Recovers the deleted certificate back to its current version under /certificates.
 
@@ -6206,31 +6256,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.recover_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6240,38 +6290,43 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}  # type: ignore
+    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}
 
     @distributed_trace
     def get_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6287,15 +6342,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6306,70 +6361,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("StorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_storage_accounts.metadata = {"url": "/storage"}  # type: ignore
+    get_storage_accounts.metadata = {"url": "/storage"}
 
     @distributed_trace
     def get_deleted_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedStorageAccountItem"]:
         """Lists deleted storage accounts for the specified vault.
 
         The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedStorageAccountItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedStorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6385,15 +6445,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6404,43 +6464,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedStorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_storage_accounts.metadata = {"url": "/deletedstorage"}  # type: ignore
+    get_deleted_storage_accounts.metadata = {"url": "/deletedstorage"}
 
     @distributed_trace_async
     async def get_deleted_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.DeletedStorageBundle:
         """Gets the specified deleted storage account.
 
@@ -6463,31 +6523,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6497,15 +6557,15 @@
         deserialized = self._deserialize("DeletedStorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}  # type: ignore
+    get_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}
 
     @distributed_trace_async
     async def purge_deleted_storage_account(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified storage account.
 
@@ -6529,45 +6589,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.purge_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}  # type: ignore
+    purge_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}"}
 
     @distributed_trace_async
     async def recover_deleted_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Recovers the deleted storage account.
 
@@ -6591,31 +6651,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.recover_deleted_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6625,15 +6685,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}/recover"}  # type: ignore
+    recover_deleted_storage_account.metadata = {"url": "/deletedstorage/{storage-account-name}/recover"}
 
     @distributed_trace_async
     async def backup_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.BackupStorageResult:
         """Backs up the specified storage account.
 
@@ -6656,31 +6716,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupStorageResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.BackupStorageResult] = kwargs.pop("cls", None)
 
         request = build_backup_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.backup_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6690,15 +6750,15 @@
         deserialized = self._deserialize("BackupStorageResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_storage_account.metadata = {"url": "/storage/{storage-account-name}/backup"}  # type: ignore
+    backup_storage_account.metadata = {"url": "/storage/{storage-account-name}/backup"}
 
     @overload
     async def restore_storage_account(
         self,
         vault_base_url: str,
         parameters: _models.StorageRestoreParameters,
         *,
@@ -6752,16 +6812,16 @@
         """Restores a backed up storage account to a vault.
 
         Restores a backed up storage account to a vault. This operation requires the storage/restore
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the storage account. Is either a model type or a
-         IO type. Required.
+        :param parameters: The parameters to restore the storage account. Is either a
+         StorageRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -6774,17 +6834,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6799,17 +6859,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6819,15 +6879,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_storage_account.metadata = {"url": "/storage/restore"}  # type: ignore
+    restore_storage_account.metadata = {"url": "/storage/restore"}
 
     @distributed_trace_async
     async def delete_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.DeletedStorageBundle:
         """Deletes a storage account. This operation requires the storage/delete permission.
 
@@ -6847,31 +6907,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedStorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedStorageBundle] = kwargs.pop("cls", None)
 
         request = build_delete_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.delete_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6881,15 +6941,15 @@
         deserialized = self._deserialize("DeletedStorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @distributed_trace_async
     async def get_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Gets information about a specified storage account. This operation requires the storage/get
         permission.
@@ -6910,31 +6970,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6944,15 +7004,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def set_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountCreateParameters,
@@ -7014,16 +7074,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -7036,17 +7096,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7062,17 +7122,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7082,15 +7142,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def update_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountUpdateParameters,
@@ -7155,16 +7215,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -7177,17 +7237,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7203,17 +7263,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7223,15 +7283,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def regenerate_storage_account_key(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountRegenerteKeyParameters,
@@ -7296,16 +7356,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -7318,17 +7378,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7344,17 +7404,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7364,40 +7424,45 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}  # type: ignore
+    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}
 
     @distributed_trace
     def get_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SasDefinitionItem"]:
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -7414,15 +7479,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -7433,72 +7498,77 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}  # type: ignore
+    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}
 
     @distributed_trace
     def get_deleted_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedSasDefinitionItem"]:
         """Lists deleted SAS definitions for the specified vault and storage account.
 
         The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSasDefinitionItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedSasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionListResult]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -7515,15 +7585,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -7534,43 +7604,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_sas_definitions.metadata = {"url": "/deletedstorage/{storage-account-name}/sas"}  # type: ignore
+    get_deleted_sas_definitions.metadata = {"url": "/deletedstorage/{storage-account-name}/sas"}
 
     @distributed_trace_async
     async def get_deleted_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.DeletedSasDefinitionBundle:
         """Gets the specified deleted sas definition.
 
@@ -7595,32 +7665,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_deleted_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7630,15 +7700,15 @@
         deserialized = self._deserialize("DeletedSasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace_async
     async def recover_deleted_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Recovers the deleted SAS definition.
 
@@ -7664,32 +7734,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.recover_deleted_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7699,15 +7769,17 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_sas_definition.metadata = {"url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"}  # type: ignore
+    recover_deleted_sas_definition.metadata = {
+        "url": "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
+    }
 
     @distributed_trace_async
     async def delete_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.DeletedSasDefinitionBundle:
         """Deletes a SAS definition from a specified storage account. This operation requires the
         storage/deletesas permission.
@@ -7730,32 +7802,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.DeletedSasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_delete_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.delete_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7765,15 +7837,15 @@
         deserialized = self._deserialize("DeletedSasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace_async
     async def get_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Gets information about a SAS definition for the specified storage account. This operation
         requires the storage/getsas permission.
@@ -7796,32 +7868,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7831,15 +7903,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     async def set_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -7913,16 +7985,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SasDefinitionBundle
@@ -7935,17 +8007,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7962,17 +8034,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7982,15 +8054,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     async def update_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -8064,16 +8136,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.SasDefinitionBundle
@@ -8086,17 +8158,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.0"))  # type: Literal["7.0"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", _params.pop("api-version", "7.0"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8113,17 +8185,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8133,8 +8205,8 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,158 +6,145 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
-class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of the action."""
-
-    EMAIL_CONTACTS = "EmailContacts"
-    AUTO_RENEW = "AutoRenew"
-
-
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
     RSA1_5 = "RSA1_5"
+    A128_GCM = "A128GCM"
+    A192_GCM = "A192GCM"
+    A256_GCM = "A256GCM"
+    A128_KW = "A128KW"
+    A192_KW = "A192KW"
+    A256_KW = "A256KW"
+    A128_CBC = "A128CBC"
+    A192_CBC = "A192CBC"
+    A256_CBC = "A256CBC"
+    A128_CBCPAD = "A128CBCPAD"
+    A192_CBCPAD = "A192CBCPAD"
+    A256_CBCPAD = "A256CBCPAD"
 
 
 class JsonWebKeyOperation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JSON web key operations. For more information, see JsonWebKeyOperation."""
 
     ENCRYPT = "encrypt"
     DECRYPT = "decrypt"
     SIGN = "sign"
     VERIFY = "verify"
     WRAP_KEY = "wrapKey"
     UNWRAP_KEY = "unwrapKey"
+    IMPORT = "import"
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is not exportable from the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is not exportable from the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is not exportable from the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Not supported in this version. Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is not exportable from the HSM."""
     OCT = "oct"
-
-
-class KeyUsageType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """KeyUsageType."""
-
-    DIGITAL_SIGNATURE = "digitalSignature"
-    NON_REPUDIATION = "nonRepudiation"
-    KEY_ENCIPHERMENT = "keyEncipherment"
-    DATA_ENCIPHERMENT = "dataEncipherment"
-    KEY_AGREEMENT = "keyAgreement"
-    KEY_CERT_SIGN = "keyCertSign"
-    C_RL_SIGN = "cRLSign"
-    ENCIPHER_ONLY = "encipherOnly"
-    DECIPHER_ONLY = "decipherOnly"
-
-
-class SasTokenType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of SAS token the SAS definition will create."""
-
-    ACCOUNT = "account"
-    SERVICE = "service"
+    """Octet sequence (used to represent symmetric keys)"""
+    OCT_HSM = "oct-HSM"
+    """Octet sequence (used to represent symmetric keys) which is not exportable from the HSM."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -102,15 +102,15 @@
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._key_vault_client_enums import KeyUsageType
 from ._key_vault_client_enums import SasTokenType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Action",
     "AdministratorDetails",
     "Attributes",
     "BackupCertificateResult",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_models_py3.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -24,15 +24,15 @@
     :vartype action_type: str or ~azure.keyvault.v7_0.models.ActionType
     """
 
     _attribute_map = {
         "action_type": {"key": "action_type", "type": "str"},
     }
 
-    def __init__(self, *, action_type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs):
+    def __init__(self, *, action_type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs: Any) -> None:
         """
         :keyword action_type: The type of the action. Known values are: "EmailContacts" and
          "AutoRenew".
         :paramtype action_type: str or ~azure.keyvault.v7_0.models.ActionType
         """
         super().__init__(**kwargs)
         self.action_type = action_type
@@ -61,16 +61,16 @@
     def __init__(
         self,
         *,
         first_name: Optional[str] = None,
         last_name: Optional[str] = None,
         email_address: Optional[str] = None,
         phone: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword first_name: First name.
         :paramtype first_name: str
         :keyword last_name: Last name.
         :paramtype last_name: str
         :keyword email_address: Email address.
         :paramtype email_address: str
@@ -116,16 +116,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -151,15 +151,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class BackupKeyResult(_serialization.Model):
     """The backup key result, containing the backup blob.
@@ -174,15 +174,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class BackupSecretResult(_serialization.Model):
     """The backup secret result, containing the backup blob.
@@ -197,15 +197,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class BackupStorageResult(_serialization.Model):
     """The backup storage result, containing the backup blob.
@@ -220,15 +220,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class CertificateAttributes(Attributes):
     """The certificate management attributes.
@@ -271,16 +271,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -337,16 +337,16 @@
     def __init__(
         self,
         *,
         cer: Optional[bytes] = None,
         content_type: Optional[str] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cer: CER contents of x509 certificate.
         :paramtype cer: bytes
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
         :keyword attributes: The certificate attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
@@ -384,16 +384,16 @@
 
     def __init__(
         self,
         *,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword certificate_policy: The management policy for the certificate.
         :paramtype certificate_policy: ~azure.keyvault.v7_0.models.CertificatePolicy
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -439,16 +439,16 @@
         self,
         *,
         base64_encoded_certificate: str,
         password: Optional[str] = None,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword base64_encoded_certificate: A PEM file or a base64-encoded PFX file.  PEM files need
          to contain the private key. Required.
         :paramtype base64_encoded_certificate: str
         :keyword password: If the private key in base64EncodedCertificate is encrypted, the password
          used for encryption.
         :paramtype password: str
@@ -478,16 +478,20 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "provider": {"key": "provider", "type": "str"},
     }
 
     def __init__(
-        self, *, id: Optional[str] = None, provider: Optional[str] = None, **kwargs  # pylint: disable=redefined-builtin
-    ):
+        self,
+        *,
+        id: Optional[str] = None,  # pylint: disable=redefined-builtin
+        provider: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate Identifier.
         :paramtype id: str
         :keyword provider: The issuer provider.
         :paramtype provider: str
         """
         super().__init__(**kwargs)
@@ -513,15 +517,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[CertificateIssuerItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class CertificateIssuerSetParameters(_serialization.Model):
@@ -553,16 +557,16 @@
     def __init__(
         self,
         *,
         provider: str,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider. Required.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v7_0.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v7_0.models.OrganizationDetails
@@ -599,16 +603,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v7_0.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v7_0.models.OrganizationDetails
@@ -645,16 +649,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         x509_thumbprint: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate identifier.
         :paramtype id: str
         :keyword attributes: The certificate management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -686,15 +690,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[CertificateItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class CertificateMergeParameters(_serialization.Model):
@@ -722,16 +726,16 @@
 
     def __init__(
         self,
         *,
         x509_certificates: List[bytes],
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword x509_certificates: The certificate or the certificate chain to merge. Required.
         :paramtype x509_certificates: list[bytes]
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -792,16 +796,16 @@
         csr: Optional[bytes] = None,
         cancellation_requested: Optional[bool] = None,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         target: Optional[str] = None,
         request_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword issuer_parameters: Parameters for the issuer of the X509 component of a certificate.
         :paramtype issuer_parameters: ~azure.keyvault.v7_0.models.IssuerParameters
         :keyword csr: The certificate signing request (CSR) that is being used in the certificate
          operation.
         :paramtype csr: bytes
         :keyword cancellation_requested: Indicates if cancellation was requested on the certificate
@@ -844,15 +848,15 @@
         "cancellation_requested": {"required": True},
     }
 
     _attribute_map = {
         "cancellation_requested": {"key": "cancellation_requested", "type": "bool"},
     }
 
-    def __init__(self, *, cancellation_requested: bool, **kwargs):
+    def __init__(self, *, cancellation_requested: bool, **kwargs: Any) -> None:
         """
         :keyword cancellation_requested: Indicates if cancellation was requested on the certificate
          operation. Required.
         :paramtype cancellation_requested: bool
         """
         super().__init__(**kwargs)
         self.cancellation_requested = cancellation_requested
@@ -899,16 +903,16 @@
         *,
         key_properties: Optional["_models.KeyProperties"] = None,
         secret_properties: Optional["_models.SecretProperties"] = None,
         x509_certificate_properties: Optional["_models.X509CertificateProperties"] = None,
         lifetime_actions: Optional[List["_models.LifetimeAction"]] = None,
         issuer_parameters: Optional["_models.IssuerParameters"] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_properties: Properties of the key backing a certificate.
         :paramtype key_properties: ~azure.keyvault.v7_0.models.KeyProperties
         :keyword secret_properties: Properties of the secret backing a certificate.
         :paramtype secret_properties: ~azure.keyvault.v7_0.models.SecretProperties
         :keyword x509_certificate_properties: Properties of the X509 component of a certificate.
         :paramtype x509_certificate_properties: ~azure.keyvault.v7_0.models.X509CertificateProperties
@@ -944,15 +948,15 @@
         "certificate_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "certificate_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, certificate_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, certificate_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword certificate_bundle_backup: The backup blob associated with a certificate bundle.
          Required.
         :paramtype certificate_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.certificate_bundle_backup = certificate_bundle_backup
@@ -977,16 +981,16 @@
 
     def __init__(
         self,
         *,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword certificate_policy: The management policy for the certificate.
         :paramtype certificate_policy: ~azure.keyvault.v7_0.models.CertificatePolicy
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1011,16 +1015,21 @@
     _attribute_map = {
         "email_address": {"key": "email", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "phone": {"key": "phone", "type": "str"},
     }
 
     def __init__(
-        self, *, email_address: Optional[str] = None, name: Optional[str] = None, phone: Optional[str] = None, **kwargs
-    ):
+        self,
+        *,
+        email_address: Optional[str] = None,
+        name: Optional[str] = None,
+        phone: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword email_address: Email address.
         :paramtype email_address: str
         :keyword name: Name.
         :paramtype name: str
         :keyword phone: Phone number.
         :paramtype phone: str
@@ -1047,26 +1056,27 @@
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "contact_list": {"key": "contacts", "type": "[Contact]"},
     }
 
-    def __init__(self, *, contact_list: Optional[List["_models.Contact"]] = None, **kwargs):
+    def __init__(self, *, contact_list: Optional[List["_models.Contact"]] = None, **kwargs: Any) -> None:
         """
         :keyword contact_list: The contact list for the vault certificates.
         :paramtype contact_list: list[~azure.keyvault.v7_0.models.Contact]
         """
         super().__init__(**kwargs)
         self.id = None
         self.contact_list = contact_list
 
 
 class DeletedCertificateBundle(CertificateBundle):  # pylint: disable=too-many-instance-attributes
-    """A Deleted Certificate consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A Deleted Certificate consisting of its previous id, attributes and its tags, as well as
+    information on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The certificate id.
     :vartype id: str
     :ivar kid: The key id.
     :vartype kid: str
@@ -1122,16 +1132,16 @@
         self,
         *,
         cer: Optional[bytes] = None,
         content_type: Optional[str] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cer: CER contents of x509 certificate.
         :paramtype cer: bytes
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
         :keyword attributes: The certificate attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
@@ -1188,16 +1198,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         x509_thumbprint: Optional[bytes] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate identifier.
         :paramtype id: str
         :keyword attributes: The certificate management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1231,15 +1241,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedCertificateItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyBundle(_serialization.Model):
@@ -1271,16 +1281,16 @@
 
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_0.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1334,16 +1344,16 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_0.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1386,16 +1396,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1449,16 +1459,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1490,15 +1500,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SasDefinitionBundle(_serialization.Model):
@@ -1541,28 +1551,29 @@
         "template_uri": {"key": "templateUri", "type": "str"},
         "sas_type": {"key": "sasType", "type": "str"},
         "validity_period": {"key": "validityPeriod", "type": "str"},
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.secret_id = None
         self.template_uri = None
         self.sas_type = None
         self.validity_period = None
         self.attributes = None
         self.tags = None
 
 
 class DeletedSasDefinitionBundle(SasDefinitionBundle):
-    """A deleted SAS definition bundle consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A deleted SAS definition bundle consisting of its previous id, attributes and its tags, as well
+    as information on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The SAS definition id.
     :vartype id: str
     :ivar secret_id: Storage account SAS definition secret id.
     :vartype secret_id: str
@@ -1609,15 +1620,15 @@
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
         "recovery_id": {"key": "recoveryId", "type": "str"},
         "scheduled_purge_date": {"key": "scheduledPurgeDate", "type": "unix-time"},
         "deleted_date": {"key": "deletedDate", "type": "unix-time"},
     }
 
-    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          SAS definition.
         :paramtype recovery_id: str
         """
         super().__init__(**kwargs)
         self.recovery_id = recovery_id
@@ -1650,15 +1661,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "secret_id": {"key": "sid", "type": "str"},
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.secret_id = None
         self.attributes = None
         self.tags = None
 
@@ -1700,15 +1711,15 @@
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
         "recovery_id": {"key": "recoveryId", "type": "str"},
         "scheduled_purge_date": {"key": "scheduledPurgeDate", "type": "unix-time"},
         "deleted_date": {"key": "deletedDate", "type": "unix-time"},
     }
 
-    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          SAS definition.
         :paramtype recovery_id: str
         """
         super().__init__(**kwargs)
         self.recovery_id = recovery_id
@@ -1734,15 +1745,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedSasDefinitionItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SecretBundle(_serialization.Model):
@@ -1787,16 +1798,16 @@
         self,
         *,
         value: Optional[str] = None,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         content_type: Optional[str] = None,
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The secret value.
         :paramtype value: str
         :keyword id: The secret id.
         :paramtype id: str
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
@@ -1812,15 +1823,16 @@
         self.attributes = attributes
         self.tags = tags
         self.kid = None
         self.managed = None
 
 
 class DeletedSecretBundle(SecretBundle):
-    """A Deleted Secret consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A Deleted Secret consisting of its previous id, attributes and its tags, as well as information
+    on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: The secret value.
     :vartype value: str
     :ivar id: The secret id.
     :vartype id: str
@@ -1870,16 +1882,16 @@
         *,
         value: Optional[str] = None,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         content_type: Optional[str] = None,
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The secret value.
         :paramtype value: str
         :keyword id: The secret id.
         :paramtype id: str
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
@@ -1930,16 +1942,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Secret identifier.
         :paramtype id: str
         :keyword attributes: The secret management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -2000,16 +2012,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Secret identifier.
         :paramtype id: str
         :keyword attributes: The secret management attributes.
         :paramtype attributes: ~azure.keyvault.v7_0.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -2043,15 +2055,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedSecretItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class StorageAccountItem(_serialization.Model):
@@ -2079,15 +2091,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "resource_id": {"key": "resourceId", "type": "str"},
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.resource_id = None
         self.attributes = None
         self.tags = None
 
@@ -2130,15 +2142,15 @@
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
         "recovery_id": {"key": "recoveryId", "type": "str"},
         "scheduled_purge_date": {"key": "scheduledPurgeDate", "type": "unix-time"},
         "deleted_date": {"key": "deletedDate", "type": "unix-time"},
     }
 
-    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          storage account.
         :paramtype recovery_id: str
         """
         super().__init__(**kwargs)
         self.recovery_id = recovery_id
@@ -2183,28 +2195,29 @@
         "active_key_name": {"key": "activeKeyName", "type": "str"},
         "auto_regenerate_key": {"key": "autoRegenerateKey", "type": "bool"},
         "regeneration_period": {"key": "regenerationPeriod", "type": "str"},
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.resource_id = None
         self.active_key_name = None
         self.auto_regenerate_key = None
         self.regeneration_period = None
         self.attributes = None
         self.tags = None
 
 
 class DeletedStorageBundle(StorageBundle):
-    """A deleted storage account bundle consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A deleted storage account bundle consisting of its previous id, attributes and its tags, as
+    well as information on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The storage account id.
     :vartype id: str
     :ivar resource_id: The storage account resource id.
     :vartype resource_id: str
@@ -2249,15 +2262,15 @@
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
         "recovery_id": {"key": "recoveryId", "type": "str"},
         "scheduled_purge_date": {"key": "scheduledPurgeDate", "type": "unix-time"},
         "deleted_date": {"key": "deletedDate", "type": "unix-time"},
     }
 
-    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, recovery_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          storage account.
         :paramtype recovery_id: str
         """
         super().__init__(**kwargs)
         self.recovery_id = recovery_id
@@ -2283,15 +2296,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedStorageAccountItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -2315,15 +2328,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -2347,15 +2360,15 @@
 
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: Determines whether the issuer is enabled.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -2394,16 +2407,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v7_0.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v7_0.models.OrganizationDetails
@@ -2428,15 +2441,15 @@
     """
 
     _attribute_map = {
         "account_id": {"key": "account_id", "type": "str"},
         "password": {"key": "pwd", "type": "str"},
     }
 
-    def __init__(self, *, account_id: Optional[str] = None, password: Optional[str] = None, **kwargs):
+    def __init__(self, *, account_id: Optional[str] = None, password: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword account_id: The user name/account name/account id.
         :paramtype account_id: str
         :keyword password: The password/secret/account key.
         :paramtype password: str
         """
         super().__init__(**kwargs)
@@ -2466,16 +2479,16 @@
 
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         certificate_type: Optional[str] = None,
         certificate_transparency: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: Name of the referenced issuer object or reserved names; for example, 'Self' or
          'Unknown'.
         :paramtype name: str
         :keyword certificate_type: Certificate type as supported by the provider (optional); for
          example 'OV-SSL', 'EV-SSL'.
         :paramtype certificate_type: str
@@ -2563,16 +2576,16 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype kty: str or ~azure.keyvault.v7_0.models.JsonWebKeyType
@@ -2666,16 +2679,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -2723,16 +2736,16 @@
         *,
         kty: Union[str, "_models.JsonWebKeyType"],
         key_size: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype kty: str or ~azure.keyvault.v7_0.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword key_ops:
@@ -2783,16 +2796,16 @@
     def __init__(
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.v7_0.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.v7_0.models.KeyAttributes
@@ -2824,15 +2837,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -2852,15 +2865,15 @@
     }
 
     _attribute_map = {
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
 
 
 class KeyOperationsParameters(_serialization.Model):
@@ -2881,15 +2894,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", and "RSA1_5".
         :paramtype algorithm: str or ~azure.keyvault.v7_0.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         """
@@ -2927,16 +2942,16 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "_models.JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Indicates if the private key can be exported.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype key_type: str or ~azure.keyvault.v7_0.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
@@ -2968,15 +2983,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -3001,15 +3016,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
          "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_0.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
@@ -3040,16 +3057,16 @@
 
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.v7_0.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_0.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -3074,15 +3091,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
@@ -3113,16 +3130,16 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
          "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_0.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
@@ -3148,15 +3165,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class LifetimeAction(_serialization.Model):
     """Action and its trigger that will be performed by Key Vault over the lifetime of a certificate.
@@ -3169,16 +3186,16 @@
 
     _attribute_map = {
         "trigger": {"key": "trigger", "type": "Trigger"},
         "action": {"key": "action", "type": "Action"},
     }
 
     def __init__(
-        self, *, trigger: Optional["_models.Trigger"] = None, action: Optional["_models.Action"] = None, **kwargs
-    ):
+        self, *, trigger: Optional["_models.Trigger"] = None, action: Optional["_models.Action"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword trigger: The condition that will execute the action.
         :paramtype trigger: ~azure.keyvault.v7_0.models.Trigger
         :keyword action: The action that will be executed.
         :paramtype action: ~azure.keyvault.v7_0.models.Action
         """
         super().__init__(**kwargs)
@@ -3201,16 +3218,16 @@
     }
 
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         admin_details: Optional[List["_models.AdministratorDetails"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Id of the organization.
         :paramtype id: str
         :keyword admin_details: Details of the organization administrator.
         :paramtype admin_details: list[~azure.keyvault.v7_0.models.AdministratorDetails]
         """
         super().__init__(**kwargs)
@@ -3231,15 +3248,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class SasDefinitionAttributes(_serialization.Model):
     """The SAS definition management attributes.
@@ -3271,15 +3288,15 @@
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
         "recovery_level": {"key": "recoveryLevel", "type": "str"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: the enabled state of the object.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -3326,16 +3343,16 @@
         self,
         *,
         template_uri: str,
         sas_type: Union[str, "_models.SasTokenType"],
         validity_period: str,
         sas_definition_attributes: Optional["_models.SasDefinitionAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword template_uri: The SAS definition token template signed with an arbitrary key.  Tokens
          created according to the SAS definition will have the same properties as the template.
          Required.
         :paramtype template_uri: str
         :keyword sas_type: The type of SAS token the SAS definition will create. Required. Known values
          are: "account" and "service".
@@ -3374,15 +3391,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SasDefinitionItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SasDefinitionUpdateParameters(_serialization.Model):
@@ -3415,16 +3432,16 @@
         self,
         *,
         template_uri: Optional[str] = None,
         sas_type: Optional[Union[str, "_models.SasTokenType"]] = None,
         validity_period: Optional[str] = None,
         sas_definition_attributes: Optional["_models.SasDefinitionAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword template_uri: The SAS definition token template signed with an arbitrary key.  Tokens
          created according to the SAS definition will have the same properties as the template.
         :paramtype template_uri: str
         :keyword sas_type: The type of SAS token the SAS definition will create. Known values are:
          "account" and "service".
         :paramtype sas_type: str or ~azure.keyvault.v7_0.models.SasTokenType
@@ -3485,16 +3502,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -3521,15 +3538,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SecretItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SecretProperties(_serialization.Model):
@@ -3539,15 +3556,15 @@
     :vartype content_type: str
     """
 
     _attribute_map = {
         "content_type": {"key": "contentType", "type": "str"},
     }
 
-    def __init__(self, *, content_type: Optional[str] = None, **kwargs):
+    def __init__(self, *, content_type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword content_type: The media type (MIME type).
         :paramtype content_type: str
         """
         super().__init__(**kwargs)
         self.content_type = content_type
 
@@ -3565,15 +3582,15 @@
         "secret_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "secret_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, secret_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, secret_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword secret_bundle_backup: The backup blob associated with a secret bundle. Required.
         :paramtype secret_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.secret_bundle_backup = secret_bundle_backup
 
@@ -3607,16 +3624,16 @@
     def __init__(
         self,
         *,
         value: str,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
         secret_attributes: Optional["_models.SecretAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The value of the secret. Required.
         :paramtype value: str
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword content_type: Type of the secret value such as a password.
         :paramtype content_type: str
@@ -3649,16 +3666,16 @@
 
     def __init__(
         self,
         *,
         content_type: Optional[str] = None,
         secret_attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword content_type: Type of the secret value such as a password.
         :paramtype content_type: str
         :keyword secret_attributes: The secret management attributes.
         :paramtype secret_attributes: ~azure.keyvault.v7_0.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -3699,15 +3716,15 @@
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
         "recovery_level": {"key": "recoveryLevel", "type": "str"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: the enabled state of the object.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -3755,16 +3772,16 @@
         *,
         resource_id: str,
         active_key_name: str,
         auto_regenerate_key: bool,
         regeneration_period: Optional[str] = None,
         storage_account_attributes: Optional["_models.StorageAccountAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword resource_id: Storage account resource id. Required.
         :paramtype resource_id: str
         :keyword active_key_name: Current active storage account key name. Required.
         :paramtype active_key_name: str
         :keyword auto_regenerate_key: whether keyvault should manage the storage account for the user.
          Required.
@@ -3798,15 +3815,15 @@
         "key_name": {"required": True},
     }
 
     _attribute_map = {
         "key_name": {"key": "keyName", "type": "str"},
     }
 
-    def __init__(self, *, key_name: str, **kwargs):
+    def __init__(self, *, key_name: str, **kwargs: Any) -> None:
         """
         :keyword key_name: The storage account key name. Required.
         :paramtype key_name: str
         """
         super().__init__(**kwargs)
         self.key_name = key_name
 
@@ -3838,16 +3855,16 @@
         self,
         *,
         active_key_name: Optional[str] = None,
         auto_regenerate_key: Optional[bool] = None,
         regeneration_period: Optional[str] = None,
         storage_account_attributes: Optional["_models.StorageAccountAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword active_key_name: The current active storage account key name.
         :paramtype active_key_name: str
         :keyword auto_regenerate_key: whether keyvault should manage the storage account for the user.
         :paramtype auto_regenerate_key: bool
         :keyword regeneration_period: The key regeneration time duration specified in ISO-8601 format.
         :paramtype regeneration_period: str
@@ -3882,15 +3899,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[StorageAccountItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class StorageRestoreParameters(_serialization.Model):
@@ -3906,15 +3923,15 @@
         "storage_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "storage_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, storage_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, storage_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword storage_bundle_backup: The backup blob associated with a storage account. Required.
         :paramtype storage_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.storage_bundle_backup = storage_bundle_backup
 
@@ -3938,16 +3955,16 @@
 
     def __init__(
         self,
         *,
         emails: Optional[List[str]] = None,
         dns_names: Optional[List[str]] = None,
         upns: Optional[List[str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword emails: Email addresses.
         :paramtype emails: list[str]
         :keyword dns_names: Domain names.
         :paramtype dns_names: list[str]
         :keyword upns: User principal names.
         :paramtype upns: list[str]
@@ -3976,16 +3993,16 @@
 
     _attribute_map = {
         "lifetime_percentage": {"key": "lifetime_percentage", "type": "int"},
         "days_before_expiry": {"key": "days_before_expiry", "type": "int"},
     }
 
     def __init__(
-        self, *, lifetime_percentage: Optional[int] = None, days_before_expiry: Optional[int] = None, **kwargs
-    ):
+        self, *, lifetime_percentage: Optional[int] = None, days_before_expiry: Optional[int] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword lifetime_percentage: Percentage of lifetime at which to trigger. Value should be
          between 1 and 99.
         :paramtype lifetime_percentage: int
         :keyword days_before_expiry: Days before expiry to attempt renewal. Value should be between 1
          and validity_in_months multiplied by 27. If validity_in_months is 36, then value should be
          between 1 and 972 (36 * 27).
@@ -4027,16 +4044,16 @@
         self,
         *,
         subject: Optional[str] = None,
         ekus: Optional[List[str]] = None,
         subject_alternative_names: Optional["_models.SubjectAlternativeNames"] = None,
         key_usage: Optional[List[Union[str, "_models.KeyUsageType"]]] = None,
         validity_in_months: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword subject: The subject name. Should be a valid X509 distinguished Name.
         :paramtype subject: str
         :keyword ekus: The enhanced key usage.
         :paramtype ekus: list[str]
         :keyword subject_alternative_names: The subject alternative names.
         :paramtype subject_alternative_names: ~azure.keyvault.v7_0.models.SubjectAlternativeNames
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -22,31 +22,28 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.1". Note that overriding this default
-     value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2016-10-01". Note that overriding this
+     default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.1")  # type: Literal["7.1"]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", "2016-10-01")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
         self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_key_vault_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -26,17 +26,17 @@
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/operations/_key_vault_client_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -67,25 +67,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -94,50 +94,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -146,49 +146,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -197,15 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -218,40 +218,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -264,26 +264,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -292,26 +292,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -320,26 +320,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -348,26 +348,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -376,26 +376,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -404,26 +404,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -432,15 +432,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -453,72 +453,72 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
+    api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -601,16 +601,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -623,17 +623,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -649,17 +649,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -669,15 +669,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -750,16 +750,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -772,17 +772,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -798,17 +798,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -818,15 +818,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -849,31 +849,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -883,15 +883,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -977,16 +977,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -999,17 +999,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1026,17 +1026,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1046,15 +1046,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -1079,32 +1079,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1114,42 +1114,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_1.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1166,15 +1171,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1185,70 +1190,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_1.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1264,15 +1274,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1283,43 +1293,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -1349,31 +1359,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1383,15 +1393,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1469,16 +1479,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -1491,17 +1501,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1516,17 +1526,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1536,15 +1546,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1642,16 +1652,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1664,17 +1674,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1691,17 +1701,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1711,15 +1721,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1811,16 +1821,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1833,17 +1843,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1860,17 +1870,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1880,15 +1890,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1971,16 +1981,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1993,17 +2003,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2020,17 +2030,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2040,15 +2050,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2137,16 +2147,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyVerifyResult
@@ -2159,17 +2169,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2186,17 +2196,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2206,15 +2216,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2306,16 +2316,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -2328,17 +2338,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2355,17 +2365,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2375,15 +2385,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2469,16 +2479,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -2491,17 +2501,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2518,17 +2528,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2538,15 +2548,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2554,27 +2564,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_1.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2590,15 +2605,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2609,43 +2624,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2667,31 +2682,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2701,15 +2716,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2733,45 +2748,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2794,31 +2809,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2828,8 +2843,8 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     :keyword api_version: Api Version. Default value is "7.1". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.1")  # type: Literal["7.1"]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", "7.1")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_key_vault_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.1". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
@@ -62,9 +62,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -135,16 +135,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -157,17 +157,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -183,17 +183,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -203,15 +203,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -284,16 +284,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -306,17 +306,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -332,17 +332,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -352,15 +352,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -383,31 +383,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -417,15 +417,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -511,16 +511,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -533,17 +533,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -560,17 +560,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -580,15 +580,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -613,32 +613,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -648,42 +648,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_1.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -700,15 +705,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -719,70 +724,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_1.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -798,15 +808,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -817,43 +827,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -883,31 +893,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -917,15 +927,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1003,16 +1013,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyBundle
@@ -1025,17 +1035,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1050,17 +1060,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1070,15 +1080,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1176,16 +1186,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1198,17 +1208,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1225,17 +1235,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1245,15 +1255,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1345,16 +1355,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1367,17 +1377,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1394,17 +1404,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1414,15 +1424,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1505,16 +1515,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1527,17 +1537,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1554,17 +1564,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1574,15 +1584,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1671,16 +1681,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyVerifyResult
@@ -1693,17 +1703,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1720,17 +1730,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1740,15 +1750,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1840,16 +1850,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -1862,17 +1872,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1889,17 +1899,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1909,15 +1919,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2003,16 +2013,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_1.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_1.models.KeyOperationResult
@@ -2025,17 +2035,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2052,17 +2062,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2072,15 +2082,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2088,27 +2098,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_1.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2124,15 +2139,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2143,43 +2158,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2201,31 +2216,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2235,15 +2250,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2267,45 +2282,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2328,31 +2343,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.1"))  # type: Literal["7.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", _params.pop("api-version", "7.1"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2362,8 +2377,8 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_key_vault_client_enums.py`

 * *Files 10% similar despite different names*

```diff
@@ -12,63 +12,63 @@
 
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
@@ -88,49 +88,49 @@
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is not exportable from the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is not exportable from the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is not exportable from the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Not supported in this version. Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is not exportable from the HSM."""
     OCT = "oct"
+    """Not supported in this version. Octet sequence (used to represent symmetric keys)"""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 from ._key_vault_client_enums import DeletionRecoveryLevel
 from ._key_vault_client_enums import JsonWebKeyCurveName
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "BackupKeyResult",
     "DeletedKeyBundle",
     "DeletedKeyItem",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/models/_models_py3.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -84,15 +84,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyBundle(_serialization.Model):
     """A KeyBundle consisting of a WebKey plus its attributes.
@@ -123,16 +123,16 @@
 
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_1.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_1.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -186,16 +186,16 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_1.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_1.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -238,16 +238,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_1.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -301,16 +301,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_1.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -342,15 +342,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -374,15 +374,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -460,16 +460,16 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype kty: str or ~azure.keyvault.v7_1.models.JsonWebKeyType
@@ -568,16 +568,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -626,16 +626,16 @@
         *,
         kty: Union[str, "_models.JsonWebKeyType"],
         key_size: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype kty: str or ~azure.keyvault.v7_1.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword key_ops:
@@ -686,16 +686,16 @@
     def __init__(
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.v7_1.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.v7_1.models.KeyAttributes
@@ -727,15 +727,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -755,15 +755,15 @@
     }
 
     _attribute_map = {
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
 
 
 class KeyOperationsParameters(_serialization.Model):
@@ -784,15 +784,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", and "RSA1_5".
         :paramtype algorithm: str or ~azure.keyvault.v7_1.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         """
@@ -830,16 +832,16 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "_models.JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Not supported in this version. Indicates if the private key can be
          exported.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype key_type: str or ~azure.keyvault.v7_1.models.JsonWebKeyType
@@ -872,15 +874,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -905,15 +907,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
          "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_1.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
@@ -944,16 +948,16 @@
 
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.v7_1.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_1.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -978,15 +982,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
@@ -1017,16 +1021,16 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
          "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_1.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
@@ -1052,11 +1056,11 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,38 +9,38 @@
 # regenerated.
 # --------------------------------------------------------------------------
 from typing import Any
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from .._version import VERSION
+from ._version import VERSION
 
 class KeyVaultClientConfiguration(Configuration):
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
     """
 
     def __init__(
         self,
-        **kwargs  # type: Any
-    ) -> None:
+        **kwargs: Any
+    ):
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
 
         kwargs.setdefault('sdk_moniker', 'azure-keyvault/{}'.format(VERSION))
         self._configure(**kwargs)
 
     def _configure(
         self,
         **kwargs: Any
-    ) -> None:
+    ):
         self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get('http_logging_policy') or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get('authentication_policy')
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is
 # regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, Optional
 
-from azure.core import AsyncPipelineClient
+from azure.core import PipelineClient
 from azure.profiles import KnownProfiles, ProfileDefinition
 from azure.profiles.multiapiclient import MultiApiClientMixin
 
-from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from ._operations_mixin import KeyVaultClientOperationsMixin
+from ._serialization import Deserializer, Serializer
 
 class _SDKClient(object):
     def __init__(self, *args, **kwargs):
         """This is a fake class to support current implemetation of MultiApiClientMixin."
         Will be removed in final version of multiapi azure-core based client
         """
         pass
@@ -38,15 +38,15 @@
     group is not described in the profile.
     :param api_version: API version to use if no profile is provided, or if missing in profile.
     :type api_version: str
     :param profile: A profile definition, from KnownProfiles to dict.
     :type profile: azure.profiles.KnownProfiles
     """
 
-    DEFAULT_API_VERSION = '7.3'
+    DEFAULT_API_VERSION = '7.4'
     _PROFILE_TAG = "azure.keyvault.KeyVaultClient"
     LATEST_PROFILE = ProfileDefinition({
         _PROFILE_TAG: {
             None: DEFAULT_API_VERSION,
             'backup_certificate': '7.0',
             'backup_secret': '7.0',
             'backup_storage_account': '7.0',
@@ -108,24 +108,24 @@
             'update_storage_account': '7.0',
         }},
         _PROFILE_TAG + " latest"
     )
 
     def __init__(
         self,
-        api_version: Optional[str] = None,
-        profile: KnownProfiles = KnownProfiles.default,
-        **kwargs  # type: Any
-    ) -> None:
-        if api_version == '2016-10-01' or api_version == '7.0' or api_version == '7.1' or api_version == '7.2' or api_version == '7.3' or api_version == '7.4-preview.1':
+        api_version: Optional[str]=None,
+        profile: KnownProfiles=KnownProfiles.default,
+        **kwargs: Any
+    ):
+        if api_version == '2016-10-01' or api_version == '7.0' or api_version == '7.1' or api_version == '7.2' or api_version == '7.3' or api_version == '7.4':
             base_url = '{vaultBaseUrl}'
         else:
             raise ValueError("API version {} is not available".format(api_version))
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = PipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(KeyVaultClient, self).__init__(
             api_version=api_version,
             profile=profile
         )
 
     @classmethod
     def _models_dict(cls, api_version):
@@ -136,36 +136,36 @@
         """Module depends on the API version:
 
            * 2016-10-01: :mod:`v2016_10_01.models<azure.keyvault.v2016_10_01.models>`
            * 7.0: :mod:`v7_0.models<azure.keyvault.v7_0.models>`
            * 7.1: :mod:`v7_1.models<azure.keyvault.v7_1.models>`
            * 7.2: :mod:`v7_2.models<azure.keyvault.v7_2.models>`
            * 7.3: :mod:`v7_3.models<azure.keyvault.v7_3.models>`
-           * 7.4-preview.1: :mod:`v7_4_preview_1.models<azure.keyvault.v7_4_preview_1.models>`
+           * 7.4: :mod:`v7_4.models<azure.keyvault.v7_4.models>`
         """
         if api_version == '2016-10-01':
-            from ..v2016_10_01 import models
+            from .v2016_10_01 import models
             return models
         elif api_version == '7.0':
-            from ..v7_0 import models
+            from .v7_0 import models
             return models
         elif api_version == '7.1':
-            from ..v7_1 import models
+            from .v7_1 import models
             return models
         elif api_version == '7.2':
-            from ..v7_2 import models
+            from .v7_2 import models
             return models
         elif api_version == '7.3':
-            from ..v7_3 import models
+            from .v7_3 import models
             return models
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1 import models
+        elif api_version == '7.4':
+            from .v7_4 import models
             return models
         raise ValueError("API version {} is not available".format(api_version))
 
-    async def close(self):
-        await self._client.close()
-    async def __aenter__(self):
-        await self._client.__aenter__()
+    def close(self):
+        self._client.close()
+    def __enter__(self):
+        self._client.__enter__()
         return self
-    async def __aexit__(self, *exc_details):
-        await self._client.__aexit__(*exc_details)
+    def __exit__(self, *exc_details):
+        self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/aio/_operations_mixin.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/aio/_operations_mixin.py`

 * *Files 3% similar despite different names*

```diff
@@ -75,30 +75,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupKeyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.BackupKeyResult
+        :rtype: ~azure.keyvault.v7_4.models.BackupKeyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('backup_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'backup_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -188,16 +188,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateOperation
@@ -235,38 +235,38 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters or IO
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('create_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'create_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -296,38 +296,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('decrypt')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'decrypt'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -493,30 +493,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to delete. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('delete_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'delete_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -651,38 +651,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('encrypt')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'encrypt'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -809,16 +809,21 @@
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -923,16 +928,21 @@
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -961,16 +971,21 @@
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1038,16 +1053,21 @@
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1082,30 +1102,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_deleted_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1130,30 +1150,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.DeletedKeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_deleted_keys')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_deleted_keys'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1210,16 +1230,21 @@
         The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSasDefinitionItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedSasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1283,16 +1308,21 @@
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1355,16 +1385,21 @@
         """Lists deleted storage accounts for the specified vault.
 
         The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted
         for a vault enabled for soft-delete. This operation requires the storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedStorageAccountItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_0.models.DeletedStorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -1401,30 +1436,30 @@
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key. This
          URI fragment is optional. If not specified, the latest version of the key is returned.
          Required.
         :type key_version: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1445,22 +1480,22 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in a given key vault. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key_rotation_policy')
         if api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key_rotation_policy'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1485,30 +1520,30 @@
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_key_versions')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_key_versions'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1532,30 +1567,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_keys')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_keys'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1571,30 +1606,30 @@
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest or IO
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_random_bytes')
         if api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_random_bytes'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1649,16 +1684,21 @@
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1729,16 +1769,21 @@
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_secret_versions')
@@ -1767,16 +1812,21 @@
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_secrets')
@@ -1836,16 +1886,21 @@
         **kwargs: Any
     ) -> AsyncIterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -1879,16 +1934,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -1926,38 +1981,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters or IO
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('import_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'import_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -1978,16 +2033,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -2074,16 +2129,16 @@
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'purge_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2216,30 +2271,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the deleted key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('recover_deleted_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'recover_deleted_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2366,16 +2421,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -2413,30 +2468,30 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters or IO
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('release')
         if api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'release'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2453,16 +2508,16 @@
         """Restores a backed up certificate to a vault.
 
         Restores a backed up certificate, and all its versions, to a vault. This operation requires the
         certificates/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to restore the certificate. Is either a
+         CertificateRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.CertificateRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.CertificateBundle
@@ -2499,38 +2554,38 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters or IO
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('restore_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'restore_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2547,16 +2602,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2587,16 +2642,16 @@
         """Restores a backed up storage account to a vault.
 
         Restores a backed up storage account to a vault. This operation requires the storage/restore
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the storage account. Is either a model type or a
-         IO type. Required.
+        :param parameters: The parameters to restore the storage account. Is either a
+         StorageRestoreParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_0.models.StorageRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_0.models.StorageBundle
@@ -2631,22 +2686,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to be rotated. The system will generate a new version in the
          specified key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('rotate_key')
         if api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'rotate_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2663,15 +2718,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v2016_10_01.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -2706,16 +2761,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -2750,16 +2805,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -2794,16 +2849,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2834,16 +2889,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -2881,38 +2936,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters or IO
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('sign')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'sign'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2937,38 +2992,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('unwrap_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'unwrap_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -2992,16 +3047,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -3035,16 +3090,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -3078,16 +3133,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation:
          ~azure.keyvault.v2016_10_01.models.CertificateOperationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -3122,16 +3177,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
@@ -3170,38 +3225,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters or IO
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('update_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'update_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3221,30 +3276,30 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy or IO
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('update_key_rotation_policy')
         if api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'update_key_rotation_policy'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3265,16 +3320,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -3312,16 +3367,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -3353,16 +3408,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -3402,38 +3457,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters or IO
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('verify')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'verify'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -3460,38 +3515,38 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('wrap_key')
         if api_version == '2016-10-01':
             from ..v2016_10_01.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.0':
             from ..v7_0.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.1':
             from ..v7_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'wrap_key'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,26 +29,23 @@
     :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.2")  # type: Literal["7.2"]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", "7.2")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/operations/_key_vault_client_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -67,25 +67,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -94,50 +94,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -146,49 +146,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -197,15 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -218,40 +218,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -264,26 +264,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -292,26 +292,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -320,26 +320,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -348,26 +348,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -376,26 +376,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -404,26 +404,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -432,15 +432,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -453,72 +453,72 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -601,16 +601,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -623,17 +623,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -649,17 +649,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -669,15 +669,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -750,16 +750,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -772,17 +772,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -798,17 +798,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -818,15 +818,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -849,31 +849,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -883,15 +883,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -977,16 +977,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -999,17 +999,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1026,17 +1026,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1046,15 +1046,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -1079,32 +1079,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1114,42 +1114,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1166,15 +1171,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1185,70 +1190,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1264,15 +1274,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1283,43 +1293,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -1349,31 +1359,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1383,15 +1393,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1469,16 +1479,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -1491,17 +1501,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1516,17 +1526,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1536,15 +1546,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1642,16 +1652,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1664,17 +1674,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1691,17 +1701,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1711,15 +1721,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1811,16 +1821,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1833,17 +1843,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1860,17 +1870,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1880,15 +1890,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1971,16 +1981,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1993,17 +2003,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2020,17 +2030,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2040,15 +2050,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2137,16 +2147,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyVerifyResult
@@ -2159,17 +2169,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2186,17 +2196,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2206,15 +2216,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2306,16 +2316,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -2328,17 +2338,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2355,17 +2365,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2375,15 +2385,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2469,16 +2479,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -2491,17 +2501,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2518,17 +2528,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2538,15 +2548,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2554,27 +2564,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2590,15 +2605,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2609,43 +2624,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2667,31 +2682,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2701,15 +2716,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2733,45 +2748,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2794,31 +2809,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2828,8 +2843,8 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -22,22 +22,22 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.2")  # type: Literal["7.2"]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", "7.4")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -26,17 +26,17 @@
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
@@ -62,9 +62,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_key_vault_client_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -135,16 +135,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -157,17 +157,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -183,17 +183,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -203,15 +203,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -284,16 +284,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -306,17 +306,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -332,17 +332,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -352,15 +352,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -383,31 +383,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -417,15 +417,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -511,16 +511,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -533,17 +533,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -560,17 +560,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -580,15 +580,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -613,32 +613,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -648,42 +648,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -700,15 +705,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -719,70 +724,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -798,15 +808,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -817,43 +827,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -883,31 +893,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -917,15 +927,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1003,16 +1013,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyBundle
@@ -1025,17 +1035,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1050,17 +1060,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1070,15 +1080,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1176,16 +1186,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1198,17 +1208,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1225,17 +1235,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1245,15 +1255,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1345,16 +1355,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1367,17 +1377,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1394,17 +1404,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1414,15 +1424,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1505,16 +1515,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1527,17 +1537,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1554,17 +1564,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1574,15 +1584,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1671,16 +1681,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyVerifyResult
@@ -1693,17 +1703,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1720,17 +1730,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1740,15 +1750,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1840,16 +1850,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -1862,17 +1872,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1889,17 +1899,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1909,15 +1919,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2003,16 +2013,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.KeyOperationResult
@@ -2025,17 +2035,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2052,17 +2062,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2072,15 +2082,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2088,27 +2098,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2124,15 +2139,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2143,43 +2158,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2201,31 +2216,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2235,15 +2250,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2267,45 +2282,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2328,31 +2343,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2362,8 +2377,8 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,69 +6,79 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
+class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The type of the action."""
+
+    ROTATE = "rotate"
+    """Rotate the key based on the key policy."""
+    NOTIFY = "notify"
+    """Trigger event grid events. For preview, the notification time is not configurable and it is
+    #: default to 30 days before expiry."""
+
+
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
@@ -93,58 +103,67 @@
     ENCRYPT = "encrypt"
     DECRYPT = "decrypt"
     SIGN = "sign"
     VERIFY = "verify"
     WRAP_KEY = "wrapKey"
     UNWRAP_KEY = "unwrapKey"
     IMPORT = "import"
+    EXPORT = "export"
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is not exportable from the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is stored in the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is not exportable from the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is stored in the HSM."""
     OCT = "oct"
-    #: Octet sequence (used to represent symmetric keys) which is not exportable from the HSM.
+    """Octet sequence (used to represent symmetric keys)"""
     OCT_HSM = "oct-HSM"
+    """Octet sequence (used to represent symmetric keys) which is stored the HSM."""
+
+
+class KeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The encryption algorithm to use to protected the exported key material."""
+
+    CKM_RSA_AES_KEY_WRAP = "CKM_RSA_AES_KEY_WRAP"
+    RSA_AES_KEY_WRAP256 = "RSA_AES_KEY_WRAP_256"
+    RSA_AES_KEY_WRAP384 = "RSA_AES_KEY_WRAP_384"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 from ._key_vault_client_enums import DeletionRecoveryLevel
 from ._key_vault_client_enums import JsonWebKeyCurveName
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "BackupKeyResult",
     "DeletedKeyBundle",
     "DeletedKeyItem",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/models/_models_py3.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -84,15 +84,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyBundle(_serialization.Model):
     """A KeyBundle consisting of a WebKey plus its attributes.
@@ -123,16 +123,16 @@
 
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_2.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -186,16 +186,16 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_2.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -238,16 +238,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -301,16 +301,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -342,15 +342,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -374,15 +374,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -460,16 +460,16 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.v7_2.models.JsonWebKeyType
@@ -568,16 +568,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -593,15 +593,16 @@
     All required parameters must be populated in order to send to Azure.
 
     :ivar kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
      values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
     :vartype kty: str or ~azure.keyvault.v7_2.models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
-    :ivar public_exponent: The public exponent for a RSA key.
+    :ivar public_exponent: The public exponent for a RSA key. This applies only to keys created in
+     a Managed HSM.
     :vartype public_exponent: int
     :ivar key_ops:
     :vartype key_ops: list[str or ~azure.keyvault.v7_2.models.JsonWebKeyOperation]
     :ivar key_attributes: The attributes of a key managed by the key vault service.
     :vartype key_attributes: ~azure.keyvault.v7_2.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
@@ -630,23 +631,24 @@
         kty: Union[str, "_models.JsonWebKeyType"],
         key_size: Optional[int] = None,
         public_exponent: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.v7_2.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
-        :keyword public_exponent: The public exponent for a RSA key.
+        :keyword public_exponent: The public exponent for a RSA key. This applies only to keys created
+         in a Managed HSM.
         :paramtype public_exponent: int
         :keyword key_ops:
         :paramtype key_ops: list[str or ~azure.keyvault.v7_2.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -693,16 +695,16 @@
     def __init__(
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.v7_2.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.v7_2.models.KeyAttributes
@@ -734,15 +736,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -774,15 +776,15 @@
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
         "iv": {"key": "iv", "type": "base64"},
         "authentication_tag": {"key": "tag", "type": "base64"},
         "additional_authenticated_data": {"key": "aad", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
         self.iv = None
         self.authentication_tag = None
         self.additional_authenticated_data = None
@@ -825,16 +827,16 @@
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"],
         value: bytes,
         iv: Optional[bytes] = None,
         aad: Optional[bytes] = None,
         tag: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW", "A192KW", "A256KW",
          "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD", and "A256CBCPAD".
         :paramtype algorithm: str or ~azure.keyvault.v7_2.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
@@ -884,16 +886,16 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "_models.JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Not supported in this version. Indicates if the private key can be
          exported.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype key_type: str or ~azure.keyvault.v7_2.models.JsonWebKeyType
@@ -926,15 +928,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -959,15 +961,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
          "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_2.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
@@ -998,16 +1002,16 @@
 
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.v7_2.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_2.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -1032,15 +1036,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
@@ -1071,16 +1075,16 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
          "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_2.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
@@ -1106,11 +1110,11 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -22,33 +22,30 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "2016-10-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2016-10-01")  # type: Literal["2016-10-01"]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", "7.3")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -26,17 +26,17 @@
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_key_vault_client_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -67,25 +67,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -94,50 +94,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -146,49 +146,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -197,15 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -218,40 +218,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -264,26 +264,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -292,26 +292,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -320,26 +320,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -348,26 +348,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -376,26 +376,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -404,26 +404,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -432,15 +432,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -453,97 +453,97 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -552,50 +552,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/{secret-version}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
         "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -604,40 +604,40 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/{secret-version}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
         "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets")
 
     # Construct parameters
     if maxresults is not None:
@@ -652,24 +652,24 @@
 
 def build_get_secret_versions_request(
     secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/versions")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -678,15 +678,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets")
 
     # Construct parameters
     if maxresults is not None:
@@ -699,112 +699,112 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedsecrets/{secret-name}/recover")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/{secret-name}/backup")
     path_format_arguments = {
         "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_secret_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/secrets/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -817,15 +817,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificates_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates")
 
     # Construct parameters
     if maxresults is not None:
@@ -838,40 +838,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -884,15 +884,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -903,15 +903,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/contacts")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -922,15 +922,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_issuers_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers")
 
     # Construct parameters
     if maxresults is not None:
@@ -943,25 +943,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -970,25 +970,25 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -997,73 +997,73 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/issuers/{issuer-name}")
     path_format_arguments = {
         "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/create")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1072,25 +1072,25 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/import")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1101,24 +1101,24 @@
 
 def build_get_certificate_versions_request(
     certificate_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/versions")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -1127,49 +1127,49 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/policy")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/policy")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1178,26 +1178,26 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_request(certificate_name: str, certificate_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/{certificate-version}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
         "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1206,50 +1206,50 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_request(certificate_name: str, certificate_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/{certificate-version}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
         "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1258,73 +1258,73 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_merge_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/certificates/{certificate-name}/pending/merge")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1333,15 +1333,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_certificates_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates")
 
     # Construct parameters
     if maxresults is not None:
@@ -1354,87 +1354,87 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedcertificates/{certificate-name}/recover")
     path_format_arguments = {
         "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_storage_accounts_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage")
 
     # Construct parameters
     if maxresults is not None:
@@ -1447,79 +1447,79 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1528,27 +1528,27 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1557,27 +1557,27 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_regenerate_storage_account_key_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/regeneratekey")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1588,26 +1588,26 @@
 
 def build_get_sas_definitions_request(
     storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -1618,88 +1618,88 @@
 
 def build_delete_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_sas_definition_request(storage_account_name: str, sas_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_set_sas_definition_request(storage_account_name: str, sas_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1710,30 +1710,30 @@
 
 def build_update_sas_definition_request(
     storage_account_name: str, sas_definition_name: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/storage/{storage-account-name}/sas/{sas-definition-name}")
     path_format_arguments = {
         "storage-account-name": _SERIALIZER.url(
             "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
         "sas-definition-name": _SERIALIZER.url(
             "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
         ),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -1818,16 +1818,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -1840,17 +1840,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1866,17 +1866,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1886,15 +1886,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -1967,16 +1967,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -1989,17 +1989,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2015,17 +2015,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2035,15 +2035,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -2066,31 +2066,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2100,15 +2100,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2194,16 +2194,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -2216,17 +2216,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2243,17 +2243,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2263,15 +2263,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -2295,32 +2295,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2330,42 +2330,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2382,15 +2387,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2401,70 +2406,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2480,15 +2490,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2499,43 +2509,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -2565,31 +2575,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2599,15 +2609,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -2685,16 +2695,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -2707,17 +2717,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2732,17 +2742,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2752,15 +2762,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2858,16 +2868,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -2880,17 +2890,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2907,17 +2917,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2927,15 +2937,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3027,16 +3037,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -3049,17 +3059,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3076,17 +3086,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3096,15 +3106,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3187,16 +3197,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -3209,17 +3219,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3236,17 +3246,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3256,15 +3266,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3353,16 +3363,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyVerifyResult
@@ -3375,17 +3385,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3402,17 +3412,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3422,15 +3432,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3522,16 +3532,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -3544,17 +3554,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3571,17 +3581,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3591,15 +3601,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -3685,16 +3695,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -3707,17 +3717,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3734,17 +3744,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3754,15 +3764,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -3770,27 +3780,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3806,15 +3821,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3825,43 +3840,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -3883,31 +3898,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3917,15 +3932,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -3949,45 +3964,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -4010,31 +4025,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4044,15 +4059,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @overload
     def set_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         parameters: _models.SecretSetParameters,
@@ -4122,16 +4137,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -4144,17 +4159,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4170,17 +4185,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4190,15 +4205,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    set_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @distributed_trace
     def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Deletes a secret from a specified key vault.
 
         The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
         to an individual version of a secret. This operation requires the secrets/delete permission.
@@ -4219,31 +4234,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_delete_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.delete_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4253,15 +4268,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    delete_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @overload
     def update_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         secret_version: str,
@@ -4344,16 +4359,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -4366,17 +4381,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4393,17 +4408,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4413,15 +4428,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secret(
         self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Get a specified secret from a given key vault.
 
@@ -4446,32 +4461,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_secret_request(
             secret_name=secret_name,
             secret_version=secret_version,
             api_version=api_version,
             template_url=self.get_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4481,41 +4496,46 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SecretItem"]:
         """List secrets in a specified key vault.
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4531,15 +4551,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4550,70 +4570,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_secrets.metadata = {"url": "/secrets"}  # type: ignore
+    get_secrets.metadata = {"url": "/secrets"}
 
     @distributed_trace
     def get_secret_versions(
         self, vault_base_url: str, secret_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SecretItem"]:
         """List all versions of the specified secret.
 
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4630,15 +4655,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4649,68 +4674,73 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}  # type: ignore
+    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}
 
     @distributed_trace
     def get_deleted_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedSecretItem"]:
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4726,15 +4756,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4745,43 +4775,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}  # type: ignore
+    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}
 
     @distributed_trace
     def get_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Gets the specified deleted secret.
 
         The Get Deleted Secret operation returns the specified deleted secret along with its
         attributes. This operation requires the secrets/get permission.
@@ -4802,31 +4832,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.get_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4836,15 +4866,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace
     def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified secret.
 
@@ -4868,45 +4898,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.purge_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace
     def recover_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.SecretBundle:
         """Recovers the deleted secret to the latest version.
 
         Recovers the deleted secret in the specified vault. This operation can only be performed on a
         soft-delete enabled vault. This operation requires the secrets/recover permission.
@@ -4927,31 +4957,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.recover_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4961,15 +4991,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}  # type: ignore
+    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}
 
     @distributed_trace
     def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.BackupSecretResult:
         """Backs up the specified secret.
 
         Requests that a backup of the specified secret be downloaded to the client. All versions of the
         secret will be downloaded. This operation requires the secrets/backup permission.
@@ -4990,31 +5020,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupSecretResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.BackupSecretResult] = kwargs.pop("cls", None)
 
         request = build_backup_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.backup_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5024,15 +5054,15 @@
         deserialized = self._deserialize("BackupSecretResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}  # type: ignore
+    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}
 
     @overload
     def restore_secret(
         self,
         vault_base_url: str,
         parameters: _models.SecretRestoreParameters,
         *,
@@ -5086,16 +5116,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -5108,17 +5138,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5133,17 +5163,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5153,40 +5183,45 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_secret.metadata = {"url": "/secrets/restore"}  # type: ignore
+    restore_secret.metadata = {"url": "/secrets/restore"}
 
     @distributed_trace
     def get_certificates(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.CertificateItem"]:
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5202,15 +5237,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5221,43 +5256,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificates.metadata = {"url": "/certificates"}  # type: ignore
+    get_certificates.metadata = {"url": "/certificates"}
 
     @distributed_trace
     def delete_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Deletes a certificate from a specified key vault.
 
@@ -5281,31 +5316,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5315,15 +5350,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}  # type: ignore
+    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}
 
     @overload
     def set_certificate_contacts(
         self, vault_base_url: str, contacts: _models.Contacts, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Contacts:
         """Sets the certificate contacts for the specified key vault.
 
@@ -5372,15 +5407,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v2016_10_01.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -5394,17 +5429,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(contacts, (IO, bytes)):
             _content = contacts
         else:
@@ -5419,17 +5454,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5439,15 +5474,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Lists the certificate contacts for a specified key vault.
 
         The GetCertificateContacts operation returns the set of certificate contact resources in the
         specified key vault. This operation requires the certificates/managecontacts permission.
@@ -5466,30 +5501,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_get_certificate_contacts_request(
             api_version=api_version,
             template_url=self.get_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5499,15 +5534,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def delete_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Deletes the certificate contacts for a specified key vault.
 
         Deletes the certificate contacts for a specified key vault certificate. This operation requires
         the certificates/managecontacts permission.
@@ -5526,30 +5561,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_contacts_request(
             api_version=api_version,
             template_url=self.delete_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5559,42 +5594,47 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_issuers(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.CertificateIssuerItem"]:
         """List certificate issuers for a specified key vault.
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateIssuerListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateIssuerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5610,15 +5650,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5629,43 +5669,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateIssuerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}  # type: ignore
+    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}
 
     @overload
     def set_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerSetParameters,
@@ -5736,16 +5776,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -5758,17 +5798,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -5784,17 +5824,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5804,15 +5844,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     def update_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerUpdateParameters,
@@ -5883,16 +5923,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -5905,17 +5945,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -5931,17 +5971,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5951,15 +5991,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace
     def get_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> _models.IssuerBundle:
         """Lists the specified certificate issuer.
 
         The GetCertificateIssuer operation returns the specified certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
@@ -5981,31 +6021,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.get_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6015,15 +6055,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace
     def delete_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> _models.IssuerBundle:
         """Deletes the specified certificate issuer.
 
         The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from
         the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
@@ -6044,31 +6084,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.delete_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6078,15 +6118,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     def create_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateCreateParameters,
@@ -6157,16 +6197,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateOperation
@@ -6179,17 +6219,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6205,17 +6245,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6225,15 +6265,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}  # type: ignore
+    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}
 
     @overload
     def import_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateImportParameters,
@@ -6310,16 +6350,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -6332,17 +6372,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6358,17 +6398,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6378,42 +6418,47 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}  # type: ignore
+    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}
 
     @distributed_trace
     def get_certificate_versions(
         self, vault_base_url: str, certificate_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.CertificateItem"]:
         """List the versions of a certificate.
 
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6430,15 +6475,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6449,43 +6494,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}  # type: ignore
+    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}
 
     @distributed_trace
     def get_certificate_policy(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificatePolicy:
         """Lists the policy for a certificate.
 
@@ -6508,31 +6553,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         request = build_get_certificate_policy_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6542,15 +6587,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     def update_certificate_policy(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_policy: _models.CertificatePolicy,
@@ -6621,16 +6666,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
@@ -6643,17 +6688,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_policy, (IO, bytes)):
             _content = certificate_policy
         else:
@@ -6669,17 +6714,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6689,15 +6734,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     def update_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_version: str,
@@ -6780,16 +6825,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -6802,17 +6847,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6829,17 +6874,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6849,15 +6894,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @distributed_trace
     def get_certificate(
         self, vault_base_url: str, certificate_name: str, certificate_version: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Gets information about a certificate.
 
@@ -6882,32 +6927,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_request(
             certificate_name=certificate_name,
             certificate_version=certificate_version,
             api_version=api_version,
             template_url=self.get_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6917,15 +6962,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @overload
     def update_certificate_operation(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_operation: _models.CertificateOperationUpdateParameter,
@@ -6997,16 +7042,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation:
          ~azure.keyvault.v2016_10_01.models.CertificateOperationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -7020,17 +7065,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_operation, (IO, bytes)):
             _content = certificate_operation
         else:
@@ -7046,17 +7091,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7066,15 +7111,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace
     def get_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Gets the creation operation of a certificate.
 
@@ -7097,31 +7142,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_get_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7131,15 +7176,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace
     def delete_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Deletes the creation operation for a specific certificate.
 
@@ -7163,31 +7208,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7197,15 +7242,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @overload
     def merge_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateMergeParameters,
@@ -7279,16 +7324,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -7301,17 +7346,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7327,17 +7372,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7347,43 +7392,48 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}  # type: ignore
+    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}
 
     @distributed_trace
     def get_deleted_certificates(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedCertificateItem"]:
         """Lists the deleted certificates in the specified vault currently available for recovery.
 
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -7399,15 +7449,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -7418,43 +7468,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedCertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}  # type: ignore
+    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}
 
     @distributed_trace
     def get_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Retrieves information about the specified deleted certificate.
 
@@ -7478,31 +7528,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7512,15 +7562,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace
     def purge_deleted_certificate(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified deleted certificate.
 
@@ -7544,45 +7594,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.purge_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace
     def recover_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Recovers the deleted certificate back to its current version under /certificates.
 
@@ -7607,31 +7657,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.recover_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7641,38 +7691,43 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}  # type: ignore
+    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}
 
     @distributed_trace
     def get_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -7688,15 +7743,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -7707,43 +7762,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("StorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_storage_accounts.metadata = {"url": "/storage"}  # type: ignore
+    get_storage_accounts.metadata = {"url": "/storage"}
 
     @distributed_trace
     def delete_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Deletes a storage account. This operation requires the storage/delete permission.
 
@@ -7763,31 +7818,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_delete_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.delete_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7797,15 +7852,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @distributed_trace
     def get_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Gets information about a specified storage account. This operation requires the storage/get
         permission.
@@ -7826,31 +7881,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7860,15 +7915,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def set_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountCreateParameters,
@@ -7930,16 +7985,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -7952,17 +8007,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7978,17 +8033,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7998,15 +8053,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def update_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountUpdateParameters,
@@ -8071,16 +8126,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -8093,17 +8148,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8119,17 +8174,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8139,15 +8194,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     def regenerate_storage_account_key(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountRegenerteKeyParameters,
@@ -8212,16 +8267,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -8234,17 +8289,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8260,17 +8315,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8280,40 +8335,45 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}  # type: ignore
+    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}
 
     @distributed_trace
     def get_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.SasDefinitionItem"]:
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v2016_10_01.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -8330,15 +8390,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -8349,43 +8409,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("SasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}  # type: ignore
+    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}
 
     @distributed_trace
     def delete_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Deletes a SAS definition from a specified storage account. This operation requires the
         storage/deletesas permission.
@@ -8408,32 +8468,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_delete_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.delete_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8443,15 +8503,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace
     def get_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Gets information about a SAS definition for the specified storage account. This operation
         requires the storage/getsas permission.
@@ -8474,32 +8534,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8509,15 +8569,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     def set_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -8591,16 +8651,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -8613,17 +8673,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8640,17 +8700,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8660,15 +8720,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     def update_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -8742,16 +8802,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -8764,17 +8824,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -8791,17 +8851,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -8811,8 +8871,8 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/_configuration.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,30 +22,30 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "2016-10-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.0". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "2016-10-01")  # type: Literal["2016-10-01"]
+        api_version: Literal["7.0"] = kwargs.pop("api_version", "7.0")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_key_vault_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -26,17 +26,17 @@
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
@@ -62,9 +62,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -183,16 +183,16 @@
         keys/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -205,17 +205,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -231,17 +231,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -251,15 +251,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -332,16 +332,16 @@
         named key already exists, Azure Key Vault creates a new version of the key. This operation
         requires the keys/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -354,17 +354,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -380,17 +380,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -400,15 +400,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -431,31 +431,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -465,15 +465,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -559,16 +559,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -581,17 +581,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -608,17 +608,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -628,15 +628,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -660,32 +660,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -695,42 +695,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -747,15 +752,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -766,70 +771,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -845,15 +855,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -864,43 +874,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -930,31 +940,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -964,15 +974,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1050,16 +1060,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyBundle
@@ -1072,17 +1082,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1097,17 +1107,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1117,15 +1127,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1223,16 +1233,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -1245,17 +1255,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1272,17 +1282,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1292,15 +1302,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1392,16 +1402,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -1414,17 +1424,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1441,17 +1451,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1461,15 +1471,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1552,16 +1562,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -1574,17 +1584,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1601,17 +1611,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1621,15 +1631,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1718,16 +1728,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyVerifyResult
@@ -1740,17 +1750,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1767,17 +1777,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1787,15 +1797,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1887,16 +1897,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -1909,17 +1919,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1936,17 +1946,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1956,15 +1966,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2050,16 +2060,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.KeyOperationResult
@@ -2072,17 +2082,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2099,17 +2109,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2119,15 +2129,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2135,28 +2145,33 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2172,15 +2187,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2191,43 +2206,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2249,31 +2264,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2283,15 +2298,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2315,45 +2330,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2376,31 +2391,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2410,15 +2425,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @overload
     async def set_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         parameters: _models.SecretSetParameters,
@@ -2488,16 +2503,16 @@
         Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param parameters: The parameters for setting the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for setting the secret. Is either a SecretSetParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2510,17 +2525,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2536,17 +2551,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2556,15 +2571,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    set_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @distributed_trace_async
     async def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.DeletedSecretBundle:
         """Deletes a secret from a specified key vault.
 
         The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
         to an individual version of a secret. This operation requires the secrets/delete permission.
@@ -2585,31 +2600,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_delete_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.delete_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2619,15 +2634,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_secret.metadata = {"url": "/secrets/{secret-name}"}  # type: ignore
+    delete_secret.metadata = {"url": "/secrets/{secret-name}"}
 
     @overload
     async def update_secret(
         self,
         vault_base_url: str,
         secret_name: str,
         secret_version: str,
@@ -2710,16 +2725,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
         :param secret_version: The version of the secret. Required.
         :type secret_version: str
-        :param parameters: The parameters for update secret operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for update secret operation. Is either a
+         SecretUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -2732,17 +2747,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2759,17 +2774,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2779,15 +2794,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    update_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace_async
     async def get_secret(
         self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Get a specified secret from a given key vault.
 
@@ -2812,32 +2827,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_secret_request(
             secret_name=secret_name,
             secret_version=secret_version,
             api_version=api_version,
             template_url=self.get_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2847,41 +2862,46 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}  # type: ignore
+    get_secret.metadata = {"url": "/secrets/{secret-name}/{secret-version}"}
 
     @distributed_trace
     def get_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SecretItem"]:
         """List secrets in a specified key vault.
 
         The Get Secrets operation is applicable to the entire vault. However, only the base secret
         identifier and its attributes are provided in the response. Individual secret versions are not
         listed in the response. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2897,15 +2917,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2916,70 +2936,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_secrets.metadata = {"url": "/secrets"}  # type: ignore
+    get_secrets.metadata = {"url": "/secrets"}
 
     @distributed_trace
     def get_secret_versions(
         self, vault_base_url: str, secret_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SecretItem"]:
         """List all versions of the specified secret.
 
         The full secret identifier and attributes are provided in the response. No values are returned
         for the secrets. This operations requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param secret_name: The name of the secret. Required.
         :type secret_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified, the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SecretItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2996,15 +3021,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3015,69 +3040,74 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}  # type: ignore
+    get_secret_versions.metadata = {"url": "/secrets/{secret-name}/versions"}
 
     @distributed_trace
     def get_deleted_secrets(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedSecretItem"]:
         """Lists deleted secrets for the specified vault.
 
         The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
         enabled for soft-delete. This operation requires the secrets/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedSecretItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.DeletedSecretItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3093,15 +3123,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3112,43 +3142,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedSecretListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}  # type: ignore
+    get_deleted_secrets.metadata = {"url": "/deletedsecrets"}
 
     @distributed_trace_async
     async def get_deleted_secret(
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> _models.DeletedSecretBundle:
         """Gets the specified deleted secret.
 
@@ -3171,31 +3201,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedSecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedSecretBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.get_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3205,15 +3235,15 @@
         deserialized = self._deserialize("DeletedSecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    get_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace_async
     async def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified secret.
 
@@ -3237,45 +3267,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.purge_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}  # type: ignore
+    purge_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}"}
 
     @distributed_trace_async
     async def recover_deleted_secret(
         self, vault_base_url: str, secret_name: str, **kwargs: Any
     ) -> _models.SecretBundle:
         """Recovers the deleted secret to the latest version.
 
@@ -3298,31 +3328,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.recover_deleted_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3332,15 +3362,15 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}  # type: ignore
+    recover_deleted_secret.metadata = {"url": "/deletedsecrets/{secret-name}/recover"}
 
     @distributed_trace_async
     async def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> _models.BackupSecretResult:
         """Backs up the specified secret.
 
         Requests that a backup of the specified secret be downloaded to the client. All versions of the
         secret will be downloaded. This operation requires the secrets/backup permission.
@@ -3361,31 +3391,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupSecretResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.BackupSecretResult] = kwargs.pop("cls", None)
 
         request = build_backup_secret_request(
             secret_name=secret_name,
             api_version=api_version,
             template_url=self.backup_secret.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3395,15 +3425,15 @@
         deserialized = self._deserialize("BackupSecretResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}  # type: ignore
+    backup_secret.metadata = {"url": "/secrets/{secret-name}/backup"}
 
     @overload
     async def restore_secret(
         self,
         vault_base_url: str,
         parameters: _models.SecretRestoreParameters,
         *,
@@ -3457,16 +3487,16 @@
         """Restores a backed up secret to a vault.
 
         Restores a backed up secret, and all its versions, to a vault. This operation requires the
         secrets/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the secret. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the secret. Is either a SecretRestoreParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SecretRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SecretBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SecretBundle
@@ -3479,17 +3509,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SecretBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SecretBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3504,17 +3534,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3524,41 +3554,46 @@
         deserialized = self._deserialize("SecretBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_secret.metadata = {"url": "/secrets/restore"}  # type: ignore
+    restore_secret.metadata = {"url": "/secrets/restore"}
 
     @distributed_trace
     def get_certificates(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.CertificateItem"]:
         """List certificates in a specified key vault.
 
         The GetCertificates operation returns the set of certificates resources in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3574,15 +3609,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3593,43 +3628,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificates.metadata = {"url": "/certificates"}  # type: ignore
+    get_certificates.metadata = {"url": "/certificates"}
 
     @distributed_trace_async
     async def delete_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Deletes a certificate from a specified key vault.
 
@@ -3653,31 +3688,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3687,15 +3722,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}  # type: ignore
+    delete_certificate.metadata = {"url": "/certificates/{certificate-name}"}
 
     @overload
     async def set_certificate_contacts(
         self, vault_base_url: str, contacts: _models.Contacts, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.Contacts:
         """Sets the certificate contacts for the specified key vault.
 
@@ -3744,15 +3779,15 @@
         """Sets the certificate contacts for the specified key vault.
 
         Sets the certificate contacts for the specified key vault. This operation requires the
         certificates/managecontacts permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param contacts: The contacts for the key vault certificate. Is either a model type or a IO
+        :param contacts: The contacts for the key vault certificate. Is either a Contacts type or a IO
          type. Required.
         :type contacts: ~azure.keyvault.v2016_10_01.models.Contacts or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Contacts or the result of cls(response)
@@ -3766,17 +3801,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(contacts, (IO, bytes)):
             _content = contacts
         else:
@@ -3791,17 +3826,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3811,15 +3846,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    set_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace_async
     async def get_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Lists the certificate contacts for a specified key vault.
 
         The GetCertificateContacts operation returns the set of certificate contact resources in the
         specified key vault. This operation requires the certificates/managecontacts permission.
@@ -3838,30 +3873,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_get_certificate_contacts_request(
             api_version=api_version,
             template_url=self.get_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3871,15 +3906,15 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    get_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace_async
     async def delete_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> _models.Contacts:
         """Deletes the certificate contacts for a specified key vault.
 
         Deletes the certificate contacts for a specified key vault certificate. This operation requires
         the certificates/managecontacts permission.
@@ -3898,30 +3933,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Contacts]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.Contacts] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_contacts_request(
             api_version=api_version,
             template_url=self.delete_certificate_contacts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3931,43 +3966,48 @@
         deserialized = self._deserialize("Contacts", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}  # type: ignore
+    delete_certificate_contacts.metadata = {"url": "/certificates/contacts"}
 
     @distributed_trace
     def get_certificate_issuers(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.CertificateIssuerItem"]:
         """List certificate issuers for a specified key vault.
 
         The GetCertificateIssuers operation returns the set of certificate issuer resources in the
         specified key vault. This operation requires the certificates/manageissuers/getissuers
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateIssuerItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateIssuerItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateIssuerListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateIssuerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3983,15 +4023,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4002,43 +4042,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateIssuerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}  # type: ignore
+    get_certificate_issuers.metadata = {"url": "/certificates/issuers"}
 
     @overload
     async def set_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerSetParameters,
@@ -4109,16 +4149,16 @@
         The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
         operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer set parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer set parameter. Is either a CertificateIssuerSetParameters
+         type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerSetParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -4131,17 +4171,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -4157,17 +4197,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4177,15 +4217,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    set_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     async def update_certificate_issuer(
         self,
         vault_base_url: str,
         issuer_name: str,
         parameter: _models.CertificateIssuerUpdateParameters,
@@ -4256,16 +4296,16 @@
         The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
         entity. This operation requires the certificates/setissuers permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param issuer_name: The name of the issuer. Required.
         :type issuer_name: str
-        :param parameter: Certificate issuer update parameter. Is either a model type or a IO type.
-         Required.
+        :param parameter: Certificate issuer update parameter. Is either a
+         CertificateIssuerUpdateParameters type or a IO type. Required.
         :type parameter: ~azure.keyvault.v2016_10_01.models.CertificateIssuerUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: IssuerBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.IssuerBundle
@@ -4278,17 +4318,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameter, (IO, bytes)):
             _content = parameter
         else:
@@ -4304,17 +4344,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4324,15 +4364,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    update_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace_async
     async def get_certificate_issuer(
         self, vault_base_url: str, issuer_name: str, **kwargs: Any
     ) -> _models.IssuerBundle:
         """Lists the specified certificate issuer.
 
@@ -4356,31 +4396,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.get_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4390,15 +4430,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    get_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @distributed_trace_async
     async def delete_certificate_issuer(
         self, vault_base_url: str, issuer_name: str, **kwargs: Any
     ) -> _models.IssuerBundle:
         """Deletes the specified certificate issuer.
 
@@ -4421,31 +4461,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.IssuerBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.IssuerBundle] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_issuer_request(
             issuer_name=issuer_name,
             api_version=api_version,
             template_url=self.delete_certificate_issuer.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4455,15 +4495,15 @@
         deserialized = self._deserialize("IssuerBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}  # type: ignore
+    delete_certificate_issuer.metadata = {"url": "/certificates/issuers/{issuer-name}"}
 
     @overload
     async def create_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateCreateParameters,
@@ -4534,16 +4574,16 @@
         If this is the first version, the certificate resource is created. This operation requires the
         certificates/create permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to create a certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a certificate. Is either a
+         CertificateCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateOperation
@@ -4556,17 +4596,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4582,17 +4622,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4602,15 +4642,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}  # type: ignore
+    create_certificate.metadata = {"url": "/certificates/{certificate-name}/create"}
 
     @overload
     async def import_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateImportParameters,
@@ -4687,16 +4727,16 @@
         format the PEM file must contain the key as well as x509 certificates. This operation requires
         the certificates/import permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to import the certificate. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to import the certificate. Is either a
+         CertificateImportParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -4709,17 +4749,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -4735,17 +4775,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4755,43 +4795,48 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}  # type: ignore
+    import_certificate.metadata = {"url": "/certificates/{certificate-name}/import"}
 
     @distributed_trace
     def get_certificate_versions(
         self, vault_base_url: str, certificate_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.CertificateItem"]:
         """List the versions of a certificate.
 
         The GetCertificateVersions operation returns the versions of a certificate in the specified key
         vault. This operation requires the certificates/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either CertificateItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.CertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -4808,15 +4853,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -4827,43 +4872,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("CertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}  # type: ignore
+    get_certificate_versions.metadata = {"url": "/certificates/{certificate-name}/versions"}
 
     @distributed_trace_async
     async def get_certificate_policy(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificatePolicy:
         """Lists the policy for a certificate.
 
@@ -4886,31 +4931,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         request = build_get_certificate_policy_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -4920,15 +4965,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    get_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     async def update_certificate_policy(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_policy: _models.CertificatePolicy,
@@ -4999,16 +5044,16 @@
         Set specified members in the certificate policy. Leave others as null. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given vault. Required.
         :type certificate_name: str
-        :param certificate_policy: The policy for the certificate. Is either a model type or a IO type.
-         Required.
+        :param certificate_policy: The policy for the certificate. Is either a CertificatePolicy type
+         or a IO type. Required.
         :type certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificatePolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
@@ -5021,17 +5066,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificatePolicy]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificatePolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_policy, (IO, bytes)):
             _content = certificate_policy
         else:
@@ -5047,17 +5092,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5067,15 +5112,15 @@
         deserialized = self._deserialize("CertificatePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}  # type: ignore
+    update_certificate_policy.metadata = {"url": "/certificates/{certificate-name}/policy"}
 
     @overload
     async def update_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_version: str,
@@ -5158,16 +5203,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate in the given key vault. Required.
         :type certificate_name: str
         :param certificate_version: The version of the certificate. Required.
         :type certificate_version: str
-        :param parameters: The parameters for certificate update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for certificate update. Is either a
+         CertificateUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -5180,17 +5225,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5207,17 +5252,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5227,15 +5272,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    update_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @distributed_trace_async
     async def get_certificate(
         self, vault_base_url: str, certificate_name: str, certificate_version: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Gets information about a certificate.
 
@@ -5260,32 +5305,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_certificate_request(
             certificate_name=certificate_name,
             certificate_version=certificate_version,
             api_version=api_version,
             template_url=self.get_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5295,15 +5340,15 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}  # type: ignore
+    get_certificate.metadata = {"url": "/certificates/{certificate-name}/{certificate-version}"}
 
     @overload
     async def update_certificate_operation(
         self,
         vault_base_url: str,
         certificate_name: str,
         certificate_operation: _models.CertificateOperationUpdateParameter,
@@ -5375,16 +5420,16 @@
         Updates a certificate creation operation that is already in progress. This operation requires
         the certificates/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param certificate_operation: The certificate operation response. Is either a model type or a
-         IO type. Required.
+        :param certificate_operation: The certificate operation response. Is either a
+         CertificateOperationUpdateParameter type or a IO type. Required.
         :type certificate_operation:
          ~azure.keyvault.v2016_10_01.models.CertificateOperationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateOperation or the result of cls(response)
@@ -5398,17 +5443,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(certificate_operation, (IO, bytes)):
             _content = certificate_operation
         else:
@@ -5424,17 +5469,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5444,15 +5489,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    update_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace_async
     async def get_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Gets the creation operation of a certificate.
 
@@ -5475,31 +5520,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_get_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5509,15 +5554,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    get_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @distributed_trace_async
     async def delete_certificate_operation(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateOperation:
         """Deletes the creation operation for a specific certificate.
 
@@ -5541,31 +5586,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateOperation]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateOperation] = kwargs.pop("cls", None)
 
         request = build_delete_certificate_operation_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.delete_certificate_operation.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5575,15 +5620,15 @@
         deserialized = self._deserialize("CertificateOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}  # type: ignore
+    delete_certificate_operation.metadata = {"url": "/certificates/{certificate-name}/pending"}
 
     @overload
     async def merge_certificate(
         self,
         vault_base_url: str,
         certificate_name: str,
         parameters: _models.CertificateMergeParameters,
@@ -5657,16 +5702,16 @@
         a key pair currently available in the service. This operation requires the certificates/create
         permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param certificate_name: The name of the certificate. Required.
         :type certificate_name: str
-        :param parameters: The parameters to merge certificate. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to merge certificate. Is either a CertificateMergeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.CertificateMergeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CertificateBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.CertificateBundle
@@ -5679,17 +5724,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -5705,17 +5750,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5725,44 +5770,49 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}  # type: ignore
+    merge_certificate.metadata = {"url": "/certificates/{certificate-name}/pending/merge"}
 
     @distributed_trace
     def get_deleted_certificates(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedCertificateItem"]:
         """Lists the deleted certificates in the specified vault currently available for recovery.
 
         The GetDeletedCertificates operation retrieves the certificates in the current vault which are
         in a deleted state and ready for recovery or purging. This operation includes deletion-specific
         information. This operation requires the certificates/get/list permission. This operation can
         only be enabled on soft-delete enabled vaults.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedCertificateItem or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.DeletedCertificateItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -5778,15 +5828,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -5797,43 +5847,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedCertificateListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}  # type: ignore
+    get_deleted_certificates.metadata = {"url": "/deletedcertificates"}
 
     @distributed_trace_async
     async def get_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.DeletedCertificateBundle:
         """Retrieves information about the specified deleted certificate.
 
@@ -5857,31 +5907,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedCertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.DeletedCertificateBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.get_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -5891,15 +5941,15 @@
         deserialized = self._deserialize("DeletedCertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    get_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace_async
     async def purge_deleted_certificate(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified deleted certificate.
 
@@ -5923,45 +5973,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.purge_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}  # type: ignore
+    purge_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}"}
 
     @distributed_trace_async
     async def recover_deleted_certificate(
         self, vault_base_url: str, certificate_name: str, **kwargs: Any
     ) -> _models.CertificateBundle:
         """Recovers the deleted certificate back to its current version under /certificates.
 
@@ -5986,31 +6036,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.CertificateBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.CertificateBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_certificate_request(
             certificate_name=certificate_name,
             api_version=api_version,
             template_url=self.recover_deleted_certificate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6020,39 +6070,44 @@
         deserialized = self._deserialize("CertificateBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}  # type: ignore
+    recover_deleted_certificate.metadata = {"url": "/deletedcertificates/{certificate-name}/recover"}
 
     @distributed_trace
     def get_storage_accounts(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.StorageAccountItem"]:
         """List storage accounts managed by the specified key vault. This operation requires the
         storage/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either StorageAccountItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.StorageAccountItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6068,15 +6123,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6087,43 +6142,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("StorageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_storage_accounts.metadata = {"url": "/storage"}  # type: ignore
+    get_storage_accounts.metadata = {"url": "/storage"}
 
     @distributed_trace_async
     async def delete_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Deletes a storage account. This operation requires the storage/delete permission.
 
@@ -6143,31 +6198,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_delete_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.delete_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6177,15 +6232,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    delete_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @distributed_trace_async
     async def get_storage_account(
         self, vault_base_url: str, storage_account_name: str, **kwargs: Any
     ) -> _models.StorageBundle:
         """Gets information about a specified storage account. This operation requires the storage/get
         permission.
@@ -6206,31 +6261,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         request = build_get_storage_account_request(
             storage_account_name=storage_account_name,
             api_version=api_version,
             template_url=self.get_storage_account.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6240,15 +6295,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    get_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def set_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountCreateParameters,
@@ -6310,16 +6365,16 @@
     ) -> _models.StorageBundle:
         """Creates or updates a new storage account. This operation requires the storage/set permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to create a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a storage account. Is either a
+         StorageAccountCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -6332,17 +6387,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6358,17 +6413,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6378,15 +6433,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    set_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def update_storage_account(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountUpdateParameters,
@@ -6451,16 +6506,16 @@
         """Updates the specified attributes associated with the given storage account. This operation
         requires the storage/set/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to update a storage account. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a storage account. Is either a
+         StorageAccountUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -6473,17 +6528,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6499,17 +6554,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6519,15 +6574,15 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}  # type: ignore
+    update_storage_account.metadata = {"url": "/storage/{storage-account-name}"}
 
     @overload
     async def regenerate_storage_account_key(
         self,
         vault_base_url: str,
         storage_account_name: str,
         parameters: _models.StorageAccountRegenerteKeyParameters,
@@ -6592,16 +6647,16 @@
         """Regenerates the specified key value for the given storage account. This operation requires the
         storage/regeneratekey permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param parameters: The parameters to regenerate storage account key. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters to regenerate storage account key. Is either a
+         StorageAccountRegenerteKeyParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.StorageAccountRegenerteKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: StorageBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.StorageBundle
@@ -6614,17 +6669,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.StorageBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.StorageBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -6640,17 +6695,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6660,41 +6715,46 @@
         deserialized = self._deserialize("StorageBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}  # type: ignore
+    regenerate_storage_account_key.metadata = {"url": "/storage/{storage-account-name}/regeneratekey"}
 
     @distributed_trace
     def get_sas_definitions(
         self, vault_base_url: str, storage_account_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.SasDefinitionItem"]:
         """List storage SAS definitions for the given storage account. This operation requires the
         storage/listsas permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SasDefinitionItem or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v2016_10_01.models.SasDefinitionItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionListResult]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -6711,15 +6771,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -6730,43 +6790,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SasDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}  # type: ignore
+    get_sas_definitions.metadata = {"url": "/storage/{storage-account-name}/sas"}
 
     @distributed_trace_async
     async def delete_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Deletes a SAS definition from a specified storage account. This operation requires the
         storage/deletesas permission.
@@ -6789,32 +6849,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_delete_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.delete_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6824,15 +6884,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    delete_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @distributed_trace_async
     async def get_sas_definition(
         self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
     ) -> _models.SasDefinitionBundle:
         """Gets information about a SAS definition for the specified storage account. This operation
         requires the storage/getsas permission.
@@ -6855,32 +6915,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         request = build_get_sas_definition_request(
             storage_account_name=storage_account_name,
             sas_definition_name=sas_definition_name,
             api_version=api_version,
             template_url=self.get_sas_definition.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -6890,15 +6950,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    get_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     async def set_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -6972,16 +7032,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to create a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to create a SAS definition. Is either a
+         SasDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -6994,17 +7054,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7021,17 +7081,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7041,15 +7101,15 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    set_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
 
     @overload
     async def update_sas_definition(
         self,
         vault_base_url: str,
         storage_account_name: str,
         sas_definition_name: str,
@@ -7123,16 +7183,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param storage_account_name: The name of the storage account. Required.
         :type storage_account_name: str
         :param sas_definition_name: The name of the SAS definition. Required.
         :type sas_definition_name: str
-        :param parameters: The parameters to update a SAS definition. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters to update a SAS definition. Is either a
+         SasDefinitionUpdateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v2016_10_01.models.SasDefinitionUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SasDefinitionBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v2016_10_01.models.SasDefinitionBundle
@@ -7145,17 +7205,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))  # type: Literal["2016-10-01"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SasDefinitionBundle]
+        api_version: Literal["2016-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2016-10-01"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SasDefinitionBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -7172,17 +7232,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -7192,8 +7252,8 @@
         deserialized = self._deserialize("SasDefinitionBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}  # type: ignore
+    update_sas_definition.metadata = {"url": "/storage/{storage-account-name}/sas/{sas-definition-name}"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_key_vault_client_enums.py`

 * *Files 5% similar despite different names*

```diff
@@ -19,39 +19,39 @@
 
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Soft-delete is not enabled for this vault. A DELETE operation results in immediate and
-    #: irreversible data loss.
     PURGEABLE = "Purgeable"
-    #: Soft-delete is enabled for this vault; A privileged user may trigger an immediate, irreversible
-    #: deletion(purge) of a deleted entity.
+    """Soft-delete is not enabled for this vault. A DELETE operation results in immediate and
+    #: irreversible data loss."""
     RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Soft-delete is enabled for this vault and purge has been disabled. A deleted entity will remain
-    #: in this state until recovered, or the end of the retention interval.
+    """Soft-delete is enabled for this vault; A privileged user may trigger an immediate, irreversible
+    #: deletion(purge) of a deleted entity."""
     RECOVERABLE = "Recoverable"
-    #: Soft-delete is enabled for this vault, and the subscription is protected against immediate
-    #: deletion.
+    """Soft-delete is enabled for this vault and purge has been disabled. A deleted entity will remain
+    #: in this state until recovered, or the end of the retention interval."""
     RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Soft-delete is enabled for this vault, and the subscription is protected against immediate
+    #: deletion."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     SECP256_K1 = "SECP256K1"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -91,15 +91,15 @@
 from ._key_vault_client_enums import JsonWebKeyCurveName
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._key_vault_client_enums import KeyUsageType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Action",
     "AdministratorDetails",
     "Attributes",
     "BackupKeyResult",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_models_py3.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -24,15 +24,15 @@
     :vartype action_type: str or ~azure.keyvault.v2016_10_01.models.ActionType
     """
 
     _attribute_map = {
         "action_type": {"key": "action_type", "type": "str"},
     }
 
-    def __init__(self, *, action_type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs):
+    def __init__(self, *, action_type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs: Any) -> None:
         """
         :keyword action_type: The type of the action. Known values are: "EmailContacts" and
          "AutoRenew".
         :paramtype action_type: str or ~azure.keyvault.v2016_10_01.models.ActionType
         """
         super().__init__(**kwargs)
         self.action_type = action_type
@@ -61,16 +61,16 @@
     def __init__(
         self,
         *,
         first_name: Optional[str] = None,
         last_name: Optional[str] = None,
         email_address: Optional[str] = None,
         phone: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword first_name: First name.
         :paramtype first_name: str
         :keyword last_name: Last name.
         :paramtype last_name: str
         :keyword email_address: Email address.
         :paramtype email_address: str
@@ -116,16 +116,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -151,15 +151,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class BackupSecretResult(_serialization.Model):
     """The backup secret result, containing the backup blob.
@@ -174,15 +174,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class CertificateAttributes(Attributes):
     """The certificate management attributes.
@@ -224,16 +224,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -290,16 +290,16 @@
     def __init__(
         self,
         *,
         cer: Optional[bytes] = None,
         content_type: Optional[str] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cer: CER contents of x509 certificate.
         :paramtype cer: bytes
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
         :keyword attributes: The certificate attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
@@ -337,16 +337,16 @@
 
     def __init__(
         self,
         *,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword certificate_policy: The management policy for the certificate.
         :paramtype certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -392,16 +392,16 @@
         self,
         *,
         base64_encoded_certificate: str,
         password: Optional[str] = None,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword base64_encoded_certificate: Base64 encoded representation of the certificate object to
          import. This certificate needs to contain the private key. Required.
         :paramtype base64_encoded_certificate: str
         :keyword password: If the private key in base64EncodedCertificate is encrypted, the password
          used for encryption.
         :paramtype password: str
@@ -431,16 +431,20 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "provider": {"key": "provider", "type": "str"},
     }
 
     def __init__(
-        self, *, id: Optional[str] = None, provider: Optional[str] = None, **kwargs  # pylint: disable=redefined-builtin
-    ):
+        self,
+        *,
+        id: Optional[str] = None,  # pylint: disable=redefined-builtin
+        provider: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate Identifier.
         :paramtype id: str
         :keyword provider: The issuer provider.
         :paramtype provider: str
         """
         super().__init__(**kwargs)
@@ -466,15 +470,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[CertificateIssuerItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class CertificateIssuerSetParameters(_serialization.Model):
@@ -506,16 +510,16 @@
     def __init__(
         self,
         *,
         provider: str,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider. Required.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v2016_10_01.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v2016_10_01.models.OrganizationDetails
@@ -552,16 +556,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v2016_10_01.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v2016_10_01.models.OrganizationDetails
@@ -598,16 +602,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         x509_thumbprint: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate identifier.
         :paramtype id: str
         :keyword attributes: The certificate management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -639,15 +643,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[CertificateItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class CertificateMergeParameters(_serialization.Model):
@@ -675,16 +679,16 @@
 
     def __init__(
         self,
         *,
         x509_certificates: List[bytes],
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword x509_certificates: The certificate or the certificate chain to merge. Required.
         :paramtype x509_certificates: list[bytes]
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -745,16 +749,16 @@
         csr: Optional[bytes] = None,
         cancellation_requested: Optional[bool] = None,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         target: Optional[str] = None,
         request_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword issuer_parameters: Parameters for the issuer of the X509 component of a certificate.
         :paramtype issuer_parameters: ~azure.keyvault.v2016_10_01.models.IssuerParameters
         :keyword csr: The certificate signing request (CSR) that is being used in the certificate
          operation.
         :paramtype csr: bytes
         :keyword cancellation_requested: Indicates if cancellation was requested on the certificate
@@ -797,15 +801,15 @@
         "cancellation_requested": {"required": True},
     }
 
     _attribute_map = {
         "cancellation_requested": {"key": "cancellation_requested", "type": "bool"},
     }
 
-    def __init__(self, *, cancellation_requested: bool, **kwargs):
+    def __init__(self, *, cancellation_requested: bool, **kwargs: Any) -> None:
         """
         :keyword cancellation_requested: Indicates if cancellation was requested on the certificate
          operation. Required.
         :paramtype cancellation_requested: bool
         """
         super().__init__(**kwargs)
         self.cancellation_requested = cancellation_requested
@@ -853,16 +857,16 @@
         *,
         key_properties: Optional["_models.KeyProperties"] = None,
         secret_properties: Optional["_models.SecretProperties"] = None,
         x509_certificate_properties: Optional["_models.X509CertificateProperties"] = None,
         lifetime_actions: Optional[List["_models.LifetimeAction"]] = None,
         issuer_parameters: Optional["_models.IssuerParameters"] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_properties: Properties of the key backing a certificate.
         :paramtype key_properties: ~azure.keyvault.v2016_10_01.models.KeyProperties
         :keyword secret_properties: Properties of the secret backing a certificate.
         :paramtype secret_properties: ~azure.keyvault.v2016_10_01.models.SecretProperties
         :keyword x509_certificate_properties: Properties of the X509 component of a certificate.
         :paramtype x509_certificate_properties:
@@ -904,16 +908,16 @@
 
     def __init__(
         self,
         *,
         certificate_policy: Optional["_models.CertificatePolicy"] = None,
         certificate_attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword certificate_policy: The management policy for the certificate.
         :paramtype certificate_policy: ~azure.keyvault.v2016_10_01.models.CertificatePolicy
         :keyword certificate_attributes: The attributes of the certificate (optional).
         :paramtype certificate_attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -938,16 +942,21 @@
     _attribute_map = {
         "email_address": {"key": "email", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "phone": {"key": "phone", "type": "str"},
     }
 
     def __init__(
-        self, *, email_address: Optional[str] = None, name: Optional[str] = None, phone: Optional[str] = None, **kwargs
-    ):
+        self,
+        *,
+        email_address: Optional[str] = None,
+        name: Optional[str] = None,
+        phone: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword email_address: Email address.
         :paramtype email_address: str
         :keyword name: Name.
         :paramtype name: str
         :keyword phone: Phone number.
         :paramtype phone: str
@@ -974,26 +983,27 @@
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "contact_list": {"key": "contacts", "type": "[Contact]"},
     }
 
-    def __init__(self, *, contact_list: Optional[List["_models.Contact"]] = None, **kwargs):
+    def __init__(self, *, contact_list: Optional[List["_models.Contact"]] = None, **kwargs: Any) -> None:
         """
         :keyword contact_list: The contact list for the vault certificates.
         :paramtype contact_list: list[~azure.keyvault.v2016_10_01.models.Contact]
         """
         super().__init__(**kwargs)
         self.id = None
         self.contact_list = contact_list
 
 
 class DeletedCertificateBundle(CertificateBundle):  # pylint: disable=too-many-instance-attributes
-    """A Deleted Certificate consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A Deleted Certificate consisting of its previous id, attributes and its tags, as well as
+    information on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The certificate id.
     :vartype id: str
     :ivar kid: The key id.
     :vartype kid: str
@@ -1049,16 +1059,16 @@
         self,
         *,
         cer: Optional[bytes] = None,
         content_type: Optional[str] = None,
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cer: CER contents of x509 certificate.
         :paramtype cer: bytes
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
         :keyword attributes: The certificate attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
@@ -1115,16 +1125,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.CertificateAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         x509_thumbprint: Optional[bytes] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Certificate identifier.
         :paramtype id: str
         :keyword attributes: The certificate management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.CertificateAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1158,15 +1168,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedCertificateItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyBundle(_serialization.Model):
@@ -1198,16 +1208,16 @@
 
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v2016_10_01.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1261,16 +1271,16 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v2016_10_01.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1313,16 +1323,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1376,16 +1386,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1417,15 +1427,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SecretBundle(_serialization.Model):
@@ -1470,16 +1480,16 @@
         self,
         *,
         value: Optional[str] = None,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         content_type: Optional[str] = None,
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The secret value.
         :paramtype value: str
         :keyword id: The secret id.
         :paramtype id: str
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
@@ -1495,15 +1505,16 @@
         self.attributes = attributes
         self.tags = tags
         self.kid = None
         self.managed = None
 
 
 class DeletedSecretBundle(SecretBundle):
-    """A Deleted Secret consisting of its previous id, attributes and its tags, as well as information on when it will be purged.
+    """A Deleted Secret consisting of its previous id, attributes and its tags, as well as information
+    on when it will be purged.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: The secret value.
     :vartype value: str
     :ivar id: The secret id.
     :vartype id: str
@@ -1553,16 +1564,16 @@
         *,
         value: Optional[str] = None,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         content_type: Optional[str] = None,
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The secret value.
         :paramtype value: str
         :keyword id: The secret id.
         :paramtype id: str
         :keyword content_type: The content type of the secret.
         :paramtype content_type: str
@@ -1613,16 +1624,16 @@
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Secret identifier.
         :paramtype id: str
         :keyword attributes: The secret management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1683,16 +1694,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Secret identifier.
         :paramtype id: str
         :keyword attributes: The secret management attributes.
         :paramtype attributes: ~azure.keyvault.v2016_10_01.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -1726,15 +1737,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedSecretItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -1758,15 +1769,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -1790,15 +1801,15 @@
 
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: Determines whether the issuer is enabled.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -1837,16 +1848,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         credentials: Optional["_models.IssuerCredentials"] = None,
         organization_details: Optional["_models.OrganizationDetails"] = None,
         attributes: Optional["_models.IssuerAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The issuer provider.
         :paramtype provider: str
         :keyword credentials: The credentials to be used for the issuer.
         :paramtype credentials: ~azure.keyvault.v2016_10_01.models.IssuerCredentials
         :keyword organization_details: Details of the organization as provided to the issuer.
         :paramtype organization_details: ~azure.keyvault.v2016_10_01.models.OrganizationDetails
@@ -1871,15 +1882,15 @@
     """
 
     _attribute_map = {
         "account_id": {"key": "account_id", "type": "str"},
         "password": {"key": "pwd", "type": "str"},
     }
 
-    def __init__(self, *, account_id: Optional[str] = None, password: Optional[str] = None, **kwargs):
+    def __init__(self, *, account_id: Optional[str] = None, password: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword account_id: The user name/account name/account id.
         :paramtype account_id: str
         :keyword password: The password/secret/account key.
         :paramtype password: str
         """
         super().__init__(**kwargs)
@@ -1898,15 +1909,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "certificate_type": {"key": "cty", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, certificate_type: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, certificate_type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: Name of the referenced issuer object or reserved names; for example, 'Self' or
          'Unknown'.
         :paramtype name: str
         :keyword certificate_type: Type of certificate to be requested from the issuer provider.
         :paramtype certificate_type: str
         """
@@ -1988,16 +1999,16 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey key type (kty). Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
          and "oct".
         :paramtype kty: str or ~azure.keyvault.v2016_10_01.models.JsonWebKeyType
         :keyword key_ops:
@@ -2089,16 +2100,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -2146,16 +2157,16 @@
         *,
         kty: Union[str, "_models.JsonWebKeyType"],
         key_size: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", and "oct".
         :paramtype kty: str or ~azure.keyvault.v2016_10_01.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword key_ops:
@@ -2206,16 +2217,16 @@
     def __init__(
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.v2016_10_01.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
@@ -2247,15 +2258,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -2275,15 +2286,15 @@
     }
 
     _attribute_map = {
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
 
 
 class KeyOperationsParameters(_serialization.Model):
@@ -2304,15 +2315,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", and "RSA1_5".
         :paramtype algorithm: str or ~azure.keyvault.v2016_10_01.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         """
@@ -2344,16 +2357,16 @@
     def __init__(
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[str] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Indicates if the private key can be exported.
         :paramtype exportable: bool
         :keyword key_type: The key type.
         :paramtype key_type: str
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
@@ -2380,15 +2393,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -2413,15 +2426,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
          "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ECDSA256".
         :paramtype algorithm: str or ~azure.keyvault.v2016_10_01.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
@@ -2452,16 +2467,16 @@
 
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.v2016_10_01.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v2016_10_01.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -2486,15 +2501,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
@@ -2525,16 +2540,16 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
          "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ECDSA256".
         :paramtype algorithm: str or ~azure.keyvault.v2016_10_01.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
@@ -2561,15 +2576,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class LifetimeAction(_serialization.Model):
     """Action and its trigger that will be performed by Key Vault over the lifetime of a certificate.
@@ -2582,16 +2597,16 @@
 
     _attribute_map = {
         "trigger": {"key": "trigger", "type": "Trigger"},
         "action": {"key": "action", "type": "Action"},
     }
 
     def __init__(
-        self, *, trigger: Optional["_models.Trigger"] = None, action: Optional["_models.Action"] = None, **kwargs
-    ):
+        self, *, trigger: Optional["_models.Trigger"] = None, action: Optional["_models.Action"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword trigger: The condition that will execute the action.
         :paramtype trigger: ~azure.keyvault.v2016_10_01.models.Trigger
         :keyword action: The action that will be executed.
         :paramtype action: ~azure.keyvault.v2016_10_01.models.Action
         """
         super().__init__(**kwargs)
@@ -2614,16 +2629,16 @@
     }
 
     def __init__(
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         admin_details: Optional[List["_models.AdministratorDetails"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: Id of the organization.
         :paramtype id: str
         :keyword admin_details: Details of the organization administrator.
         :paramtype admin_details: list[~azure.keyvault.v2016_10_01.models.AdministratorDetails]
         """
         super().__init__(**kwargs)
@@ -2644,15 +2659,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class SasDefinitionAttributes(_serialization.Model):
     """The SAS definition management attributes.
@@ -2674,15 +2689,15 @@
 
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: the enabled state of the object.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -2718,15 +2733,15 @@
         "id": {"key": "id", "type": "str"},
         "secret_id": {"key": "sid", "type": "str"},
         "parameters": {"key": "parameters", "type": "{str}"},
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.secret_id = None
         self.parameters = None
         self.attributes = None
         self.tags = None
@@ -2757,16 +2772,16 @@
 
     def __init__(
         self,
         *,
         parameters: Dict[str, str],
         sas_definition_attributes: Optional["_models.SasDefinitionAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword parameters: Sas definition creation metadata in the form of key-value pairs. Required.
         :paramtype parameters: dict[str, str]
         :keyword sas_definition_attributes: The attributes of the SAS definition.
         :paramtype sas_definition_attributes:
          ~azure.keyvault.v2016_10_01.models.SasDefinitionAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -2803,15 +2818,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "secret_id": {"key": "sid", "type": "str"},
         "attributes": {"key": "attributes", "type": "SasDefinitionAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.secret_id = None
         self.attributes = None
         self.tags = None
 
@@ -2834,15 +2849,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SasDefinitionItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SasDefinitionUpdateParameters(_serialization.Model):
@@ -2864,16 +2879,16 @@
 
     def __init__(
         self,
         *,
         parameters: Optional[Dict[str, str]] = None,
         sas_definition_attributes: Optional["_models.SasDefinitionAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword parameters: Sas definition update metadata in the form of key-value pairs.
         :paramtype parameters: dict[str, str]
         :keyword sas_definition_attributes: The attributes of the SAS definition.
         :paramtype sas_definition_attributes:
          ~azure.keyvault.v2016_10_01.models.SasDefinitionAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -2925,16 +2940,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -2961,15 +2976,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SecretItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SecretProperties(_serialization.Model):
@@ -2979,15 +2994,15 @@
     :vartype content_type: str
     """
 
     _attribute_map = {
         "content_type": {"key": "contentType", "type": "str"},
     }
 
-    def __init__(self, *, content_type: Optional[str] = None, **kwargs):
+    def __init__(self, *, content_type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword content_type: The media type (MIME type).
         :paramtype content_type: str
         """
         super().__init__(**kwargs)
         self.content_type = content_type
 
@@ -3005,15 +3020,15 @@
         "secret_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "secret_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, secret_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, secret_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword secret_bundle_backup: The backup blob associated with a secret bundle. Required.
         :paramtype secret_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.secret_bundle_backup = secret_bundle_backup
 
@@ -3047,16 +3062,16 @@
     def __init__(
         self,
         *,
         value: str,
         tags: Optional[Dict[str, str]] = None,
         content_type: Optional[str] = None,
         secret_attributes: Optional["_models.SecretAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword value: The value of the secret. Required.
         :paramtype value: str
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword content_type: Type of the secret value such as a password.
         :paramtype content_type: str
@@ -3089,16 +3104,16 @@
 
     def __init__(
         self,
         *,
         content_type: Optional[str] = None,
         secret_attributes: Optional["_models.SecretAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword content_type: Type of the secret value such as a password.
         :paramtype content_type: str
         :keyword secret_attributes: The secret management attributes.
         :paramtype secret_attributes: ~azure.keyvault.v2016_10_01.models.SecretAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -3129,15 +3144,15 @@
 
     _attribute_map = {
         "enabled": {"key": "enabled", "type": "bool"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, enabled: Optional[bool] = None, **kwargs):
+    def __init__(self, *, enabled: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword enabled: the enabled state of the object.
         :paramtype enabled: bool
         """
         super().__init__(**kwargs)
         self.enabled = enabled
         self.created = None
@@ -3185,16 +3200,16 @@
         *,
         resource_id: str,
         active_key_name: str,
         auto_regenerate_key: bool,
         regeneration_period: Optional[str] = None,
         storage_account_attributes: Optional["_models.StorageAccountAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword resource_id: Storage account resource id. Required.
         :paramtype resource_id: str
         :keyword active_key_name: Current active storage account key name. Required.
         :paramtype active_key_name: str
         :keyword auto_regenerate_key: whether keyvault should manage the storage account for the user.
          Required.
@@ -3241,15 +3256,15 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "resource_id": {"key": "resourceId", "type": "str"},
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.resource_id = None
         self.attributes = None
         self.tags = None
 
@@ -3267,15 +3282,15 @@
         "key_name": {"required": True},
     }
 
     _attribute_map = {
         "key_name": {"key": "keyName", "type": "str"},
     }
 
-    def __init__(self, *, key_name: str, **kwargs):
+    def __init__(self, *, key_name: str, **kwargs: Any) -> None:
         """
         :keyword key_name: The storage account key name. Required.
         :paramtype key_name: str
         """
         super().__init__(**kwargs)
         self.key_name = key_name
 
@@ -3308,16 +3323,16 @@
         self,
         *,
         active_key_name: Optional[str] = None,
         auto_regenerate_key: Optional[bool] = None,
         regeneration_period: Optional[str] = None,
         storage_account_attributes: Optional["_models.StorageAccountAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword active_key_name: The current active storage account key name.
         :paramtype active_key_name: str
         :keyword auto_regenerate_key: whether keyvault should manage the storage account for the user.
         :paramtype auto_regenerate_key: bool
         :keyword regeneration_period: The key regeneration time duration specified in ISO-8601 format.
         :paramtype regeneration_period: str
@@ -3372,15 +3387,15 @@
         "active_key_name": {"key": "activeKeyName", "type": "str"},
         "auto_regenerate_key": {"key": "autoRegenerateKey", "type": "bool"},
         "regeneration_period": {"key": "regenerationPeriod", "type": "str"},
         "attributes": {"key": "attributes", "type": "StorageAccountAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.resource_id = None
         self.active_key_name = None
         self.auto_regenerate_key = None
         self.regeneration_period = None
@@ -3406,15 +3421,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[StorageAccountItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class SubjectAlternativeNames(_serialization.Model):
@@ -3436,16 +3451,16 @@
 
     def __init__(
         self,
         *,
         emails: Optional[List[str]] = None,
         dns_names: Optional[List[str]] = None,
         upns: Optional[List[str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword emails: Email addresses.
         :paramtype emails: list[str]
         :keyword dns_names: Domain names.
         :paramtype dns_names: list[str]
         :keyword upns: User principal names.
         :paramtype upns: list[str]
@@ -3474,16 +3489,16 @@
 
     _attribute_map = {
         "lifetime_percentage": {"key": "lifetime_percentage", "type": "int"},
         "days_before_expiry": {"key": "days_before_expiry", "type": "int"},
     }
 
     def __init__(
-        self, *, lifetime_percentage: Optional[int] = None, days_before_expiry: Optional[int] = None, **kwargs
-    ):
+        self, *, lifetime_percentage: Optional[int] = None, days_before_expiry: Optional[int] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword lifetime_percentage: Percentage of lifetime at which to trigger. Value should be
          between 1 and 99.
         :paramtype lifetime_percentage: int
         :keyword days_before_expiry: Days before expiry to attempt renewal. Value should be between 1
          and validity_in_months multiplied by 27. If validity_in_months is 36, then value should be
          between 1 and 972 (36 * 27).
@@ -3525,16 +3540,16 @@
         self,
         *,
         subject: Optional[str] = None,
         ekus: Optional[List[str]] = None,
         subject_alternative_names: Optional["_models.SubjectAlternativeNames"] = None,
         key_usage: Optional[List[Union[str, "_models.KeyUsageType"]]] = None,
         validity_in_months: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword subject: The subject name. Should be a valid X509 distinguished Name.
         :paramtype subject: str
         :keyword ekus: The enhanced key usage.
         :paramtype ekus: list[str]
         :keyword subject_alternative_names: The subject alternative names.
         :paramtype subject_alternative_names:
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -22,31 +22,28 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.1". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.4-preview.1")  # type: Literal["7.4-preview.1"]
+        api_version: Literal["7.1"] = kwargs.pop("api_version", "7.1")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
         self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_key_vault_client.py`

 * *Files 7% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -40,27 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -69,53 +67,49 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_rotate_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotate")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -124,54 +118,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -180,53 +170,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -235,17 +221,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -258,44 +242,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -308,28 +288,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -338,28 +316,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -368,28 +344,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -398,28 +372,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -428,28 +400,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -458,28 +428,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -488,28 +456,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_release_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/release")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -518,17 +484,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -541,131 +505,121 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotationpolicy")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotationpolicy")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -674,18 +628,16 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_random_bytes_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/rng")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -719,21 +671,21 @@
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
         :param parameters: The parameters to create a key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyCreateParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_key(
         self,
         vault_base_url: str,
@@ -759,15 +711,15 @@
         :param parameters: The parameters to create a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyCreateParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -780,41 +732,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyCreateParameters or IO
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -830,17 +780,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -850,15 +800,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @distributed_trace
     def rotate_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Creates a new key version, stores it, then returns key parameters, attributes and policy to the
         client.
 
         The operation will rotate the key based on the key policy. It requires the keys/rotate
@@ -867,47 +817,45 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to be rotated. The system will generate a new version in the
          specified key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_rotate_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.rotate_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -917,15 +865,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}  # type: ignore
+    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -943,21 +891,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
         :param parameters: The parameters to import a key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyImportParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
@@ -983,15 +931,15 @@
         :param parameters: The parameters to import a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def import_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyImportParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1004,41 +952,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyImportParameters or IO
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1054,17 +1000,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1074,15 +1020,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -1091,47 +1037,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to delete. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1141,15 +1085,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1168,21 +1112,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
         :param parameters: The parameters of the key to update. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyUpdateParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
@@ -1209,15 +1153,15 @@
         :param parameters: The parameters of the key to update. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update_key(
         self,
         vault_base_url: str,
@@ -1235,41 +1179,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyUpdateParameters or IO
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1286,17 +1228,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1306,15 +1248,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -1325,48 +1267,46 @@
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key. This
          URI fragment is optional. If not specified, the latest version of the key is returned.
          Required.
         :type key_version: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1376,44 +1316,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4_preview_1.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1430,15 +1373,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1449,72 +1392,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4_preview_1.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1530,15 +1476,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1549,43 +1495,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -1601,47 +1547,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupKeyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.BackupKeyResult
+        :rtype: ~azure.keyvault.v7_3.models.BackupKeyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1651,15 +1595,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1678,21 +1622,21 @@
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The parameters to restore the key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyRestoreParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def restore_key(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1714,15 +1658,15 @@
         :param parameters: The parameters to restore the key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def restore_key(
         self, vault_base_url: str, parameters: Union[_models.KeyRestoreParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1737,41 +1681,39 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyRestoreParameters or IO
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1786,17 +1728,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1806,15 +1748,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1837,21 +1779,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the encryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
@@ -1882,15 +1824,15 @@
         :param parameters: The parameters for the encryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def encrypt(
         self,
         vault_base_url: str,
@@ -1912,41 +1854,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1963,17 +1903,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1983,15 +1923,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2015,21 +1955,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the decryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
@@ -2061,15 +2001,15 @@
         :param parameters: The parameters for the decryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def decrypt(
         self,
         vault_base_url: str,
@@ -2092,41 +2032,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2143,17 +2081,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2163,15 +2101,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2189,21 +2127,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the signing operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeySignParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def sign(
         self,
         vault_base_url: str,
@@ -2229,15 +2167,15 @@
         :param parameters: The parameters for the signing operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def sign(
         self,
         vault_base_url: str,
@@ -2254,41 +2192,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeySignParameters or IO
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2305,17 +2241,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2325,15 +2261,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2353,21 +2289,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for verify operations. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def verify(
         self,
         vault_base_url: str,
@@ -2395,15 +2331,15 @@
         :param parameters: The parameters for verify operations. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def verify(
         self,
         vault_base_url: str,
@@ -2422,41 +2358,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyParameters or IO
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2473,17 +2407,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2493,15 +2427,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2522,21 +2456,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for wrap operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
@@ -2565,15 +2499,15 @@
         :param parameters: The parameters for wrap operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def wrap_key(
         self,
         vault_base_url: str,
@@ -2593,41 +2527,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2644,17 +2576,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2664,15 +2596,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2691,21 +2623,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the key operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
@@ -2732,15 +2664,15 @@
         :param parameters: The parameters for the key operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def unwrap_key(
         self,
         vault_base_url: str,
@@ -2758,41 +2690,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2809,17 +2739,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2829,15 +2759,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @overload
     def release(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2855,21 +2785,21 @@
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
         :param parameters: The parameters for the key release operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseParameters
+        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def release(
         self,
         vault_base_url: str,
@@ -2895,15 +2825,15 @@
         :param parameters: The parameters for the key release operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def release(
         self,
         vault_base_url: str,
@@ -2920,41 +2850,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseParameters or IO
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyReleaseResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyReleaseResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2971,17 +2899,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2991,15 +2919,15 @@
         deserialized = self._deserialize("KeyReleaseResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}  # type: ignore
+    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -3007,29 +2935,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4_preview_1.models.DeletedKeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -3045,15 +2976,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -3064,43 +2995,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -3108,47 +3039,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3158,15 +3087,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -3190,47 +3119,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -3239,47 +3166,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the deleted key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3289,62 +3214,60 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @distributed_trace
     def get_key_rotation_policy(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyRotationPolicy:
         """Lists the policy for a key.
 
         The GetKeyRotationPolicy operation returns the specified key policy resources in the specified
         key vault. This operation requires the keys/get permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in a given key vault. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         request = build_get_key_rotation_policy_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_key_rotation_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3354,15 +3277,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
         key_name: str,
         key_rotation_policy: _models.KeyRotationPolicy,
@@ -3376,21 +3299,21 @@
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
         :param key_rotation_policy: The policy for the key. Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -3412,15 +3335,15 @@
         :param key_rotation_policy: The policy for the key. Required.
         :type key_rotation_policy: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -3433,41 +3356,39 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy or IO
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
+        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(key_rotation_policy, (IO, bytes)):
             _content = key_rotation_policy
         else:
@@ -3483,17 +3404,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3503,15 +3424,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     def get_random_bytes(
         self,
         vault_base_url: str,
         parameters: _models.GetRandomBytesRequest,
         *,
@@ -3521,21 +3442,21 @@
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The request object to get random bytes. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.GetRandomBytesRequest
+        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def get_random_bytes(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RandomBytes:
@@ -3548,55 +3469,53 @@
         :param parameters: The request object to get random bytes. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def get_random_bytes(
         self, vault_base_url: str, parameters: Union[_models.GetRandomBytesRequest, IO], **kwargs: Any
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.GetRandomBytesRequest or IO
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RandomBytes]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RandomBytes] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3611,17 +3530,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3631,8 +3550,8 @@
         deserialized = self._deserialize("RandomBytes", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_random_bytes.metadata = {"url": "/rng"}  # type: ignore
+    get_random_bytes.metadata = {"url": "/rng"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -22,30 +22,30 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.4-preview.1")  # type: Literal["7.4-preview.1"]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", "7.4")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_1/aio/_key_vault_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.1". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
@@ -62,9 +62,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -85,21 +85,21 @@
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
         :param parameters: The parameters to create a key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_key(
         self,
         vault_base_url: str,
@@ -125,15 +125,15 @@
         :param parameters: The parameters to create a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyCreateParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -146,41 +146,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyCreateParameters or IO
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -196,17 +194,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -216,15 +214,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @distributed_trace_async
     async def rotate_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Creates a new key version, stores it, then returns key parameters, attributes and policy to the
         client.
 
         The operation will rotate the key based on the key policy. It requires the keys/rotate
@@ -233,47 +231,45 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to be rotated. The system will generate a new version in the
          specified key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_rotate_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.rotate_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -283,15 +279,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}  # type: ignore
+    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -309,21 +305,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
         :param parameters: The parameters to import a key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyImportParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
@@ -349,15 +345,15 @@
         :param parameters: The parameters to import a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def import_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyImportParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -370,41 +366,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyImportParameters or IO
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -420,17 +414,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -440,15 +434,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -457,47 +451,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to delete. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -507,15 +499,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -534,21 +526,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
         :param parameters: The parameters of the key to update. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyUpdateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
@@ -575,15 +567,15 @@
         :param parameters: The parameters of the key to update. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update_key(
         self,
         vault_base_url: str,
@@ -601,41 +593,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyUpdateParameters or IO
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -652,17 +642,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -672,15 +662,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -691,48 +681,46 @@
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key. This
          URI fragment is optional. If not specified, the latest version of the key is returned.
          Required.
         :type key_version: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -742,15 +730,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
@@ -762,24 +750,22 @@
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4_preview_1.models.KeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -796,15 +782,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -815,43 +801,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
@@ -863,24 +849,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4_preview_1.models.KeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -896,15 +880,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -915,43 +899,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -967,47 +951,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupKeyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.BackupKeyResult
+        :rtype: ~azure.keyvault.v7_4.models.BackupKeyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1017,15 +999,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1044,21 +1026,21 @@
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The parameters to restore the key. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyRestoreParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def restore_key(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1080,15 +1062,15 @@
         :param parameters: The parameters to restore the key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def restore_key(
         self, vault_base_url: str, parameters: Union[_models.KeyRestoreParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1103,41 +1085,39 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyRestoreParameters or IO
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1152,17 +1132,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1172,15 +1152,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1203,21 +1183,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the encryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
@@ -1248,15 +1228,15 @@
         :param parameters: The parameters for the encryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def encrypt(
         self,
         vault_base_url: str,
@@ -1278,41 +1258,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1329,17 +1307,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1349,15 +1327,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1381,21 +1359,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the decryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
@@ -1427,15 +1405,15 @@
         :param parameters: The parameters for the decryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def decrypt(
         self,
         vault_base_url: str,
@@ -1458,41 +1436,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1509,17 +1485,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1529,15 +1505,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1555,21 +1531,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the signing operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeySignParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
@@ -1595,15 +1571,15 @@
         :param parameters: The parameters for the signing operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def sign(
         self,
         vault_base_url: str,
@@ -1620,41 +1596,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeySignParameters or IO
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1671,17 +1645,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1691,15 +1665,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1719,21 +1693,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for verify operations. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
@@ -1761,15 +1735,15 @@
         :param parameters: The parameters for verify operations. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def verify(
         self,
         vault_base_url: str,
@@ -1788,41 +1762,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyParameters or IO
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1839,17 +1811,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1859,15 +1831,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1888,21 +1860,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for wrap operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
@@ -1931,15 +1903,15 @@
         :param parameters: The parameters for wrap operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def wrap_key(
         self,
         vault_base_url: str,
@@ -1959,41 +1931,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2010,17 +1980,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2030,15 +2000,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2057,21 +2027,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the key operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
@@ -2098,15 +2068,15 @@
         :param parameters: The parameters for the key operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def unwrap_key(
         self,
         vault_base_url: str,
@@ -2124,41 +2094,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2175,17 +2143,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2195,15 +2163,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @overload
     async def release(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2221,21 +2189,21 @@
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
         :param parameters: The parameters for the key release operation. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def release(
         self,
         vault_base_url: str,
@@ -2261,15 +2229,15 @@
         :param parameters: The parameters for the key release operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def release(
         self,
         vault_base_url: str,
@@ -2286,41 +2254,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseParameters or IO
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyReleaseResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyReleaseResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2337,17 +2303,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2357,15 +2323,15 @@
         deserialized = self._deserialize("KeyReleaseResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}  # type: ignore
+    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2378,25 +2344,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4_preview_1.models.DeletedKeyItem]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2412,15 +2375,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2431,43 +2394,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2475,47 +2438,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2525,15 +2486,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2557,47 +2518,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2606,47 +2565,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the deleted key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2656,15 +2613,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @distributed_trace_async
     async def get_key_rotation_policy(
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> _models.KeyRotationPolicy:
         """Lists the policy for a key.
 
@@ -2673,47 +2630,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in a given key vault. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         request = build_get_key_rotation_policy_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_key_rotation_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2723,15 +2678,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     async def update_key_rotation_policy(
         self,
         vault_base_url: str,
         key_name: str,
         key_rotation_policy: _models.KeyRotationPolicy,
@@ -2745,21 +2700,21 @@
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
         :param key_rotation_policy: The policy for the key. Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -2781,15 +2736,15 @@
         :param key_rotation_policy: The policy for the key. Required.
         :type key_rotation_policy: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -2802,41 +2757,39 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy or IO
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(key_rotation_policy, (IO, bytes)):
             _content = key_rotation_policy
         else:
@@ -2852,17 +2805,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2872,15 +2825,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     async def get_random_bytes(
         self,
         vault_base_url: str,
         parameters: _models.GetRandomBytesRequest,
         *,
@@ -2890,21 +2843,21 @@
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The request object to get random bytes. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.GetRandomBytesRequest
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def get_random_bytes(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RandomBytes:
@@ -2917,55 +2870,53 @@
         :param parameters: The request object to get random bytes. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def get_random_bytes(
         self, vault_base_url: str, parameters: Union[_models.GetRandomBytesRequest, IO], **kwargs: Any
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.GetRandomBytesRequest or IO
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RandomBytes]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RandomBytes] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2980,17 +2931,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3000,8 +2951,8 @@
         deserialized = self._deserialize("RandomBytes", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_random_bytes.metadata = {"url": "/rng"}  # type: ignore
+    get_random_bytes.metadata = {"url": "/rng"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v2016_10_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_key_vault_client_enums.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,78 +9,76 @@
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
 class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of the action."""
 
-    #: Rotate the key based on the key policy.
     ROTATE = "rotate"
-    #: Trigger event grid events. For preview, the notification time is not configurable and it is
-    #: default to 30 days before expiry.
+    """Rotate the key based on the key policy."""
     NOTIFY = "notify"
+    """Trigger event grid events. For preview, the notification time is not configurable and it is
+    #: default to 30 days before expiry."""
 
 
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
-    #: The Ed25519 Edwards curve.
-    ED25519 = "Ed25519"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
@@ -113,65 +111,58 @@
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
-    #: Edwards-Curve Digital Signature Algorithm, as described in https://tools.ietf.org/html/rfc8032.
-    ED_DSA = "EdDSA"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is stored in the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is stored in the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is stored in the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is stored in the HSM."""
     OCT = "oct"
-    #: Octet sequence (used to represent symmetric keys) which is stored the HSM.
+    """Octet sequence (used to represent symmetric keys)"""
     OCT_HSM = "oct-HSM"
-    #: Octet key pair (https://tools.ietf.org/html/rfc8037)
-    OKP = "OKP"
-    #: Octet key pair (https://tools.ietf.org/html/rfc8037) with a private key which is stored in the
-    #: HSM.
-    OKP_HSM = "OKP-HSM"
+    """Octet sequence (used to represent symmetric keys) which is stored the HSM."""
 
 
 class KeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The encryption algorithm to use to protected the exported key material."""
 
     CKM_RSA_AES_KEY_WRAP = "CKM_RSA_AES_KEY_WRAP"
     RSA_AES_KEY_WRAP256 = "RSA_AES_KEY_WRAP_256"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -45,15 +45,15 @@
 from ._key_vault_client_enums import JsonWebKeyCurveName
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._key_vault_client_enums import KeyEncryptionAlgorithm
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "BackupKeyResult",
     "DeletedKeyBundle",
     "DeletedKeyItem",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_4_preview_1/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_models_py3.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -84,36 +84,36 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyBundle(_serialization.Model):
     """A KeyBundle consisting of a WebKey plus its attributes.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar key: The Json web key.
-    :vartype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+    :vartype key: ~azure.keyvault.v7_4.models.JsonWebKey
     :ivar attributes: The key management attributes.
-    :vartype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar managed: True if the key's lifetime is managed by key vault. If this is a key backing a
      certificate, then managed will be true.
     :vartype managed: bool
     :ivar release_policy: The policy rules under which the key can be exported.
-    :vartype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+    :vartype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
     """
 
     _validation = {
         "managed": {"readonly": True},
     }
 
     _attribute_map = {
@@ -127,25 +127,25 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
-        :paramtype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+        :paramtype key: ~azure.keyvault.v7_4.models.JsonWebKey
         :keyword attributes: The key management attributes.
-        :paramtype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
         """
         super().__init__(**kwargs)
         self.key = key
         self.attributes = attributes
         self.tags = tags
         self.managed = None
         self.release_policy = release_policy
@@ -153,24 +153,24 @@
 
 class DeletedKeyBundle(KeyBundle):
     """A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion info.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar key: The Json web key.
-    :vartype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+    :vartype key: ~azure.keyvault.v7_4.models.JsonWebKey
     :ivar attributes: The key management attributes.
-    :vartype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar managed: True if the key's lifetime is managed by key vault. If this is a key backing a
      certificate, then managed will be true.
     :vartype managed: bool
     :ivar release_policy: The policy rules under which the key can be exported.
-    :vartype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+    :vartype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
     :ivar recovery_id: The url of the recovery object, used to identify and recover the deleted
      key.
     :vartype recovery_id: str
     :ivar scheduled_purge_date: The time when the key is scheduled to be purged, in UTC.
     :vartype scheduled_purge_date: ~datetime.datetime
     :ivar deleted_date: The time when the key was deleted, in UTC.
     :vartype deleted_date: ~datetime.datetime
@@ -197,25 +197,25 @@
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
-        :paramtype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+        :paramtype key: ~azure.keyvault.v7_4.models.JsonWebKey
         :keyword attributes: The key management attributes.
-        :paramtype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          key.
         :paramtype recovery_id: str
         """
         super().__init__(key=key, attributes=attributes, tags=tags, release_policy=release_policy, **kwargs)
         self.recovery_id = recovery_id
         self.scheduled_purge_date = None
@@ -226,15 +226,15 @@
     """The key item containing key metadata.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar kid: Key identifier.
     :vartype kid: str
     :ivar attributes: The key management attributes.
-    :vartype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar managed: True if the key's lifetime is managed by key vault. If this is a key backing a
      certificate, then managed will be true.
     :vartype managed: bool
     """
 
@@ -251,21 +251,21 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
-        :paramtype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.kid = kid
         self.attributes = attributes
         self.tags = tags
@@ -276,15 +276,15 @@
     """The deleted key item containing the deleted key metadata and information about deletion.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar kid: Key identifier.
     :vartype kid: str
     :ivar attributes: The key management attributes.
-    :vartype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar managed: True if the key's lifetime is managed by key vault. If this is a key backing a
      certificate, then managed will be true.
     :vartype managed: bool
     :ivar recovery_id: The url of the recovery object, used to identify and recover the deleted
      key.
@@ -314,21 +314,21 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
-        :paramtype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword recovery_id: The url of the recovery object, used to identify and recover the deleted
          key.
         :paramtype recovery_id: str
         """
         super().__init__(kid=kid, attributes=attributes, tags=tags, **kwargs)
@@ -340,30 +340,30 @@
 class DeletedKeyListResult(_serialization.Model):
     """A list of keys that have been deleted in this vault.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: A response message containing a list of deleted keys in the vault along with a
      link to the next page of deleted keys.
-    :vartype value: list[~azure.keyvault.v7_4_preview_1.models.DeletedKeyItem]
+    :vartype value: list[~azure.keyvault.v7_4.models.DeletedKeyItem]
     :ivar next_link: The URL to get the next set of deleted keys.
     :vartype next_link: str
     """
 
     _validation = {
         "value": {"readonly": True},
         "next_link": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -372,30 +372,30 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar code: The error code.
     :vartype code: str
     :ivar message: The error message.
     :vartype message: str
     :ivar inner_error: The key vault server error.
-    :vartype inner_error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype inner_error: ~azure.keyvault.v7_4.models.Error
     """
 
     _validation = {
         "code": {"readonly": True},
         "message": {"readonly": True},
         "inner_error": {"readonly": True},
     }
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -412,15 +412,15 @@
         "count": {"required": True, "maximum": 128, "minimum": 1},
     }
 
     _attribute_map = {
         "count": {"key": "count", "type": "int"},
     }
 
-    def __init__(self, *, count: int, **kwargs):
+    def __init__(self, *, count: int, **kwargs: Any) -> None:
         """
         :keyword count: The requested number of random bytes. Required.
         :paramtype count: int
         """
         super().__init__(**kwargs)
         self.count = count
 
@@ -428,23 +428,23 @@
 class JsonWebKey(_serialization.Model):  # pylint: disable=too-many-instance-attributes
     """As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18.
 
     :ivar kid: Key identifier.
     :vartype kid: str
     :ivar kty: JsonWebKey Key Type (kty), as defined in
      https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
-     "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-    :vartype kty: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+     "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+    :vartype kty: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
     :ivar key_ops:
     :vartype key_ops: list[str]
     :ivar n: RSA modulus.
     :vartype n: bytes
     :ivar e: RSA public exponent.
     :vartype e: bytes
-    :ivar d: RSA private exponent, or the D component of an EC or OKP private key.
+    :ivar d: RSA private exponent, or the D component of an EC private key.
     :vartype d: bytes
     :ivar dp: RSA private key parameter.
     :vartype dp: bytes
     :ivar dq: RSA private key parameter.
     :vartype dq: bytes
     :ivar qi: RSA private key parameter.
     :vartype qi: bytes
@@ -453,17 +453,17 @@
     :ivar q: RSA secret prime, with p < q.
     :vartype q: bytes
     :ivar k: Symmetric key.
     :vartype k: bytes
     :ivar t: Protected Key, used with 'Bring Your Own Key'.
     :vartype t: bytes
     :ivar crv: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-    :vartype crv: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
-    :ivar x: X component of an EC or OKP public key.
+     "P-256", "P-384", "P-521", and "P-256K".
+    :vartype crv: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
+    :ivar x: X component of an EC public key.
     :vartype x: bytes
     :ivar y: Y component of an EC public key.
     :vartype y: bytes
     """
 
     _attribute_map = {
         "kid": {"key": "kid", "type": "str"},
@@ -499,30 +499,30 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
-         "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-        :paramtype kty: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+         "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+        :paramtype kty: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
         :keyword key_ops:
         :paramtype key_ops: list[str]
         :keyword n: RSA modulus.
         :paramtype n: bytes
         :keyword e: RSA public exponent.
         :paramtype e: bytes
-        :keyword d: RSA private exponent, or the D component of an EC or OKP private key.
+        :keyword d: RSA private exponent, or the D component of an EC private key.
         :paramtype d: bytes
         :keyword dp: RSA private key parameter.
         :paramtype dp: bytes
         :keyword dq: RSA private key parameter.
         :paramtype dq: bytes
         :keyword qi: RSA private key parameter.
         :paramtype qi: bytes
@@ -531,17 +531,17 @@
         :keyword q: RSA secret prime, with p < q.
         :paramtype q: bytes
         :keyword k: Symmetric key.
         :paramtype k: bytes
         :keyword t: Protected Key, used with 'Bring Your Own Key'.
         :paramtype t: bytes
         :keyword crv: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-         "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-        :paramtype crv: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
-        :keyword x: X component of an EC or OKP public key.
+         "P-256", "P-384", "P-521", and "P-256K".
+        :paramtype crv: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
+        :keyword x: X component of an EC public key.
         :paramtype x: bytes
         :keyword y: Y component of an EC public key.
         :paramtype y: bytes
         """
         super().__init__(**kwargs)
         self.kid = kid
         self.kty = kty
@@ -581,15 +581,15 @@
     :vartype recoverable_days: int
     :ivar recovery_level: Reflects the deletion recovery level currently in effect for keys in the
      current vault. If it contains 'Purgeable' the key can be permanently deleted by a privileged
      user; otherwise, only the system can purge the key, at the end of the retention interval. Known
      values are: "Purgeable", "Recoverable+Purgeable", "Recoverable",
      "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
      "CustomizedRecoverable", and "CustomizedRecoverable+ProtectedSubscription".
-    :vartype recovery_level: str or ~azure.keyvault.v7_4_preview_1.models.DeletionRecoveryLevel
+    :vartype recovery_level: str or ~azure.keyvault.v7_4.models.DeletionRecoveryLevel
     :ivar exportable: Indicates if the private key can be exported. Release policy must be provided
      when creating the first version of an exportable key.
     :vartype exportable: bool
     """
 
     _validation = {
         "created": {"readonly": True},
@@ -612,16 +612,16 @@
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
         exportable: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -637,31 +637,31 @@
 
 class KeyCreateParameters(_serialization.Model):
     """The key create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
-     values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-    :vartype kty: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+     values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+    :vartype kty: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
     :ivar public_exponent: The public exponent for a RSA key.
     :vartype public_exponent: int
     :ivar key_ops:
-    :vartype key_ops: list[str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyOperation]
+    :vartype key_ops: list[str or ~azure.keyvault.v7_4.models.JsonWebKeyOperation]
     :ivar key_attributes: The attributes of a key managed by the key vault service.
-    :vartype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-    :vartype curve: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
+     "P-256", "P-384", "P-521", and "P-256K".
+    :vartype curve: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
     :ivar release_policy: The policy rules under which the key can be exported.
-    :vartype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+    :vartype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
     """
 
     _validation = {
         "kty": {"required": True},
     }
 
     _attribute_map = {
@@ -682,35 +682,35 @@
         key_size: Optional[int] = None,
         public_exponent: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
-         values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-        :paramtype kty: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+         values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+        :paramtype kty: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword public_exponent: The public exponent for a RSA key.
         :paramtype public_exponent: int
         :keyword key_ops:
-        :paramtype key_ops: list[str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyOperation]
+        :paramtype key_ops: list[str or ~azure.keyvault.v7_4.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
-        :paramtype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values
-         are: "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-        :paramtype curve: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
+         are: "P-256", "P-384", "P-521", and "P-256K".
+        :paramtype curve: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
         """
         super().__init__(**kwargs)
         self.kty = kty
         self.key_size = key_size
         self.public_exponent = public_exponent
         self.key_ops = key_ops
         self.key_attributes = key_attributes
@@ -720,47 +720,47 @@
 
 
 class KeyExportParameters(_serialization.Model):
     """The export key parameters.
 
     :ivar wrapping_key: The export key encryption Json web key. This key MUST be a RSA key that
      supports encryption.
-    :vartype wrapping_key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+    :vartype wrapping_key: ~azure.keyvault.v7_4.models.JsonWebKey
     :ivar wrapping_kid: The export key encryption key identifier. This key MUST be a RSA key that
      supports encryption.
     :vartype wrapping_kid: str
     :ivar enc: The encryption algorithm to use to protected the exported key material. Known values
      are: "CKM_RSA_AES_KEY_WRAP", "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
-    :vartype enc: str or ~azure.keyvault.v7_4_preview_1.models.KeyEncryptionAlgorithm
+    :vartype enc: str or ~azure.keyvault.v7_4.models.KeyEncryptionAlgorithm
     """
 
     _attribute_map = {
         "wrapping_key": {"key": "wrappingKey", "type": "JsonWebKey"},
         "wrapping_kid": {"key": "wrappingKid", "type": "str"},
         "enc": {"key": "enc", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         wrapping_key: Optional["_models.JsonWebKey"] = None,
         wrapping_kid: Optional[str] = None,
         enc: Optional[Union[str, "_models.KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword wrapping_key: The export key encryption Json web key. This key MUST be a RSA key that
          supports encryption.
-        :paramtype wrapping_key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+        :paramtype wrapping_key: ~azure.keyvault.v7_4.models.JsonWebKey
         :keyword wrapping_kid: The export key encryption key identifier. This key MUST be a RSA key
          that supports encryption.
         :paramtype wrapping_kid: str
         :keyword enc: The encryption algorithm to use to protected the exported key material. Known
          values are: "CKM_RSA_AES_KEY_WRAP", "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
-        :paramtype enc: str or ~azure.keyvault.v7_4_preview_1.models.KeyEncryptionAlgorithm
+        :paramtype enc: str or ~azure.keyvault.v7_4.models.KeyEncryptionAlgorithm
         """
         super().__init__(**kwargs)
         self.wrapping_key = wrapping_key
         self.wrapping_kid = wrapping_kid
         self.enc = enc
 
 
@@ -768,21 +768,21 @@
     """The key import parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar hsm: Whether to import as a hardware key (HSM) or software key.
     :vartype hsm: bool
     :ivar key: The Json web key. Required.
-    :vartype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+    :vartype key: ~azure.keyvault.v7_4.models.JsonWebKey
     :ivar key_attributes: The key management attributes.
-    :vartype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar release_policy: The policy rules under which the key can be exported.
-    :vartype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+    :vartype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
     """
 
     _validation = {
         "key": {"required": True},
     }
 
     _attribute_map = {
@@ -797,27 +797,27 @@
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
-        :paramtype key: ~azure.keyvault.v7_4_preview_1.models.JsonWebKey
+        :paramtype key: ~azure.keyvault.v7_4.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
-        :paramtype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
         """
         super().__init__(**kwargs)
         self.hsm = hsm
         self.key = key
         self.key_attributes = key_attributes
         self.tags = tags
         self.release_policy = release_policy
@@ -826,30 +826,30 @@
 class KeyListResult(_serialization.Model):
     """The key list result.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: A response message containing a list of keys in the key vault along with a link to
      the next page of keys.
-    :vartype value: list[~azure.keyvault.v7_4_preview_1.models.KeyItem]
+    :vartype value: list[~azure.keyvault.v7_4.models.KeyItem]
     :ivar next_link: The URL to get the next set of keys.
     :vartype next_link: str
     """
 
     _validation = {
         "value": {"readonly": True},
         "next_link": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -881,15 +881,15 @@
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
         "iv": {"key": "iv", "type": "base64"},
         "authentication_tag": {"key": "tag", "type": "base64"},
         "additional_authenticated_data": {"key": "aad", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
         self.iv = None
         self.authentication_tag = None
         self.additional_authenticated_data = None
@@ -899,15 +899,15 @@
     """The key operations parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP", "RSA-OAEP-256",
      "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW", "A192KW", "A256KW", "A128CBC", "A192CBC",
      "A256CBC", "A128CBCPAD", "A192CBCPAD", and "A256CBCPAD".
-    :vartype algorithm: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyEncryptionAlgorithm
+    :vartype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeyEncryptionAlgorithm
     :ivar value: Required.
     :vartype value: bytes
     :ivar iv: Cryptographically random, non-repeating initialization vector for symmetric
      algorithms.
     :vartype iv: bytes
     :ivar aad: Additional data to authenticate but not encrypt/decrypt when using authenticated
      crypto algorithms.
@@ -933,22 +933,21 @@
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"],
         value: bytes,
         iv: Optional[bytes] = None,
         aad: Optional[bytes] = None,
         tag: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW", "A192KW", "A256KW",
          "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD", and "A256CBCPAD".
-        :paramtype algorithm: str or
-         ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyEncryptionAlgorithm
+        :paramtype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         :keyword iv: Cryptographically random, non-repeating initialization vector for symmetric
          algorithms.
         :paramtype iv: bytes
         :keyword aad: Additional data to authenticate but not encrypt/decrypt when using authenticated
          crypto algorithms.
@@ -968,23 +967,23 @@
 class KeyProperties(_serialization.Model):
     """Properties of the key pair backing a certificate.
 
     :ivar exportable: Indicates if the private key can be exported. Release policy must be provided
      when creating the first version of an exportable key.
     :vartype exportable: bool
     :ivar key_type: The type of key pair to be used for the certificate. Known values are: "EC",
-     "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-    :vartype key_type: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+     "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+    :vartype key_type: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
     :ivar reuse_key: Indicates if the same key pair will be used on certificate renewal.
     :vartype reuse_key: bool
     :ivar curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values are:
-     "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-    :vartype curve: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
+     "P-256", "P-384", "P-521", and "P-256K".
+    :vartype curve: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
     """
 
     _attribute_map = {
         "exportable": {"key": "exportable", "type": "bool"},
         "key_type": {"key": "kty", "type": "str"},
         "key_size": {"key": "key_size", "type": "int"},
         "reuse_key": {"key": "reuse_key", "type": "bool"},
@@ -995,30 +994,30 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "_models.JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Indicates if the private key can be exported. Release policy must be
          provided when creating the first version of an exportable key.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
-         "EC-HSM", "RSA", "RSA-HSM", "oct", "oct-HSM", "OKP", and "OKP-HSM".
-        :paramtype key_type: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyType
+         "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
+        :paramtype key_type: str or ~azure.keyvault.v7_4.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
         :keyword reuse_key: Indicates if the same key pair will be used on certificate renewal.
         :paramtype reuse_key: bool
         :keyword curve: Elliptic curve name. For valid values, see JsonWebKeyCurveName. Known values
-         are: "P-256", "P-384", "P-521", "P-256K", and "Ed25519".
-        :paramtype curve: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyCurveName
+         are: "P-256", "P-384", "P-521", and "P-256K".
+        :paramtype curve: str or ~azure.keyvault.v7_4.models.JsonWebKeyCurveName
         """
         super().__init__(**kwargs)
         self.exportable = exportable
         self.key_type = key_type
         self.key_size = key_size
         self.reuse_key = reuse_key
         self.curve = curve
@@ -1032,15 +1031,15 @@
     :ivar target_attestation_token: The attestation assertion for the target of the key release.
      Required.
     :vartype target_attestation_token: str
     :ivar nonce: A client provided nonce for freshness.
     :vartype nonce: str
     :ivar enc: The encryption algorithm to use to protected the exported key material. Known values
      are: "CKM_RSA_AES_KEY_WRAP", "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
-    :vartype enc: str or ~azure.keyvault.v7_4_preview_1.models.KeyEncryptionAlgorithm
+    :vartype enc: str or ~azure.keyvault.v7_4.models.KeyEncryptionAlgorithm
     """
 
     _validation = {
         "target_attestation_token": {"required": True, "min_length": 1},
     }
 
     _attribute_map = {
@@ -1051,25 +1050,25 @@
 
     def __init__(
         self,
         *,
         target_attestation_token: str,
         nonce: Optional[str] = None,
         enc: Optional[Union[str, "_models.KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword target_attestation_token: The attestation assertion for the target of the key release.
          Required.
         :paramtype target_attestation_token: str
         :keyword nonce: A client provided nonce for freshness.
         :paramtype nonce: str
         :keyword enc: The encryption algorithm to use to protected the exported key material. Known
          values are: "CKM_RSA_AES_KEY_WRAP", "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
-        :paramtype enc: str or ~azure.keyvault.v7_4_preview_1.models.KeyEncryptionAlgorithm
+        :paramtype enc: str or ~azure.keyvault.v7_4.models.KeyEncryptionAlgorithm
         """
         super().__init__(**kwargs)
         self.target_attestation_token = target_attestation_token
         self.nonce = nonce
         self.enc = enc
 
 
@@ -1094,16 +1093,16 @@
 
     def __init__(
         self,
         *,
         content_type: str = "application/json; charset=utf-8",
         immutable: Optional[bool] = None,
         encoded_policy: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword content_type: Content type and version of key release policy.
         :paramtype content_type: str
         :keyword immutable: Defines the mutability state of the policy. Once marked immutable, this
          flag cannot be reset and the policy cannot be changed under any circumstances.
         :paramtype immutable: bool
         :keyword encoded_policy: Blob encoding the policy rules under which the key can be released.
@@ -1129,15 +1128,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyRestoreParameters(_serialization.Model):
     """The key restore parameters.
@@ -1152,15 +1151,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -1171,17 +1170,17 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The key policy id.
     :vartype id: str
     :ivar lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a key.
      For preview, lifetimeActions can only have two items at maximum: one for rotate, one for
      notify. Notification time would be default to 30 days before expiry and it is not configurable.
-    :vartype lifetime_actions: list[~azure.keyvault.v7_4_preview_1.models.LifetimeActions]
+    :vartype lifetime_actions: list[~azure.keyvault.v7_4.models.LifetimeActions]
     :ivar attributes: The key rotation policy attributes.
-    :vartype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicyAttributes
+    :vartype attributes: ~azure.keyvault.v7_4.models.KeyRotationPolicyAttributes
     """
 
     _validation = {
         "id": {"readonly": True},
     }
 
     _attribute_map = {
@@ -1191,23 +1190,23 @@
     }
 
     def __init__(
         self,
         *,
         lifetime_actions: Optional[List["_models.LifetimeActions"]] = None,
         attributes: Optional["_models.KeyRotationPolicyAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a
          key. For preview, lifetimeActions can only have two items at maximum: one for rotate, one for
          notify. Notification time would be default to 30 days before expiry and it is not configurable.
-        :paramtype lifetime_actions: list[~azure.keyvault.v7_4_preview_1.models.LifetimeActions]
+        :paramtype lifetime_actions: list[~azure.keyvault.v7_4.models.LifetimeActions]
         :keyword attributes: The key rotation policy attributes.
-        :paramtype attributes: ~azure.keyvault.v7_4_preview_1.models.KeyRotationPolicyAttributes
+        :paramtype attributes: ~azure.keyvault.v7_4.models.KeyRotationPolicyAttributes
         """
         super().__init__(**kwargs)
         self.id = None
         self.lifetime_actions = lifetime_actions
         self.attributes = attributes
 
 
@@ -1233,15 +1232,15 @@
 
     _attribute_map = {
         "expiry_time": {"key": "expiryTime", "type": "str"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs):
+    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword expiry_time: The expiryTime will be applied on the new key version. It should be at
          least 28 days. It will be in ISO 8601 Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours:
          PT48H, 1 year and 10 days: P1Y10D.
         :paramtype expiry_time: str
         """
         super().__init__(**kwargs)
@@ -1253,58 +1252,60 @@
 class KeySignParameters(_serialization.Model):
     """The key operations parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar algorithm: The signing/verification algorithm identifier. For more information on
      possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
-     "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512",
-     "ES256K", and "EdDSA".
-    :vartype algorithm: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeySignatureAlgorithm
+     "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
+     "ES256K".
+    :vartype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeySignatureAlgorithm
     :ivar value: Required.
     :vartype value: bytes
     """
 
     _validation = {
         "algorithm": {"required": True},
         "value": {"required": True},
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
-         "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512",
-         "ES256K", and "EdDSA".
-        :paramtype algorithm: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeySignatureAlgorithm
+         "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
+         "ES256K".
+        :paramtype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
         """
         super().__init__(**kwargs)
         self.algorithm = algorithm
         self.value = value
 
 
 class KeyUpdateParameters(_serialization.Model):
     """The key update parameters.
 
     :ivar key_ops: Json web key operations. For more information on possible key operations, see
      JsonWebKeyOperation.
-    :vartype key_ops: list[str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyOperation]
+    :vartype key_ops: list[str or ~azure.keyvault.v7_4.models.JsonWebKeyOperation]
     :ivar key_attributes: The attributes of a key managed by the key vault service.
-    :vartype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+    :vartype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
     :ivar release_policy: The policy rules under which the key can be exported.
-    :vartype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+    :vartype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
     """
 
     _attribute_map = {
         "key_ops": {"key": "key_ops", "type": "[str]"},
         "key_attributes": {"key": "attributes", "type": "KeyAttributes"},
         "tags": {"key": "tags", "type": "{str}"},
         "release_policy": {"key": "release_policy", "type": "KeyReleasePolicy"},
@@ -1313,66 +1314,66 @@
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
-        :paramtype key_ops: list[str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeyOperation]
+        :paramtype key_ops: list[str or ~azure.keyvault.v7_4.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
-        :paramtype key_attributes: ~azure.keyvault.v7_4_preview_1.models.KeyAttributes
+        :paramtype key_attributes: ~azure.keyvault.v7_4.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
         :keyword release_policy: The policy rules under which the key can be exported.
-        :paramtype release_policy: ~azure.keyvault.v7_4_preview_1.models.KeyReleasePolicy
+        :paramtype release_policy: ~azure.keyvault.v7_4.models.KeyReleasePolicy
         """
         super().__init__(**kwargs)
         self.key_ops = key_ops
         self.key_attributes = key_attributes
         self.tags = tags
         self.release_policy = release_policy
 
 
 class KeyVaultError(_serialization.Model):
     """The key vault error exception.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar error: The key vault server error.
-    :vartype error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype error: ~azure.keyvault.v7_4.models.Error
     """
 
     _validation = {
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar algorithm: The signing/verification algorithm. For more information on possible algorithm
      types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256", "PS384", "PS512",
-     "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", "ES256K", and "EdDSA".
-    :vartype algorithm: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeySignatureAlgorithm
+     "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
+    :vartype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeySignatureAlgorithm
     :ivar digest: The digest used for signing. Required.
     :vartype digest: bytes
     :ivar signature: The signature to be verified. Required.
     :vartype signature: bytes
     """
 
     _validation = {
@@ -1389,22 +1390,21 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
-         "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", "ES256K", and
-         "EdDSA".
-        :paramtype algorithm: str or ~azure.keyvault.v7_4_preview_1.models.JsonWebKeySignatureAlgorithm
+         "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
+        :paramtype algorithm: str or ~azure.keyvault.v7_4.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
         :keyword signature: The signature to be verified. Required.
         :paramtype signature: bytes
         """
         super().__init__(**kwargs)
         self.algorithm = algorithm
@@ -1425,46 +1425,46 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class LifetimeActions(_serialization.Model):
     """Action and its trigger that will be performed by Key Vault over the lifetime of a key.
 
     :ivar trigger: The condition that will execute the action.
-    :vartype trigger: ~azure.keyvault.v7_4_preview_1.models.LifetimeActionsTrigger
+    :vartype trigger: ~azure.keyvault.v7_4.models.LifetimeActionsTrigger
     :ivar action: The action that will be executed.
-    :vartype action: ~azure.keyvault.v7_4_preview_1.models.LifetimeActionsType
+    :vartype action: ~azure.keyvault.v7_4.models.LifetimeActionsType
     """
 
     _attribute_map = {
         "trigger": {"key": "trigger", "type": "LifetimeActionsTrigger"},
         "action": {"key": "action", "type": "LifetimeActionsType"},
     }
 
     def __init__(
         self,
         *,
         trigger: Optional["_models.LifetimeActionsTrigger"] = None,
         action: Optional["_models.LifetimeActionsType"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword trigger: The condition that will execute the action.
-        :paramtype trigger: ~azure.keyvault.v7_4_preview_1.models.LifetimeActionsTrigger
+        :paramtype trigger: ~azure.keyvault.v7_4.models.LifetimeActionsTrigger
         :keyword action: The action that will be executed.
-        :paramtype action: ~azure.keyvault.v7_4_preview_1.models.LifetimeActionsType
+        :paramtype action: ~azure.keyvault.v7_4.models.LifetimeActionsType
         """
         super().__init__(**kwargs)
         self.trigger = trigger
         self.action = action
 
 
 class LifetimeActionsTrigger(_serialization.Model):
@@ -1479,15 +1479,17 @@
     """
 
     _attribute_map = {
         "time_after_create": {"key": "timeAfterCreate", "type": "str"},
         "time_before_expiry": {"key": "timeBeforeExpiry", "type": "str"},
     }
 
-    def __init__(self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword time_after_create: Time after creation to attempt to rotate. It only applies to
          rotate. It will be in ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_after_create: str
         :keyword time_before_expiry: Time before expiry to attempt to rotate or notify. It will be in
          ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_before_expiry: str
@@ -1497,25 +1499,25 @@
         self.time_before_expiry = time_before_expiry
 
 
 class LifetimeActionsType(_serialization.Model):
     """The action that will be executed.
 
     :ivar type: The type of the action. Known values are: "rotate" and "notify".
-    :vartype type: str or ~azure.keyvault.v7_4_preview_1.models.ActionType
+    :vartype type: str or ~azure.keyvault.v7_4.models.ActionType
     """
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs):
+    def __init__(self, *, type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs: Any) -> None:
         """
         :keyword type: The type of the action. Known values are: "rotate" and "notify".
-        :paramtype type: str or ~azure.keyvault.v7_4_preview_1.models.ActionType
+        :paramtype type: str or ~azure.keyvault.v7_4.models.ActionType
         """
         super().__init__(**kwargs)
         self.type = type
 
 
 class RandomBytes(_serialization.Model):
     """The get random bytes response object containing the bytes.
@@ -1530,14 +1532,14 @@
         "value": {"required": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, value: bytes, **kwargs):
+    def __init__(self, *, value: bytes, **kwargs: Any) -> None:
         """
         :keyword value: The bytes encoded as a base64url string. Required.
         :paramtype value: bytes
         """
         super().__init__(**kwargs)
         self.value = value
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,31 +22,28 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.3")  # type: Literal["7.3"]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", "7.2")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
         self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/_key_vault_client.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_2/_key_vault_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,35 +8,35 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
-    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
@@ -55,19 +55,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/create")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -67,49 +67,49 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_rotate_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotate")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -118,50 +118,50 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -170,49 +170,49 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_versions_request(key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/versions")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if maxresults is not None:
         _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -221,15 +221,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys")
 
     # Construct parameters
     if maxresults is not None:
@@ -242,40 +242,40 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/backup")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_key_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -288,26 +288,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/encrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -316,26 +316,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/decrypt")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -344,26 +344,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/sign")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -372,26 +372,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/verify")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -400,26 +400,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/wrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -428,26 +428,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/unwrapkey")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -456,26 +456,26 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_release_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/{key-version}/release")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
         "key-version": _SERIALIZER.url("key_version", key_version, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -484,15 +484,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys")
 
     # Construct parameters
     if maxresults is not None:
@@ -505,121 +505,121 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/deletedkeys/{key-name}/recover")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotationpolicy")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{key-name}/rotationpolicy")
     path_format_arguments = {
         "key-name": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -628,16 +628,16 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_random_bytes_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/rng")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -671,21 +671,21 @@
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
         :param parameters: The parameters to create a key. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_key(
         self,
         vault_base_url: str,
@@ -711,15 +711,15 @@
         :param parameters: The parameters to create a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyCreateParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -732,39 +732,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters or IO
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -780,17 +780,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -800,15 +800,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @distributed_trace
     def rotate_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Creates a new key version, stores it, then returns key parameters, attributes and policy to the
         client.
 
         The operation will rotate the key based on the key policy. It requires the keys/rotate
@@ -817,45 +817,45 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to be rotated. The system will generate a new version in the
          specified key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_rotate_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.rotate_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -865,15 +865,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}  # type: ignore
+    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -891,21 +891,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
         :param parameters: The parameters to import a key. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def import_key(
         self,
         vault_base_url: str,
@@ -931,15 +931,15 @@
         :param parameters: The parameters to import a key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def import_key(
         self, vault_base_url: str, key_name: str, parameters: Union[_models.KeyImportParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -952,39 +952,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters or IO
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1000,17 +1000,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1020,15 +1020,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace
     def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -1037,45 +1037,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to delete. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1085,15 +1085,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1112,21 +1112,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
         :param parameters: The parameters of the key to update. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update_key(
         self,
         vault_base_url: str,
@@ -1153,15 +1153,15 @@
         :param parameters: The parameters of the key to update. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update_key(
         self,
         vault_base_url: str,
@@ -1179,39 +1179,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters or IO
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1228,17 +1228,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1248,15 +1248,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -1267,46 +1267,46 @@
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key. This
          URI fragment is optional. If not specified, the latest version of the key is returned.
          Required.
         :type key_version: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1316,15 +1316,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
@@ -1336,22 +1336,22 @@
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1368,15 +1368,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1387,43 +1387,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
@@ -1435,22 +1435,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.KeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1466,15 +1466,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1485,43 +1485,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace
     def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -1537,45 +1537,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: BackupKeyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.BackupKeyResult
+        :rtype: ~azure.keyvault.v7_4.models.BackupKeyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1585,15 +1585,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1612,21 +1612,21 @@
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The parameters to restore the key. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def restore_key(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1648,15 +1648,15 @@
         :param parameters: The parameters to restore the key. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def restore_key(
         self, vault_base_url: str, parameters: Union[_models.KeyRestoreParameters, IO], **kwargs: Any
     ) -> _models.KeyBundle:
@@ -1671,39 +1671,39 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters or IO
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1718,17 +1718,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1738,15 +1738,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1769,21 +1769,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the encryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def encrypt(
         self,
         vault_base_url: str,
@@ -1814,15 +1814,15 @@
         :param parameters: The parameters for the encryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def encrypt(
         self,
         vault_base_url: str,
@@ -1844,39 +1844,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1893,17 +1893,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1913,15 +1913,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1945,21 +1945,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the decryption operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def decrypt(
         self,
         vault_base_url: str,
@@ -1991,15 +1991,15 @@
         :param parameters: The parameters for the decryption operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def decrypt(
         self,
         vault_base_url: str,
@@ -2022,39 +2022,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2071,17 +2071,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2091,15 +2091,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2117,21 +2117,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the signing operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def sign(
         self,
         vault_base_url: str,
@@ -2157,15 +2157,15 @@
         :param parameters: The parameters for the signing operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def sign(
         self,
         vault_base_url: str,
@@ -2182,39 +2182,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters or IO
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2231,17 +2231,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2251,15 +2251,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2279,21 +2279,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for verify operations. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def verify(
         self,
         vault_base_url: str,
@@ -2321,15 +2321,15 @@
         :param parameters: The parameters for verify operations. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def verify(
         self,
         vault_base_url: str,
@@ -2348,39 +2348,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters or IO
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyVerifyResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2397,17 +2397,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2417,15 +2417,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2446,21 +2446,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for wrap operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def wrap_key(
         self,
         vault_base_url: str,
@@ -2489,15 +2489,15 @@
         :param parameters: The parameters for wrap operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def wrap_key(
         self,
         vault_base_url: str,
@@ -2517,39 +2517,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2566,17 +2566,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2586,15 +2586,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2613,21 +2613,21 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
         :param parameters: The parameters for the key operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def unwrap_key(
         self,
         vault_base_url: str,
@@ -2654,15 +2654,15 @@
         :param parameters: The parameters for the key operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def unwrap_key(
         self,
         vault_base_url: str,
@@ -2680,39 +2680,39 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2729,17 +2729,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2749,15 +2749,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @overload
     def release(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2775,21 +2775,21 @@
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
         :param parameters: The parameters for the key release operation. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def release(
         self,
         vault_base_url: str,
@@ -2815,15 +2815,15 @@
         :param parameters: The parameters for the key release operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def release(
         self,
         vault_base_url: str,
@@ -2840,39 +2840,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters or IO
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
+        :rtype: ~azure.keyvault.v7_4.models.KeyReleaseResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyReleaseResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyReleaseResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2889,17 +2889,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2909,15 +2909,15 @@
         deserialized = self._deserialize("KeyReleaseResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}  # type: ignore
+    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2930,22 +2930,22 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param maxresults: Maximum number of results to return in a page. If not specified the service
          will return up to 25 results. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.DeletedKeyItem]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2961,15 +2961,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2980,43 +2980,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace
     def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -3024,45 +3024,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DeletedKeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.DeletedKeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.DeletedKeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3072,15 +3072,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -3104,45 +3104,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace
     def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -3151,45 +3151,45 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the deleted key. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyBundle
+        :rtype: ~azure.keyvault.v7_4.models.KeyBundle
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3199,60 +3199,60 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @distributed_trace
     def get_key_rotation_policy(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyRotationPolicy:
         """Lists the policy for a key.
 
         The GetKeyRotationPolicy operation returns the specified key policy resources in the specified
         key vault. This operation requires the keys/get permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in a given key vault. Required.
         :type key_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         request = build_get_key_rotation_policy_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_key_rotation_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3262,15 +3262,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
         key_name: str,
         key_rotation_policy: _models.KeyRotationPolicy,
@@ -3284,21 +3284,21 @@
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
         :param key_rotation_policy: The policy for the key. Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -3320,15 +3320,15 @@
         :param key_rotation_policy: The policy for the key. Required.
         :type key_rotation_policy: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update_key_rotation_policy(
         self,
         vault_base_url: str,
@@ -3341,39 +3341,39 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
-        :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy or IO
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
+        :type key_rotation_policy: ~azure.keyvault.v7_4.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
+        :rtype: ~azure.keyvault.v7_4.models.KeyRotationPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(key_rotation_policy, (IO, bytes)):
             _content = key_rotation_policy
         else:
@@ -3389,17 +3389,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3409,15 +3409,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     def get_random_bytes(
         self,
         vault_base_url: str,
         parameters: _models.GetRandomBytesRequest,
         *,
@@ -3427,21 +3427,21 @@
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param parameters: The request object to get random bytes. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def get_random_bytes(
         self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RandomBytes:
@@ -3454,53 +3454,53 @@
         :param parameters: The request object to get random bytes. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def get_random_bytes(
         self, vault_base_url: str, parameters: Union[_models.GetRandomBytesRequest, IO], **kwargs: Any
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest or IO
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RandomBytes
+        :rtype: ~azure.keyvault.v7_4.models.RandomBytes
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RandomBytes]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RandomBytes] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -3515,17 +3515,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -3535,8 +3535,8 @@
         deserialized = self._deserialize("RandomBytes", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_random_bytes.metadata = {"url": "/rng"}  # type: ignore
+    get_random_bytes.metadata = {"url": "/rng"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_vendor.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/_configuration.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,23 +29,23 @@
     :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.3")  # type: Literal["7.3"]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", "7.3")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/aio/operations/_key_vault_client_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -146,16 +146,16 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name for the new key. The system will generate the version name for the
          new key. The value you provide may be copied globally for the purpose of running the service.
          The value provided should not include personally identifiable or sensitive information.
          Required.
         :type key_name: str
-        :param parameters: The parameters to create a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to create a key. Is either a KeyCreateParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyBundle
@@ -168,17 +168,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -194,17 +194,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -214,15 +214,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_key.metadata = {"url": "/keys/{key-name}/create"}  # type: ignore
+    create_key.metadata = {"url": "/keys/{key-name}/create"}
 
     @distributed_trace_async
     async def rotate_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Creates a new key version, stores it, then returns key parameters, attributes and policy to the
         client.
 
         The operation will rotate the key based on the key policy. It requires the keys/rotate
@@ -245,31 +245,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_rotate_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.rotate_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -279,15 +279,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}  # type: ignore
+    rotate_key.metadata = {"url": "/keys/{key-name}/rotate"}
 
     @overload
     async def import_key(
         self,
         vault_base_url: str,
         key_name: str,
         parameters: _models.KeyImportParameters,
@@ -366,16 +366,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: Name for the imported key. The value you provide may be copied globally for
          the purpose of running the service. The value provided should not include personally
          identifiable or sensitive information. Required.
         :type key_name: str
-        :param parameters: The parameters to import a key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to import a key. Is either a KeyImportParameters type or a IO
+         type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyImportParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyBundle
@@ -388,17 +388,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -414,17 +414,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -434,15 +434,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    import_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    import_key.metadata = {"url": "/keys/{key-name}"}
 
     @distributed_trace_async
     async def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Deletes a key of any type from storage in Azure Key Vault.
 
         The delete key operation cannot be used to remove individual versions of a key. This operation
         removes the cryptographic material associated with the key, which means the key is not usable
@@ -465,31 +465,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_delete_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.delete_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -499,15 +499,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete_key.metadata = {"url": "/keys/{key-name}"}  # type: ignore
+    delete_key.metadata = {"url": "/keys/{key-name}"}
 
     @overload
     async def update_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -593,16 +593,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of key to update. Required.
         :type key_name: str
         :param key_version: The version of the key to update. Required.
         :type key_version: str
-        :param parameters: The parameters of the key to update. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters of the key to update. Is either a KeyUpdateParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyUpdateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyBundle
@@ -615,17 +615,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -642,17 +642,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -662,15 +662,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    update_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace_async
     async def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> _models.KeyBundle:
         """Gets the public part of a stored key.
 
         The get key operation is applicable to all key types. If the requested key is symmetric, then
         no key material is released in the response. This operation requires the keys/get permission.
@@ -695,32 +695,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_key_request(
             key_name=key_name,
             key_version=key_version,
             api_version=api_version,
             template_url=self.get_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -730,42 +730,47 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}  # type: ignore
+    get_key.metadata = {"url": "/keys/{key-name}/{key-version}"}
 
     @distributed_trace
     def get_key_versions(
         self, vault_base_url: str, key_name: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """Retrieves a list of individual key versions with the same key name.
 
         The full key identifier, attributes, and tags are provided in the response. This operation
         requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -782,15 +787,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -801,70 +806,75 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}  # type: ignore
+    get_key_versions.metadata = {"url": "/keys/{key-name}/versions"}
 
     @distributed_trace
     def get_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.KeyItem"]:
         """List keys in the specified vault.
 
         Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
         public part of a stored key. The LIST operation is applicable to all key types, however only
         the base key identifier, attributes, and tags are provided in the response. Individual versions
         of a key are not listed in the response. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either KeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.KeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -880,15 +890,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -899,43 +909,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("KeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_keys.metadata = {"url": "/keys"}  # type: ignore
+    get_keys.metadata = {"url": "/keys"}
 
     @distributed_trace_async
     async def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.BackupKeyResult:
         """Requests that a backup of the specified key be downloaded to the client.
 
         The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
         operation does NOT return key material in a form that can be used outside the Azure Key Vault
@@ -965,31 +975,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.BackupKeyResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.BackupKeyResult] = kwargs.pop("cls", None)
 
         request = build_backup_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.backup_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -999,15 +1009,15 @@
         deserialized = self._deserialize("BackupKeyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    backup_key.metadata = {"url": "/keys/{key-name}/backup"}  # type: ignore
+    backup_key.metadata = {"url": "/keys/{key-name}/backup"}
 
     @overload
     async def restore_key(
         self,
         vault_base_url: str,
         parameters: _models.KeyRestoreParameters,
         *,
@@ -1085,16 +1095,16 @@
         different vault. Restore will restore all versions and preserve version identifiers. The
         RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
         same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
         in the target Key Vault. This operation requires the keys/restore permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The parameters to restore the key. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters to restore the key. Is either a KeyRestoreParameters type or
+         a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyRestoreParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyBundle or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyBundle
@@ -1107,17 +1117,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1132,17 +1142,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1152,15 +1162,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_key.metadata = {"url": "/keys/restore"}  # type: ignore
+    restore_key.metadata = {"url": "/keys/restore"}
 
     @overload
     async def encrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1258,16 +1268,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the encryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the encryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
@@ -1280,17 +1290,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1307,17 +1317,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1327,15 +1337,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}  # type: ignore
+    encrypt.metadata = {"url": "/keys/{key-name}/{key-version}/encrypt"}
 
     @overload
     async def decrypt(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1436,16 +1446,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the decryption operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the decryption operation. Is either a
+         KeyOperationsParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
@@ -1458,17 +1468,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1485,17 +1495,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1505,15 +1515,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}  # type: ignore
+    decrypt.metadata = {"url": "/keys/{key-name}/{key-version}/decrypt"}
 
     @overload
     async def sign(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1596,16 +1606,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the signing operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the signing operation. Is either a KeySignParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeySignParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
@@ -1618,17 +1628,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1645,17 +1655,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1665,15 +1675,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}  # type: ignore
+    sign.metadata = {"url": "/keys/{key-name}/{key-version}/sign"}
 
     @overload
     async def verify(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1762,16 +1772,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for verify operations. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for verify operations. Is either a KeyVerifyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyVerifyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyVerifyResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyVerifyResult
@@ -1784,17 +1794,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyVerifyResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyVerifyResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1811,17 +1821,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1831,15 +1841,15 @@
         deserialized = self._deserialize("KeyVerifyResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}  # type: ignore
+    verify.metadata = {"url": "/keys/{key-name}/{key-version}/verify"}
 
     @overload
     async def wrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -1931,16 +1941,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for wrap operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for wrap operation. Is either a KeyOperationsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
@@ -1953,17 +1963,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -1980,17 +1990,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2000,15 +2010,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}  # type: ignore
+    wrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/wrapkey"}
 
     @overload
     async def unwrap_key(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2094,16 +2104,16 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key. Required.
         :type key_name: str
         :param key_version: The version of the key. Required.
         :type key_version: str
-        :param parameters: The parameters for the key operation. Is either a model type or a IO type.
-         Required.
+        :param parameters: The parameters for the key operation. Is either a KeyOperationsParameters
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyOperationsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyOperationResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyOperationResult
@@ -2116,17 +2126,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyOperationResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyOperationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2143,17 +2153,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2163,15 +2173,15 @@
         deserialized = self._deserialize("KeyOperationResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}  # type: ignore
+    unwrap_key.metadata = {"url": "/keys/{key-name}/{key-version}/unwrapkey"}
 
     @overload
     async def release(
         self,
         vault_base_url: str,
         key_name: str,
         key_version: str,
@@ -2254,16 +2264,16 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to get. Required.
         :type key_name: str
         :param key_version: Adding the version parameter retrieves a specific version of a key.
          Required.
         :type key_version: str
-        :param parameters: The parameters for the key release operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the key release operation. Is either a
+         KeyReleaseParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.KeyReleaseParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyReleaseResult or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyReleaseResult
@@ -2276,17 +2286,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyReleaseResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyReleaseResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2303,17 +2313,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2323,15 +2333,15 @@
         deserialized = self._deserialize("KeyReleaseResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}  # type: ignore
+    release.metadata = {"url": "/keys/{key-name}/{key-version}/release"}
 
     @distributed_trace
     def get_deleted_keys(
         self, vault_base_url: str, maxresults: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DeletedKeyItem"]:
         """Lists the deleted keys in the specified vault.
 
@@ -2339,27 +2349,32 @@
         public part of a deleted key. This operation includes deletion-specific information. The Get
         Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
         vault. This operation requires the keys/list permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param maxresults: Maximum number of results to return in a page. If not specified the service
-         will return up to 25 results. Default value is None.
+        :param maxresults: Specifies the maximum number of results to return in a page. Setting
+         maxresults to a value less than 1 or greater than 25 results in error response code 400 (Bad
+         Request). If there are additional results to return, then the service returns a nextLink
+         containing a skip token for pagination. In certain cases, the service might return fewer
+         results than specified by maxresults (even 0 results) and also return a nextLink. Clients
+         should not make any assumptions on the minimum number of results per page, and should enumerate
+         all pages until the nextLink becomes null. Default value is None.
         :type maxresults: int
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DeletedKeyItem or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.DeletedKeyItem]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -2375,15 +2390,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -2394,43 +2409,43 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DeletedKeyListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get_deleted_keys.metadata = {"url": "/deletedkeys"}  # type: ignore
+    get_deleted_keys.metadata = {"url": "/deletedkeys"}
 
     @distributed_trace_async
     async def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.DeletedKeyBundle:
         """Gets the public part of a deleted key.
 
         The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
         can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
@@ -2452,31 +2467,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeletedKeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.DeletedKeyBundle] = kwargs.pop("cls", None)
 
         request = build_get_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2486,15 +2501,15 @@
         deserialized = self._deserialize("DeletedKeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    get_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> None:
         """Permanently deletes the specified key.
 
@@ -2518,45 +2533,45 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_purge_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.purge_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
             raise HttpResponseError(response=response, model=error)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}  # type: ignore
+    purge_deleted_key.metadata = {"url": "/deletedkeys/{key-name}"}
 
     @distributed_trace_async
     async def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> _models.KeyBundle:
         """Recovers the deleted key to its latest version.
 
         The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
         It recovers the deleted key back to its latest version under /keys. An attempt to recover an
@@ -2579,31 +2594,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyBundle]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyBundle] = kwargs.pop("cls", None)
 
         request = build_recover_deleted_key_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.recover_deleted_key.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2613,15 +2628,15 @@
         deserialized = self._deserialize("KeyBundle", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}  # type: ignore
+    recover_deleted_key.metadata = {"url": "/deletedkeys/{key-name}/recover"}
 
     @distributed_trace_async
     async def get_key_rotation_policy(
         self, vault_base_url: str, key_name: str, **kwargs: Any
     ) -> _models.KeyRotationPolicy:
         """Lists the policy for a key.
 
@@ -2644,31 +2659,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         request = build_get_key_rotation_policy_request(
             key_name=key_name,
             api_version=api_version,
             template_url=self.get_key_rotation_policy.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2678,15 +2693,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    get_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     async def update_key_rotation_policy(
         self,
         vault_base_url: str,
         key_name: str,
         key_rotation_policy: _models.KeyRotationPolicy,
@@ -2757,16 +2772,16 @@
         Set specified members in the key policy. Leave others as undefined. This operation requires the
         keys/update permission.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key in the given vault. Required.
         :type key_name: str
-        :param key_rotation_policy: The policy for the key. Is either a model type or a IO type.
-         Required.
+        :param key_rotation_policy: The policy for the key. Is either a KeyRotationPolicy type or a IO
+         type. Required.
         :type key_rotation_policy: ~azure.keyvault.v7_3.models.KeyRotationPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: KeyRotationPolicy or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.KeyRotationPolicy
@@ -2779,17 +2794,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.KeyRotationPolicy]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.KeyRotationPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(key_rotation_policy, (IO, bytes)):
             _content = key_rotation_policy
         else:
@@ -2805,17 +2820,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2825,15 +2840,15 @@
         deserialized = self._deserialize("KeyRotationPolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}  # type: ignore
+    update_key_rotation_policy.metadata = {"url": "/keys/{key-name}/rotationpolicy"}
 
     @overload
     async def get_random_bytes(
         self,
         vault_base_url: str,
         parameters: _models.GetRandomBytesRequest,
         *,
@@ -2884,16 +2899,16 @@
     ) -> _models.RandomBytes:
         """Get the requested number of bytes containing random values.
 
         Get the requested number of bytes containing random values from a managed HSM.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
-        :param parameters: The request object to get random bytes. Is either a model type or a IO type.
-         Required.
+        :param parameters: The request object to get random bytes. Is either a GetRandomBytesRequest
+         type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.GetRandomBytesRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RandomBytes or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.RandomBytes
@@ -2906,17 +2921,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RandomBytes]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RandomBytes] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -2931,17 +2946,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -2951,8 +2966,8 @@
         deserialized = self._deserialize("RandomBytes", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_random_bytes.metadata = {"url": "/rng"}  # type: ignore
+    get_random_bytes.metadata = {"url": "/rng"}
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_patch.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_0/models/_key_vault_client_enums.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,161 +9,155 @@
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
 class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of the action."""
 
-    #: Rotate the key based on the key policy.
-    ROTATE = "rotate"
-    #: Trigger event grid events. For preview, the notification time is not configurable and it is
-    #: default to 30 days before expiry.
-    NOTIFY = "notify"
+    EMAIL_CONTACTS = "EmailContacts"
+    AUTO_RENEW = "AutoRenew"
 
 
 class DeletionRecoveryLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Reflects the deletion recovery level currently in effect for keys in the current vault. If it
     contains 'Purgeable' the key can be permanently deleted by a privileged user; otherwise, only
     the system can purge the key, at the end of the retention interval.
     """
 
-    #: Denotes a vault state in which deletion is an irreversible operation, without the possibility
+    PURGEABLE = "Purgeable"
+    """Denotes a vault state in which deletion is an irreversible operation, without the possibility
     #: for recovery. This level corresponds to no protection being available against a Delete
     #: operation; the data is irretrievably lost upon accepting a Delete operation at the entity level
-    #: or higher (vault, resource group, subscription etc.)
-    PURGEABLE = "Purgeable"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: or higher (vault, resource group, subscription etc.)"""
+    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity
     #: during the retention interval (90 days), unless a Purge operation is requested, or the
-    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE_PURGEABLE = "Recoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: subscription is cancelled. System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE = "Recoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted
     #: entity during the retention interval(90 days) and while the subscription is still available.
-    #: System wil permanently delete it after 90 days, if not recovered
-    RECOVERABLE = "Recoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable within retention
+    #: System wil permanently delete it after 90 days, if not recovered"""
+    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable within retention
     #: interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in
     #: which the subscription itself  cannot be permanently canceled. System wil permanently delete it
-    #: after 90 days, if not recovered
-    RECOVERABLE_PROTECTED_SUBSCRIPTION = "Recoverable+ProtectedSubscription"
-    #: Denotes a vault state in which deletion is recoverable, and which also permits immediate and
+    #: after 90 days, if not recovered"""
+    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
+    """Denotes a vault state in which deletion is recoverable, and which also permits immediate and
     #: permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees
     #: the recoverability of the deleted entity during the retention interval, unless a Purge
-    #: operation is requested, or the subscription is cancelled.
-    CUSTOMIZED_RECOVERABLE_PURGEABLE = "CustomizedRecoverable+Purgeable"
-    #: Denotes a vault state in which deletion is recoverable without the possibility for immediate
+    #: operation is requested, or the subscription is cancelled."""
+    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
+    """Denotes a vault state in which deletion is recoverable without the possibility for immediate
     #: and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level
     #: guarantees the recoverability of the deleted entity during the retention interval and while the
-    #: subscription is still available.
-    CUSTOMIZED_RECOVERABLE = "CustomizedRecoverable"
-    #: Denotes a vault and subscription state in which deletion is recoverable, immediate and
+    #: subscription is still available."""
+    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    """Denotes a vault and subscription state in which deletion is recoverable, immediate and
     #: permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot
     #: be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the
     #: recoverability of the deleted entity during the retention interval, and also reflects the fact
-    #: that the subscription itself cannot be cancelled.
-    CUSTOMIZED_RECOVERABLE_PROTECTED_SUBSCRIPTION = "CustomizedRecoverable+ProtectedSubscription"
+    #: that the subscription itself cannot be cancelled."""
 
 
 class JsonWebKeyCurveName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Elliptic curve name. For valid values, see JsonWebKeyCurveName."""
 
-    #: The NIST P-256 elliptic curve, AKA SECG curve SECP256R1.
     P256 = "P-256"
-    #: The NIST P-384 elliptic curve, AKA SECG curve SECP384R1.
+    """The NIST P-256 elliptic curve, AKA SECG curve SECP256R1."""
     P384 = "P-384"
-    #: The NIST P-521 elliptic curve, AKA SECG curve SECP521R1.
+    """The NIST P-384 elliptic curve, AKA SECG curve SECP384R1."""
     P521 = "P-521"
-    #: The SECG SECP256K1 elliptic curve.
+    """The NIST P-521 elliptic curve, AKA SECG curve SECP521R1."""
     P256_K = "P-256K"
+    """The SECG SECP256K1 elliptic curve."""
 
 
 class JsonWebKeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """algorithm identifier."""
 
     RSA_OAEP = "RSA-OAEP"
     RSA_OAEP256 = "RSA-OAEP-256"
     RSA1_5 = "RSA1_5"
-    A128_GCM = "A128GCM"
-    A192_GCM = "A192GCM"
-    A256_GCM = "A256GCM"
-    A128_KW = "A128KW"
-    A192_KW = "A192KW"
-    A256_KW = "A256KW"
-    A128_CBC = "A128CBC"
-    A192_CBC = "A192CBC"
-    A256_CBC = "A256CBC"
-    A128_CBCPAD = "A128CBCPAD"
-    A192_CBCPAD = "A192CBCPAD"
-    A256_CBCPAD = "A256CBCPAD"
 
 
 class JsonWebKeyOperation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JSON web key operations. For more information, see JsonWebKeyOperation."""
 
     ENCRYPT = "encrypt"
     DECRYPT = "decrypt"
     SIGN = "sign"
     VERIFY = "verify"
     WRAP_KEY = "wrapKey"
     UNWRAP_KEY = "unwrapKey"
-    IMPORT = "import"
-    EXPORT = "export"
 
 
 class JsonWebKeySignatureAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The signing/verification algorithm identifier. For more information on possible algorithm
     types, see JsonWebKeySignatureAlgorithm.
     """
 
-    #: RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
-    #: https://tools.ietf.org/html/rfc7518
     PS256 = "PS256"
-    #: RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-256 and MGF1 with SHA-256, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS384 = "PS384"
-    #: RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
-    #: https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-384 and MGF1 with SHA-384, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     PS512 = "PS512"
-    #: RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PSS using SHA-512 and MGF1 with SHA-512, as described in
+    #: https://tools.ietf.org/html/rfc7518"""
     RS256 = "RS256"
-    #: RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
     RS384 = "RS384"
-    #: RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """RSASSA-PKCS1-v1_5 using SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     RS512 = "RS512"
-    #: Reserved
+    """RSASSA-PKCS1-v1_5 using SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     RSNULL = "RSNULL"
-    #: ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518.
+    """Reserved"""
     ES256 = "ES256"
-    #: ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-256 and SHA-256, as described in https://tools.ietf.org/html/rfc7518."""
     ES384 = "ES384"
-    #: ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-384 and SHA-384, as described in https://tools.ietf.org/html/rfc7518"""
     ES512 = "ES512"
-    #: ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518
+    """ECDSA using P-521 and SHA-512, as described in https://tools.ietf.org/html/rfc7518"""
     ES256_K = "ES256K"
+    """ECDSA using P-256K and SHA-256, as described in https://tools.ietf.org/html/rfc7518"""
 
 
 class JsonWebKeyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """JsonWebKey Key Type (kty), as defined in
     https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
     """
 
-    #: Elliptic Curve.
     EC = "EC"
-    #: Elliptic Curve with a private key which is stored in the HSM.
+    """Elliptic Curve."""
     EC_HSM = "EC-HSM"
-    #: RSA (https://tools.ietf.org/html/rfc3447)
+    """Elliptic Curve with a private key which is not exportable from the HSM."""
     RSA = "RSA"
-    #: RSA with a private key which is stored in the HSM.
+    """RSA (https://tools.ietf.org/html/rfc3447)"""
     RSA_HSM = "RSA-HSM"
-    #: Octet sequence (used to represent symmetric keys)
+    """RSA with a private key which is not exportable from the HSM."""
     OCT = "oct"
-    #: Octet sequence (used to represent symmetric keys) which is stored the HSM.
-    OCT_HSM = "oct-HSM"
+    """Not supported in this version. Octet sequence (used to represent symmetric keys)"""
+
+
+class KeyUsageType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """KeyUsageType."""
+
+    DIGITAL_SIGNATURE = "digitalSignature"
+    NON_REPUDIATION = "nonRepudiation"
+    KEY_ENCIPHERMENT = "keyEncipherment"
+    DATA_ENCIPHERMENT = "dataEncipherment"
+    KEY_AGREEMENT = "keyAgreement"
+    KEY_CERT_SIGN = "keyCertSign"
+    C_RL_SIGN = "cRLSign"
+    ENCIPHER_ONLY = "encipherOnly"
+    DECIPHER_ONLY = "decipherOnly"
 
 
-class KeyEncryptionAlgorithm(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The encryption algorithm to use to protected the exported key material."""
+class SasTokenType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The type of SAS token the SAS definition will create."""
 
-    CKM_RSA_AES_KEY_WRAP = "CKM_RSA_AES_KEY_WRAP"
-    RSA_AES_KEY_WRAP256 = "RSA_AES_KEY_WRAP_256"
-    RSA_AES_KEY_WRAP384 = "RSA_AES_KEY_WRAP_384"
+    ACCOUNT = "account"
+    SERVICE = "service"
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/__init__.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_4/models/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -45,15 +45,15 @@
 from ._key_vault_client_enums import JsonWebKeyCurveName
 from ._key_vault_client_enums import JsonWebKeyEncryptionAlgorithm
 from ._key_vault_client_enums import JsonWebKeyOperation
 from ._key_vault_client_enums import JsonWebKeySignatureAlgorithm
 from ._key_vault_client_enums import JsonWebKeyType
 from ._key_vault_client_enums import KeyEncryptionAlgorithm
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "BackupKeyResult",
     "DeletedKeyBundle",
     "DeletedKeyItem",
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py` & `azure-keyvault-keys-4.9.0b1/azure/keyvault/keys/_generated/v7_3/models/_models_py3.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -84,15 +84,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyBundle(_serialization.Model):
     """A KeyBundle consisting of a WebKey plus its attributes.
@@ -127,16 +127,16 @@
     def __init__(
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_3.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -197,16 +197,16 @@
         self,
         *,
         key: Optional["_models.JsonWebKey"] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key: The Json web key.
         :paramtype key: ~azure.keyvault.v7_3.models.JsonWebKey
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -251,16 +251,16 @@
 
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -314,16 +314,16 @@
     def __init__(
         self,
         *,
         kid: Optional[str] = None,
         attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         recovery_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword attributes: The key management attributes.
         :paramtype attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -355,15 +355,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DeletedKeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class Error(_serialization.Model):
@@ -387,15 +387,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -412,15 +412,15 @@
         "count": {"required": True, "maximum": 128, "minimum": 1},
     }
 
     _attribute_map = {
         "count": {"key": "count", "type": "int"},
     }
 
-    def __init__(self, *, count: int, **kwargs):
+    def __init__(self, *, count: int, **kwargs: Any) -> None:
         """
         :keyword count: The requested number of random bytes. Required.
         :paramtype count: int
         """
         super().__init__(**kwargs)
         self.count = count
 
@@ -499,16 +499,16 @@
         p: Optional[bytes] = None,
         q: Optional[bytes] = None,
         k: Optional[bytes] = None,
         t: Optional[bytes] = None,
         crv: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         x: Optional[bytes] = None,
         y: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kid: Key identifier.
         :paramtype kid: str
         :keyword kty: JsonWebKey Key Type (kty), as defined in
          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.v7_3.models.JsonWebKeyType
@@ -612,16 +612,16 @@
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
         exportable: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -641,15 +641,16 @@
     All required parameters must be populated in order to send to Azure.
 
     :ivar kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
      values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
     :vartype kty: str or ~azure.keyvault.v7_3.models.JsonWebKeyType
     :ivar key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
     :vartype key_size: int
-    :ivar public_exponent: The public exponent for a RSA key.
+    :ivar public_exponent: The public exponent for a RSA key. This applies only to keys created in
+     a Managed HSM.
     :vartype public_exponent: int
     :ivar key_ops:
     :vartype key_ops: list[str or ~azure.keyvault.v7_3.models.JsonWebKeyOperation]
     :ivar key_attributes: The attributes of a key managed by the key vault service.
     :vartype key_attributes: ~azure.keyvault.v7_3.models.KeyAttributes
     :ivar tags: Application specific metadata in the form of key-value pairs.
     :vartype tags: dict[str, str]
@@ -682,23 +683,24 @@
         key_size: Optional[int] = None,
         public_exponent: Optional[int] = None,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword kty: The type of key to create. For valid values, see JsonWebKeyType. Required. Known
          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype kty: str or ~azure.keyvault.v7_3.models.JsonWebKeyType
         :keyword key_size: The key size in bits. For example: 2048, 3072, or 4096 for RSA.
         :paramtype key_size: int
-        :keyword public_exponent: The public exponent for a RSA key.
+        :keyword public_exponent: The public exponent for a RSA key. This applies only to keys created
+         in a Managed HSM.
         :paramtype public_exponent: int
         :keyword key_ops:
         :paramtype key_ops: list[str or ~azure.keyvault.v7_3.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
         :paramtype tags: dict[str, str]
@@ -741,16 +743,16 @@
 
     def __init__(
         self,
         *,
         wrapping_key: Optional["_models.JsonWebKey"] = None,
         wrapping_kid: Optional[str] = None,
         enc: Optional[Union[str, "_models.KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword wrapping_key: The export key encryption Json web key. This key MUST be a RSA key that
          supports encryption.
         :paramtype wrapping_key: ~azure.keyvault.v7_3.models.JsonWebKey
         :keyword wrapping_kid: The export key encryption key identifier. This key MUST be a RSA key
          that supports encryption.
         :paramtype wrapping_kid: str
@@ -797,16 +799,16 @@
         self,
         *,
         key: "_models.JsonWebKey",
         hsm: Optional[bool] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword hsm: Whether to import as a hardware key (HSM) or software key.
         :paramtype hsm: bool
         :keyword key: The Json web key. Required.
         :paramtype key: ~azure.keyvault.v7_3.models.JsonWebKey
         :keyword key_attributes: The key management attributes.
         :paramtype key_attributes: ~azure.keyvault.v7_3.models.KeyAttributes
@@ -841,15 +843,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[KeyItem]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class KeyOperationResult(_serialization.Model):
@@ -881,15 +883,15 @@
         "kid": {"key": "kid", "type": "str"},
         "result": {"key": "value", "type": "base64"},
         "iv": {"key": "iv", "type": "base64"},
         "authentication_tag": {"key": "tag", "type": "base64"},
         "additional_authenticated_data": {"key": "aad", "type": "base64"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.kid = None
         self.result = None
         self.iv = None
         self.authentication_tag = None
         self.additional_authenticated_data = None
@@ -933,16 +935,16 @@
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeyEncryptionAlgorithm"],
         value: bytes,
         iv: Optional[bytes] = None,
         aad: Optional[bytes] = None,
         tag: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: algorithm identifier. Required. Known values are: "RSA-OAEP",
          "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW", "A192KW", "A256KW",
          "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD", and "A256CBCPAD".
         :paramtype algorithm: str or ~azure.keyvault.v7_3.models.JsonWebKeyEncryptionAlgorithm
         :keyword value: Required.
         :paramtype value: bytes
@@ -994,16 +996,16 @@
         self,
         *,
         exportable: Optional[bool] = None,
         key_type: Optional[Union[str, "_models.JsonWebKeyType"]] = None,
         key_size: Optional[int] = None,
         reuse_key: Optional[bool] = None,
         curve: Optional[Union[str, "_models.JsonWebKeyCurveName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword exportable: Indicates if the private key can be exported. Release policy must be
          provided when creating the 1st version of an exportable key.
         :paramtype exportable: bool
         :keyword key_type: The type of key pair to be used for the certificate. Known values are: "EC",
          "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
         :paramtype key_type: str or ~azure.keyvault.v7_3.models.JsonWebKeyType
@@ -1050,16 +1052,16 @@
 
     def __init__(
         self,
         *,
         target_attestation_token: str,
         nonce: Optional[str] = None,
         enc: Optional[Union[str, "_models.KeyEncryptionAlgorithm"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword target_attestation_token: The attestation assertion for the target of the key release.
          Required.
         :paramtype target_attestation_token: str
         :keyword nonce: A client provided nonce for freshness.
         :paramtype nonce: str
         :keyword enc: The encryption algorithm to use to protected the exported key material. Known
@@ -1093,16 +1095,16 @@
 
     def __init__(
         self,
         *,
         content_type: str = "application/json; charset=utf-8",
         immutable: Optional[bool] = None,
         encoded_policy: Optional[bytes] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword content_type: Content type and version of key release policy.
         :paramtype content_type: str
         :keyword immutable: Defines the mutability state of the policy. Once marked immutable, this
          flag cannot be reset and the policy cannot be changed under any circumstances.
         :paramtype immutable: bool
         :keyword encoded_policy: Blob encoding the policy rules under which the key can be released.
@@ -1128,15 +1130,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class KeyRestoreParameters(_serialization.Model):
     """The key restore parameters.
@@ -1151,15 +1153,15 @@
         "key_bundle_backup": {"required": True},
     }
 
     _attribute_map = {
         "key_bundle_backup": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, key_bundle_backup: bytes, **kwargs):
+    def __init__(self, *, key_bundle_backup: bytes, **kwargs: Any) -> None:
         """
         :keyword key_bundle_backup: The backup blob associated with a key bundle. Required.
         :paramtype key_bundle_backup: bytes
         """
         super().__init__(**kwargs)
         self.key_bundle_backup = key_bundle_backup
 
@@ -1190,16 +1192,16 @@
     }
 
     def __init__(
         self,
         *,
         lifetime_actions: Optional[List["_models.LifetimeActions"]] = None,
         attributes: Optional["_models.KeyRotationPolicyAttributes"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword lifetime_actions: Actions that will be performed by Key Vault over the lifetime of a
          key. For preview, lifetimeActions can only have two items at maximum: one for rotate, one for
          notify. Notification time would be default to 30 days before expiry and it is not configurable.
         :paramtype lifetime_actions: list[~azure.keyvault.v7_3.models.LifetimeActions]
         :keyword attributes: The key rotation policy attributes.
         :paramtype attributes: ~azure.keyvault.v7_3.models.KeyRotationPolicyAttributes
@@ -1232,15 +1234,15 @@
 
     _attribute_map = {
         "expiry_time": {"key": "expiryTime", "type": "str"},
         "created": {"key": "created", "type": "unix-time"},
         "updated": {"key": "updated", "type": "unix-time"},
     }
 
-    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs):
+    def __init__(self, *, expiry_time: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword expiry_time: The expiryTime will be applied on the new key version. It should be at
          least 28 days. It will be in ISO 8601 Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours:
          PT48H, 1 year and 10 days: P1Y10D.
         :paramtype expiry_time: str
         """
         super().__init__(**kwargs)
@@ -1269,15 +1271,17 @@
     }
 
     _attribute_map = {
         "algorithm": {"key": "alg", "type": "str"},
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs):
+    def __init__(
+        self, *, algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"], value: bytes, **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm identifier. For more information on
          possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are:
          "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and
          "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_3.models.JsonWebKeySignatureAlgorithm
         :keyword value: Required.
@@ -1312,16 +1316,16 @@
     def __init__(
         self,
         *,
         key_ops: Optional[List[Union[str, "_models.JsonWebKeyOperation"]]] = None,
         key_attributes: Optional["_models.KeyAttributes"] = None,
         tags: Optional[Dict[str, str]] = None,
         release_policy: Optional["_models.KeyReleasePolicy"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_ops: Json web key operations. For more information on possible key operations, see
          JsonWebKeyOperation.
         :paramtype key_ops: list[str or ~azure.keyvault.v7_3.models.JsonWebKeyOperation]
         :keyword key_attributes: The attributes of a key managed by the key vault service.
         :paramtype key_attributes: ~azure.keyvault.v7_3.models.KeyAttributes
         :keyword tags: Application specific metadata in the form of key-value pairs.
@@ -1349,15 +1353,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class KeyVerifyParameters(_serialization.Model):
     """The key verify parameters.
@@ -1388,16 +1392,16 @@
 
     def __init__(
         self,
         *,
         algorithm: Union[str, "_models.JsonWebKeySignatureAlgorithm"],
         digest: bytes,
         signature: bytes,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword algorithm: The signing/verification algorithm. For more information on possible
          algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known values are: "PS256",
          "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
         :paramtype algorithm: str or ~azure.keyvault.v7_3.models.JsonWebKeySignatureAlgorithm
         :keyword digest: The digest used for signing. Required.
         :paramtype digest: bytes
@@ -1423,15 +1427,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "bool"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class LifetimeActions(_serialization.Model):
     """Action and its trigger that will be performed by Key Vault over the lifetime of a key.
@@ -1448,16 +1452,16 @@
     }
 
     def __init__(
         self,
         *,
         trigger: Optional["_models.LifetimeActionsTrigger"] = None,
         action: Optional["_models.LifetimeActionsType"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword trigger: The condition that will execute the action.
         :paramtype trigger: ~azure.keyvault.v7_3.models.LifetimeActionsTrigger
         :keyword action: The action that will be executed.
         :paramtype action: ~azure.keyvault.v7_3.models.LifetimeActionsType
         """
         super().__init__(**kwargs)
@@ -1477,15 +1481,17 @@
     """
 
     _attribute_map = {
         "time_after_create": {"key": "timeAfterCreate", "type": "str"},
         "time_before_expiry": {"key": "timeBeforeExpiry", "type": "str"},
     }
 
-    def __init__(self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, time_after_create: Optional[str] = None, time_before_expiry: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword time_after_create: Time after creation to attempt to rotate. It only applies to
          rotate. It will be in ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_after_create: str
         :keyword time_before_expiry: Time before expiry to attempt to rotate or notify. It will be in
          ISO 8601 duration format. Example: 90 days : "P90D".
         :paramtype time_before_expiry: str
@@ -1502,15 +1508,15 @@
     :vartype type: str or ~azure.keyvault.v7_3.models.ActionType
     """
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs):
+    def __init__(self, *, type: Optional[Union[str, "_models.ActionType"]] = None, **kwargs: Any) -> None:
         """
         :keyword type: The type of the action. Known values are: "rotate" and "notify".
         :paramtype type: str or ~azure.keyvault.v7_3.models.ActionType
         """
         super().__init__(**kwargs)
         self.type = type
 
@@ -1528,14 +1534,14 @@
         "value": {"required": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "base64"},
     }
 
-    def __init__(self, *, value: bytes, **kwargs):
+    def __init__(self, *, value: bytes, **kwargs: Any) -> None:
         """
         :keyword value: The bytes encoded as a base64url string. Required.
         :paramtype value: bytes
         """
         super().__init__(**kwargs)
         self.value = value
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/list_operations.py` & `azure-keyvault-keys-4.9.0b1/samples/list_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -41,44 +41,42 @@
 client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
 # Let's create keys with RSA and EC type. If the key
 # already exists in the Key Vault, then a new version of the key is created.
 print("\n.. Create Key")
 rsa_key = client.create_rsa_key("rsaKeyName")
 ec_key = client.create_ec_key("ecKeyName")
-print("Key with name '{0}' was created of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
-print("Key with name '{0}' was created of type '{1}'.".format(ec_key.name, ec_key.key_type))
+print(f"Key with name '{rsa_key.name}' was created of type '{rsa_key.key_type}'.")
+print(f"Key with name '{ec_key.name}' was created of type '{ec_key.key_type}'.")
 
 # You need to check the type of all the keys in the vault.
 # Let's list the keys and print their key types.
 # List operations don 't return the keys with their type information.
 # So, for each returned key we call get_key to get the key with its type information.
 print("\n.. List keys from the Key Vault")
 keys = client.list_properties_of_keys()
 for key in keys:
     retrieved_key = client.get_key(key.name)
-    print(
-        "Key with name '{0}' with type '{1}' was found.".format(retrieved_key.name, retrieved_key.key_type)
-    )
+    print(f"Key with name '{retrieved_key.name}' with type '{retrieved_key.key_type}' was found.")
 
 # The rsa key size now should now be 3072, default - 2048. So you want to update the key in Key Vault to ensure
 # it reflects the new key size. Calling create_rsa_key on an existing key creates a new version of the key in
 # the Key Vault with the new key size.
 new_key = client.create_rsa_key(rsa_key.name, size=3072)
-print("New version was created for Key with name '{0}' with the updated size.".format(new_key.name))
+print(f"New version was created for Key with name '{new_key.name}' with the updated size.")
 
 # You should have more than one version of the rsa key at this time. Lets print all the versions of this key.
 print("\n.. List versions of a key using its name")
 key_versions = client.list_properties_of_key_versions(rsa_key.name)
 for key in key_versions:
-    print("Key '{0}' has version: '{1}'".format(key.name, key.version))
+    print(f"Key '{key.name}' has version: '{key.version}'")
 
 # Both the rsa key and ec key are not needed anymore. Let's delete those keys.
 print("\n.. Delete the created keys...")
 for key_name in (ec_key.name, rsa_key.name):
     client.begin_delete_key(key_name).wait()
 
 # You can list all the deleted and non-purged keys.
 print("\n.. List deleted keys from the Key Vault (requires soft-delete)")
 deleted_keys = client.list_deleted_keys()
 for deleted_key in deleted_keys:
-    print("Key with name '{0}' has recovery id '{1}'".format(deleted_key.name, deleted_key.recovery_id))
+    print(f"Key with name '{deleted_key.name}' has recovery id '{deleted_key.recovery_id}'")
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations.py` & `azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -40,33 +40,33 @@
 credential = DefaultAzureCredential()
 client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
 # Let's create a Key of type RSA.
 # if the key already exists in the Key Vault, then a new version of the key is created.
 print("\n.. Create Key")
 key = client.create_key("keyName", "RSA")
-print("Key with name '{0}' created with key type '{1}'".format(key.name, key.key_type))
+print(f"Key with name '{key.name}' created with key type '{key.key_type}'")
 
 # Backups are good to have, if in case keys gets deleted accidentally.
 # For long term storage, it is ideal to write the backup to a file.
 print("\n.. Create a backup for an existing Key")
 key_backup = client.backup_key(key.name)
-print("Backup created for key with name '{0}'.".format(key.name))
+print(f"Backup created for key with name '{key.name}'.")
 
 # The rsa key is no longer in use, so you delete it.
 print("\n.. Delete the key")
 delete_operation = client.begin_delete_key(key.name)
 deleted_key = delete_operation.result()
-print("Deleted key with name '{0}'".format(deleted_key.name))
+print(f"Deleted key with name '{deleted_key.name}'")
 
 # Wait for the deletion to complete before purging the key.
 # The purge will take some time, so wait before restoring the backup to avoid a conflict.
 delete_operation.wait()
 print("\n.. Purge the key")
 client.purge_deleted_key(key.name)
 time.sleep(60)
-print("Purged key with name '{0}'".format(deleted_key.name))
+print(f"Purged key with name '{deleted_key.name}'")
 
 # In the future, if the key is required again, we can use the backup value to restore it in the Key Vault.
 print("\n.. Restore the key using the backed up key bytes")
 key = client.restore_key_backup(key_backup)
-print("Restored key with name '{0}'".format(key.name))
+print(f"Restored key with name '{key.name}'")
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/key_rotation.py` & `azure-keyvault-keys-4.9.0b1/samples/key_rotation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import os
 from azure.identity import DefaultAzureCredential
-from azure.keyvault.keys import KeyClient, KeyRotationLifetimeAction, KeyRotationPolicy, KeyRotationPolicyAction
+from azure.keyvault.keys import KeyClient
 
 # ----------------------------------------------------------------------------------------------------------
 # Prerequisites:
 # 1. An Azure Key Vault (https://docs.microsoft.com/azure/key-vault/quick-create-cli)
 #
 # 2. azure-keyvault-keys and azure-identity libraries (pip install these)
 #
@@ -36,64 +36,69 @@
 # Instantiate a key client that will be used to call the service.
 # Here we use the DefaultAzureCredential, but any azure-identity credential can be used.
 VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
 client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
 # First, create a key
-key_name = "rotation-sample-key"
-key = client.create_rsa_key(key_name)
-print("\nCreated a key; new version is {}".format(key.properties.version))
+key = client.create_rsa_key("rotation-sample-key")
+print(f"\nCreated a key; new version is {key.properties.version}")
 
-# Set the key's automated rotation policy to rotate the key two months after the key was created.
+# [START update_a_rotation_policy]
+from azure.keyvault.keys import KeyRotationLifetimeAction, KeyRotationPolicy, KeyRotationPolicyAction
+
+# Here we set the key's automated rotation policy to rotate the key two months after the key was created.
 # If you pass an empty KeyRotationPolicy() as the `policy` parameter, the rotation policy will be set to the
 # default policy. Any keyword arguments will update specified properties of the policy.
 actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.rotate, time_after_create="P2M")]
 updated_policy = client.update_key_rotation_policy(
-    key_name, KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
+    "rotation-sample-key", policy=KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
 )
 assert updated_policy.expires_in == "P90D"
+# [END update_a_rotation_policy]
 
 # The updated policy should have the specified lifetime action
 policy_action = None
 for i in range(len(updated_policy.lifetime_actions)):
     if updated_policy.lifetime_actions[i].action == KeyRotationPolicyAction.rotate:
         policy_action = updated_policy.lifetime_actions[i]
 assert policy_action, "The specified action should exist in the key rotation policy"
 assert policy_action.time_after_create == "P2M", "The action should have the specified time_after_create"
 assert policy_action.time_before_expiry is None, "The action shouldn't have a time_before_expiry"
-print("\nCreated a new key rotation policy: {} after {}".format(policy_action.action, policy_action.time_after_create))
+print(f"\nCreated a new key rotation policy: {policy_action.action} after {policy_action.time_after_create}")
 
 # Get the key's current rotation policy
-current_policy = client.get_key_rotation_policy(key_name)
+current_policy = client.get_key_rotation_policy("rotation-sample-key")
 policy_action = None
 for i in range(len(current_policy.lifetime_actions)):
     if current_policy.lifetime_actions[i].action == KeyRotationPolicyAction.rotate:
         policy_action = current_policy.lifetime_actions[i]
-print("\nCurrent rotation policy: {} after {}".format(policy_action.action, policy_action.time_after_create))
+print(f"\nCurrent rotation policy: {policy_action.action} after {policy_action.time_after_create}")
 
 # Update the key's automated rotation policy to notify 10 days before the key expires
 new_actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.notify, time_before_expiry="P10D")]
 # To preserve an existing rotation policy, pass in the existing policy as the `policy` parameter.
 # Any property specified as a keyword argument will be overridden completely by the provided value.
 # In this case, the rotate action we created earlier will be removed from the policy.
-new_policy = client.update_key_rotation_policy(key_name, current_policy, lifetime_actions=new_actions)
+new_policy = client.update_key_rotation_policy("rotation-sample-key", current_policy, lifetime_actions=new_actions)
 assert new_policy.expires_in == "P90D", "The key's expiry time should have been preserved"
 
 # The updated policy should include the new notify action
 notify_action = None
 for i in range(len(new_policy.lifetime_actions)):
     if new_policy.lifetime_actions[i].action == KeyRotationPolicyAction.notify:
         notify_action = new_policy.lifetime_actions[i]
 
 assert notify_action, "The specified action should exist in the key rotation policy"
 assert notify_action.time_after_create is None, "The action shouldn't have a time_after_create"
 assert notify_action.time_before_expiry == "P10D", "The action should have the specified time_before_expiry"
-print("\nNew policy action: {} {} before expiry".format(notify_action.action, notify_action.time_before_expiry))
+print(f"\nNew policy action: {notify_action.action} {notify_action.time_before_expiry} before expiry\n")
 
 # Finally, you can rotate a key on-demand by creating a new version of the key
-rotated_key = client.rotate_key(key_name)
-print("\nRotated the key on-demand; new version is {}".format(rotated_key.properties.version))
+# [START rotate_key]
+rotated_key = client.rotate_key("rotation-sample-key")
+print(f"Rotated the key on-demand; new version is {rotated_key.properties.version}")
+# [END rotate_key]
 
 # To clean up, delete the key
-client.begin_delete_key(key_name)
+client.begin_delete_key("rotation-sample-key")
 print("\nDeleted the key")
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations.py` & `azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -36,35 +36,35 @@
 VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
 client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
 print("\n.. Create keys")
 rsa_key = client.create_rsa_key("rsaKeyName")
 ec_key = client.create_ec_key("ecKeyName")
-print("Created key '{0}' of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
-print("Created key '{0}' of type '{1}'.".format(ec_key.name, ec_key.key_type))
+print(f"Created key '{rsa_key.name}' of type '{rsa_key.key_type}'.")
+print(f"Created key '{ec_key.name}' of type '{ec_key.key_type}'.")
 
 print("\n.. Delete the keys")
 for key_name in (ec_key.name, rsa_key.name):
     client.begin_delete_key(key_name).wait()
-    print("Deleted key '{0}'".format(key_name))
+    print(f"Deleted key '{key_name}'")
 
 # A deleted key can only be recovered if the Key Vault is soft-delete enabled.
 print("\n.. Recover a deleted key")
 recover_key_poller = client.begin_recover_deleted_key(rsa_key.name)
 recovered_key = recover_key_poller.result()
 
 # This wait is just to ensure recovery is complete before we delete the key again
 recover_key_poller.wait()
-print("Recovered key '{0}'".format(recovered_key.name))
+print(f"Recovered key '{recovered_key.name}'")
 
 # To permanently delete the key, the deleted key needs to be purged.
 # Calling result() on the method will immediately return the `DeletedKey`, but calling wait() blocks
 # until the key is deleted server-side so it can be purged.
 client.begin_delete_key(recovered_key.name).wait()
 
 # Keys will still purge eventually on their scheduled purge date, but calling `purge_deleted_key` immediately
 # purges.
 print("\n.. Purge keys")
 for key_name in (ec_key.name, rsa_key.name):
     client.purge_deleted_key(key_name)
-    print("Purged '{}'".format(key_name))
+    print(f"Purged '{key_name}'")
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/hello_world.py` & `azure-keyvault-keys-4.9.0b1/samples/hello_world.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import datetime
 import os
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.keys import KeyClient
 
 # ----------------------------------------------------------------------------------------------------------
 # Prerequisites:
 # 1. An Azure Key Vault (https://docs.microsoft.com/azure/key-vault/quick-create-cli)
 #
 # 2. azure-keyvault-keys and azure-identity libraries (pip install these)
 #
@@ -32,56 +30,55 @@
 # 4. Update an existing key (update_key)
 #
 # 5. Delete a key (begin_delete_key)
 # ----------------------------------------------------------------------------------------------------------
 
 # Instantiate a key client that will be used to call the service.
 # Here we use the DefaultAzureCredential, but any azure-identity credential can be used.
+# [START create_a_key_client]
+from azure.identity import DefaultAzureCredential
+from azure.keyvault.keys import KeyClient
+
 VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
 client = KeyClient(vault_url=VAULT_URL, credential=credential)
+# [END create_a_key_client]
 
 # Let's create an RSA key with size 2048, hsm disabled and optional key_operations of encrypt, decrypt.
 # if the key already exists in the Key Vault, then a new version of the key is created.
 print("\n.. Create an RSA Key")
 key_size = 2048
 key_ops = ["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"]
 key_name = "rsaKeyName"
 rsa_key = client.create_rsa_key(key_name, size=key_size, key_operations=key_ops)
-print("RSA Key with name '{0}' created of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
+print(f"RSA Key with name '{rsa_key.name}' created of type '{rsa_key.key_type}'.")
 
 # Let's create an Elliptic Curve key with algorithm curve type P-256.
 # if the key already exists in the Key Vault, then a new version of the key is created.
 print("\n.. Create an EC Key")
 key_curve = "P-256"
 key_name = "ECKeyName"
 ec_key = client.create_ec_key(key_name, curve=key_curve)
-print("EC Key with name '{0}' created of type '{1}'.".format(ec_key.name, ec_key.key_type))
+print(f"EC Key with name '{ec_key.name}' created of type '{ec_key.key_type}'.")
 
 # Let's get the rsa key details using its name
 print("\n.. Get a Key by its name")
 rsa_key = client.get_key(rsa_key.name)
-print("Key with name '{0}' was found.".format(rsa_key.name))
+print(f"Key with name '{rsa_key.name}' was found.")
 
 # Let's say we want to update the expiration time for the EC key and disable the key to be usable
 # for cryptographic operations. The update method allows the user to modify the metadata (key attributes)
 # associated with a key previously stored within Key Vault.
 print("\n.. Update a Key by name")
 expires = datetime.datetime.utcnow() + datetime.timedelta(days=365)
 updated_ec_key = client.update_key_properties(
     ec_key.name, ec_key.properties.version, expires_on=expires, enabled=False
 )
-print(
-    "Key with name '{0}' was updated on date '{1}'".format(updated_ec_key.name, updated_ec_key.properties.updated_on)
-)
-print(
-    "Key with name '{0}' was updated to expire on '{1}'".format(
-        updated_ec_key.name, updated_ec_key.properties.expires_on
-    )
-)
+print(f"Key with name '{updated_ec_key.name}' was updated on date '{updated_ec_key.properties.updated_on}'")
+print(f"Key with name '{updated_ec_key.name}' was updated to expire on '{updated_ec_key.properties.expires_on}'")
 
 # The RSA key is no longer used, need to delete it from the Key Vault.
 print("\n.. Delete Keys")
 client.begin_delete_key(ec_key.name)
 client.begin_delete_key(rsa_key.name)
-print("Deleted key '{0}'".format(ec_key.name))
-print("Deleted key '{0}'".format(rsa_key.name))
+print(f"Deleted key '{ec_key.name}'")
+print(f"Deleted key '{rsa_key.name}'")
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/key_rotation_async.py` & `azure-keyvault-keys-4.9.0b1/samples/key_rotation_async.py`

 * *Files 7% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     VAULT_URL = os.environ["VAULT_URL"]
     credential = DefaultAzureCredential()
     client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
     # First, create a key
     key_name = "rotation-sample-key-async"
     key = await client.create_rsa_key(key_name)
-    print("\nCreated a key; new version is {}".format(key.properties.version))
+    print(f"\nCreated a key; new version is {key.properties.version}")
 
     # Set the key's automated rotation policy to rotate the key two months after the key was created.
     # If you pass an empty KeyRotationPolicy() as the `policy` parameter, the rotation policy will be set to the
     # default policy. Any keyword arguments will update specified properties of the policy.
     actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.rotate, time_after_create="P2M")]
     updated_policy = await client.update_key_rotation_policy(
         key_name, KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
@@ -60,25 +60,23 @@
     policy_action = None
     for i in range(len(updated_policy.lifetime_actions)):
         if updated_policy.lifetime_actions[i].action == KeyRotationPolicyAction.rotate:
             policy_action = updated_policy.lifetime_actions[i]
     assert policy_action, "The specified action should exist in the key rotation policy"
     assert policy_action.time_after_create == "P2M", "The action should have the specified time_after_create"
     assert policy_action.time_before_expiry is None, "The action shouldn't have a time_before_expiry"
-    print(
-        "\nCreated a new key rotation policy: {} after {}".format(policy_action.action, policy_action.time_after_create)
-    )
+    print(f"\nCreated a new key rotation policy: {policy_action.action} after {policy_action.time_after_create}")
 
     # Get the key's current rotation policy
     current_policy = await client.get_key_rotation_policy(key_name)
     policy_action = None
     for i in range(len(current_policy.lifetime_actions)):
         if current_policy.lifetime_actions[i].action == KeyRotationPolicyAction.rotate:
             policy_action = current_policy.lifetime_actions[i]
-    print("\nCurrent rotation policy: {} after {}".format(policy_action.action, policy_action.time_after_create))
+    print(f"\nCurrent rotation policy: {policy_action.action} after {policy_action.time_after_create}")
 
     # Update the key's automated rotation policy to notify 10 days before the key expires
     new_actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.notify, time_before_expiry="P10D")]
     # To preserve an existing rotation policy, pass in the existing policy as the `policy` parameter.
     # Any property specified as a keyword argument will be overridden completely by the provided value.
     # In this case, the rotate action we created earlier will be removed from the policy.
     new_policy = await client.update_key_rotation_policy(key_name, current_policy, lifetime_actions=new_actions)
@@ -89,19 +87,19 @@
     for i in range(len(new_policy.lifetime_actions)):
         if new_policy.lifetime_actions[i].action == KeyRotationPolicyAction.notify:
             notify_action = new_policy.lifetime_actions[i]
 
     assert notify_action, "The specified action should exist in the key rotation policy"
     assert notify_action.time_after_create is None, "The action shouldn't have a time_after_create"
     assert notify_action.time_before_expiry == "P10D", "The action should have the specified time_before_expiry"
-    print("\nNew policy action: {} {} before expiry".format(notify_action.action, notify_action.time_before_expiry))
+    print(f"\nNew policy action: {notify_action.action} {notify_action.time_before_expiry} before expiry")
 
     # Finally, you can rotate a key on-demand by creating a new version of the key
     rotated_key = await client.rotate_key(key_name)
-    print("\nRotated the key on-demand; new version is {}".format(rotated_key.properties.version))
+    print(f"\nRotated the key on-demand; new version is {rotated_key.properties.version}")
 
     # To clean up, delete the key
     await client.delete_key(key_name)
     print("\nDeleted the key")
 
     await credential.close()
     await client.close()
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/recover_purge_operations_async.py` & `azure-keyvault-keys-4.9.0b1/samples/recover_purge_operations_async.py`

 * *Files 12% similar despite different names*

```diff
@@ -37,36 +37,36 @@
     VAULT_URL = os.environ["VAULT_URL"]
     credential = DefaultAzureCredential()
     client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
     print("\n.. Create keys")
     rsa_key = await client.create_rsa_key("rsaKeyNameAsync")
     ec_key = await client.create_ec_key("ecKeyNameAsync")
-    print("Created key '{0}' of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
-    print("Created key '{0}' of type '{1}'.".format(ec_key.name, ec_key.key_type))
+    print(f"Created key '{rsa_key.name}' of type '{rsa_key.key_type}'.")
+    print(f"Created key '{ec_key.name}' of type '{ec_key.key_type}'.")
 
     print("\n.. Delete the keys")
     for key_name in (ec_key.name, rsa_key.name):
         deleted_key = await client.delete_key(key_name)
-        print("Deleted key '{0}'".format(deleted_key.name))
+        print(f"Deleted key '{deleted_key.name}'")
 
     # A deleted key can only be recovered if the Key Vault is soft-delete enabled.
     print("\n.. Recover a deleted key")
     recovered_key = await client.recover_deleted_key(rsa_key.name)
-    print("Recovered key '{0}'".format(recovered_key.name))
+    print(f"Recovered key '{recovered_key.name}'")
 
     # To permanently delete the key, the deleted key needs to be purged.
     await client.delete_key(recovered_key.name)
 
     # Keys will still purge eventually on their scheduled purge date, but calling `purge_deleted_key` immediately
     # purges.
     print("\n.. Purge keys")
     for key_name in (ec_key.name, rsa_key.name):
         await client.purge_deleted_key(key_name)
-        print("Purged '{}'".format(key_name))
+        print(f"Purged '{key_name}'")
 
     print("\nrun_sample done")
     await credential.close()
     await client.close()
 
 
 if __name__ == "__main__":
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/hello_world_async.py` & `azure-keyvault-keys-4.9.0b1/samples/hello_world_async.py`

 * *Files 8% similar despite different names*

```diff
@@ -45,53 +45,45 @@
     # Let's create an RSA key with size 2048, hsm disabled and optional key_operations of encrypt, decrypt.
     # if the key already exists in the Key Vault, then a new version of the key is created.
     print("\n.. Create an RSA Key")
     key_size = 2048
     key_ops = ["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"]
     key_name = "rsaKeyNameAsync"
     rsa_key = await client.create_rsa_key(key_name, size=key_size, key_operations=key_ops)
-    print("RSA Key with name '{0}' created of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
+    print(f"RSA Key with name '{rsa_key.name}' created of type '{rsa_key.key_type}'.")
 
     # Let's create an Elliptic Curve key with algorithm curve type P-256.
     # if the key already exists in the Key Vault, then a new version of the key is created.
     print("\n.. Create an EC Key")
     key_curve = "P-256"
     key_name = "ECKeyNameAsync"
     ec_key = await client.create_ec_key(key_name, curve=key_curve)
-    print("EC Key with name '{0}' created of type {1}.".format(ec_key.name, ec_key.key_type))
+    print(f"EC Key with name '{ec_key.name}' created of type {ec_key.key_type}.")
 
     # Let's get the rsa key details using its name
     print("\n.. Get a Key using it's name")
     rsa_key = await client.get_key(rsa_key.name)
-    print("Key with name '{0}' was found.".format(rsa_key.name))
+    print(f"Key with name '{rsa_key.name}' was found.")
 
     # Let's say we want to update the expiration time for the EC key and disable the key to be usable
     # for cryptographic operations. The update method allows the user to modify the metadata (key attributes)
     # associated with a key previously stored within Key Vault.
     print("\n.. Update a Key by name")
     expires_on = datetime.datetime.utcnow() + datetime.timedelta(days=365)
     updated_ec_key = await client.update_key_properties(
         ec_key.name, version=ec_key.properties.version, expires_on=expires_on, enabled=False
     )
-    print(
-        "Key with name '{0}' was updated on date '{1}'".format(
-            updated_ec_key.name, updated_ec_key.properties.updated_on
-        )
-    )
-    print(
-        "Key with name '{0}' was updated to expire on '{1}'".format(
-            updated_ec_key.name, updated_ec_key.properties.expires_on
-        )
-    )
+    print(f"Key with name '{updated_ec_key.name}' was updated on date '{updated_ec_key.properties.updated_on}'")
+    print(f"Key with name '{updated_ec_key.name}' was updated to expire on '{updated_ec_key.properties.expires_on}'")
 
     # The keys are no longer used, let's delete them
     print("\n.. Deleting keys")
     for key_name in (ec_key.name, rsa_key.name):
         deleted_key = await client.delete_key(key_name)
-        print("\nDeleted '{}'".format(deleted_key.name))
+        print(f"\nDeleted '{deleted_key.name}'")
 
     print("\nrun_sample done")
     await credential.close()
     await client.close()
 
 
 if __name__ == "__main__":
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/list_operations_async.py` & `azure-keyvault-keys-4.9.0b1/samples/list_operations_async.py`

 * *Files 6% similar despite different names*

```diff
@@ -43,53 +43,49 @@
     client = KeyClient(vault_url=VAULT_URL, credential=credential)
 
     # Let's create keys with RSA and EC type. If the key
     # already exists in the Key Vault, then a new version of the key is created.
     print("\n.. Create Key")
     rsa_key = await client.create_rsa_key("rsaKeyNameAsync")
     ec_key = await client.create_ec_key("ecKeyNameAsync")
-    print("Key with name '{0}' was created of type '{1}'.".format(rsa_key.name, rsa_key.key_type))
-    print("Key with name '{0}' was created of type '{1}'.".format(ec_key.name, ec_key.key_type))
+    print(f"Key with name '{rsa_key.name}' was created of type '{rsa_key.key_type}'.")
+    print(f"Key with name '{ec_key.name}' was created of type '{ec_key.key_type}'.")
 
     # You need to check the type of all the keys in the vault.
     # Let's list the keys and print their key types.
     # List operations don 't return the keys with their type information.
     # So, for each returned key we call get_key to get the key with its type information.
     print("\n.. List keys from the Key Vault")
     keys = client.list_properties_of_keys()
     async for key in keys:
         retrieved_key = await client.get_key(key.name)
-        print(
-            "Key with name '{0}' with type '{1}' was found.".format(
-                retrieved_key.name, retrieved_key.key_type
-            )
-        )
+        print(f"Key with name '{retrieved_key.name}' with type '{retrieved_key.key_type}' was found.")
 
     # The rsa key size now should now be 3072, default - 2048. So you want to update the key in Key Vault to ensure
     # it reflects the new key size. Calling create_rsa_key on an existing key creates a new version of the key in
     # the Key Vault with the new key size.
     new_key = await client.create_rsa_key(rsa_key.name, size=3072)
-    print("New version was created for Key with name '{0}' with the updated size.".format(new_key.name))
+    print(f"New version was created for Key with name '{new_key.name}' with the updated size.")
 
     # You should have more than one version of the rsa key at this time. Lets print all the versions of this key.
     print("\n.. List versions of the key using its name")
     key_versions = client.list_properties_of_key_versions(rsa_key.name)
     async for key in key_versions:
-        print("RSA Key with name '{0}' has version: '{1}'".format(key.name, key.version))
+        print(f"RSA Key with name '{key.name}' has version: '{key.version}'")
 
     # Both the rsa key and ec key are not needed anymore. Let's delete those keys.
     print("\n..Deleting keys...")
     await client.delete_key(rsa_key.name)
     await client.delete_key(ec_key.name)
 
     # You can list all the deleted and non-purged keys.
     print("\n.. List deleted keys from the Key Vault")
     deleted_keys = client.list_deleted_keys()
     async for deleted_key in deleted_keys:
-        print("Key with name '{0}' has recovery id '{1}'".format(deleted_key.name, deleted_key.recovery_id))
+        print(f"Key with name '{deleted_key.name}' has recovery id '{deleted_key.recovery_id}'")
 
     print("\nrun_sample done")
     await credential.close()
     await client.close()
 
 
 if __name__ == "__main__":
```

## Comparing `azure-keyvault-keys-4.8.0b2/samples/backup_restore_operations_async.py` & `azure-keyvault-keys-4.9.0b1/samples/backup_restore_operations_async.py`

 * *Files 10% similar despite different names*

```diff
@@ -41,37 +41,37 @@
     credential = DefaultAzureCredential()
     client = KeyClient(vault_url=VAULT_URL, credential=credential)
     
     # Let's create a Key of type RSA.
     # if the key already exists in the Key Vault, then a new version of the key is created.
     print("\n.. Create Key")
     key = await client.create_key("keyNameAsync", "RSA")
-    print("Key with name '{0}' created with key type '{1}'".format(key.name, key.key_type))
+    print(f"Key with name '{key.name}' created with key type '{key.key_type}'")
 
     # Backups are good to have, if in case keys gets deleted accidentally.
     # For long term storage, it is ideal to write the backup to a file.
     print("\n.. Create a backup for an existing Key")
     key_backup = await client.backup_key(key.name)
-    print("Backup created for key with name '{0}'.".format(key.name))
+    print(f"Backup created for key with name '{key.name}'.")
 
     # The rsa key is no longer in use, so you delete it.
     deleted_key = await client.delete_key(key.name)
-    print("Deleted key with name '{0}'".format(deleted_key.name))
+    print(f"Deleted key with name '{deleted_key.name}'")
 
     # Purge the deleted key.
     # The purge will take some time, so wait before restoring the backup to avoid a conflict.
     print("\n.. Purge the key")
     await client.purge_deleted_key(key.name)
     await asyncio.sleep(60)
-    print("Purged key with name '{0}'".format(deleted_key.name))
+    print(f"Purged key with name '{deleted_key.name}'")
 
     # In the future, if the key is required again, we can use the backup value to restore it in the Key Vault.
     print("\n.. Restore the key using the backed up key bytes")
     key = await client.restore_key_backup(key_backup)
-    print("Restored key with name '{0}'".format(key.name))
+    print(f"Restored key with name '{key.name}'")
 
     print("\nrun_sample done")
     await credential.close()
     await client.close()
 
 
 if __name__ == "__main__":
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/PKG-INFO` & `azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 Metadata-Version: 2.1
 Name: azure-keyvault-keys
-Version: 4.8.0b2
+Version: 4.9.0b1
 Summary: Microsoft Azure Key Vault Keys Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys
 Author: Microsoft Corporation
 Author-email: azurekeyvault@microsoft.com
 License: MIT License
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Azure Key Vault Keys client library for Python
 Azure Key Vault helps solve the following problems:
@@ -28,63 +29,76 @@
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 - Vault administration ([azure-keyvault-administration](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration)) - role-based access control (RBAC), and vault-level backup and restore options
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_keys] | [API reference documentation][reference_docs] | [Product documentation][azure_keyvault] | [Samples][key_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_keys]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][azure_keyvault]
+| [Samples][key_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_.
 
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
 ### Install the package
 Install [azure-keyvault-keys][pypi_package_keys] and
 [azure-identity][azure_identity_pypi] with [pip][pip]:
 ```Bash
 pip install azure-keyvault-keys azure-identity
 ```
-[azure-identity][azure_identity] is used for Azure Active Directory
-authentication as demonstrated below.
+[azure-identity][azure_identity] is used for Azure Active Directory authentication as demonstrated below.
 
 ### Prerequisites
 * An [Azure subscription][azure_sub]
 * Python 3.7 or later
 * An existing [Azure Key Vault][azure_keyvault]. If you need to create one, you can do so using the Azure CLI by following the steps in [this document][azure_keyvault_cli].
 * If using Managed HSM, an existing [Key Vault Managed HSM][managed_hsm]. If you need to create a Managed HSM, you can do so using the Azure CLI by following the steps in [this document][managed_hsm_cli].
 
 ### Authenticate the client
-In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as well as a **vault url** and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
+In order to interact with the Azure Key Vault service, you will need an instance of a [KeyClient][key_client_docs], as
+well as a **vault URL** and a credential object. This document demonstrates using a
+[DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios. We recommend using a
+[managed identity][managed_identity] for authentication in production environments.
 
-See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
+See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their
+corresponding credential types.
 
 #### Create a client
-After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a key client (replacing the value of `vault_url` with your vault's URL):
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of
+authentication, you can do the following to create a key client (replacing the value of `VAULT_URL` with your vault's
+URL):
+
+<!-- SNIPPET:hello_world.create_a_key_client -->
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 
+VAULT_URL = os.environ["VAULT_URL"]
 credential = DefaultAzureCredential()
-
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+client = KeyClient(vault_url=VAULT_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.keys.aio`'s `KeyClient` instead.
 
 ## Key concepts
 ### Keys
-Azure Key Vault can create and store RSA and elliptic curve keys. Both can
-optionally be protected by hardware security modules (HSMs). Azure Key Vault
-can also perform cryptographic operations with them. For more information about
-keys and supported operations and algorithms, see the
+Azure Key Vault can create and store RSA and elliptic curve keys. Both can optionally be protected by hardware security
+modules (HSMs). Azure Key Vault can also perform cryptographic operations with them. For more information about keys
+and supported operations and algorithms, see the
 [Key Vault documentation](https://docs.microsoft.com/azure/key-vault/keys/about-keys).
 
 [KeyClient][key_client_docs] can create keys in the vault, get existing keys
 from the vault, update key metadata, and delete keys, as shown in the
 [examples](#examples) below.
 
 ## Examples
@@ -97,14 +111,16 @@
 * [List keys](#list-keys)
 * [Perform cryptographic operations](#cryptographic-operations)
 * [Async API](#async-api)
 * [Asynchronously create a key](#asynchronously-create-a-key)
 * [Asynchronously list keys](#asynchronously-list-keys)
 
 ### Create a key
+The [create_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_key) method can be
+used by a `KeyClient` to create a key of any type -- alternatively, specific helpers such as
 [create_rsa_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_rsa_key) and
 [create_ec_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.create_ec_key)
 create RSA and elliptic curve keys in the vault, respectively. If a key with the same name already exists, a new version
 of that key is created.
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -173,40 +189,47 @@
 deleted_key = key_client.begin_delete_key("key-name").result()
 
 print(deleted_key.name)
 print(deleted_key.deleted_date)
 ```
 
 ### Configure automatic key rotation
-[update_key_rotation_policy](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
-allows you to configure automatic key rotation for a key by specifying a rotation policy.
-In addition,
-[rotate_key](https://azuresdkdocs.blob.core.windows.net/$web/python/azure-keyvault-keys/4.5.0b5/azure.keyvault.keys.html#azure.keyvault.keys.KeyClient.rotate_key)
-allows you to rotate a key on-demand by creating a new version of the given key.
+[update_key_rotation_policy](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.update_key_rotation_policy)
+can be used by a `KeyClient` to configure automatic key rotation for a key by specifying a rotation policy.
+
+<!-- SNIPPET:key_rotation.update_a_rotation_policy -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.keys import KeyClient, KeyRotationLifetimeAction, KeyRotationPolicyAction
+from azure.keyvault.keys import KeyRotationLifetimeAction, KeyRotationPolicy, KeyRotationPolicyAction
 
-credential = DefaultAzureCredential()
-key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
+# Here we set the key's automated rotation policy to rotate the key two months after the key was created.
+# If you pass an empty KeyRotationPolicy() as the `policy` parameter, the rotation policy will be set to the
+# default policy. Any keyword arguments will update specified properties of the policy.
+actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.rotate, time_after_create="P2M")]
+updated_policy = client.update_key_rotation_policy(
+    "rotation-sample-key", policy=KeyRotationPolicy(), expires_in="P90D", lifetime_actions=actions
+)
+assert updated_policy.expires_in == "P90D"
+```
 
-# Set the key's automated rotation policy to rotate the key 30 days before the key expires
-actions = [KeyRotationLifetimeAction(KeyRotationPolicyAction.ROTATE, time_before_expiry="P30D")]
-# You may also specify the duration after which the newly rotated key will expire
-# In this example, any new key versions will expire after 90 days
-updated_policy = key_client.update_key_rotation_policy("key-name", expires_in="P90D", lifetime_actions=actions)
+<!-- END SNIPPET -->
 
-# You can get the current rotation policy for a key with get_key_rotation_policy
-current_policy = key_client.get_key_rotation_policy("key-name")
+In addition,
+[rotate_key](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.rotate_key)
+allows you to rotate a key on-demand by creating a new version of the given key.
 
-# Finally, you can rotate a key on-demand by creating a new version of the key
-rotated_key = key_client.rotate_key("key-name")
+<!-- SNIPPET:key_rotation.rotate_key -->
+
+```python
+rotated_key = client.rotate_key("rotation-sample-key")
+print(f"Rotated the key on-demand; new version is {rotated_key.properties.version}")
 ```
 
+<!-- END SNIPPET -->
+
 ### List keys
 [list_properties_of_keys](https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient.list_properties_of_keys)
 lists the properties of all of the keys in the client's vault.
 
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
@@ -221,15 +244,15 @@
     print(key.name)
 ```
 
 ### Cryptographic operations
 [CryptographyClient](https://aka.ms/azsdk/python/keyvault-keys/crypto/docs#azure.keyvault.keys.crypto.CryptographyClient)
 enables cryptographic operations (encrypt/decrypt, wrap/unwrap, sign/verify) using a particular key.
 
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 from azure.keyvault.keys.crypto import CryptographyClient, EncryptionAlgorithm
 
 credential = DefaultAzureCredential()
 key_client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
 
@@ -252,15 +275,15 @@
 [azure-core documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/core/azure-core/CLIENT_LIBRARY_DEVELOPER.md#transport)
 for more information.
 
 Async clients and credentials should be closed when they're no longer needed. These
 objects are async context managers and define async `close` methods. For
 example:
 
-```py
+```python
 from azure.identity.aio import DefaultAzureCredential
 from azure.keyvault.keys.aio import KeyClient
 
 credential = DefaultAzureCredential()
 
 # call close when the client and credential are no longer needed
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential)
@@ -344,15 +367,15 @@
 This library uses the standard
 [logging](https://docs.python.org/3/library/logging.html) library for logging.
 Basic information about HTTP sessions (URLs, headers, etc.) is logged at INFO
 level.
 
 Detailed DEBUG level logging, including request/response bodies and unredacted
 headers, can be enabled on a client with the `logging_enable` argument:
-```py
+```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.keys import KeyClient
 import sys
 import logging
 
 # Create a logger for the 'azure' SDK
 logger = logging.getLogger('azure')
@@ -366,27 +389,29 @@
 
 # This client will log detailed information about its HTTP sessions, at DEBUG level
 client = KeyClient(vault_url="https://my-key-vault.vault.azure.net/", credential=credential, logging_enable=True)
 ```
 
 Similarly, `logging_enable` can enable detailed logging for a single operation,
 even when it isn't enabled for the client:
-```py
+```python
 client.get_key("my-key", logging_enable=True)
 ```
 
 ## Next steps
 Several samples are available in the Azure SDK for Python GitHub repository.
 These provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [hello_world.py][hello_world_sample] ([async version][hello_world_async_sample]) | create/get/update/delete keys |
 | [list_operations.py][list_operations_sample] ([async version][list_operations_async_sample]) | basic list operations for keys |
 | [backup_restore_operations.py][backup_operations_sample] ([async version][backup_operations_async_sample]) | back up and recover keys |
 | [recover_purge_operations.py][recover_purge_sample] ([async version][recover_purge_async_sample]) | recover and purge keys |
+| [key_rotation.py][key_rotation_sample] ([async version][key_rotation_async_sample]) | create/update key rotation policies and rotate keys on-demand |
+| [send_request.py][send_request_sample] | use the `send_request` client method |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the
 [API reference documentation][reference_docs].
 
 ## Contributing
 This project welcomes contributions and suggestions. Most contributions require
@@ -421,14 +446,16 @@
 
 [default_cred_ref]: https://aka.ms/azsdk/python/identity/docs#azure.identity.DefaultAzureCredential
 
 [hello_world_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world.py
 [hello_world_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/hello_world_async.py
 
 [key_client_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs#azure.keyvault.keys.KeyClient
+[key_rotation_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation.py
+[key_rotation_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/key_rotation_async.py
 [key_samples]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples
 
 [library_src]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/azure/keyvault/keys
 [list_operations_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations.py
 [list_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/list_operations_async.py
 
 [managed_hsm]: https://docs.microsoft.com/azure/key-vault/managed-hsm/overview
@@ -438,21 +465,51 @@
 [pip]: https://pypi.org/project/pip/
 [pypi_package_keys]: https://pypi.org/project/azure-keyvault-keys/
 
 [recover_purge_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations.py
 [recover_purge_async_sample]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/keyvault/azure-keyvault-keys/samples/recover_purge_operations_async.py
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-keys/docs
 
+[send_request_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-keys/samples/send_request.py
 [soft_delete]: https://docs.microsoft.com/azure/key-vault/general/soft-delete-overview
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-keys%2FREADME.png)
 
 
 # Release History
 
+## 4.9.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.8.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.8.0b1) An attempt will be made to generate an IV if one isn't provided for local encryption
+  ([#25380](https://github.com/Azure/azure-sdk-for-python/pull/25380))
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.7.0. Only code written against a beta version such as 4.8.0b2 may be affected.
+- Removed support for octet key pair (OKP) keys and operations
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.8.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.8.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.8.0b1) Updated minimum `msrest` version to 0.7.1
+- (From 4.8.0b2) Dropped `msrest` requirement
+- (From 4.8.0b2) Dropped `six` requirement
+- (From 4.8.0b2) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.8.0b2) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.8.0b2 (2022-11-15)
 
 ### Features Added
 - Added support for service API version `7.4-preview.1`
 - `KeyClient` has a `create_okp_key` method to create an octet key pair (OKP) on Managed HSM
 - Added `eddsa` to `SignatureAlgorithm` enum to support signing and verifying using an
   Edwards-Curve Digital Signature Algorithm (EdDSA) on Managed HSM
```

## Comparing `azure-keyvault-keys-4.8.0b2/azure_keyvault_keys.egg-info/SOURCES.txt` & `azure-keyvault-keys-4.9.0b1/azure_keyvault_keys.egg-info/SOURCES.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 CHANGELOG.md
 LICENSE
 MANIFEST.in
 README.md
 TROUBLESHOOTING.md
 migration_guide.md
+pyproject.toml
 setup.py
 azure/__init__.py
 azure/keyvault/__init__.py
 azure/keyvault/keys/__init__.py
 azure/keyvault/keys/_client.py
 azure/keyvault/keys/_enums.py
 azure/keyvault/keys/_generated_models.py
@@ -122,34 +123,34 @@
 azure/keyvault/keys/_generated/v7_3/models/__init__.py
 azure/keyvault/keys/_generated/v7_3/models/_key_vault_client_enums.py
 azure/keyvault/keys/_generated/v7_3/models/_models_py3.py
 azure/keyvault/keys/_generated/v7_3/models/_patch.py
 azure/keyvault/keys/_generated/v7_3/operations/__init__.py
 azure/keyvault/keys/_generated/v7_3/operations/_key_vault_client_operations.py
 azure/keyvault/keys/_generated/v7_3/operations/_patch.py
-azure/keyvault/keys/_generated/v7_4_preview_1/__init__.py
-azure/keyvault/keys/_generated/v7_4_preview_1/_configuration.py
-azure/keyvault/keys/_generated/v7_4_preview_1/_key_vault_client.py
-azure/keyvault/keys/_generated/v7_4_preview_1/_patch.py
-azure/keyvault/keys/_generated/v7_4_preview_1/_vendor.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/__init__.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/_configuration.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/_key_vault_client.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/_patch.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/_vendor.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/__init__.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
-azure/keyvault/keys/_generated/v7_4_preview_1/aio/operations/_patch.py
-azure/keyvault/keys/_generated/v7_4_preview_1/models/__init__.py
-azure/keyvault/keys/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
-azure/keyvault/keys/_generated/v7_4_preview_1/models/_models_py3.py
-azure/keyvault/keys/_generated/v7_4_preview_1/models/_patch.py
-azure/keyvault/keys/_generated/v7_4_preview_1/operations/__init__.py
-azure/keyvault/keys/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
-azure/keyvault/keys/_generated/v7_4_preview_1/operations/_patch.py
+azure/keyvault/keys/_generated/v7_4/__init__.py
+azure/keyvault/keys/_generated/v7_4/_configuration.py
+azure/keyvault/keys/_generated/v7_4/_key_vault_client.py
+azure/keyvault/keys/_generated/v7_4/_patch.py
+azure/keyvault/keys/_generated/v7_4/_vendor.py
+azure/keyvault/keys/_generated/v7_4/aio/__init__.py
+azure/keyvault/keys/_generated/v7_4/aio/_configuration.py
+azure/keyvault/keys/_generated/v7_4/aio/_key_vault_client.py
+azure/keyvault/keys/_generated/v7_4/aio/_patch.py
+azure/keyvault/keys/_generated/v7_4/aio/_vendor.py
+azure/keyvault/keys/_generated/v7_4/aio/operations/__init__.py
+azure/keyvault/keys/_generated/v7_4/aio/operations/_key_vault_client_operations.py
+azure/keyvault/keys/_generated/v7_4/aio/operations/_patch.py
+azure/keyvault/keys/_generated/v7_4/models/__init__.py
+azure/keyvault/keys/_generated/v7_4/models/_key_vault_client_enums.py
+azure/keyvault/keys/_generated/v7_4/models/_models_py3.py
+azure/keyvault/keys/_generated/v7_4/models/_patch.py
+azure/keyvault/keys/_generated/v7_4/operations/__init__.py
+azure/keyvault/keys/_generated/v7_4/operations/_key_vault_client_operations.py
+azure/keyvault/keys/_generated/v7_4/operations/_patch.py
 azure/keyvault/keys/_shared/__init__.py
 azure/keyvault/keys/_shared/_polling.py
 azure/keyvault/keys/_shared/_polling_async.py
 azure/keyvault/keys/_shared/async_challenge_auth_policy.py
 azure/keyvault/keys/_shared/async_client_base.py
 azure/keyvault/keys/_shared/challenge_auth_policy.py
 azure/keyvault/keys/_shared/client_base.py
@@ -198,14 +199,15 @@
 samples/hello_world_async.py
 samples/key_rotation.py
 samples/key_rotation_async.py
 samples/list_operations.py
 samples/list_operations_async.py
 samples/recover_purge_operations.py
 samples/recover_purge_operations_async.py
+samples/send_request.py
 tests/_async_test_case.py
 tests/_keys_test_case.py
 tests/_test_case.py
 tests/conftest.py
 tests/crypto_client_preparer.py
 tests/crypto_client_preparer_async.py
 tests/keys.py
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_key_client.py` & `azure-keyvault-keys-4.9.0b1/tests/test_key_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,38 +8,39 @@
 import logging
 import os
 import time
 
 import pytest
 from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError
 from azure.core.pipeline.policies import SansIOHTTPPolicy
+from azure.core.rest import HttpRequest
 from azure.keyvault.keys import (
-    ApiVersion,
     JsonWebKey,
     KeyClient,
     KeyReleasePolicy,
     KeyRotationLifetimeAction,
     KeyRotationPolicy,
     KeyRotationPolicyAction,
     KeyType
 )
 from azure.keyvault.keys._generated.v7_3.models import KeyRotationPolicy as _KeyRotationPolicy
+from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION
 from dateutil import parser as date_parse
 from devtools_testutils import recorded_by_proxy, set_bodiless_matcher
 
 from _shared.test_case import KeyVaultTestCase
 from _test_case import KeysClientPreparer, get_attestation_token, get_decorator, get_release_policy, is_public_cloud
 
 from _keys_test_case import KeysTestCase
 
 all_api_versions = get_decorator()
 only_hsm = get_decorator(only_hsm=True)
-only_hsm_7_3 = get_decorator(only_hsm=True, api_versions=[ApiVersion.V7_3])
-only_vault_7_3 = get_decorator(only_vault=True, api_versions=[ApiVersion.V7_3])
-only_7_3 = get_decorator(api_versions=[ApiVersion.V7_3])
+only_hsm_latest = get_decorator(only_hsm=True, api_versions=[DEFAULT_VERSION])
+only_vault_latest = get_decorator(only_vault=True, api_versions=[DEFAULT_VERSION])
+only_latest = get_decorator(api_versions=[DEFAULT_VERSION])
 logging_enabled = get_decorator(logging_enable=True)
 logging_disabled = get_decorator(logging_enable=False)
 
 LIST_TEST_SIZE = 7
 
 
 def _assert_rotation_policies_equal(p1, p2):
@@ -103,27 +104,27 @@
         return created_key
 
     def _validate_ec_key_bundle(self, key_curve, key_attributes, vault, key_name, kty):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
         assert key_curve == key.crv
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
         
 
     def _validate_rsa_key_bundle(self, key_attributes, vault, key_name, kty, key_ops):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key.n and key.e, "Bad RSA public material."
-        assert sorted(key_ops) == sorted(key.key_ops), "keyOps should be '{}', but is '{}'".format(key_ops, key.key_ops)
+        assert sorted(key_ops) == sorted(key.key_ops), f"keyOps should be '{key_ops}', but is '{key.key_ops}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on, "Missing required date attributes."
 
     def _update_key_properties(self, client, key, release_policy=None):
         expires = date_parse.parse("2050-01-02T08:00:00.000Z")
         tags = {"foo": "updated tag"}
         key_ops = ["decrypt", "encrypt"]
 
@@ -141,15 +142,15 @@
         if release_policy:
             assert key.properties.release_policy.encoded_policy != key_bundle.properties.release_policy.encoded_policy
         return key_bundle
 
     def _import_test_key(self, client, name, hardware_protected=False, **kwargs):
         def _to_bytes(hex):
             if len(hex) % 2:
-                hex = "0{}".format(hex)
+                hex = f"0{hex}"
             return codecs.decode(hex, "hex_codec")
 
         key = JsonWebKey(
             kty="RSA-HSM" if hardware_protected else "RSA",
             key_ops=["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"],
             n=_to_bytes(
                 "00a0914d00234ac683b21b4c15d5bed887bdc959c2e57af54ae734e8f00720d775d275e455207e3784ceeb60a50a4655dd72a7a94d271e8ee8f7959a669ca6e775bf0e23badae991b4529d978528b4bd90521d32dd2656796ba82b6bbfc7668c8f5eeb5053747fd199319d29a8440d08f4412d527ff9311eda71825920b47b1c46b11ab3e91d7316407e89c7f340f7b85a34042ce51743b27d4718403d34c7b438af6181be05e4d11eb985d38253d7fe9bf53fc2f1b002d22d2d793fa79a504b6ab42d0492804d7071d727a06cf3a8893aa542b1503f832b296371b6707d4dc6e372f8fe67d8ded1c908fde45ce03bc086a71487fa75e43aa0e0679aa0d20efe35"
@@ -292,15 +293,15 @@
         assert client is not None
 
         max_keys = LIST_TEST_SIZE
         expected = {}
 
         # create many keys
         for x in range(max_keys):
-            key_name = self.get_resource_name("key{}".format(x))
+            key_name = self.get_resource_name(f"key{x}")
             key = self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
             expected[key.name] = key
 
         # list keys
         result = client.list_properties_of_keys(max_page_size=max_keys - 1)
         for key in result:
             if key.name in expected.keys():
@@ -341,15 +342,15 @@
         set_bodiless_matcher()
         assert client is not None
 
         expected = {}
 
         # create keys
         for i in range(LIST_TEST_SIZE):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             expected[key_name] = self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
 
         # delete them
         for key_name in expected.keys():
             client.begin_delete_key(key_name).wait()
 
         # validate list deleted keys with attributes
@@ -371,15 +372,15 @@
     def test_recover(self, client, is_hsm, **kwargs):
         set_bodiless_matcher()
         assert client is not None
 
         # create keys
         keys = {}
         for i in range(LIST_TEST_SIZE):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             keys[key_name] = self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
 
         # delete them
         for key_name in keys.keys():
             client.begin_delete_key(key_name).wait()
 
         # validate the deleted keys are returned by list_deleted_keys
@@ -396,15 +397,15 @@
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_purge(self, client, is_hsm, **kwargs):
         set_bodiless_matcher()
         assert client is not None
 
         # create keys
-        key_names = [self.get_resource_name("key{}".format(i)) for i in range(LIST_TEST_SIZE)]
+        key_names = [self.get_resource_name(f"key{i}") for i in range(LIST_TEST_SIZE)]
         for name in key_names:
             self._create_rsa_key(client, name, hardware_protected=is_hsm)
 
         # delete them
         for key_name in key_names:
             client.begin_delete_key(key_name).wait()
 
@@ -489,15 +490,15 @@
                             assert False, "Client request body was logged"
                     except (ValueError, KeyError):
                         # this means the request section is not JSON or has no kty property
                         pass
 
         mock_handler.close()
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_get_random_bytes(self, client, **kwargs):
         assert client
 
         generated_random_bytes = []
         for i in range(5):
@@ -505,15 +506,15 @@
             # get eight random bytes from a managed HSM
             random_bytes = client.get_random_bytes(count=8)
             # [END get_random_bytes]
             assert len(random_bytes) == 8
             assert all(random_bytes != rb for rb in generated_random_bytes)
             generated_random_bytes.append(random_bytes)
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_key_release(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -528,15 +529,15 @@
         assert key.properties.release_policy
         assert key.properties.release_policy.encoded_policy
         assert key.properties.exportable
 
         release_result = client.release_key(rsa_key_name, attestation)
         assert release_result.value
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_imported_key_release(self, client, **kwargs):
         set_bodiless_matcher()
         attestation_uri = self._get_attestation_uri()
         attestation = get_attestation_token(attestation_uri)
         release_policy = get_release_policy(attestation_uri)
@@ -548,15 +549,15 @@
         assert key.properties.release_policy
         assert key.properties.release_policy.encoded_policy
         assert key.properties.exportable
 
         release_result = client.release_key(imported_key_name, attestation)
         assert release_result.value
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_update_release_policy(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -593,15 +594,15 @@
         updated_key = self._update_key_properties(client, key, new_release_policy)
         updated_policy = json.loads(updated_key.properties.release_policy.encoded_policy.decode())
         claim_condition = updated_policy["anyOf"][0]["anyOf"][0]["equals"]
         claim_condition = claim_condition if isinstance(claim_condition, bool) else json.loads(claim_condition)
         assert claim_condition is False
 
     #Immutable policies aren't currently supported on Managed HSM
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_immutable_release_policy(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -630,15 +631,15 @@
         }
         policy_string = json.dumps(new_release_policy_json).encode()
         new_release_policy = KeyReleasePolicy(policy_string, immutable=True)
 
         with pytest.raises(HttpResponseError):
             self._update_key_properties(client, key, new_release_policy)
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_key_rotation(self, client, **kwargs):
         if (not is_public_cloud() and self.is_live):
             pytest.skip("This test is not supported in usgov/china region. Follow up with service team.")
 
         set_bodiless_matcher()
@@ -648,15 +649,15 @@
 
         # the rotated key should have a new ID, version, and key material (for RSA, n and e fields)
         assert key.id != rotated_key.id
         assert key.properties.version != rotated_key.properties.version
         assert key.key.n != rotated_key.key.n
 
     @pytest.mark.playback_test_only("Currently fails in live mode because of service regression; will be fixed soon.")
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_key_rotation_policy(self, client, **kwargs):
         if (not is_public_cloud() and self.is_live):
             pytest.skip("This test is not supported in usgov/china region. Follow up with service team.")
 
         set_bodiless_matcher()
@@ -752,14 +753,30 @@
         assert result.key_id == key.id
 
         result = crypto_client.decrypt(result.algorithm, result.ciphertext)
         assert result.key_id == key.id
         assert "RSA-OAEP" == result.algorithm
         assert plaintext == result.plaintext
 
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
+    @KeysClientPreparer()
+    @recorded_by_proxy
+    def test_send_request(self, client, is_hsm, **kwargs):
+        key_name = self.get_resource_name("key-name")
+        key = self._create_rsa_key(client, key_name)
+
+        # fetch the key we just created
+        request = HttpRequest(
+            method="GET",
+            url=f"keys/{key_name}/{key.properties.version}",
+            headers={"Accept": "application/json"},
+        )
+        response = client.send_request(request)
+        assert response.json()["key"]["kid"] == key.id
+
 
 def test_positive_bytes_count_required():
     client = KeyClient("...", object())
     with pytest.raises(ValueError):
         client.get_random_bytes(count=0)
     with pytest.raises(ValueError):
         client.get_random_bytes(count=-1)
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer.py` & `azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_exceptions.py` & `azure-keyvault-keys-4.9.0b1/tests/test_exceptions.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_examples_crypto.py` & `azure-keyvault-keys-4.9.0b1/tests/test_examples_crypto.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_keys_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_keys_async.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,38 +8,39 @@
 import functools
 import json
 import logging
 import os
 
 from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError
 from azure.core.pipeline.policies import SansIOHTTPPolicy
+from azure.core.rest import HttpRequest
 from azure.keyvault.keys import (
-    ApiVersion,
     JsonWebKey,
     KeyReleasePolicy,
     KeyRotationLifetimeAction,
     KeyRotationPolicy,
     KeyRotationPolicyAction,
 )
 from azure.keyvault.keys.aio import KeyClient
+from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION
 import pytest
 
 from _shared.test_case_async import KeyVaultTestCase
 from _async_test_case import get_attestation_token, get_decorator, get_release_policy, is_public_cloud, AsyncKeysClientPreparer
 from test_key_client import _assert_lifetime_actions_equal, _assert_rotation_policies_equal
 from devtools_testutils import set_bodiless_matcher
 from devtools_testutils.aio import recorded_by_proxy_async
 from _keys_test_case import KeysTestCase
 
 
 all_api_versions = get_decorator(is_async=True)
 only_hsm = get_decorator(only_hsm=True, is_async=True)
-only_hsm_7_3 = get_decorator(only_hsm=True, is_async=True, api_versions=[ApiVersion.V7_3])
-only_vault_7_3 = get_decorator(only_vault=True, is_async=True, api_versions=[ApiVersion.V7_3])
-only_7_3 = get_decorator(is_async=True, api_versions=[ApiVersion.V7_3])
+only_hsm_latest = get_decorator(only_hsm=True, is_async=True, api_versions=[DEFAULT_VERSION])
+only_vault_latest = get_decorator(only_vault=True, is_async=True, api_versions=[DEFAULT_VERSION])
+only_latest = get_decorator(is_async=True, api_versions=[DEFAULT_VERSION])
 logging_enabled = get_decorator(is_async=True, logging_enable=True)
 logging_disabled = get_decorator(is_async=True, logging_enable=False)
 
 LIST_TEST_SIZE = 7
 
 
 # used for logging tests
@@ -91,26 +92,26 @@
         return created_key
 
     def _validate_ec_key_bundle(self, key_curve, key_attributes, vault, key_name, kty):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
         assert key_curve == key.crv
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
 
     def _validate_rsa_key_bundle(self, key_attributes, vault, key_name, kty, key_ops):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key.n and key.e, "Bad RSA public material."
-        assert sorted(key_ops) == sorted(key.key_ops), "keyOps should be '{}', but is '{}'".format(key_ops, key.key_ops)
+        assert sorted(key_ops) == sorted(key.key_ops), f"keyOps should be '{key_ops}', but is '{key.key_ops}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
 
     async def _update_key_properties(self, client, key, release_policy=None):
         expires = date_parse.parse("2050-01-02T08:00:00.000Z")
         tags = {"foo": "updated tag"}
         key_ops = ["decrypt", "encrypt"]
 
@@ -135,15 +136,15 @@
                 self._assert_key_attributes_equal(expected[key.name].properties, key)
                 del expected[key.name]
         assert len(expected) == 0
 
     async def _import_test_key(self, client, name, hardware_protected=False, **kwargs):
         def _to_bytes(hex):
             if len(hex) % 2:
-                hex = "0{}".format(hex)
+                hex = f"0{hex}"
             return codecs.decode(hex, "hex_codec")
 
         key = JsonWebKey(
             kty="RSA-HSM" if hardware_protected else "RSA",
             key_ops=["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"],
             n=_to_bytes(
                 "00a0914d00234ac683b21b4c15d5bed887bdc959c2e57af54ae734e8f00720d775d275e455207e3784ceeb60a50a4655dd72a7a94d271e8ee8f7959a669ca6e775bf0e23badae991b4529d978528b4bd90521d32dd2656796ba82b6bbfc7668c8f5eeb5053747fd199319d29a8440d08f4412d527ff9311eda71825920b47b1c46b11ab3e91d7316407e89c7f340f7b85a34042ce51743b27d4718403d34c7b438af6181be05e4d11eb985d38253d7fe9bf53fc2f1b002d22d2d793fa79a504b6ab42d0492804d7071d727a06cf3a8893aa542b1503f832b296371b6707d4dc6e372f8fe67d8ded1c908fde45ce03bc086a71487fa75e43aa0e0679aa0d20efe35"
@@ -288,15 +289,15 @@
         assert client is not None
 
         max_keys = LIST_TEST_SIZE
         expected = {}
 
         # create many keys
         for x in range(max_keys):
-            key_name = self.get_resource_name("key{}".format(x))
+            key_name = self.get_resource_name(f"key{x}")
             key = await self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
             expected[key.name] = key
 
         # list keys
         result = client.list_properties_of_keys(max_page_size=max_keys - 1)
         async for key in result:
             if key.name in expected.keys():
@@ -338,15 +339,15 @@
     async def test_list_deleted_keys(self, client, is_hsm, **kwargs):
         assert client is not None
 
         expected = {}
 
         # create keys to delete
         for i in range(LIST_TEST_SIZE):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             expected[key_name] = await self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
 
         # delete all keys
         for key_name in expected.keys():
             await client.delete_key(key_name)
 
         # validate list deleted keys with attributes
@@ -369,15 +370,15 @@
     @recorded_by_proxy_async
     async def test_recover(self, client, is_hsm, **kwargs):
         assert client is not None
 
         # create keys
         keys = {}
         for i in range(LIST_TEST_SIZE):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             keys[key_name] = await self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
 
         # delete them
         for key_name in keys.keys():
             await client.delete_key(key_name)
 
         # recover them
@@ -398,15 +399,15 @@
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_purge(self, client, is_hsm, **kwargs):
         assert client is not None
 
         # create keys
-        key_names = [self.get_resource_name("key{}".format(i)) for i in range(LIST_TEST_SIZE)]
+        key_names = [self.get_resource_name(f"key{i}") for i in range(LIST_TEST_SIZE)]
         for key_name in key_names:
             await self._create_rsa_key(client, key_name, hardware_protected=is_hsm)
 
         # delete them
         for key_name in key_names:
             await client.delete_key(key_name)
 
@@ -490,15 +491,15 @@
                     except (ValueError, KeyError):
                         # this means the request section is not JSON or has no kty property
                         pass
 
         mock_handler.close()
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_get_random_bytes(self, client, **kwargs):
         assert client
 
         generated_random_bytes = []
         for i in range(5):
@@ -507,15 +508,15 @@
             random_bytes = await client.get_random_bytes(count=8)
             # [END get_random_bytes]
             assert len(random_bytes) == 8
             assert all(random_bytes != rb for rb in generated_random_bytes)
             generated_random_bytes.append(random_bytes)
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_key_release(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -531,15 +532,15 @@
         assert key.properties.release_policy.encoded_policy
         assert key.properties.exportable
 
         release_result = await client.release_key(rsa_key_name, attestation)
         assert release_result.value
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_hsm_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_imported_key_release(self, client, **kwargs):
         set_bodiless_matcher()
         attestation_uri = self._get_attestation_uri()
         attestation = await get_attestation_token(attestation_uri)
         release_policy = get_release_policy(attestation_uri)
@@ -552,15 +553,15 @@
         assert key.properties.release_policy.encoded_policy
         assert key.properties.exportable
 
         release_result = await client.release_key(imported_key_name, attestation)
         assert release_result.value
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_update_release_policy(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -598,15 +599,15 @@
         updated_policy = json.loads(updated_key.properties.release_policy.encoded_policy.decode())
         claim_condition = updated_policy["anyOf"][0]["anyOf"][0]["equals"]
         claim_condition = claim_condition if isinstance(claim_condition, bool) else json.loads(claim_condition)
         assert claim_condition is False
 
     # Immutable policies aren't currently supported on Managed HSM
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_immutable_release_policy(self, client, **kwargs):
         if (self.is_live and os.environ["KEYVAULT_SKU"] != "premium"):
             pytest.skip("This test is not supported on standard SKU vaults. Follow up with service team")
 
         set_bodiless_matcher()
@@ -636,15 +637,15 @@
         policy_string = json.dumps(new_release_policy_json).encode()
         new_release_policy = KeyReleasePolicy(policy_string, immutable=True)
 
         with pytest.raises(HttpResponseError):
             await self._update_key_properties(client, key, new_release_policy)
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_key_rotation(self, client, **kwargs):
         if (not is_public_cloud() and self.is_live):
             pytest.skip("This test is not supported in usgov/china region. Follow up with service team.")
 
         set_bodiless_matcher()
@@ -655,15 +656,15 @@
         # the rotated key should have a new ID, version, and key material (for RSA, n and e fields)
         assert key.id != rotated_key.id
         assert key.properties.version != rotated_key.properties.version
         assert key.key.n != rotated_key.key.n
 
     @pytest.mark.playback_test_only("Currently fails in live mode because of service regression; will be fixed soon.")
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_vault_7_3)
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_key_rotation_policy(self, client, **kwargs):
         if (not is_public_cloud() and self.is_live):
             pytest.skip("This test is not supported in usgov/china region. Follow up with service team.")
 
         set_bodiless_matcher()
@@ -764,14 +765,31 @@
         assert result.key_id == key.id
 
         result = await crypto_client.decrypt(result.algorithm, result.ciphertext)
         assert result.key_id == key.id
         assert "RSA-OAEP" == result.algorithm
         assert plaintext == result.plaintext
 
+    @pytest.mark.asyncio
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
+    @AsyncKeysClientPreparer()
+    @recorded_by_proxy_async
+    async def test_send_request(self, client, is_hsm, **kwargs):
+        key_name = self.get_resource_name("key-name")
+        key = await self._create_rsa_key(client, key_name)
+
+        # fetch the key we just created
+        request = HttpRequest(
+            method="GET",
+            url=f"keys/{key_name}/{key.properties.version}",
+            headers={"Accept": "application/json"},
+        )
+        response = await client.send_request(request)
+        assert response.json()["key"]["kid"] == key.id
+
 
 @pytest.mark.asyncio
 async def test_positive_bytes_count_required():
     client = KeyClient("...", object())
     with pytest.raises(ValueError):
         await client.get_random_bytes(count=0)
     with pytest.raises(ValueError):
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth_async.py`

 * *Files 7% similar despite different names*

```diff
@@ -129,19 +129,19 @@
 
     # an AADv1 resource becomes an AADv2 scope with the addition of '/.default'
     resource = "https://vault.azure.net"
     scope = resource + "/.default"
 
     challenge_with_resource = Mock(
         status_code=401,
-        headers={"WWW-Authenticate": 'Bearer authorization="{}", resource={}'.format(endpoint, resource)},
+        headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
     )
 
     challenge_with_scope = Mock(
-        status_code=401, headers={"WWW-Authenticate": 'Bearer authorization="{}", scope={}'.format(endpoint, scope)}
+        status_code=401, headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", scope={scope}'}
     )
 
     await test_with_challenge(challenge_with_resource, scope)
     await test_with_challenge(challenge_with_scope, scope)
 
 
 @pytest.mark.asyncio
@@ -183,15 +183,71 @@
         request = HttpRequest("POST", get_random_url())
         request.set_bytes_body(expected_content)
         await pipeline.run(request)
 
         assert credential.get_token.call_count == 1
 
     tenant = "tenant-id"
-    endpoint = "https://authority.net/{}".format(tenant)
+    endpoint = f"https://authority.net/{tenant}"
+    resource = "https://vault.azure.net"
+
+    challenge = Mock(
+        status_code=401,
+        headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
+    )
+
+    await test_with_challenge(challenge, tenant)
+
+
+@pytest.mark.asyncio
+@empty_challenge_cache
+async def test_adfs():
+    """The policy should handle AD FS challenges as a special case and omit the tenant ID from token requests"""
+
+    expected_content = b"a duck"
+
+    async def test_with_challenge(challenge, expected_tenant):
+        expected_token = "expected_token"
+
+        class Requests:
+            count = 0
+
+        async def send(request):
+            Requests.count += 1
+            if Requests.count == 1:
+                # first request should be unauthorized and have no content
+                assert not request.body
+                assert request.headers["Content-Length"] == "0"
+                return challenge
+            elif Requests.count == 2:
+                # second request should be authorized according to challenge and have the expected content
+                assert request.headers["Content-Length"]
+                assert request.body == expected_content
+                assert expected_token in request.headers["Authorization"]
+                return Mock(status_code=200)
+            raise ValueError("unexpected request")
+
+        async def get_token(*_, **kwargs):
+            # we shouldn't provide a tenant ID during AD FS authentication
+            assert "tenant_id" not in kwargs
+            return AccessToken(expected_token, 0)
+
+        credential = Mock(get_token=Mock(wraps=get_token))
+        pipeline = AsyncPipeline(
+            policies=[AsyncChallengeAuthPolicy(credential=credential)], transport=Mock(send=send)
+        )
+        request = HttpRequest("POST", get_random_url())
+        request.set_bytes_body(expected_content)
+        await pipeline.run(request)
+
+        assert credential.get_token.call_count == 1
+
+    tenant = "tenant-id"
+    # AD FS challenges have an unusual authority format; see https://github.com/Azure/azure-sdk-for-python/issues/28648
+    endpoint = f"https://adfs.redmond.azurestack.corp.microsoft.com/adfs/{tenant}"
     resource = "https://vault.azure.net"
 
     challenge = Mock(
         status_code=401,
         headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
     )
 
@@ -207,37 +263,37 @@
     """
 
     url = get_random_url()
     first_scope = "https://vault.azure.net/first-scope"
     first_token = "first-scope-token"
     second_scope = "https://vault.azure.net/second-scope"
     second_token = "second-scope-token"
-    challenge_fmt = 'Bearer authorization="https://login.authority.net/tenant", resource={}'
+    challenge_fmt = 'Bearer authorization="https://login.authority.net/tenant", resource='
 
     # mocking a tenant change:
     # 1. first request -> respond with challenge
     # 2. second request should be authorized according to the challenge
     # 3. third request should match the second (using a cached access token)
     # 4. fourth request should also match the second -> respond with a new challenge
     # 5. fifth request should be authorized according to the new challenge
     # 6. sixth request should match the fifth
     transport = async_validating_transport(
         requests=(
             Request(url),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(second_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(second_token)}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {second_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {second_token}"}),
         ),
         responses=(
-            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt.format(first_scope)}),
+            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt + first_scope}),
             mock_response(status_code=200),
             mock_response(status_code=200),
-            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt.format(second_scope)}),
+            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt + second_scope}),
             mock_response(status_code=200),
             mock_response(status_code=200),
         ),
     )
 
     token = AccessToken(first_token, time.time() + 3600)
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_samples_keys_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_samples_keys_async.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,22 +2,21 @@
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import asyncio
 import os
 
 import pytest
-from azure.keyvault.keys import ApiVersion, KeyCurveName, KeyType
+from azure.keyvault.keys import KeyType
 from devtools_testutils.aio import recorded_by_proxy_async
 
 from _async_test_case import AsyncKeysClientPreparer, get_decorator
 from _shared.test_case_async import KeyVaultTestCase
 
 all_api_versions = get_decorator(is_async=True, only_vault=True)
-only_7_4_hsm = get_decorator(only_hsm=True, api_versions=[ApiVersion.V7_4_PREVIEW_1])
 only_hsm = get_decorator(only_hsm=True, is_async=True)
 
 
 def print(*args):
     assert all(arg is not None for arg in args)
 
 
@@ -143,38 +142,23 @@
 
         print(key.id)
         print(key.name)
         print(key.key_type)
         # [END create_oct_key]
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_4_hsm)
-    @AsyncKeysClientPreparer()
-    @recorded_by_proxy_async
-    async def test_example_create_okp_key(self, key_client, **kwargs):
-        key_name = self.get_resource_name("key")
-
-        # [START create_okp_key]
-        key = await key_client.create_okp_key(key_name, curve=KeyCurveName.ed25519, hardware_protected=True)
-
-        print(key.id)
-        print(key.name)
-        print(key.key_type)
-        # [END create_okp_key]
-
-    @pytest.mark.asyncio
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_example_key_list_operations(self, key_client, **kwargs):
         for i in range(4):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             await key_client.create_ec_key(key_name)
         for i in range(4):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             await key_client.create_rsa_key(key_name)
 
         # [START list_keys]
         # list keys
         keys = key_client.list_properties_of_keys()
 
         async for key in keys:
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_keys_test_case.py` & `azure-keyvault-keys-4.9.0b1/tests/_keys_test_case.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/keys.py` & `azure-keyvault-keys-4.9.0b1/tests/keys.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/crypto_client_preparer_async.py` & `azure-keyvault-keys-4.9.0b1/tests/crypto_client_preparer_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/conftest.py` & `azure-keyvault-keys-4.9.0b1/tests/conftest.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,16 +7,28 @@
 import os
 from unittest import mock
 
 import pytest
 from devtools_testutils import (add_general_regex_sanitizer,
                                 add_oauth_response_sanitizer, is_live,
                                 test_proxy)
+from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION, ApiVersion
 
 os.environ['PYTHONHASHSEED'] = '0'
+ALL_API_VERSIONS = "--all-api-versions"
+
+def pytest_addoption(parser):
+    parser.addoption(ALL_API_VERSIONS, action="store_true", default=False,
+                     help="Test all api version in live mode. Not applicable in playback mode.")
+
+def pytest_configure(config):
+    if is_live() and not config.getoption(ALL_API_VERSIONS):
+        pytest.api_version = [DEFAULT_VERSION]
+    else:
+        pytest.api_version = ApiVersion
 
 @pytest.fixture(scope="session", autouse=True)
 def add_sanitizers(test_proxy):
     azure_keyvault_url = os.getenv("azure_keyvault_url", "https://vaultname.vault.azure.net")
     azure_keyvault_url = azure_keyvault_url.rstrip("/")
     keyvault_tenant_id = os.getenv("keyvault_tenant_id", "keyvault_tenant_id")
     keyvault_subscription_id = os.getenv("keyvault_subscription_id", "keyvault_subscription_id")
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_local_crypto.py` & `azure-keyvault-keys-4.9.0b1/tests/test_local_crypto.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_samples_keys.py` & `azure-keyvault-keys-4.9.0b1/tests/test_samples_keys.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,23 +4,22 @@
 # ------------------------------------
 from __future__ import print_function
 
 import os
 import time
 
 import pytest
-from azure.keyvault.keys import ApiVersion, KeyCurveName, KeyType
+from azure.keyvault.keys import KeyType
 from devtools_testutils import recorded_by_proxy
 
 from _shared.test_case import KeyVaultTestCase
 from _test_case import KeysClientPreparer, get_decorator
 from _keys_test_case import KeysTestCase
 
 all_api_versions = get_decorator(only_vault=True)
-only_7_4_hsm = get_decorator(only_hsm=True, api_versions=[ApiVersion.V7_4_PREVIEW_1])
 only_hsm = get_decorator(only_hsm=True)
 
 
 def print(*args):
     assert all(arg is not None for arg in args)
 
 
@@ -143,37 +142,23 @@
         key = key_client.create_oct_key(key_name, size=256, hardware_protected=True)
 
         print(key.id)
         print(key.name)
         print(key.key_type)
         # [END create_oct_key]
 
-    @pytest.mark.parametrize("api_version,is_hsm",only_7_4_hsm)
-    @KeysClientPreparer()
-    @recorded_by_proxy
-    def test_example_create_okp_key(self, key_client, **kwargs):
-        key_name = self.get_resource_name("key")
-
-        # [START create_okp_key]
-        key = key_client.create_okp_key(key_name, curve=KeyCurveName.ed25519, hardware_protected=True)
-
-        print(key.id)
-        print(key.name)
-        print(key.key_type)
-        # [END create_okp_key]
-
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_example_key_list_operations(self, key_client, **kwargs):
         for i in range(4):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             key_client.create_ec_key(key_name)
         for i in range(4):
-            key_name = self.get_resource_name("key{}".format(i))
+            key_name = self.get_resource_name(f"key{i}")
             key_client.create_rsa_key(key_name)
 
         # [START list_keys]
         # get an iterator of keys
         keys = key_client.list_properties_of_keys()
 
         for key in keys:
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_multi_api.py` & `azure-keyvault-keys-4.9.0b1/tests/test_multi_api.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_crypto_client.py` & `azure-keyvault-keys-4.9.0b1/tests/test_crypto_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,46 +2,50 @@
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import codecs
 import hashlib
 import os
 import time
-from datetime import datetime
+from datetime import datetime, timezone
 
 from devtools_testutils import recorded_by_proxy, set_bodiless_matcher
 
 try:
     from unittest import mock
 except ImportError:
     import mock
 
 import pytest
 from azure.core.exceptions import AzureError, HttpResponseError
 from azure.core.pipeline.policies import SansIOHTTPPolicy
-from azure.keyvault.keys import (ApiVersion, JsonWebKey, KeyCurveName, KeyOperation,
-                                 KeyVaultKey)
-from azure.keyvault.keys.crypto import (CryptographyClient,
-                                        EncryptionAlgorithm, KeyWrapAlgorithm,
-                                        SignatureAlgorithm)
-from azure.keyvault.keys.crypto._key_validity import _UTC
-from azure.keyvault.keys.crypto._providers import (
-    NoLocalCryptography, get_local_cryptography_provider)
+from azure.core.rest import HttpRequest
+from azure.keyvault.keys import JsonWebKey, KeyCurveName, KeyOperation, KeyVaultKey
+from azure.keyvault.keys.crypto import (
+    CryptographyClient,
+    EncryptionAlgorithm,
+    KeyWrapAlgorithm,
+    SignatureAlgorithm,
+)
+from azure.keyvault.keys.crypto._providers import NoLocalCryptography, get_local_cryptography_provider
+from azure.keyvault.keys._generated._serialization import Deserializer, Serializer
+from azure.keyvault.keys._generated_models import KeySignParameters
+from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION
 from azure.mgmt.keyvault.models import KeyPermissions, Permissions
 
 from _shared.test_case import KeyVaultTestCase
 from _test_case import KeysClientPreparer, get_decorator
 from _keys_test_case import KeysTestCase
 
 # without keys/get, a CryptographyClient created with a key ID performs all ops remotely
 NO_GET = Permissions(keys=[p.value for p in KeyPermissions if p.value != "get"])
 
 all_api_versions = get_decorator()
-only_7_4_hsm = get_decorator(only_hsm=True, api_versions=[ApiVersion.V7_4_PREVIEW_1])
 only_hsm = get_decorator(only_hsm=True)
+only_vault_latest = get_decorator(only_vault=True, api_versions=[DEFAULT_VERSION])
 no_get = get_decorator(permissions=NO_GET)
 
 
 class TestCryptoClient(KeyVaultTestCase, KeysTestCase):
     plaintext = b"5063e6aaa845f150200547944fd199679c98ed6f99da0a0b2dafeaf1f4684496fd532c1c229968cb9dee44957fcef7ccef59ceda0b362e56bcd78fd3faee5781c623c0bb22b35beabde0664fd30e0e824aba3dd1b0afffc4a3d955ede20cf6a854d52cfd"
     iv = codecs.decode("89b8adbfb07345e3598932a09c517441", "hex_codec")
     aad = b"test"
@@ -66,35 +70,35 @@
         self._validate_ec_key_bundle(key_curve, created_key, client.vault_url, key_name, key_type)
         return created_key
 
     def _validate_rsa_key_bundle(self, key_attributes, vault, key_name, kty, key_ops):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key.n and key.e, "Bad RSA public material."
-        assert sorted(key_ops) == sorted(key.key_ops), "keyOps should be '{}', but is '{}'".format(key_ops, key.key_ops)
+        assert sorted(key_ops) == sorted(key.key_ops), f"keyOps should be '{key_ops}', but is '{key.key_ops}'"
         
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on, "Missing required date attributes."
         
 
     def _validate_ec_key_bundle(self, key_curve, key_attributes, vault, key_name, kty):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
         assert key_curve == key.crv
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
 
     def _import_test_key(self, client, name, hardware_protected=False):
         def _to_bytes(hex):
             if len(hex) % 2:
-                hex = "0{}".format(hex)
+                hex = f"0{hex}"
             return codecs.decode(hex, "hex_codec")
 
         key = JsonWebKey(
             kty="RSA-HSM" if hardware_protected else "RSA",
             key_ops=["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"],
             n=_to_bytes(
                 "00a0914d00234ac683b21b4c15d5bed887bdc959c2e57af54ae734e8f00720d775d275e455207e3784ceeb60a50a4655dd72a7a94d271e8ee8f7959a669ca6e775bf0e23badae991b4529d978528b4bd90521d32dd2656796ba82b6bbfc7668c8f5eeb5053747fd199319d29a8440d08f4412d527ff9311eda71825920b47b1c46b11ab3e91d7316407e89c7f340f7b85a34042ce51743b27d4718403d34c7b438af6181be05e4d11eb985d38253d7fe9bf53fc2f1b002d22d2d793fa79a504b6ab42d0492804d7071d727a06cf3a8893aa542b1503f832b296371b6707d4dc6e372f8fe67d8ded1c908fde45ce03bc086a71487fa75e43aa0e0679aa0d20efe35"
@@ -207,36 +211,14 @@
         assert result.key_id == imported_key.id
 
         verified = crypto_client.verify(result.algorithm, digest, result.signature)
         assert result.key_id == imported_key.id
         assert result.algorithm == SignatureAlgorithm.rs256
         assert verified.is_valid
 
-    @pytest.mark.parametrize("api_version,is_hsm", only_7_4_hsm)
-    @KeysClientPreparer()
-    @recorded_by_proxy
-    def test_sign_and_verify_okp(self, key_client, is_hsm, **kwargs):
-        key_name = self.get_resource_name("keysign")
-
-        md = hashlib.sha256()
-        md.update(self.plaintext)
-        digest = md.digest()
-
-        # Local crypto isn't supported for OKP, so operations will be remote even without explicit NO_GET permissions
-        key = key_client.create_okp_key(key_name, curve=KeyCurveName.ed25519)
-        crypto_client = self.create_crypto_client(key.id, api_version=key_client.api_version)
-
-        result = crypto_client.sign(SignatureAlgorithm.eddsa, digest)
-        assert result.key_id == key.id
-
-        verified = crypto_client.verify(result.algorithm, digest, result.signature)
-        assert result.key_id == key.id
-        assert result.algorithm == SignatureAlgorithm.eddsa
-        assert verified.is_valid
-
     @pytest.mark.parametrize("api_version,is_hsm", no_get)
     @KeysClientPreparer(permissions=NO_GET)
     @recorded_by_proxy
     def test_wrap_and_unwrap(self, key_client, is_hsm, **kwargs):
         set_bodiless_matcher()
         key_name = self.get_resource_name("keywrap")
 
@@ -449,15 +431,15 @@
 
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_rsa_verify_local(self, key_client, is_hsm, **kwargs):
         """Sign with Key Vault, verify locally"""
         for size in (2048, 3072, 4096):
-            key_name = self.get_resource_name("rsa-verify-{}".format(size))
+            key_name = self.get_resource_name(f"rsa-verify-{size}")
             key = self._create_rsa_key(key_client, key_name, size=size, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, api_version=key_client.api_version)
             for signature_algorithm, hash_function in (
                 (SignatureAlgorithm.ps256, hashlib.sha256),
                 (SignatureAlgorithm.ps384, hashlib.sha384),
                 (SignatureAlgorithm.ps512, hashlib.sha512),
                 (SignatureAlgorithm.rs256, hashlib.sha256),
@@ -474,15 +456,15 @@
 
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @KeysClientPreparer()
     @recorded_by_proxy
     def test_rsa_verify_local_from_jwk(self, key_client, is_hsm, **kwargs):
         """Sign with Key Vault, verify locally"""
         for size in (2048, 3072, 4096):
-            key_name = self.get_resource_name("rsa-verify-{}".format(size))
+            key_name = self.get_resource_name(f"rsa-verify-{size}")
             key = self._create_rsa_key(key_client, key_name, size=size, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, api_version=key_client.api_version)
             local_client = CryptographyClient.from_jwk(key.key)
             for signature_algorithm, hash_function in (
                     (SignatureAlgorithm.ps256, hashlib.sha256),
                     (SignatureAlgorithm.ps384, hashlib.sha384),
                     (SignatureAlgorithm.ps512, hashlib.sha512),
@@ -507,15 +489,15 @@
             KeyCurveName.p_256: (SignatureAlgorithm.es256, hashlib.sha256),
             KeyCurveName.p_256_k: (SignatureAlgorithm.es256_k, hashlib.sha256),
             KeyCurveName.p_384: (SignatureAlgorithm.es384, hashlib.sha384),
             KeyCurveName.p_521: (SignatureAlgorithm.es512, hashlib.sha512),
         }
 
         for curve, (signature_algorithm, hash_function) in sorted(matrix.items()):
-            key_name = self.get_resource_name("ec-verify-{}".format(curve.value))
+            key_name = self.get_resource_name(f"ec-verify-{curve.value}")
             key = self._create_ec_key(key_client, key_name, curve=curve, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, api_version=key_client.api_version)
 
             digest = hash_function(self.plaintext).digest()
 
             result = crypto_client.sign(signature_algorithm, digest)
             assert result.key_id, key.id
@@ -532,15 +514,15 @@
             KeyCurveName.p_256: (SignatureAlgorithm.es256, hashlib.sha256),
             KeyCurveName.p_256_k: (SignatureAlgorithm.es256_k, hashlib.sha256),
             KeyCurveName.p_384: (SignatureAlgorithm.es384, hashlib.sha384),
             KeyCurveName.p_521: (SignatureAlgorithm.es512, hashlib.sha512),
         }
 
         for curve, (signature_algorithm, hash_function) in sorted(matrix.items()):
-            key_name = self.get_resource_name("ec-verify-{}".format(curve.value))
+            key_name = self.get_resource_name(f"ec-verify-{curve.value}")
             key = self._create_ec_key(key_client, key_name, curve=curve, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, api_version=key_client.api_version)
             local_client = CryptographyClient.from_jwk(key.key)
 
             digest = hash_function(self.plaintext).digest()
 
             result = crypto_client.sign(signature_algorithm, digest)
@@ -564,42 +546,74 @@
             for algorithm in wrap_algorithms:
                 with pytest.raises(ValueError) as ex:
                     crypto_client.wrap_key(algorithm, self.plaintext)
                 for substring in expected_error_substrings:
                     assert substring in str(ex.value)
 
         # operations should not succeed with a key whose nbf is in the future
-        the_year_3000 = datetime(3000, 1, 1, tzinfo=_UTC)
+        the_year_3000 = datetime(3000, 1, 1, tzinfo=timezone.utc)
 
         rsa_wrap_algorithms = [algorithm for algorithm in KeyWrapAlgorithm if algorithm.startswith("RSA")]
         rsa_encryption_algorithms = [algorithm for algorithm in EncryptionAlgorithm if algorithm.startswith("RSA")]
         key_name = self.get_resource_name("rsa-not-yet-valid")
         not_yet_valid_key = self._create_rsa_key(
             key_client, key_name, not_before=the_year_3000, hardware_protected=is_hsm
         )
         test_operations(not_yet_valid_key, [str(the_year_3000)], rsa_encryption_algorithms, rsa_wrap_algorithms)
 
         # nor should they succeed with a key whose exp has passed
-        the_year_2000 = datetime(2000, 1, 1, tzinfo=_UTC)
+        the_year_2000 = datetime(2000, 1, 1, tzinfo=timezone.utc)
 
         key_name = self.get_resource_name("rsa-expired")
         expired_key = self._create_rsa_key(key_client, key_name, expires_on=the_year_2000, hardware_protected=is_hsm)
         test_operations(expired_key, [str(the_year_2000)], rsa_encryption_algorithms, rsa_wrap_algorithms)
 
         # when exp and nbf are set, error messages should contain both
-        the_year_3001 = datetime(3001, 1, 1, tzinfo=_UTC)
+        the_year_3001 = datetime(3001, 1, 1, tzinfo=timezone.utc)
 
         key_name = self.get_resource_name("rsa-valid")
         valid_key = self._create_rsa_key(
             key_client, key_name, not_before=the_year_3000, expires_on=the_year_3001, hardware_protected=is_hsm
         )
         test_operations(
             valid_key, (str(the_year_3000), str(the_year_3001)), rsa_encryption_algorithms, rsa_wrap_algorithms
         )
 
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
+    @KeysClientPreparer()
+    @recorded_by_proxy
+    def test_send_request(self, key_client, is_hsm, **kwargs):
+        key_name = self.get_resource_name("keysign")
+
+        md = hashlib.sha256()
+        md.update(self.plaintext)
+        digest = md.digest()
+
+        imported_key = self._import_test_key(key_client, key_name, hardware_protected=is_hsm)
+        crypto_client = self.create_crypto_client(imported_key.id, api_version=key_client.api_version)
+
+        parameters = KeySignParameters(algorithm=SignatureAlgorithm.rs256, value=digest)
+        json = Serializer().body(parameters, "KeySignParameters")
+
+        # sign using a custom request
+        request = HttpRequest(
+            method="POST",
+            url=f"keys/{key_name}/{imported_key.properties.version}/sign",
+            headers={"Accept": "application/json"},
+            json=json
+        )
+        response = crypto_client.send_request(request)
+        result = response.json()
+        signature = Deserializer().deserialize_base64(result["value"])
+        assert result["kid"] == imported_key.id
+
+        # verify that the operation round-trips
+        verified = crypto_client.verify(SignatureAlgorithm.rs256, digest, signature)
+        assert verified.is_valid
+
 
 def test_custom_hook_policy():
     class CustomHookPolicy(SansIOHTTPPolicy):
         pass
 
     client = CryptographyClient("https://localhost/fake/key/version", object(), custom_hook_policy=CustomHookPolicy())
     assert isinstance(client._client._config.custom_hook_policy, CustomHookPolicy)
@@ -785,15 +799,15 @@
     """The client should complete operations locally whenever possible"""
 
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     supports_everything = mock.Mock(supports=mock.Mock(return_value=True))
     with mock.patch(CryptographyClient.__module__ + ".get_local_cryptography_provider", lambda *_: supports_everything):
@@ -853,15 +867,15 @@
     """The client should raise an error when arguments don't work with the specified algorithm"""
 
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     with pytest.raises(ValueError) as ex:
         client.encrypt(EncryptionAlgorithm.rsa_oaep, b"...", iv=b"...")
@@ -876,15 +890,15 @@
 
 def test_decrypt_argument_validation():
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     with pytest.raises(ValueError) as ex:
         client.decrypt(EncryptionAlgorithm.rsa_oaep, b"...", iv=b"...")
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_crypto_client_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_crypto_client_async.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,44 +2,47 @@
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import asyncio
 import codecs
 import hashlib
 import os
-from datetime import datetime
+from datetime import datetime, timezone
 from unittest import mock
 
 import pytest
 from azure.core.exceptions import AzureError, HttpResponseError
 from azure.core.pipeline.policies import SansIOHTTPPolicy
-from azure.keyvault.keys import (ApiVersion, JsonWebKey, KeyCurveName,
-                                 KeyOperation, KeyVaultKey)
-from azure.keyvault.keys.crypto._key_validity import _UTC
-from azure.keyvault.keys.crypto._providers import (
-    NoLocalCryptography, get_local_cryptography_provider)
-from azure.keyvault.keys.crypto.aio import (CryptographyClient,
-                                            EncryptionAlgorithm,
-                                            KeyWrapAlgorithm,
-                                            SignatureAlgorithm)
+from azure.core.rest import HttpRequest
+from azure.keyvault.keys import JsonWebKey, KeyCurveName, KeyOperation, KeyVaultKey
+from azure.keyvault.keys.crypto._providers import NoLocalCryptography, get_local_cryptography_provider
+from azure.keyvault.keys.crypto.aio import (
+    CryptographyClient,
+    EncryptionAlgorithm,
+    KeyWrapAlgorithm,
+    SignatureAlgorithm,
+)
+from azure.keyvault.keys._generated._serialization import Deserializer, Serializer
+from azure.keyvault.keys._generated_models import KeySignParameters
+from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION
 from azure.mgmt.keyvault.models import KeyPermissions, Permissions
 from devtools_testutils import set_bodiless_matcher
 from devtools_testutils.aio import recorded_by_proxy_async
 
 from _async_test_case import AsyncKeysClientPreparer, get_decorator
 from _shared.helpers_async import get_completed_future
 from _shared.test_case_async import KeyVaultTestCase
 from _keys_test_case import KeysTestCase
 
 # without keys/get, a CryptographyClient created with a key ID performs all ops remotely
 NO_GET = Permissions(keys=[p.value for p in KeyPermissions if p.value != "get"])
 
 all_api_versions = get_decorator(is_async=True)
-only_7_4_hsm = get_decorator(only_hsm=True, api_versions=[ApiVersion.V7_4_PREVIEW_1])
 only_hsm = get_decorator(only_hsm=True, is_async=True)
+only_vault_latest = get_decorator(only_vault=True, is_async=True, api_versions=[DEFAULT_VERSION])
 no_get = get_decorator(is_async=True, permissions=NO_GET)
 
 
 class TestCryptoClient(KeyVaultTestCase, KeysTestCase):
     plaintext = b"5063e6aaa845f150200547944fd199679c98ed6f99da0a0b2dafeaf1f4684496fd532c1c229968cb9dee44957fcef7ccef59ceda0b362e56bcd78fd3faee5781c623c0bb22b35beabde0664fd30e0e824aba3dd1b0afffc4a3d955ede20cf6a854d52cfd"
     iv = codecs.decode("89b8adbfb07345e3598932a09c517441", "hex_codec")
     aad = b"test"
@@ -64,34 +67,34 @@
         self._validate_ec_key_bundle(key_curve, created_key, client.vault_url, key_name, key_type)
         return created_key
 
     def _validate_rsa_key_bundle(self, key_attributes, vault, key_name, kty, key_ops):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key.n and key.e, "Bad RSA public material."
-        assert sorted(key_ops) == sorted(key.key_ops), "keyOps should be '{}', but is '{}'".format(key_ops, key.key_ops)
+        assert sorted(key_ops) == sorted(key.key_ops), f"keyOps should be '{key_ops}', but is '{key.key_ops}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
         
 
     def _validate_ec_key_bundle(self, key_curve, key_attributes, vault, key_name, kty):
         prefix = "/".join(s.strip("/") for s in [vault, "keys", key_name])
         key = key_attributes.key
         kid = key_attributes.id
         assert key_curve == key.crv
-        assert kid.index(prefix) == 0, "Key Id should start with '{}', but value is '{}'".format(prefix, kid)
-        assert key.kty == kty, "kty should by '{}', but is '{}'".format(key, key.kty)
+        assert kid.index(prefix) == 0, f"Key Id should start with '{prefix}', but value is '{kid}'"
+        assert key.kty == kty, f"kty should by '{key}', but is '{key.kty}'"
         assert key_attributes.properties.created_on and key_attributes.properties.updated_on,"Missing required date attributes."
 
     async def _import_test_key(self, client, name, hardware_protected=False):
         def _to_bytes(hex):
             if len(hex) % 2:
-                hex = "0{}".format(hex)
+                hex = f"0{hex}"
             return codecs.decode(hex, "hex_codec")
 
         key = JsonWebKey(
             kty="RSA-HSM" if hardware_protected else "RSA",
             key_ops=["encrypt", "decrypt", "sign", "verify", "wrapKey", "unwrapKey"],
             n=_to_bytes(
                 "00a0914d00234ac683b21b4c15d5bed887bdc959c2e57af54ae734e8f00720d775d275e455207e3784ceeb60a50a4655dd72a7a94d271e8ee8f7959a669ca6e775bf0e23badae991b4529d978528b4bd90521d32dd2656796ba82b6bbfc7668c8f5eeb5053747fd199319d29a8440d08f4412d527ff9311eda71825920b47b1c46b11ab3e91d7316407e89c7f340f7b85a34042ce51743b27d4718403d34c7b438af6181be05e4d11eb985d38253d7fe9bf53fc2f1b002d22d2d793fa79a504b6ab42d0492804d7071d727a06cf3a8893aa542b1503f832b296371b6707d4dc6e372f8fe67d8ded1c908fde45ce03bc086a71487fa75e43aa0e0679aa0d20efe35"
@@ -208,37 +211,14 @@
 
         verified = await crypto_client.verify(result.algorithm, digest, result.signature)
         assert result.key_id == imported_key.id
         assert result.algorithm == SignatureAlgorithm.rs256
         assert verified.is_valid
 
     @pytest.mark.asyncio
-    @pytest.mark.parametrize("api_version,is_hsm", only_7_4_hsm)
-    @AsyncKeysClientPreparer()
-    @recorded_by_proxy_async
-    async def test_sign_and_verify_okp(self, key_client, is_hsm, **kwargs):
-        key_name = self.get_resource_name("keysign")
-
-        md = hashlib.sha256()
-        md.update(self.plaintext)
-        digest = md.digest()
-
-        # Local crypto isn't supported for OKP, so operations will be remote even without explicit NO_GET permissions
-        key = await key_client.create_okp_key(key_name, curve=KeyCurveName.ed25519)
-        crypto_client = self.create_crypto_client(key.id, is_async=True, api_version=key_client.api_version)
-
-        result = await crypto_client.sign(SignatureAlgorithm.eddsa, digest)
-        assert result.key_id == key.id
-
-        verified = await crypto_client.verify(result.algorithm, digest, result.signature)
-        assert result.key_id == key.id
-        assert result.algorithm == SignatureAlgorithm.eddsa
-        assert verified.is_valid
-
-    @pytest.mark.asyncio
     @pytest.mark.parametrize("api_version,is_hsm",no_get)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_wrap_and_unwrap(self, key_client, is_hsm, **kwargs):
         set_bodiless_matcher()
         key_name = self.get_resource_name("keywrap")
 
@@ -460,15 +440,15 @@
     @pytest.mark.asyncio
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_rsa_verify_local(self, key_client, is_hsm, **kwargs):
         """Sign with Key Vault, verify locally"""
         for size in (2048, 3072, 4096):
-            key_name = self.get_resource_name("rsa-verify-{}".format(size))
+            key_name = self.get_resource_name(f"rsa-verify-{size}")
             key = await self._create_rsa_key(key_client, key_name, size=size, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, is_async=True, api_version=key_client.api_version)
             for signature_algorithm, hash_function in (
                 (SignatureAlgorithm.ps256, hashlib.sha256),
                 (SignatureAlgorithm.ps384, hashlib.sha384),
                 (SignatureAlgorithm.ps512, hashlib.sha512),
                 (SignatureAlgorithm.rs256, hashlib.sha256),
@@ -486,15 +466,15 @@
     @pytest.mark.asyncio
     @pytest.mark.parametrize("api_version,is_hsm",all_api_versions)
     @AsyncKeysClientPreparer()
     @recorded_by_proxy_async
     async def test_rsa_verify_local_from_jwk(self, key_client, is_hsm, **kwargs):
         """Sign with Key Vault, verify locally"""
         for size in (2048, 3072, 4096):
-            key_name = self.get_resource_name("rsa-verify-{}".format(size))
+            key_name = self.get_resource_name(f"rsa-verify-{size}")
             key = await self._create_rsa_key(key_client, key_name, size=size, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, is_async=True, api_version=key_client.api_version)
             local_client = CryptographyClient.from_jwk(key.key)
             for signature_algorithm, hash_function in (
                     (SignatureAlgorithm.ps256, hashlib.sha256),
                     (SignatureAlgorithm.ps384, hashlib.sha384),
                     (SignatureAlgorithm.ps512, hashlib.sha512),
@@ -520,15 +500,15 @@
             KeyCurveName.p_256: (SignatureAlgorithm.es256, hashlib.sha256),
             KeyCurveName.p_256_k: (SignatureAlgorithm.es256_k, hashlib.sha256),
             KeyCurveName.p_384: (SignatureAlgorithm.es384, hashlib.sha384),
             KeyCurveName.p_521: (SignatureAlgorithm.es512, hashlib.sha512),
         }
 
         for curve, (signature_algorithm, hash_function) in sorted(matrix.items()):
-            key_name = self.get_resource_name("ec-verify-{}".format(curve.value))
+            key_name = self.get_resource_name(f"ec-verify-{curve.value}")
             key = await self._create_ec_key(key_client, key_name, curve=curve, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, is_async=True, api_version=key_client.api_version)
 
             digest = hash_function(self.plaintext).digest()
 
             result = await crypto_client.sign(signature_algorithm, digest)
             assert result.key_id == key.id
@@ -546,15 +526,15 @@
             KeyCurveName.p_256: (SignatureAlgorithm.es256, hashlib.sha256),
             KeyCurveName.p_256_k: (SignatureAlgorithm.es256_k, hashlib.sha256),
             KeyCurveName.p_384: (SignatureAlgorithm.es384, hashlib.sha384),
             KeyCurveName.p_521: (SignatureAlgorithm.es512, hashlib.sha512),
         }
 
         for curve, (signature_algorithm, hash_function) in sorted(matrix.items()):
-            key_name = self.get_resource_name("ec-verify-{}".format(curve.value))
+            key_name = self.get_resource_name(f"ec-verify-{curve.value}")
             key = await self._create_ec_key(key_client, key_name, curve=curve, hardware_protected=is_hsm)
             crypto_client = self.create_crypto_client(key, is_async=True, api_version=key_client.api_version)
             local_client = CryptographyClient.from_jwk(key.key)
 
             digest = hash_function(self.plaintext).digest()
 
             result = await crypto_client.sign(signature_algorithm, digest)
@@ -579,44 +559,77 @@
             for algorithm in wrap_algorithms:
                 with pytest.raises(ValueError) as ex:
                     await crypto_client.wrap_key(algorithm, self.plaintext)
                 for substring in expected_error_substrings:
                     assert substring in str(ex.value)
 
         # operations should not succeed with a key whose nbf is in the future
-        the_year_3000 = datetime(3000, 1, 1, tzinfo=_UTC)
+        the_year_3000 = datetime(3000, 1, 1, tzinfo=timezone.utc)
 
         rsa_wrap_algorithms = [algorithm for algorithm in KeyWrapAlgorithm if algorithm.startswith("RSA")]
         rsa_encryption_algorithms = [algorithm for algorithm in EncryptionAlgorithm if algorithm.startswith("RSA")]
         key_name = self.get_resource_name("rsa-not-yet-valid")
         not_yet_valid_key = await self._create_rsa_key(
             key_client, key_name, not_before=the_year_3000, hardware_protected=is_hsm
         )
         await test_operations(not_yet_valid_key, [str(the_year_3000)], rsa_encryption_algorithms, rsa_wrap_algorithms)
 
         # nor should they succeed with a key whose exp has passed
-        the_year_2000 = datetime(2000, 1, 1, tzinfo=_UTC)
+        the_year_2000 = datetime(2000, 1, 1, tzinfo=timezone.utc)
 
         key_name = self.get_resource_name("rsa-expired")
         expired_key = await self._create_rsa_key(
             key_client, key_name, expires_on=the_year_2000, hardware_protected=is_hsm
         )
         await test_operations(expired_key, [str(the_year_2000)], rsa_encryption_algorithms, rsa_wrap_algorithms)
 
         # when exp and nbf are set, error messages should contain both
-        the_year_3001 = datetime(3001, 1, 1, tzinfo=_UTC)
+        the_year_3001 = datetime(3001, 1, 1, tzinfo=timezone.utc)
 
         key_name = self.get_resource_name("rsa-valid")
         valid_key = await self._create_rsa_key(
             key_client, key_name, not_before=the_year_3000, expires_on=the_year_3001, hardware_protected=is_hsm
         )
         await test_operations(
             valid_key, (str(the_year_3000), str(the_year_3001)), rsa_encryption_algorithms, rsa_wrap_algorithms
         )
 
+    @pytest.mark.asyncio
+    @pytest.mark.parametrize("api_version,is_hsm",only_vault_latest)
+    @AsyncKeysClientPreparer()
+    @recorded_by_proxy_async
+    async def test_send_request(self, key_client, is_hsm, **kwargs):
+        key_name = self.get_resource_name("keysign")
+
+        md = hashlib.sha256()
+        md.update(self.plaintext)
+        digest = md.digest()
+
+        imported_key = await self._import_test_key(key_client, key_name, hardware_protected=is_hsm)
+        crypto_client = self.create_crypto_client(imported_key.id, is_async=True, api_version=key_client.api_version)
+
+        parameters = KeySignParameters(algorithm=SignatureAlgorithm.rs256, value=digest)
+        json = Serializer().body(parameters, "KeySignParameters")
+
+        # sign using a custom request
+        request = HttpRequest(
+            method="POST",
+            url=f"keys/{key_name}/{imported_key.properties.version}/sign",
+            headers={"Accept": "application/json"},
+            json=json
+        )
+        response = await crypto_client.send_request(request)
+        result = response.json()
+        signature = Deserializer().deserialize_base64(result["value"])
+        assert result["kid"] == imported_key.id
+
+        # verify that the operation round-trips
+        verified = await crypto_client.verify(SignatureAlgorithm.rs256, digest, signature)
+        assert verified.is_valid
+
 
 def test_custom_hook_policy():
     class CustomHookPolicy(SansIOHTTPPolicy):
         pass
 
     client = CryptographyClient("https://localhost/fake/key/version", object(), custom_hook_policy=CustomHookPolicy())
     assert isinstance(client._client._config.custom_hook_policy, CustomHookPolicy)
@@ -832,15 +845,15 @@
     """The client should complete operations locally whenever possible"""
 
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     supports_everything = mock.Mock(supports=mock.Mock(return_value=True))
     with mock.patch(CryptographyClient.__module__ + ".get_local_cryptography_provider", lambda *_: supports_everything):
@@ -903,15 +916,15 @@
     """The client should raise an error when arguments don't work with the specified algorithm"""
     
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     with pytest.raises(ValueError) as ex:
         await client.encrypt(EncryptionAlgorithm.rsa_oaep, b"...", iv=b"...")
@@ -927,15 +940,15 @@
 @pytest.mark.asyncio
 async def test_decrypt_argument_validation():
     mock_client = mock.Mock()
     key = mock.Mock(
         spec=KeyVaultKey,
         id="https://localhost/fake/key/version",
         properties=mock.Mock(
-            not_before=datetime(2000, 1, 1, tzinfo=_UTC), expires_on=datetime(3000, 1, 1, tzinfo=_UTC)
+            not_before=datetime(2000, 1, 1, tzinfo=timezone.utc), expires_on=datetime(3000, 1, 1, tzinfo=timezone.utc)
         ),
     )
     client = CryptographyClient(key, mock.Mock())
     client._client = mock_client
 
     with pytest.raises(ValueError) as ex:
         await client.decrypt(EncryptionAlgorithm.rsa_oaep, b"...", iv=b"...")
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_async_test_case.py` & `azure-keyvault-keys-4.9.0b1/tests/_async_test_case.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 from azure.core.pipeline.transport import AioHttpTransport, HttpRequest
 from azure.keyvault.keys import KeyReleasePolicy
 from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION, ApiVersion
 from devtools_testutils import AzureRecordedTestCase
 
 
 async def get_attestation_token(attestation_uri):
-    request = HttpRequest("GET", "{}/generate-test-token".format(attestation_uri))
+    request = HttpRequest("GET", f"{attestation_uri}/generate-test-token")
     async with AsyncPipeline(transport=AioHttpTransport()) as pipeline:
         response = await pipeline.run(request)
         return json.loads(response.http_response.text())["token"]
 
 
 def get_decorator(only_hsm=False, only_vault=False, api_versions=None, **kwargs):
     """returns a test decorator for test parameterization"""
@@ -38,15 +38,15 @@
     return KeyReleasePolicy(policy_string, **kwargs)
 
 
 def get_test_parameters(only_hsm=False, only_vault=False, api_versions=None):
     """generates a list of parameter pairs for test case parameterization, where [x, y] = [api_version, is_hsm]"""
     combinations = []
     versions = api_versions or ApiVersion
-    hsm_supported_versions = {ApiVersion.V7_2, ApiVersion.V7_3, ApiVersion.V7_4_PREVIEW_1}
+    hsm_supported_versions = {ApiVersion.V7_2, ApiVersion.V7_3, ApiVersion.V7_4}
 
     for api_version in versions:
         if not only_vault and api_version in hsm_supported_versions:
             combinations.append([api_version, True])
         if not only_hsm:
             combinations.append([api_version, False])
     return combinations
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_challenge_auth.py` & `azure-keyvault-keys-4.9.0b1/tests/test_challenge_auth.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,24 +5,20 @@
 """
 Tests for the HTTP challenge authentication implementation. These tests aren't parallelizable, because
 the challenge cache is global to the process.
 """
 import functools
 import os
 import time
+from unittest.mock import Mock, patch
 from urllib.parse import urlparse
 from uuid import uuid4
 
 from devtools_testutils import recorded_by_proxy
 
-try:
-    from unittest.mock import Mock, patch
-except ImportError:  # python < 3.3
-    from mock import Mock, patch  # type: ignore
-
 import pytest
 from azure.core.credentials import AccessToken
 from azure.core.exceptions import ServiceRequestError
 from azure.core.pipeline import Pipeline
 from azure.core.pipeline.policies import SansIOHTTPPolicy
 from azure.core.pipeline.transport import HttpRequest
 from azure.identity import ClientSecretCredential
@@ -81,15 +77,15 @@
 
     return wrapper
 
 
 def get_random_url():
     """The challenge cache is keyed on URLs. Random URLs defend against tests interfering with each other."""
 
-    return "https://{}.vault.azure.net/{}".format(uuid4(), uuid4()).replace("-", "")
+    return f"https://{uuid4()}.vault.azure.net/{uuid4()}".replace("-", "")
 
 
 def add_url_port(url: str):
     """Like `get_random_url`, but includes a port number (comes after the domain, and before the path of the URL)."""
 
     parsed = urlparse(url)
     return f"{parsed.scheme}://{parsed.netloc}:443{parsed.path}"
@@ -122,18 +118,18 @@
 
         HttpChallengeCache.remove_challenge_for_url(url)
         assert not HttpChallengeCache.get_challenge_for_url(url)
 
 
 def test_challenge_parsing():
     tenant = "tenant"
-    authority = "https://login.authority.net/{}".format(tenant)
+    authority = f"https://login.authority.net/{tenant}"
     resource = "https://challenge.resource"
     challenge = HttpChallenge(
-        "https://request.uri", challenge="Bearer authorization={}, resource={}".format(authority, resource)
+        "https://request.uri", challenge=f"Bearer authorization={authority}, resource={resource}"
     )
 
     assert challenge.get_authorization_server() == authority
     assert challenge.get_resource() == resource
     assert challenge.tenant_id == tenant
 
 
@@ -181,19 +177,19 @@
 
     # an AADv1 resource becomes an AADv2 scope with the addition of '/.default'
     resource = "https://vault.azure.net"
     scope = resource + "/.default"
 
     challenge_with_resource = Mock(
         status_code=401,
-        headers={"WWW-Authenticate": 'Bearer authorization="{}", resource={}'.format(endpoint, resource)},
+        headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
     )
 
     challenge_with_scope = Mock(
-        status_code=401, headers={"WWW-Authenticate": 'Bearer authorization="{}", scope={}'.format(endpoint, scope)}
+        status_code=401, headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", scope={scope}'}
     )
 
     test_with_challenge(challenge_with_resource, scope)
     test_with_challenge(challenge_with_scope, scope)
 
 
 @empty_challenge_cache
@@ -232,15 +228,68 @@
         request = HttpRequest("POST", get_random_url())
         request.set_bytes_body(expected_content)
         pipeline.run(request)
 
         assert credential.get_token.call_count == 1
 
     tenant = "tenant-id"
-    endpoint = "https://authority.net/{}".format(tenant)
+    endpoint = f"https://authority.net/{tenant}"
+    resource = "https://vault.azure.net"
+
+    challenge = Mock(
+        status_code=401,
+        headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
+    )
+
+    test_with_challenge(challenge, tenant)
+
+
+@empty_challenge_cache
+def test_adfs():
+    """The policy should handle AD FS challenges as a special case and omit the tenant ID from token requests"""
+
+    expected_content = b"a duck"
+
+    def test_with_challenge(challenge, expected_tenant):
+        expected_token = "expected_token"
+
+        class Requests:
+            count = 0
+
+        def send(request):
+            Requests.count += 1
+            if Requests.count == 1:
+                # first request should be unauthorized and have no content
+                assert not request.body
+                assert request.headers["Content-Length"] == "0"
+                return challenge
+            elif Requests.count == 2:
+                # second request should be authorized according to challenge and have the expected content
+                assert request.headers["Content-Length"]
+                assert request.body == expected_content
+                assert expected_token in request.headers["Authorization"]
+                return Mock(status_code=200)
+            raise ValueError("unexpected request")
+
+        def get_token(*_, **kwargs):
+            # we shouldn't provide a tenant ID during AD FS authentication
+            assert "tenant_id" not in kwargs
+            return AccessToken(expected_token, 0)
+
+        credential = Mock(get_token=Mock(wraps=get_token))
+        pipeline = Pipeline(policies=[ChallengeAuthPolicy(credential=credential)], transport=Mock(send=send))
+        request = HttpRequest("POST", get_random_url())
+        request.set_bytes_body(expected_content)
+        pipeline.run(request)
+
+        assert credential.get_token.call_count == 1
+
+    tenant = "tenant-id"
+    # AD FS challenges have an unusual authority format; see https://github.com/Azure/azure-sdk-for-python/issues/28648
+    endpoint = f"https://adfs.redmond.azurestack.corp.microsoft.com/adfs/{tenant}"
     resource = "https://vault.azure.net"
 
     challenge = Mock(
         status_code=401,
         headers={"WWW-Authenticate": f'Bearer authorization="{endpoint}", resource={resource}'},
     )
 
@@ -254,37 +303,37 @@
     """
 
     url = get_random_url()
     first_scope = "https://vault.azure.net/first-scope"
     first_token = "first-scope-token"
     second_scope = "https://vault.azure.net/second-scope"
     second_token = "second-scope-token"
-    challenge_fmt = 'Bearer authorization="https://login.authority.net/tenant", resource={}'
+    challenge_fmt = 'Bearer authorization="https://login.authority.net/tenant", resource='
 
     # mocking a tenant change:
     # 1. first request -> respond with challenge
     # 2. second request should be authorized according to the challenge
     # 3. third request should match the second (using a cached access token)
     # 4. fourth request should also match the second -> respond with a new challenge
     # 5. fifth request should be authorized according to the new challenge
     # 6. sixth request should match the fifth
     transport = validating_transport(
         requests=(
             Request(url),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(first_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(second_token)}),
-            Request(url, required_headers={"Authorization": "Bearer {}".format(second_token)}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {first_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {second_token}"}),
+            Request(url, required_headers={"Authorization": f"Bearer {second_token}"}),
         ),
         responses=(
-            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt.format(first_scope)}),
+            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt + first_scope}),
             mock_response(status_code=200),
             mock_response(status_code=200),
-            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt.format(second_scope)}),
+            mock_response(status_code=401, headers={"WWW-Authenticate": challenge_fmt + second_scope}),
             mock_response(status_code=200),
             mock_response(status_code=200),
         ),
     )
 
     credential = Mock(get_token=Mock(return_value=AccessToken(first_token, time.time() + 3600)))
     pipeline = Pipeline(policies=[ChallengeAuthPolicy(credential=credential)], transport=transport)
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_parse_id.py` & `azure-keyvault-keys-4.9.0b1/tests/test_parse_id.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_test_case.py` & `azure-keyvault-keys-4.9.0b1/tests/_test_case.py`

 * *Files 5% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 from azure.core.pipeline.transport import HttpRequest, RequestsTransport
 from azure.keyvault.keys import KeyReleasePolicy
 from azure.keyvault.keys._shared.client_base import DEFAULT_VERSION, ApiVersion
 from devtools_testutils import AzureRecordedTestCase
 
 
 def get_attestation_token(attestation_uri):
-    request = HttpRequest("GET", "{}/generate-test-token".format(attestation_uri))
+    request = HttpRequest("GET", f"{attestation_uri}/generate-test-token")
     with Pipeline(transport=RequestsTransport()) as pipeline:
         response = pipeline.run(request)
         return json.loads(response.http_response.text())["token"]
 
 
 def get_decorator(only_hsm=False, only_vault=False, api_versions=None, **kwargs):
     """returns a test decorator for test parameterization"""
@@ -37,16 +37,16 @@
     policy_string = json.dumps(release_policy_json).encode()
     return KeyReleasePolicy(policy_string, **kwargs)
 
 
 def get_test_parameters(only_hsm=False, only_vault=False, api_versions=None):
     """generates a list of parameter pairs for test case parameterization, where [x, y] = [api_version, is_hsm]"""
     combinations = []
-    versions = api_versions or ApiVersion
-    hsm_supported_versions = {ApiVersion.V7_2, ApiVersion.V7_3, ApiVersion.V7_4_PREVIEW_1}
+    versions = api_versions or pytest.api_version
+    hsm_supported_versions = {ApiVersion.V7_2, ApiVersion.V7_3, ApiVersion.V7_4}
 
     for api_version in versions:
         if not only_vault and api_version in hsm_supported_versions:
             combinations.append([api_version, True])
         if not only_hsm:
             combinations.append([api_version, False])
     return combinations
```

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_context_manager_async.py` & `azure-keyvault-keys-4.9.0b1/tests/test_context_manager_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/test_context_manager.py` & `azure-keyvault-keys-4.9.0b1/tests/test_context_manager.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/test_case.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/test_case.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/test_case_async.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/test_case_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/preparer.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/preparer.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/preparer_async.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/preparer_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/json_attribute_matcher.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/json_attribute_matcher.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/helpers.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/helpers.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/_shared/helpers_async.py` & `azure-keyvault-keys-4.9.0b1/tests/_shared/helpers_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/decrypt.py` & `azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/decrypt.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/unwrap.py` & `azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/unwrap.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/get_key.py` & `azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/get_key.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-keys-4.8.0b2/tests/perfstress_tests/sign.py` & `azure-keyvault-keys-4.9.0b1/tests/perfstress_tests/sign.py`

 * *Files identical despite different names*

