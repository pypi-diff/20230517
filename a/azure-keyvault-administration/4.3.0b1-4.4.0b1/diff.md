# Comparing `tmp/azure-keyvault-administration-4.3.0b1.zip` & `tmp/azure-keyvault-administration-4.4.0b1.zip`

## zipinfo {}

```diff
@@ -1,178 +1,181 @@
-Zip file size: 260319 bytes, number of entries: 176
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/samples/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/tests/
--rw-rw-r--  2.0 unx    26599 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/PKG-INFO
--rw-rw-r--  2.0 unx    18813 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/README.md
--rw-rw-r--  2.0 unx     1073 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/LICENSE
--rw-rw-r--  2.0 unx      197 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx     6851 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx     2494 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/setup.py
--rw-rw-r--  2.0 unx      287 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/TROUBLESHOOTING.md
--rw-rw-r--  2.0 unx       38 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/setup.cfg
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/
--rw-rw-r--  2.0 unx      232 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/
--rw-rw-r--  2.0 unx      232 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/
--rw-rw-r--  2.0 unx     4720 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_enums.py
--rw-rw-r--  2.0 unx     3696 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_settings_client.py
--rw-rw-r--  2.0 unx      241 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_sdk_moniker.py
--rw-rw-r--  2.0 unx        0 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/py.typed
--rw-rw-r--  2.0 unx     6509 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_models.py
--rw-rw-r--  2.0 unx     8522 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_backup_client.py
--rw-rw-r--  2.0 unx     1051 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/__init__.py
--rw-rw-r--  2.0 unx    40054 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated_models.py
--rw-rw-r--  2.0 unx    11154 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_access_control_client.py
--rw-rw-r--  2.0 unx      172 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_version.py
--rw-rw-r--  2.0 unx     3908 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_settings_client.py
--rw-rw-r--  2.0 unx     8546 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_backup_client.py
--rw-rw-r--  2.0 unx      410 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/__init__.py
--rw-rw-r--  2.0 unx    11414 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_access_control_client.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/
--rw-rw-r--  2.0 unx     2069 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_configuration.py
--rw-rw-r--  2.0 unx      363 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/models.py
--rw-rw-r--  2.0 unx      698 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/__init__.py
--rw-rw-r--  2.0 unx     6684 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_key_vault_client.py
--rw-rw-r--  2.0 unx    78750 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_serialization.py
--rw-rw-r--  2.0 unx    19271 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_operations_mixin.py
--rw-rw-r--  2.0 unx      344 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_version.py
--rw-rw-r--  2.0 unx     2028 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_configuration.py
--rw-rw-r--  2.0 unx      543 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/__init__.py
--rw-rw-r--  2.0 unx     6790 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx    19548 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py
--rw-rw-r--  2.0 unx     3939 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py
--rw-rw-r--  2.0 unx    23942 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py
--rw-rw-r--  2.0 unx    48725 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    24179 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py
--rw-rw-r--  2.0 unx     3989 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    19599 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    44517 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    19836 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py
--rw-rw-r--  2.0 unx     4737 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     2588 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py
--rw-rw-r--  2.0 unx    32331 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_vendor.py
--rw-rw-r--  2.0 unx     2593 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/__init__.py
--rw-rw-r--  2.0 unx     3969 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_patch.py
--rw-rw-r--  2.0 unx    24336 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/__init__.py
--rw-rw-r--  2.0 unx    64024 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    24573 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_definitions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_vendor.py
--rw-rw-r--  2.0 unx     2559 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/__init__.py
--rw-rw-r--  2.0 unx     4029 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    19866 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    56863 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    20103 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_patch.py
--rw-rw-r--  2.0 unx     5259 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     2858 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/__init__.py
--rw-rw-r--  2.0 unx    35030 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_models_py3.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py
--rw-rw-r--  2.0 unx     1694 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py
--rw-rw-r--  2.0 unx     2563 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py
--rw-rw-r--  2.0 unx     3939 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py
--rw-rw-r--  2.0 unx    23942 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py
--rw-rw-r--  2.0 unx    48725 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    24179 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py
--rw-rw-r--  2.0 unx     1043 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py
--rw-rw-r--  2.0 unx     2529 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py
--rw-rw-r--  2.0 unx      844 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py
--rw-rw-r--  2.0 unx     3989 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    19599 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1033 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    44517 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py
--rw-rw-r--  2.0 unx    19836 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py
--rw-rw-r--  2.0 unx     5120 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py
--rw-rw-r--  2.0 unx     2588 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py
--rw-rw-r--  2.0 unx    32003 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py
--rw-rw-r--  2.0 unx     2520 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py
--rw-rw-r--  2.0 unx     1197 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/polling.py
--rw-rw-r--  2.0 unx     3592 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/client_base.py
--rw-rw-r--  2.0 unx     3508 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_client_base.py
--rw-rw-r--  2.0 unx     5796 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py
--rw-rw-r--  2.0 unx     4691 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge.py
--rw-rw-r--  2.0 unx     4991 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py
--rw-rw-r--  2.0 unx     2972 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/__init__.py
--rw-rw-r--  2.0 unx     2146 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/exceptions.py
--rw-rw-r--  2.0 unx      442 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_polling.py
--rw-rw-r--  2.0 unx     3024 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations.py
--rw-rw-r--  2.0 unx     4583 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/samples/access_control_operations_async.py
--rw-rw-r--  2.0 unx     3359 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations_async.py
--rw-rw-r--  2.0 unx     4178 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/samples/access_control_operations.py
--rw-rw-r--  2.0 unx    26599 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        6 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/top_level.txt
--rw-rw-r--  2.0 unx       84 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/requires.txt
--rw-rw-r--  2.0 unx     8574 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/dependency_links.txt
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/tests/_shared/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-16 09:24 azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/
--rw-rw-r--  2.0 unx     3539 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_examples_administration_async.py
--rw-rw-r--  2.0 unx     3290 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_examples_administration.py
--rw-rw-r--  2.0 unx     7327 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_backup_client_async.py
--rw-rw-r--  2.0 unx     6483 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_access_control.py
--rw-rw-r--  2.0 unx     3225 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/conftest.py
--rw-rw-r--  2.0 unx     1460 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_settings_client.py
--rw-rw-r--  2.0 unx     6523 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_access_control_async.py
--rw-rw-r--  2.0 unx     7980 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_backup_client.py
--rw-rw-r--  2.0 unx     4827 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_async_test_case.py
--rw-rw-r--  2.0 unx     1580 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/test_settings_client_async.py
--rw-rw-r--  2.0 unx     4910 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_test_case.py
--rw-rw-r--  2.0 unx     1444 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/test_case.py
--rw-rw-r--  2.0 unx     2074 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/test_case_async.py
--rw-rw-r--  2.0 unx     1094 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/preparer.py
--rw-rw-r--  2.0 unx      656 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/preparer_async.py
--rw-rw-r--  2.0 unx      151 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/__init__.py
--rw-rw-r--  2.0 unx      578 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/json_attribute_matcher.py
--rw-rw-r--  2.0 unx     3935 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/helpers.py
--rw-rw-r--  2.0 unx     1407 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/_shared/helpers_async.py
--rw-rw-r--  2.0 unx     2313 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/get_role_definition.py
--rw-rw-r--  2.0 unx        0 b- defN 22-Nov-16 09:23 azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/__init__.py
-176 files, 1204009 bytes uncompressed, 214349 bytes compressed:  82.2%
+Zip file size: 268255 bytes, number of entries: 179
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/samples/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/tests/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/
+-rw-rw-r--  2.0 unx       38 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/setup.cfg
+-rw-rw-r--  2.0 unx    29754 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx       86 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/pyproject.toml
+-rw-rw-r--  2.0 unx      197 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx    20251 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/README.md
+-rw-rw-r--  2.0 unx     8568 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2486 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/setup.py
+-rw-rw-r--  2.0 unx      287 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/TROUBLESHOOTING.md
+-rw-rw-r--  2.0 unx     1073 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/LICENSE
+-rw-rw-r--  2.0 unx     2928 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/settings_operations.py
+-rw-rw-r--  2.0 unx     3359 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations_async.py
+-rw-rw-r--  2.0 unx     4567 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/access_control_operations_async.py
+-rw-rw-r--  2.0 unx     3139 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/settings_operations_async.py
+-rw-rw-r--  2.0 unx     3269 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations.py
+-rw-rw-r--  2.0 unx     6690 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/samples/access_control_operations.py
+-rw-rw-r--  2.0 unx        1 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    29754 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx     8417 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx       84 b- defN 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/requires.txt
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/tests/_shared/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/
+-rw-rw-r--  2.0 unx     6483 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_access_control.py
+-rw-rw-r--  2.0 unx     4815 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_async_test_case.py
+-rw-rw-r--  2.0 unx     6523 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_access_control_async.py
+-rw-rw-r--  2.0 unx     4898 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_test_case.py
+-rw-rw-r--  2.0 unx     2126 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_settings_client.py
+-rw-rw-r--  2.0 unx     3225 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/conftest.py
+-rw-rw-r--  2.0 unx     3539 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_examples_administration_async.py
+-rw-rw-r--  2.0 unx     3290 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_examples_administration.py
+-rw-rw-r--  2.0 unx     7327 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_backup_client_async.py
+-rw-rw-r--  2.0 unx     7980 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_backup_client.py
+-rw-rw-r--  2.0 unx     2360 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/test_settings_client_async.py
+-rw-rw-r--  2.0 unx     3935 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/helpers.py
+-rw-rw-r--  2.0 unx      578 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/json_attribute_matcher.py
+-rw-rw-r--  2.0 unx     1407 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/helpers_async.py
+-rw-rw-r--  2.0 unx     1094 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/preparer.py
+-rw-rw-r--  2.0 unx     2244 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/test_case_async.py
+-rw-rw-r--  2.0 unx     1614 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/test_case.py
+-rw-rw-r--  2.0 unx      656 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/preparer_async.py
+-rw-rw-r--  2.0 unx      151 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/_shared/__init__.py
+-rw-rw-r--  2.0 unx     2313 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/get_role_definition.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/
+-rw-rw-r--  2.0 unx      232 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/
+-rw-rw-r--  2.0 unx      232 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/
+-rw-rw-r--  2.0 unx      172 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_version.py
+-rw-rw-r--  2.0 unx    11209 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_access_control_client.py
+-rw-rw-r--  2.0 unx     8907 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_models.py
+-rw-rw-r--  2.0 unx     4728 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_enums.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/py.typed
+-rw-rw-r--  2.0 unx      233 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_sdk_moniker.py
+-rw-rw-r--  2.0 unx     3856 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_settings_client.py
+-rw-rw-r--  2.0 unx    40505 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated_models.py
+-rw-rw-r--  2.0 unx     1067 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/__init__.py
+-rw-rw-r--  2.0 unx     8496 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_backup_client.py
+-rw-rw-r--  2.0 unx     4939 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge.py
+-rw-rw-r--  2.0 unx     2113 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/exceptions.py
+-rw-rw-r--  2.0 unx     1418 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/polling.py
+-rw-rw-r--  2.0 unx     6078 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py
+-rw-rw-r--  2.0 unx      442 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_polling.py
+-rw-rw-r--  2.0 unx     5045 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_client_base.py
+-rw-rw-r--  2.0 unx     2579 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py
+-rw-rw-r--  2.0 unx     5307 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py
+-rw-rw-r--  2.0 unx     2934 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/__init__.py
+-rw-rw-r--  2.0 unx     6181 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/client_base.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/
+-rw-rw-r--  2.0 unx    19024 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_operations_mixin.py
+-rw-rw-r--  2.0 unx     1993 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_configuration.py
+-rw-rw-r--  2.0 unx      344 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_version.py
+-rw-rw-r--  2.0 unx     6512 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_key_vault_client.py
+-rw-rw-r--  2.0 unx      353 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/models.py
+-rw-rw-r--  2.0 unx    78842 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_serialization.py
+-rw-rw-r--  2.0 unx      698 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py
+-rw-rw-r--  2.0 unx     3914 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py
+-rw-rw-r--  2.0 unx    48367 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py
+-rw-rw-r--  2.0 unx    23823 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py
+-rw-rw-r--  2.0 unx    24074 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py
+-rw-rw-r--  2.0 unx     4842 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    32637 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2573 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py
+-rw-rw-r--  2.0 unx     4027 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py
+-rw-rw-r--  2.0 unx    44235 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    19436 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    19687 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py
+-rw-rw-r--  2.0 unx     3914 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py
+-rw-rw-r--  2.0 unx    48367 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py
+-rw-rw-r--  2.0 unx    23823 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py
+-rw-rw-r--  2.0 unx    24074 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py
+-rw-rw-r--  2.0 unx     5234 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    32309 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2573 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py
+-rw-rw-r--  2.0 unx     4027 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py
+-rw-rw-r--  2.0 unx    44235 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    19436 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    19687 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx    19301 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py
+-rw-rw-r--  2.0 unx     2020 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_configuration.py
+-rw-rw-r--  2.0 unx     6632 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      543 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/
+-rw-rw-r--  2.0 unx     2511 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_patch.py
+-rw-rw-r--  2.0 unx     3914 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/__init__.py
+-rw-rw-r--  2.0 unx     1808 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_vendor.py
+-rw-rw-r--  2.0 unx    62419 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_patch.py
+-rw-rw-r--  2.0 unx    23823 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/__init__.py
+-rw-rw-r--  2.0 unx    24074 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_patch.py
+-rw-rw-r--  2.0 unx     5373 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_key_vault_client_enums.py
+-rw-rw-r--  2.0 unx    34934 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2841 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-May-16 23:25 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/
+-rw-rw-r--  2.0 unx     2521 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_patch.py
+-rw-rw-r--  2.0 unx     4027 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_key_vault_client.py
+-rw-rw-r--  2.0 unx      829 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/__init__.py
+-rw-rw-r--  2.0 unx     1043 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_vendor.py
+-rw-rw-r--  2.0 unx    55641 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_key_vault_client_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    19436 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     1018 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    19687 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx    11461 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_access_control_client.py
+-rw-rw-r--  2.0 unx     4355 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_settings_client.py
+-rw-rw-r--  2.0 unx      410 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/__init__.py
+-rw-rw-r--  2.0 unx     8536 b- defN 23-May-16 23:24 azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_backup_client.py
+179 files, 1225514 bytes uncompressed, 222249 bytes compressed:  81.9%
```

## zipnote {}

```diff
@@ -1,529 +1,538 @@
-Filename: azure-keyvault-administration-4.3.0b1/
+Filename: azure-keyvault-administration-4.4.0b1/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/
+Filename: azure-keyvault-administration-4.4.0b1/samples/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/samples/
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/
+Filename: azure-keyvault-administration-4.4.0b1/tests/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/
+Filename: azure-keyvault-administration-4.4.0b1/azure/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/PKG-INFO
+Filename: azure-keyvault-administration-4.4.0b1/setup.cfg
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/README.md
+Filename: azure-keyvault-administration-4.4.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/LICENSE
+Filename: azure-keyvault-administration-4.4.0b1/pyproject.toml
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/MANIFEST.in
+Filename: azure-keyvault-administration-4.4.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/CHANGELOG.md
+Filename: azure-keyvault-administration-4.4.0b1/README.md
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/setup.py
+Filename: azure-keyvault-administration-4.4.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/TROUBLESHOOTING.md
+Filename: azure-keyvault-administration-4.4.0b1/setup.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/setup.cfg
+Filename: azure-keyvault-administration-4.4.0b1/TROUBLESHOOTING.md
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/
+Filename: azure-keyvault-administration-4.4.0b1/LICENSE
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/samples/settings_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/
+Filename: azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/samples/access_control_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/
+Filename: azure-keyvault-administration-4.4.0b1/samples/settings_operations_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/
+Filename: azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/
+Filename: azure-keyvault-administration-4.4.0b1/samples/access_control_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_enums.py
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_settings_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_sdk_moniker.py
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/py.typed
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_models.py
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_backup_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/requires.txt
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated_models.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_access_control_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_access_control.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_version.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_async_test_case.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_settings_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_access_control_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_backup_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_test_case.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_settings_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_access_control_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/conftest.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_examples_administration_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_examples_administration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_backup_client_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_backup_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/test_settings_client_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/models.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/helpers.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/json_attribute_matcher.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/helpers_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_serialization.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/preparer.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_operations_mixin.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/test_case_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_version.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/test_case.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/preparer_async.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/_shared/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/get_role_definition.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py
+Filename: azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/
+Filename: azure-keyvault-administration-4.4.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_version.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_access_control_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_models.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_enums.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/py.typed
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_sdk_moniker.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_settings_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated_models.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_backup_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/exceptions.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/polling.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_polling.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_client_base.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/client_base.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_operations_mixin.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_version.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/models.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_serialization.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_models_py3.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/polling.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/client_base.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_client_base.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/exceptions.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_polling.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/samples/access_control_operations_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/samples/access_control_operations.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/PKG-INFO
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/top_level.txt
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/requires.txt
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/SOURCES.txt
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/not-zip-safe
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/dependency_links.txt
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_examples_administration_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_examples_administration.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_backup_client_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_access_control.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/conftest.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_settings_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_access_control_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_key_vault_client_enums.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_backup_client.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_models_py3.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_async_test_case.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/test_settings_client_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_test_case.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_configuration.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/test_case.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/test_case_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_key_vault_client.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/preparer.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/preparer_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_vendor.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_key_vault_client_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/json_attribute_matcher.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/helpers.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/_shared/helpers_async.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/get_role_definition.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/__init__.py
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_access_control_client.py
+Comment: 
+
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_settings_client.py
+Comment: 
+
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/__init__.py
+Comment: 
+
+Filename: azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_backup_client.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-keyvault-administration-4.3.0b1/PKG-INFO` & `azure-keyvault-administration-4.4.0b1/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-keyvault-administration
-Version: 4.3.0b1
+Version: 4.4.0b1
 Summary: Microsoft Azure Key Vault Administration Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration
 Author: Microsoft Corporation
 Author-email: azurekeyvault@microsoft.com
 License: MIT License
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
@@ -32,15 +32,20 @@
 ([azure-keyvault-secrets](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-secrets)) -
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_administration] | [API reference documentation][reference_docs] | [Product documentation][keyvault_docs] | [Samples][administration_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_administration]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][keyvault_docs]
+| [Samples][administration_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691._
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
@@ -61,44 +66,66 @@
 ### Authenticate the client
 In order to interact with the Azure Key Vault service, you will need an instance of either a [KeyVaultAccessControlClient](#create-a-keyvaultaccesscontrolclient) or [KeyVaultBackupClient](#create-a-keyvaultbackupclient), as well as a **vault url** (which you may see as "DNS Name" in the Azure Portal) and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
 
 See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
 
 #### Create a KeyVaultAccessControlClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create an access control client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:access_control_operations.create_an_access_control_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultAccessControlClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultAccessControlClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultAccessControlClient` instead.
 
 #### Create a KeyVaultBackupClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a backup client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:backup_restore_operations.create_a_backup_restore_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultBackupClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultBackupClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultBackupClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultBackupClient` instead.
 
+#### Create a KeyVaultSettingsClient
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a settings client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:settings_operations.create_a_settings_client -->
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.keyvault.administration import KeyVaultSettingsClient
+
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
+credential = DefaultAzureCredential()
+client = KeyVaultSettingsClient(vault_url=MANAGED_HSM_URL, credential=credential)
+```
+
+<!-- END SNIPPET -->
+
+> **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultSettingsClient` instead.
+
 ## Key concepts
 
 ### Role definition
 A role definition defines the operations that can be performed, such as read, write, and delete. It can also define the operations that are excluded from allowed operations.
 
 A role definition is specified as part of a role assignment.
 
@@ -107,200 +134,208 @@
 
 ### KeyVaultAccessControlClient
 A `KeyVaultAccessControlClient` manages role definitions and role assignments.
 
 ### KeyVaultBackupClient
 A `KeyVaultBackupClient` performs full key backups, full key restores, and selective key restores.
 
+### KeyVaultSettingsClient
+
+A `KeyVaultSettingsClient` manages Managed HSM account settings.
+
 ## Examples
 This section contains code snippets covering common tasks:
 * Access control
     * [List all role definitions](#list-all-role-definitions)
     * [Set, get, and delete a role definition](#set-get-and-delete-a-role-defintion)
     * [List all role assignments](#list-all-role-assignments)
     * [Create, get, and delete a role assignment](#create-get-and-delete-a-role-assignment)
 * Backup and restore
     * [Perform a full key backup](#perform-a-full-key-backup)
     * [Perform a full key restore](#perform-a-full-key-restore)
+    * [Perform a selective key restore](#perform-a-selective-key-restore)
 
 ### List all role definitions
-List the role definitions available for assignment.
+`list_role_definitions` can be used by a `KeyVaultAccessControlClient` to list the role definitions available for
+assignment.
 
-```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
-
-credential = DefaultAzureCredential()
-
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- SNIPPET:access_control_operations.list_role_definitions -->
 
-# this will list all role definitions available for assignment
-role_definitions = client.list_role_definitions(KeyVaultRoleScope.GLOBAL)
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
 
+role_definitions = client.list_role_definitions(scope=KeyVaultRoleScope.GLOBAL)
 for definition in role_definitions:
-    print(definition.id)
-    print(definition.role_name)
-    print(definition.description)
+    print(f"Role name: {definition.role_name}; Role definition name: {definition.name}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Set, get, and delete a role definition
 
-`set_role_definition` can be used to either create a custom role definition or update an existing definition with the specified name.
+`set_role_definition` can be used by a `KeyVaultAccessControlClient` to either create a custom role definition or update
+an existing definition with the specified unique `name` (a UUID).
+
+<!-- SNIPPET:access_control_operations.create_a_role_definition -->
 
 ```python
-import uuid
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import (
-    KeyVaultAccessControlClient,
-    KeyVaultDataAction,
-    KeyVaultPermission,
-    KeyVaultRoleScope
-)
+from azure.keyvault.administration import KeyVaultDataAction, KeyVaultPermission, KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+role_name = "customRole"
+scope = KeyVaultRoleScope.GLOBAL
+permissions = [KeyVaultPermission(data_actions=[KeyVaultDataAction.CREATE_HSM_KEY])]
+role_definition = client.set_role_definition(scope=scope, role_name=role_name, permissions=permissions)
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
 
-# create a custom role definition
-permissions = [KeyVaultPermission(allowed_data_actions=[KeyVaultDataAction.READ_HSM_KEY])]
-created_definition = client.set_role_definition(KeyVaultRoleScope.GLOBAL, permissions=permissions)
-
-# update the custom role definition
-permissions = [
-    KeyVaultPermission(allowed_data_actions=[], denied_data_actions=[KeyVaultDataAction.READ_HSM_KEY])
+<!-- SNIPPET:access_control_operations.update_a_role_definition -->
+
+```python
+new_permissions = [
+    KeyVaultPermission(
+        data_actions=[KeyVaultDataAction.READ_HSM_KEY],
+        not_data_actions=[KeyVaultDataAction.CREATE_HSM_KEY]
+    )
 ]
+unique_definition_name = role_definition.name
 updated_definition = client.set_role_definition(
-    KeyVaultRoleScope.GLOBAL, permissions=permissions, role_name=created_definition.name
+    scope=scope, name=unique_definition_name, role_name=role_name, permissions=new_permissions
 )
+```
+
+<!-- END SNIPPET -->
+
+`get_role_definition` can be used by a `KeyVaultAccessControlClient` to fetch a role definition with the specified scope
+and unique name.
 
-# get the custom role definition
-definition = client.get_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+<!-- SNIPPET:access_control_operations.get_a_role_definition -->
 
-# delete the custom role definition
-deleted_definition = client.delete_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+```python
+fetched_definition = client.get_role_definition(scope=scope, name=unique_definition_name)
 ```
 
-### List all role assignments
-Before creating a new role assignment in the [next snippet](#create-get-and-delete-a-role-assignment), list all of the current role assignments:
+<!-- END SNIPPET -->
+
+`delete_role_definition` can be used by a `KeyVaultAccessControlClient` to delete a role definition with the specified
+scope and unique name.
+
+<!-- SNIPPET:access_control_operations.delete_a_role_definition -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+client.delete_role_definition(scope=scope, name=unique_definition_name)
+```
 
-credential = DefaultAzureCredential()
+<!-- END SNIPPET -->
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+### List all role assignments
+`list_role_assignments` can be used by a `KeyVaultAccessControlClient` to list all of the current role assignments.
 
-# this will list all role assignments
-role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
+<!-- SNIPPET:access_control_operations.list_role_assignments -->
 
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
+
+role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
 for assignment in role_assignments:
-    print(assignment.name)
-    print(assignment.principal_id)
-    print(assignment.role_definition_id)
+    print(f"Role assignment name: {assignment.name}")
+    print(f"Principal ID associated with this assignment: {assignment.properties.principal_id}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Create, get, and delete a role assignment
-Assign a role to a service principal. This will require a role definition ID and service principal object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former, and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the latter.
+Role assignments assign a role to a service principal. This will require a role definition ID and service principal
+object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former,
+and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the
+latter. Provide these values, and a scope, to a `KeyVaultAccessControlClient`'s `create_role_assignment` method.
+
+<!-- SNIPPET:access_control_operations.create_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+from azure.keyvault.administration import KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+scope = KeyVaultRoleScope.GLOBAL
+role_assignment = client.create_role_assignment(scope=scope, definition_id=definition_id, principal_id=principal_id)
+print(f"Role assignment {role_assignment.name} created successfully.")
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
 
-# Replace <role-definition-id> with the id of a definition from the fetched list from an earlier example
-role_definition_id = "<role-definition-id>"
-# Replace <service-principal-object-id> with the principal_id of an assignment returned from the previous example
-principal_id = "<service-principal-object-id>"
-
-# first, let's create the role assignment
-role_assignment = client.create_role_assignment(KeyVaultRoleScope.GLOBAL, role_definition_id, principal_id)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# now, we get it
-role_assignment = client.get_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# finally, we delete this role assignment
-role_assignment = client.delete_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
+`get_role_assignment` can be used by a `KeyVaultAccessControlClient` to fetch an existing role assignment with the
+specified scope and unique name.
+
+<!-- SNIPPET:access_control_operations.get_a_role_assignment -->
+
+```python
+fetched_assignment = client.get_role_assignment(scope=scope, name=role_assignment.name)
+print(f"Role assignment for principal {fetched_assignment.properties.principal_id} fetched successfully.")
 ```
 
-### Perform a full key backup
-Back up your entire collection of keys. The backing store for full key backups is a blob storage container using Shared Access Signature authentication.
+<!-- END SNIPPET -->
+
+`delete_role_assignment` can be used by a `KeyVaultAccessControlClient` to delete a role assignment with the specified
+scope and unique name.
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+<!-- SNIPPET:access_control_operations.delete_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.delete_role_assignment(scope=scope, name=role_assignment.name)
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
+
+### Perform a full key backup
+The `KeyVaultBackupClient` can be used to back up your entire collection of keys. The backing store for full key
+backups is a blob storage container using Shared Access Signature (SAS) authentication.
 
-# blob storage container URL, for example https://<account name>.blob.core.windows.net/backup
-blob_storage_url = "<your-blob-storage-url>"
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
-
-# Backup is a long-running operation. The client returns a poller object whose result() method
-# blocks until the backup is complete, then returns an object representing the backup operation.
-backup_poller = client.begin_backup(blob_storage_url, sas_token)
-backup_operation = backup_poller.result()
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-# this is the Azure Storage Blob URL of the backup
-print(backup_operation.folder_url)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
+
+```python
+CONTAINER_URL = os.environ["CONTAINER_URL"]
+SAS_TOKEN = os.environ["SAS_TOKEN"]
+
+backup_result = client.begin_backup(CONTAINER_URL, SAS_TOKEN).result()
+print(f"Azure Storage Blob URL of the backup: {backup_result.folder_url}")
 ```
 
+<!-- END SNIPPET -->
+
+Note that the `begin_backup` method returns a poller. Calling `result()` on this poller returns a
+`KeyVaultBackupResult` containing information about the backup. Calling `wait()` on the poller will instead block until
+the operation is complete without returning an object.
 
 ### Perform a full key restore
-Restore your entire collection of keys from a backup. The data source for a full key restore is a storage blob accessed using Shared Access Signature authentication.
-You will also need the `azure_storage_blob_container_uri` from the [above snippet](#perform-a-full-key-backup).
+The `KeyVaultBackupClient` can be used to restore your entire collection of keys from a backup. The data source for a
+full key restore is a storage blob accessed using Shared Access Signature authentication. You will also need the URL of
+the backup (`KeyVaultBackupResult.folder_url`) from the [above snippet](#perform-a-full-key-backup).
+
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.begin_restore(backup_result.folder_url, SAS_TOKEN).wait()
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
 
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
+Note that the `begin_restore` method returns a poller. Unlike the poller returned by `begin_backup`, this poller's
+`result` method returns `None`; therefore, calling `wait()` is functionally the same.
 
-# URL to a storage blob, for example https://<account name>.blob.core.windows.net/backup/mhsm-account-2020090117323313
-blob_url = "<your-blob-url>"
+### Perform a selective key restore
 
-# Restore is a long-running operation. The client returns a poller object whose wait() method
-# blocks until the restore is complete.
-restore_poller = client.begin_restore(blob_url, sas_token)
-restore_poller.wait()
-```
+To restore a single key from a backed up vault instead of all keys, provide the key name as a `key_name` argument to the
+`begin_restore` method [shown above](#perform-a-full-key-restore).
 
 ## Troubleshooting
 
 See the `azure-keyvault-administration`
 [troubleshooting guide](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/TROUBLESHOOTING.md)
 for details on how to diagnose various failure scenarios.
 
@@ -329,14 +364,16 @@
 Several samples are available in the Azure SDK for Python GitHub repository. These samples provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [access_control_operations.py][access_control_operations_sample] | create/update/delete role definitions and role assignments |
 | [access_control_operations_async.py][access_control_operations_async_sample] | create/update/delete role definitions and role assignments with an async client |
 | [backup_restore_operations.py][backup_operations_sample] | full backup and restore |
 | [backup_restore_operations_async.py][backup_operations_async_sample] | full backup and restore with an async client |
+| [settings_operations.py][settings_operations_sample] | list and update Key Vault settings |
+| [settings_operations_async.py][settings_operations_async_sample] | list and update Key Vault settings with an async client |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the [API reference documentation][reference_docs].
 
 For more extensive documentation on Managed HSM, see the [service documentation][managed_hsm].
 
 ## Contributing
@@ -385,20 +422,58 @@
 [managed_identity]: https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview
 
 [pip]: https://pypi.org/project/pip/
 [pypi_package_administration]: https://pypi.org/project/azure-keyvault-administration
 
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-administration/docs
 
+[sas_docs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-blob/README.md#types-of-credentials
+[settings_operations_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations.py
+[settings_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations_async.py
+[storage_blob]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/README.md
+[storage_explorer]: https://learn.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer
+
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-administration%2FREADME.png)
 
 
 # Release History
 
+## 4.4.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.3.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.3.0b1) Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings
+- The `KeyVaultSetting` class has a `getboolean` method that will return the setting's `value` as a `bool`, if possible,
+  and raise a `ValueError` otherwise
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.2.0. Only code written against a beta version such as 4.3.0b1 may be affected.
+- `KeyVaultSettingsClient.update_setting` now accepts a single `setting` argument (a `KeyVaultSetting` instance)
+  instead of a `name` and `value`
+- The `KeyVaultSetting` model's `type` parameter and attribute have been renamed to `setting_type`
+- The `SettingType` enum has been renamed to `KeyVaultSettingType`
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.3.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.3.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.3.0b1) Dropped `msrest` requirement
+- (From 4.3.0b1) Dropped `six` requirement
+- (From 4.3.0b1) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.3.0b1) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.3.0b1 (2022-11-15)
 
 ### Features Added
 - Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings.
 - Added support for service API version `7.4-preview.1`
 
 ### Other Changes
```

## Comparing `azure-keyvault-administration-4.3.0b1/README.md` & `azure-keyvault-administration-4.4.0b1/README.md`

 * *Files 14% similar despite different names*

```diff
@@ -10,15 +10,20 @@
 ([azure-keyvault-secrets](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-secrets)) -
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_administration] | [API reference documentation][reference_docs] | [Product documentation][keyvault_docs] | [Samples][administration_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_administration]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][keyvault_docs]
+| [Samples][administration_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691._
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
@@ -39,44 +44,66 @@
 ### Authenticate the client
 In order to interact with the Azure Key Vault service, you will need an instance of either a [KeyVaultAccessControlClient](#create-a-keyvaultaccesscontrolclient) or [KeyVaultBackupClient](#create-a-keyvaultbackupclient), as well as a **vault url** (which you may see as "DNS Name" in the Azure Portal) and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
 
 See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
 
 #### Create a KeyVaultAccessControlClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create an access control client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:access_control_operations.create_an_access_control_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultAccessControlClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultAccessControlClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultAccessControlClient` instead.
 
 #### Create a KeyVaultBackupClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a backup client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:backup_restore_operations.create_a_backup_restore_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultBackupClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultBackupClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultBackupClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultBackupClient` instead.
 
+#### Create a KeyVaultSettingsClient
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a settings client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:settings_operations.create_a_settings_client -->
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.keyvault.administration import KeyVaultSettingsClient
+
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
+credential = DefaultAzureCredential()
+client = KeyVaultSettingsClient(vault_url=MANAGED_HSM_URL, credential=credential)
+```
+
+<!-- END SNIPPET -->
+
+> **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultSettingsClient` instead.
+
 ## Key concepts
 
 ### Role definition
 A role definition defines the operations that can be performed, such as read, write, and delete. It can also define the operations that are excluded from allowed operations.
 
 A role definition is specified as part of a role assignment.
 
@@ -85,200 +112,208 @@
 
 ### KeyVaultAccessControlClient
 A `KeyVaultAccessControlClient` manages role definitions and role assignments.
 
 ### KeyVaultBackupClient
 A `KeyVaultBackupClient` performs full key backups, full key restores, and selective key restores.
 
+### KeyVaultSettingsClient
+
+A `KeyVaultSettingsClient` manages Managed HSM account settings.
+
 ## Examples
 This section contains code snippets covering common tasks:
 * Access control
     * [List all role definitions](#list-all-role-definitions)
     * [Set, get, and delete a role definition](#set-get-and-delete-a-role-defintion)
     * [List all role assignments](#list-all-role-assignments)
     * [Create, get, and delete a role assignment](#create-get-and-delete-a-role-assignment)
 * Backup and restore
     * [Perform a full key backup](#perform-a-full-key-backup)
     * [Perform a full key restore](#perform-a-full-key-restore)
+    * [Perform a selective key restore](#perform-a-selective-key-restore)
 
 ### List all role definitions
-List the role definitions available for assignment.
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
-
-credential = DefaultAzureCredential()
+`list_role_definitions` can be used by a `KeyVaultAccessControlClient` to list the role definitions available for
+assignment.
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- SNIPPET:access_control_operations.list_role_definitions -->
 
-# this will list all role definitions available for assignment
-role_definitions = client.list_role_definitions(KeyVaultRoleScope.GLOBAL)
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
 
+role_definitions = client.list_role_definitions(scope=KeyVaultRoleScope.GLOBAL)
 for definition in role_definitions:
-    print(definition.id)
-    print(definition.role_name)
-    print(definition.description)
+    print(f"Role name: {definition.role_name}; Role definition name: {definition.name}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Set, get, and delete a role definition
 
-`set_role_definition` can be used to either create a custom role definition or update an existing definition with the specified name.
+`set_role_definition` can be used by a `KeyVaultAccessControlClient` to either create a custom role definition or update
+an existing definition with the specified unique `name` (a UUID).
+
+<!-- SNIPPET:access_control_operations.create_a_role_definition -->
 
 ```python
-import uuid
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import (
-    KeyVaultAccessControlClient,
-    KeyVaultDataAction,
-    KeyVaultPermission,
-    KeyVaultRoleScope
-)
+from azure.keyvault.administration import KeyVaultDataAction, KeyVaultPermission, KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+role_name = "customRole"
+scope = KeyVaultRoleScope.GLOBAL
+permissions = [KeyVaultPermission(data_actions=[KeyVaultDataAction.CREATE_HSM_KEY])]
+role_definition = client.set_role_definition(scope=scope, role_name=role_name, permissions=permissions)
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
 
-# create a custom role definition
-permissions = [KeyVaultPermission(allowed_data_actions=[KeyVaultDataAction.READ_HSM_KEY])]
-created_definition = client.set_role_definition(KeyVaultRoleScope.GLOBAL, permissions=permissions)
-
-# update the custom role definition
-permissions = [
-    KeyVaultPermission(allowed_data_actions=[], denied_data_actions=[KeyVaultDataAction.READ_HSM_KEY])
+<!-- SNIPPET:access_control_operations.update_a_role_definition -->
+
+```python
+new_permissions = [
+    KeyVaultPermission(
+        data_actions=[KeyVaultDataAction.READ_HSM_KEY],
+        not_data_actions=[KeyVaultDataAction.CREATE_HSM_KEY]
+    )
 ]
+unique_definition_name = role_definition.name
 updated_definition = client.set_role_definition(
-    KeyVaultRoleScope.GLOBAL, permissions=permissions, role_name=created_definition.name
+    scope=scope, name=unique_definition_name, role_name=role_name, permissions=new_permissions
 )
+```
+
+<!-- END SNIPPET -->
+
+`get_role_definition` can be used by a `KeyVaultAccessControlClient` to fetch a role definition with the specified scope
+and unique name.
 
-# get the custom role definition
-definition = client.get_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+<!-- SNIPPET:access_control_operations.get_a_role_definition -->
 
-# delete the custom role definition
-deleted_definition = client.delete_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+```python
+fetched_definition = client.get_role_definition(scope=scope, name=unique_definition_name)
 ```
 
-### List all role assignments
-Before creating a new role assignment in the [next snippet](#create-get-and-delete-a-role-assignment), list all of the current role assignments:
+<!-- END SNIPPET -->
+
+`delete_role_definition` can be used by a `KeyVaultAccessControlClient` to delete a role definition with the specified
+scope and unique name.
+
+<!-- SNIPPET:access_control_operations.delete_a_role_definition -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+client.delete_role_definition(scope=scope, name=unique_definition_name)
+```
 
-credential = DefaultAzureCredential()
+<!-- END SNIPPET -->
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+### List all role assignments
+`list_role_assignments` can be used by a `KeyVaultAccessControlClient` to list all of the current role assignments.
 
-# this will list all role assignments
-role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
+<!-- SNIPPET:access_control_operations.list_role_assignments -->
 
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
+
+role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
 for assignment in role_assignments:
-    print(assignment.name)
-    print(assignment.principal_id)
-    print(assignment.role_definition_id)
+    print(f"Role assignment name: {assignment.name}")
+    print(f"Principal ID associated with this assignment: {assignment.properties.principal_id}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Create, get, and delete a role assignment
-Assign a role to a service principal. This will require a role definition ID and service principal object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former, and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the latter.
+Role assignments assign a role to a service principal. This will require a role definition ID and service principal
+object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former,
+and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the
+latter. Provide these values, and a scope, to a `KeyVaultAccessControlClient`'s `create_role_assignment` method.
+
+<!-- SNIPPET:access_control_operations.create_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+from azure.keyvault.administration import KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+scope = KeyVaultRoleScope.GLOBAL
+role_assignment = client.create_role_assignment(scope=scope, definition_id=definition_id, principal_id=principal_id)
+print(f"Role assignment {role_assignment.name} created successfully.")
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
+
+`get_role_assignment` can be used by a `KeyVaultAccessControlClient` to fetch an existing role assignment with the
+specified scope and unique name.
 
-# Replace <role-definition-id> with the id of a definition from the fetched list from an earlier example
-role_definition_id = "<role-definition-id>"
-# Replace <service-principal-object-id> with the principal_id of an assignment returned from the previous example
-principal_id = "<service-principal-object-id>"
-
-# first, let's create the role assignment
-role_assignment = client.create_role_assignment(KeyVaultRoleScope.GLOBAL, role_definition_id, principal_id)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# now, we get it
-role_assignment = client.get_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# finally, we delete this role assignment
-role_assignment = client.delete_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
+<!-- SNIPPET:access_control_operations.get_a_role_assignment -->
+
+```python
+fetched_assignment = client.get_role_assignment(scope=scope, name=role_assignment.name)
+print(f"Role assignment for principal {fetched_assignment.properties.principal_id} fetched successfully.")
 ```
 
-### Perform a full key backup
-Back up your entire collection of keys. The backing store for full key backups is a blob storage container using Shared Access Signature authentication.
+<!-- END SNIPPET -->
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+`delete_role_assignment` can be used by a `KeyVaultAccessControlClient` to delete a role assignment with the specified
+scope and unique name.
+
+<!-- SNIPPET:access_control_operations.delete_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.delete_role_assignment(scope=scope, name=role_assignment.name)
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
+
+### Perform a full key backup
+The `KeyVaultBackupClient` can be used to back up your entire collection of keys. The backing store for full key
+backups is a blob storage container using Shared Access Signature (SAS) authentication.
 
-# blob storage container URL, for example https://<account name>.blob.core.windows.net/backup
-blob_storage_url = "<your-blob-storage-url>"
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
-
-# Backup is a long-running operation. The client returns a poller object whose result() method
-# blocks until the backup is complete, then returns an object representing the backup operation.
-backup_poller = client.begin_backup(blob_storage_url, sas_token)
-backup_operation = backup_poller.result()
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-# this is the Azure Storage Blob URL of the backup
-print(backup_operation.folder_url)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
+
+```python
+CONTAINER_URL = os.environ["CONTAINER_URL"]
+SAS_TOKEN = os.environ["SAS_TOKEN"]
+
+backup_result = client.begin_backup(CONTAINER_URL, SAS_TOKEN).result()
+print(f"Azure Storage Blob URL of the backup: {backup_result.folder_url}")
 ```
 
+<!-- END SNIPPET -->
+
+Note that the `begin_backup` method returns a poller. Calling `result()` on this poller returns a
+`KeyVaultBackupResult` containing information about the backup. Calling `wait()` on the poller will instead block until
+the operation is complete without returning an object.
 
 ### Perform a full key restore
-Restore your entire collection of keys from a backup. The data source for a full key restore is a storage blob accessed using Shared Access Signature authentication.
-You will also need the `azure_storage_blob_container_uri` from the [above snippet](#perform-a-full-key-backup).
+The `KeyVaultBackupClient` can be used to restore your entire collection of keys from a backup. The data source for a
+full key restore is a storage blob accessed using Shared Access Signature authentication. You will also need the URL of
+the backup (`KeyVaultBackupResult.folder_url`) from the [above snippet](#perform-a-full-key-backup).
+
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.begin_restore(backup_result.folder_url, SAS_TOKEN).wait()
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
 
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
+Note that the `begin_restore` method returns a poller. Unlike the poller returned by `begin_backup`, this poller's
+`result` method returns `None`; therefore, calling `wait()` is functionally the same.
 
-# URL to a storage blob, for example https://<account name>.blob.core.windows.net/backup/mhsm-account-2020090117323313
-blob_url = "<your-blob-url>"
+### Perform a selective key restore
 
-# Restore is a long-running operation. The client returns a poller object whose wait() method
-# blocks until the restore is complete.
-restore_poller = client.begin_restore(blob_url, sas_token)
-restore_poller.wait()
-```
+To restore a single key from a backed up vault instead of all keys, provide the key name as a `key_name` argument to the
+`begin_restore` method [shown above](#perform-a-full-key-restore).
 
 ## Troubleshooting
 
 See the `azure-keyvault-administration`
 [troubleshooting guide](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/TROUBLESHOOTING.md)
 for details on how to diagnose various failure scenarios.
 
@@ -307,14 +342,16 @@
 Several samples are available in the Azure SDK for Python GitHub repository. These samples provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [access_control_operations.py][access_control_operations_sample] | create/update/delete role definitions and role assignments |
 | [access_control_operations_async.py][access_control_operations_async_sample] | create/update/delete role definitions and role assignments with an async client |
 | [backup_restore_operations.py][backup_operations_sample] | full backup and restore |
 | [backup_restore_operations_async.py][backup_operations_async_sample] | full backup and restore with an async client |
+| [settings_operations.py][settings_operations_sample] | list and update Key Vault settings |
+| [settings_operations_async.py][settings_operations_async_sample] | list and update Key Vault settings with an async client |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the [API reference documentation][reference_docs].
 
 For more extensive documentation on Managed HSM, see the [service documentation][managed_hsm].
 
 ## Contributing
@@ -363,9 +400,15 @@
 [managed_identity]: https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview
 
 [pip]: https://pypi.org/project/pip/
 [pypi_package_administration]: https://pypi.org/project/azure-keyvault-administration
 
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-administration/docs
 
+[sas_docs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-blob/README.md#types-of-credentials
+[settings_operations_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations.py
+[settings_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations_async.py
+[storage_blob]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/README.md
+[storage_explorer]: https://learn.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer
+
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-administration%2FREADME.png)
```

## Comparing `azure-keyvault-administration-4.3.0b1/LICENSE` & `azure-keyvault-administration-4.4.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/CHANGELOG.md` & `azure-keyvault-administration-4.4.0b1/CHANGELOG.md`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,41 @@
 # Release History
 
+## 4.4.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.3.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.3.0b1) Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings
+- The `KeyVaultSetting` class has a `getboolean` method that will return the setting's `value` as a `bool`, if possible,
+  and raise a `ValueError` otherwise
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.2.0. Only code written against a beta version such as 4.3.0b1 may be affected.
+- `KeyVaultSettingsClient.update_setting` now accepts a single `setting` argument (a `KeyVaultSetting` instance)
+  instead of a `name` and `value`
+- The `KeyVaultSetting` model's `type` parameter and attribute have been renamed to `setting_type`
+- The `SettingType` enum has been renamed to `KeyVaultSettingType`
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.3.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.3.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.3.0b1) Dropped `msrest` requirement
+- (From 4.3.0b1) Dropped `six` requirement
+- (From 4.3.0b1) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.3.0b1) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.3.0b1 (2022-11-15)
 
 ### Features Added
 - Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings.
 - Added support for service API version `7.4-preview.1`
 
 ### Other Changes
```

## Comparing `azure-keyvault-administration-4.3.0b1/setup.py` & `azure-keyvault-administration-4.4.0b1/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 with open("CHANGELOG.md", encoding="utf-8") as f:
     CHANGELOG = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=VERSION,
     include_package_data=True,
-    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    description=f"Microsoft Azure {PACKAGE_PPRINT_NAME} Client Library for Python",
     long_description=README + "\n\n" + CHANGELOG,
     long_description_content_type="text/markdown",
     license="MIT License",
     author="Microsoft Corporation",
     author_email="azurekeyvault@microsoft.com",
     url="https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration",
     classifiers=[
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_enums.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_enums.py`

 * *Files 0% similar despite different names*

```diff
@@ -83,11 +83,11 @@
     READ_HSM_BACKUP_STATUS = "Microsoft.KeyVault/managedHsm/backup/status/action"
     #: Read an HSM restore status.
     READ_HSM_RESTORE_STATUS = "Microsoft.KeyVault/managedHsm/restore/status/action"
     #: Generate random numbers.
     RANDOM_NUMBERS_GENERATE = "Microsoft.KeyVault/managedHsm/rng/action"
 
 
-class SettingType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+class KeyVaultSettingType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type specifier of the setting value."""
 
     BOOLEAN = "boolean"
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_settings_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_settings_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 from azure.core.paging import ItemPaged
 from azure.core.tracing.decorator import distributed_trace
 
-from ._generated_models import UpdateSettingsRequest
+from ._generated_models import UpdateSettingRequest
 from ._internal import KeyVaultClientBase
 from ._models import KeyVaultSetting
 
+
 class KeyVaultSettingsClient(KeyVaultClientBase):
-    """Provides methods to update, get, and list settings for an Azure Key Vault.
+    """Provides methods to update, get, and list Managed HSM account settings.
 
     :param str vault_url: URL of the vault on which the client will operate. This is also called the vault's "DNS Name".
         You should validate that this URL references a valid Key Vault or Managed HSM resource.
         See https://aka.ms/azsdk/blog/vault-uri for details.
     :param credential: An object which can provide an access token for the vault, such as a credential from
         :mod:`azure.identity`
     :type credential: :class:`~azure.core.credentials.TokenCredential`
@@ -32,15 +33,15 @@
 
         :param str name: The name of the account setting.
 
         :returns: The account setting, as a :class:`~azure.keyvault.administration.KeyVaultSetting`.
         :rtype: ~azure.keyvault.administration.KeyVaultSetting
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
-        result = self._client.get_setting_value(vault_base_url=self._vault_url, setting_name=name, **kwargs)
+        result = self._client.get_setting(vault_base_url=self._vault_url, setting_name=name, **kwargs)
         return KeyVaultSetting._from_generated(result)
 
     @distributed_trace
     def list_settings(self, **kwargs) -> ItemPaged[KeyVaultSetting]:
         """Lists all account settings.
 
         :returns: A paged object containing the account's settings.
@@ -56,25 +57,26 @@
 
         def extract_data(_):
             return None, converted_result
 
         return ItemPaged(get_next, extract_data)
 
     @distributed_trace
-    def update_setting(self, name: str, value: str, **kwargs) -> KeyVaultSetting:
-        """Updates a given account setting with the provided value.
+    def update_setting(self, setting: KeyVaultSetting, **kwargs) -> KeyVaultSetting:
+        """Updates the named account setting with the provided value.
 
-        :param str name: The name of the account setting to update.
-        :param str value: The value to set.
+        :param setting: A :class:`~azure.keyvault.administration.KeyVaultSetting` to update. The account setting with
+            the provided name will be updated to have the provided value.
+        :type setting: ~azure.keyvault.administration.KeyVaultSetting
 
         :returns: The updated account setting, as a :class:`~azure.keyvault.administration.KeyVaultSetting`.
         :rtype: ~azure.keyvault.administration.KeyVaultSetting
         :raises: :class:`~azure.core.exceptions.HttpResponseError`
         """
-        parameters = UpdateSettingsRequest(value=value)
-        result = self._client.update_settings(
+        parameters = UpdateSettingRequest(value=setting.value)
+        result = self._client.update_setting(
             vault_base_url=self._vault_url,
-            setting_name=name,
+            setting_name=setting.name,
             parameters=parameters,
             **kwargs
         )
         return KeyVaultSetting._from_generated(result)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_backup_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_backup_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -38,22 +38,25 @@
     :keyword api_version: Version of the service API to use. Defaults to the most recent.
     :paramtype api_version: ~azure.keyvault.administration.ApiVersion
     :keyword bool verify_challenge_resource: Whether to verify the authentication challenge resource matches the Key
         Vault or Managed HSM domain. Defaults to True.
     """
 
     # pylint:disable=protected-access
-    def begin_backup(self, blob_storage_url, sas_token, **kwargs):
-        # type: (str, str, **Any) -> LROPoller[KeyVaultBackupResult]
+    def begin_backup(
+        self, blob_storage_url: str, sas_token: str, **kwargs
+    ) -> "LROPoller[KeyVaultBackupResult]":
         """Begin a full backup of the Key Vault.
 
         :param str blob_storage_url: URL of the blob storage container in which the backup will be stored, for example
             https://<account>.blob.core.windows.net/backup
         :param str sas_token: a Shared Access Signature (SAS) token authorizing access to the blob storage resource
+
         :keyword str continuation_token: a continuation token to restart polling from a saved state
+
         :returns: An :class:`~azure.core.polling.LROPoller` instance. Call `result()` on this object to wait for the
             operation to complete and get a :class:`KeyVaultBackupResult`.
         :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.administration.KeyVaultBackupResult]
 
         Example:
             .. literalinclude:: ../tests/test_examples_administration.py
                 :start-after: [START begin_backup]
@@ -91,26 +94,27 @@
             continuation_token=status_response,
             polling=KeyVaultBackupClientPollingMethod(
                 lro_algorithms=[KeyVaultBackupClientPolling()], timeout=polling_interval, **kwargs
             ),
             **kwargs
         )
 
-    def begin_restore(self, folder_url, sas_token, **kwargs):
-        # type: (str, str, **Any) -> LROPoller
+    def begin_restore(self, folder_url: str, sas_token: str, **kwargs) -> "LROPoller":
         """Restore a Key Vault backup.
 
         This method restores either a complete Key Vault backup or when ``key_name`` has a value, a single key.
 
         :param str folder_url: URL of the blob holding the backup. This would be the `folder_url` of a
             :class:`KeyVaultBackupResult` returned by :func:`begin_backup`, for example
             https://<account>.blob.core.windows.net/backup/mhsm-account-2020090117323313
         :param str sas_token: a Shared Access Signature (SAS) token authorizing access to the blob storage resource
+
         :keyword str continuation_token: a continuation token to restart polling from a saved state
         :keyword str key_name: name of a single key in the backup. When set, only this key will be restored.
+
         :rtype: ~azure.core.polling.LROPoller
 
         Examples:
             .. literalinclude:: ../tests/test_examples_administration.py
                 :start-after: [START begin_restore]
                 :end-before: [END begin_restore]
                 :language: python
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 from ._access_control_client import KeyVaultAccessControlClient
 from ._backup_client import KeyVaultBackupClient
-from ._enums import KeyVaultRoleScope, KeyVaultDataAction, SettingType
+from ._enums import KeyVaultRoleScope, KeyVaultDataAction, KeyVaultSettingType
 from ._internal.client_base import ApiVersion
 from ._models import (
     KeyVaultBackupResult,
     KeyVaultPermission,
     KeyVaultRoleAssignment,
     KeyVaultRoleAssignmentProperties,
     KeyVaultRoleDefinition,
@@ -26,12 +26,12 @@
     "KeyVaultPermission",
     "KeyVaultRoleAssignment",
     "KeyVaultRoleAssignmentProperties",
     "KeyVaultRoleDefinition",
     "KeyVaultRoleScope",
     "KeyVaultSetting",
     "KeyVaultSettingsClient",
-    "SettingType",
+    "KeyVaultSettingType",
 ]
 
 from ._version import VERSION
 __version__ = VERSION
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated_models.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated_models.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from enum import Enum
 import datetime
-from typing import List, Optional, Union
+from enum import Enum
+from typing import Any, List, Optional, Union
 
 from azure.core import CaseInsensitiveEnumMeta
 
 from ._generated import _serialization
 
 
 class Attributes(_serialization.Model):
@@ -48,16 +48,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -91,15 +91,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -139,16 +139,16 @@
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["Error"] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         job_id: Optional[str] = None,
         azure_storage_blob_container_uri: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the backup operation.
         :paramtype status: str
         :keyword status_details: The status details of backup operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the full backup operation.
         :paramtype error: ~azure.keyvault.administration._generated_models.Error
@@ -185,15 +185,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class Permission(_serialization.Model):
     """Role definition permissions.
@@ -220,16 +220,16 @@
     def __init__(
         self,
         *,
         actions: Optional[List[str]] = None,
         not_actions: Optional[List[str]] = None,
         data_actions: Optional[List[Union[str, "DataAction"]]] = None,
         not_data_actions: Optional[List[Union[str, "DataAction"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword actions: Action permissions that are granted.
         :paramtype actions: list[str]
         :keyword not_actions: Action permissions that are excluded but not denied. They may be granted
          by other role definitions assigned to a principal.
         :paramtype not_actions: list[str]
         :keyword data_actions: Data action permissions that are granted.
@@ -276,16 +276,16 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the restore operation.
         :paramtype error: ~azure.keyvault.administration._generated_models.Error
@@ -323,15 +323,17 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder_to_restore": {"key": "folderToRestore", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "SASTokenParameter", folder_to_restore: str, **kwargs):
+    def __init__(
+        self, *, sas_token_parameters: "SASTokenParameter", folder_to_restore: str, **kwargs: Any
+    ) -> None:
         """
         :keyword sas_token_parameters: Required.
         :paramtype sas_token_parameters: ~azure.keyvault.administration._generated_models.SASTokenParameter
         :keyword folder_to_restore: The Folder name of the blob where the previous successful full
          backup was stored. Required.
         :paramtype folder_to_restore: str
         """
@@ -364,15 +366,17 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "properties": {"key": "properties", "type": "RoleAssignmentPropertiesWithScope"},
     }
 
-    def __init__(self, *, properties: Optional["RoleAssignmentPropertiesWithScope"] = None, **kwargs):
+    def __init__(
+        self, *, properties: Optional["RoleAssignmentPropertiesWithScope"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword properties: Role assignment properties.
         :paramtype properties: ~azure.keyvault.administration._generated_models.RoleAssignmentPropertiesWithScope
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
@@ -393,15 +397,15 @@
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleAssignmentProperties"},
     }
 
-    def __init__(self, *, properties: "RoleAssignmentProperties", **kwargs):
+    def __init__(self, *, properties: "RoleAssignmentProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role assignment properties. Required.
         :paramtype properties: ~azure.keyvault.administration._generated_models.RoleAssignmentProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
@@ -413,15 +417,15 @@
     :vartype principal_id: str
     """
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, principal_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, principal_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword principal_id: Returns role assignment of the specific principal.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.principal_id = principal_id
 
@@ -437,16 +441,16 @@
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleAssignment]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role assignment list.
         :paramtype value: list[~azure.keyvault.administration._generated_models.RoleAssignment]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -472,15 +476,15 @@
     }
 
     _attribute_map = {
         "role_definition_id": {"key": "roleDefinitionId", "type": "str"},
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs):
+    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs: Any) -> None:
         """
         :keyword role_definition_id: The role definition ID used in the role assignment. Required.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID assigned to the role. This maps to the ID inside the
          Active Directory. It can point to a user, service principal, or security group. Required.
         :paramtype principal_id: str
         """
@@ -508,16 +512,16 @@
 
     def __init__(
         self,
         *,
         scope: Optional[Union[str, "RoleScope"]] = None,
         role_definition_id: Optional[str] = None,
         principal_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword scope: The role scope. Known values are: "/" and "/keys".
         :paramtype scope: str or ~azure.keyvault.administration._generated_models.RoleScope
         :keyword role_definition_id: The role definition ID.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID.
         :paramtype principal_id: str
@@ -572,16 +576,16 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "RoleType"]] = None,
         permissions: Optional[List["Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
         :paramtype role_type: str or ~azure.keyvault.administration._generated_models.RoleType
@@ -614,15 +618,15 @@
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleDefinitionProperties"},
     }
 
-    def __init__(self, *, properties: "RoleDefinitionProperties", **kwargs):
+    def __init__(self, *, properties: "RoleDefinitionProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role definition properties. Required.
         :paramtype properties: ~azure.keyvault.administration._generated_models.RoleDefinitionProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
@@ -634,15 +638,15 @@
     :vartype role_name: str
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
     }
 
-    def __init__(self, *, role_name: Optional[str] = None, **kwargs):
+    def __init__(self, *, role_name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword role_name: Returns role definition with the specific name.
         :paramtype role_name: str
         """
         super().__init__(**kwargs)
         self.role_name = role_name
 
@@ -658,16 +662,16 @@
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleDefinition]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role definition list.
         :paramtype value: list[~azure.keyvault.administration._generated_models.RoleDefinition]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -702,16 +706,16 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "RoleType"]] = None,
         permissions: Optional[List["Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
         :paramtype role_type: str or ~azure.keyvault.administration._generated_models.RoleType
@@ -745,15 +749,15 @@
     }
 
     _attribute_map = {
         "storage_resource_uri": {"key": "storageResourceUri", "type": "str"},
         "token": {"key": "token", "type": "str"},
     }
 
-    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs):
+    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs: Any) -> None:
         """
         :keyword storage_resource_uri: Azure Blob storage container Uri. Required.
         :paramtype storage_resource_uri: str
         :keyword token: The SAS token pointing to an Azure Blob storage container. Required.
         :paramtype token: str
         """
         super().__init__(**kwargs)
@@ -792,16 +796,16 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the selective key restore operation.
         :paramtype error: ~azure.keyvault.administration._generated_models.Error
@@ -839,15 +843,15 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder": {"key": "folder", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "SASTokenParameter", folder: str, **kwargs):
+    def __init__(self, *, sas_token_parameters: "SASTokenParameter", folder: str, **kwargs: Any) -> None:
         """
         :keyword sas_token_parameters: Required.
         :paramtype sas_token_parameters: ~azure.keyvault.administration._generated_models.SASTokenParameter
         :keyword folder: The Folder name of the blob where the previous successful full backup was
          stored. Required.
         :paramtype folder: str
         """
@@ -877,16 +881,16 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "value": {"key": "value", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     def __init__(
-        self, *, name: str, value: str, type: Optional[Union[str, "SettingTypeEnum"]] = None, **kwargs
-    ):
+        self, *, name: str, value: str, type: Optional[Union[str, "SettingTypeEnum"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword name: The account setting to be updated. Required.
         :paramtype name: str
         :keyword value: The value of the pool setting. Required.
         :paramtype value: str
         :keyword type: The type specifier of the value. "boolean"
         :paramtype type: str or ~azure.keyvault.administration._generated_models.SettingTypeEnum
@@ -900,32 +904,32 @@
 class SettingsListResult(_serialization.Model):
     """The settings list result.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar settings: A response message containing a list of account settings with their associated
      value.
-    :vartype settings: list[~azure.keyvault.administration._generated_models.models.Setting]
+    :vartype settings: list[~azure.keyvault.administration._generated_models.Setting]
     """
 
     _validation = {
         "settings": {"readonly": True},
     }
 
     _attribute_map = {
         "settings": {"key": "settings", "type": "[Setting]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.settings = None
 
 
-class UpdateSettingsRequest(_serialization.Model):
+class UpdateSettingRequest(_serialization.Model):
     """The update settings request object.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar value: The value of the pool setting. Required.
     :vartype value: str
     """
@@ -934,117 +938,117 @@
         "value": {"required": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, *, value: str, **kwargs):
+    def __init__(self, *, value: str, **kwargs: Any) -> None:
         """
         :keyword value: The value of the pool setting. Required.
         :paramtype value: str
         """
         super().__init__(**kwargs)
         self.value = value
 
 
 class DataAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported permissions for data actions."""
 
-    #: Read HSM key metadata.
     READ_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/read/action"
-    #: Update an HSM key.
+    """Read HSM key metadata."""
     WRITE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/write/action"
-    #: Read deleted HSM key.
+    """Update an HSM key."""
     READ_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/read/action"
-    #: Recover deleted HSM key.
+    """Read deleted HSM key."""
     RECOVER_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/recover/action"
-    #: Backup HSM keys.
+    """Recover deleted HSM key."""
     BACKUP_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/backup/action"
-    #: Restore HSM keys.
+    """Backup HSM keys."""
     RESTORE_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/restore/action"
-    #: Delete role assignment.
+    """Restore HSM keys."""
     DELETE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/delete/action"
-    #: Get role assignment.
+    """Delete role assignment."""
     GET_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/read/action"
-    #: Create or update role assignment.
+    """Get role assignment."""
     WRITE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/write/action"
-    #: Get role definition.
+    """Create or update role assignment."""
     READ_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/read/action"
-    #: Create or update role definition.
+    """Get role definition."""
     WRITE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/write/action"
-    #: Delete role definition.
+    """Create or update role definition."""
     DELETE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/delete/action"
-    #: Encrypt using an HSM key.
+    """Delete role definition."""
     ENCRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/encrypt/action"
-    #: Decrypt using an HSM key.
+    """Encrypt using an HSM key."""
     DECRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/decrypt/action"
-    #: Wrap using an HSM key.
+    """Decrypt using an HSM key."""
     WRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/wrap/action"
-    #: Unwrap using an HSM key.
+    """Wrap using an HSM key."""
     UNWRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/unwrap/action"
-    #: Sign using an HSM key.
+    """Unwrap using an HSM key."""
     SIGN_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/sign/action"
-    #: Verify using an HSM key.
+    """Sign using an HSM key."""
     VERIFY_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/verify/action"
-    #: Create an HSM key.
+    """Verify using an HSM key."""
     CREATE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/create"
-    #: Delete an HSM key.
+    """Create an HSM key."""
     DELETE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/delete"
-    #: Export an HSM key.
+    """Delete an HSM key."""
     EXPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/export/action"
-    #: Release an HSM key using Secure Key Release.
+    """Export an HSM key."""
     RELEASE_KEY = "Microsoft.KeyVault/managedHsm/keys/release/action"
-    #: Import an HSM key.
+    """Release an HSM key using Secure Key Release."""
     IMPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/import/action"
-    #: Purge a deleted HSM key.
+    """Import an HSM key."""
     PURGE_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/delete"
-    #: Download an HSM security domain.
+    """Purge a deleted HSM key."""
     DOWNLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/download/action"
-    #: Check status of HSM security domain download.
+    """Download an HSM security domain."""
     DOWNLOAD_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/download/read"
-    #: Upload an HSM security domain.
+    """Check status of HSM security domain download."""
     UPLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/upload/action"
-    #: Check the status of the HSM security domain exchange file.
+    """Upload an HSM security domain."""
     READ_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/upload/read"
-    #: Download an HSM security domain transfer key.
+    """Check the status of the HSM security domain exchange file."""
     READ_HSM_SECURITY_DOMAIN_TRANSFER_KEY = "Microsoft.KeyVault/managedHsm/securitydomain/transferkey/read"
-    #: Start an HSM backup.
+    """Download an HSM security domain transfer key."""
     START_HSM_BACKUP = "Microsoft.KeyVault/managedHsm/backup/start/action"
-    #: Start an HSM restore.
+    """Start an HSM backup."""
     START_HSM_RESTORE = "Microsoft.KeyVault/managedHsm/restore/start/action"
-    #: Read an HSM backup status.
+    """Start an HSM restore."""
     READ_HSM_BACKUP_STATUS = "Microsoft.KeyVault/managedHsm/backup/status/action"
-    #: Read an HSM restore status.
+    """Read an HSM backup status."""
     READ_HSM_RESTORE_STATUS = "Microsoft.KeyVault/managedHsm/restore/status/action"
-    #: Generate random numbers.
+    """Read an HSM restore status."""
     RANDOM_NUMBERS_GENERATE = "Microsoft.KeyVault/managedHsm/rng/action"
+    """Generate random numbers."""
 
 
 class RoleDefinitionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role definition type."""
 
     MICROSOFT_AUTHORIZATION_ROLE_DEFINITIONS = "Microsoft.Authorization/roleDefinitions"
 
 
 class RoleScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role scope."""
 
-    #: Global scope
     GLOBAL = "/"
-    #: Keys scope
+    """Global scope"""
     KEYS = "/keys"
+    """Keys scope"""
 
 
 class RoleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role type."""
 
-    #: Built in role.
     BUILT_IN_ROLE = "AKVBuiltInRole"
-    #: Custom role.
+    """Built in role."""
     CUSTOM_ROLE = "CustomRole"
+    """Custom role."""
 
 
 class SettingTypeEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type specifier of the value."""
 
     BOOLEAN = "boolean"
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_access_control_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_access_control_client.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from azure.core.tracing.decorator import distributed_trace
 
 from ._models import KeyVaultRoleAssignment, KeyVaultRoleDefinition
 from ._internal import KeyVaultClientBase
 
 if TYPE_CHECKING:
     # pylint:disable=ungrouped-imports
-    from typing import Any, Union
+    from typing import Union
     from uuid import UUID
     from azure.core.paging import ItemPaged
     from ._enums import KeyVaultRoleScope
 
 
 class KeyVaultAccessControlClient(KeyVaultClientBase):
     """Manages role-based access to Azure Key Vault.
@@ -34,26 +34,29 @@
     :keyword bool verify_challenge_resource: Whether to verify the authentication challenge resource matches the Key
         Vault or Managed HSM domain. Defaults to True.
     """
 
     # pylint:disable=protected-access
 
     @distributed_trace
-    def create_role_assignment(self, scope, definition_id, principal_id, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], str, str, **Any) -> KeyVaultRoleAssignment
+    def create_role_assignment(
+        self, scope: "Union[str, KeyVaultRoleScope]", definition_id: str, principal_id: str, **kwargs
+    ) -> KeyVaultRoleAssignment:
         """Create a role assignment.
 
         :param scope: scope the role assignment will apply over. :class:`KeyVaultRoleScope` defines common
             broad scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param str definition_id: ID of the role's definition
         :param str principal_id: Azure Active Directory object ID of the principal which will be assigned the role. The
             principal can be a user, service principal, or security group.
+
         :keyword name: a name for the role assignment. Must be a UUID.
-        :paramtype name: str or uuid.UUID
+        :paramtype name: str or uuid.UUID or None
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleAssignment
         """
         name = kwargs.pop("name", None) or uuid4()
 
         create_parameters = self._client.role_assignments.models.RoleAssignmentCreateParameters(
             properties=self._client.role_assignments.models.RoleAssignmentProperties(
                 principal_id=principal_id, role_definition_id=str(definition_id)
@@ -65,89 +68,100 @@
             role_assignment_name=str(name),
             parameters=create_parameters,
             **kwargs
         )
         return KeyVaultRoleAssignment._from_generated(assignment)
 
     @distributed_trace
-    def delete_role_assignment(self, scope, name, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], Union[str, UUID], **Any) -> None
+    def delete_role_assignment(
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
+    ) -> None:
         """Delete a role assignment.
 
         :param scope: the assignment's scope, for example "/", "/keys", or "/keys/<specific key identifier>"
             :class:`KeyVaultRoleScope` defines common broad scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param name: the role assignment's name.
         :type name: str or uuid.UUID
+
         :returns: None
         """
         try:
             self._client.role_assignments.delete(
                 vault_base_url=self._vault_url, scope=scope, role_assignment_name=str(name), **kwargs
             )
         except ResourceNotFoundError:
             pass
 
     @distributed_trace
-    def get_role_assignment(self, scope, name, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], Union[str, UUID], **Any) -> KeyVaultRoleAssignment
+    def get_role_assignment(
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
+    ) -> KeyVaultRoleAssignment:
         """Get a role assignment.
 
         :param scope: the assignment's scope, for example "/", "/keys", or "/keys/<specific key identifier>"
             :class:`KeyVaultRoleScope` defines common broad scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param name: the role assignment's name.
         :type name: str or uuid.UUID
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleAssignment
         """
         assignment = self._client.role_assignments.get(
             vault_base_url=self._vault_url, scope=scope, role_assignment_name=str(name), **kwargs
         )
         return KeyVaultRoleAssignment._from_generated(assignment)
 
     @distributed_trace
-    def list_role_assignments(self, scope, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], **Any) -> ItemPaged[KeyVaultRoleAssignment]
+    def list_role_assignments(
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
+    ) -> "ItemPaged[KeyVaultRoleAssignment]":
         """List all role assignments for a scope.
 
         :param scope: scope of the role assignments. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
+
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.administration.KeyVaultRoleAssignment]
         """
         return self._client.role_assignments.list_for_scope(
             vault_base_url=self._vault_url,
             scope=scope,
             cls=lambda result: [KeyVaultRoleAssignment._from_generated(a) for a in result],
             **kwargs
         )
 
     @distributed_trace
-    def set_role_definition(self, scope, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], **Any) -> KeyVaultRoleDefinition
+    def set_role_definition(
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
+    ) -> "KeyVaultRoleDefinition":
         """Creates or updates a custom role definition.
 
         To update a role definition, specify the definition's ``name``.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
+
         :keyword name: the role definition's name, a UUID. When this argument has a value, the client will create a new
             role definition with this name or update an existing role definition, if one exists with the given name.
             When this argument has no value, a new role definition will be created with a generated name.
-        :paramtype name: str or uuid.UUID
-        :keyword str role_name: the role's display name. If unspecified when creating or updating a role definition, the
+        :paramtype name: str or uuid.UUID or None
+        :keyword role_name: the role's display name. If unspecified when creating or updating a role definition, the
             role name will be set to an empty string.
-        :keyword str description: a description of the role definition. If unspecified when creating or updating a role
+        :paramtype role_name: str or None
+        :keyword description: a description of the role definition. If unspecified when creating or updating a role
             definition, the description will be set to an empty string.
+        :paramtype description: str or None
         :keyword permissions: the role definition's permissions. If unspecified when creating or updating a role
             definition, the role definition will have no action permissions.
-        :paramtype permissions: Iterable[KeyVaultPermission]
+        :paramtype permissions: list[KeyVaultPermission] or None
         :keyword assignable_scopes: the scopes for which the role definition can be assigned.
-        :paramtype assignable_scopes: Iterable[str] or Iterable[KeyVaultRoleScope]
+        :paramtype assignable_scopes: list[str] or list[KeyVaultRoleScope] or None
+
         :returns: The created or updated role definition
         :rtype: ~azure.keyvault.administration.KeyVaultRoleDefinition
         """
         permissions = [
             self._client.role_definitions.models.Permission(
                 actions=p.actions,
                 not_actions=p.not_actions,
@@ -171,57 +185,63 @@
             role_definition_name=str(kwargs.pop("name", None) or uuid4()),
             parameters=parameters,
             **kwargs
         )
         return KeyVaultRoleDefinition._from_generated(definition)
 
     @distributed_trace
-    def get_role_definition(self, scope, name, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], Union[str, UUID], **Any) -> KeyVaultRoleDefinition
+    def get_role_definition(
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
+    ) -> "KeyVaultRoleDefinition":
         """Get the specified role definition.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
         :param name: the role definition's name.
         :type name: str or uuid.UUID
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleDefinition
         """
         definition = self._client.role_definitions.get(
             vault_base_url=self._vault_url, scope=scope, role_definition_name=str(name), **kwargs
         )
         return KeyVaultRoleDefinition._from_generated(definition)
 
     @distributed_trace
-    def delete_role_definition(self, scope, name, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], Union[str, UUID], **Any) -> None
+    def delete_role_definition(
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
+    ) -> None:
         """Deletes a custom role definition.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
         :param name: the role definition's name.
         :type name: str or uuid.UUID
+
         :returns: None
         """
         try:
             self._client.role_definitions.delete(
                 vault_base_url=self._vault_url, scope=scope, role_definition_name=str(name), **kwargs
             )
         except ResourceNotFoundError:
             pass
 
     @distributed_trace
-    def list_role_definitions(self, scope, **kwargs):
-        # type: (Union[str, KeyVaultRoleScope], **Any) -> ItemPaged[KeyVaultRoleDefinition]
+    def list_role_definitions(
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
+    ) -> "ItemPaged[KeyVaultRoleDefinition]":
         """List all role definitions applicable at and above a scope.
 
         :param scope: scope of the role definitions. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
+
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.administration.KeyVaultRoleDefinition]
         """
         return self._client.role_definitions.list(
             vault_base_url=self._vault_url,
             scope=scope,
             cls=lambda result: [KeyVaultRoleDefinition._from_generated(d) for d in result],
             **kwargs
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_backup_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_backup_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,22 +33,24 @@
     :paramtype api_version: ~azure.keyvault.administration.ApiVersion
     :keyword bool verify_challenge_resource: Whether to verify the authentication challenge resource matches the Key
         Vault or Managed HSM domain. Defaults to True.
     """
 
     # pylint:disable=protected-access
     async def begin_backup(
-        self, blob_storage_url: str, sas_token: str, **kwargs: "Any"
+        self, blob_storage_url: str, sas_token: str, **kwargs
     ) -> "AsyncLROPoller[KeyVaultBackupResult]":
         """Begin a full backup of the Key Vault.
 
         :param str blob_storage_url: URL of the blob storage container in which the backup will be stored, for example
             https://<account>.blob.core.windows.net/backup
         :param str sas_token: a Shared Access Signature (SAS) token authorizing access to the blob storage resource
+
         :keyword str continuation_token: a continuation token to restart polling from a saved state
+
         :returns: An AsyncLROPoller. Call `result()` on this object to get a :class:`KeyVaultBackupResult`.
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.administration.KeyVaultBackupResult]
 
         Example:
             .. literalinclude:: ../tests/test_examples_administration_async.py
                 :start-after: [START begin_backup]
                 :end-before: [END begin_backup]
@@ -85,26 +87,28 @@
             continuation_token=status_response,
             polling=KeyVaultAsyncBackupClientPollingMethod(
                 lro_algorithms=[KeyVaultBackupClientPolling()], timeout=polling_interval, **kwargs
             ),
             **kwargs
         )
 
-    async def begin_restore(self, folder_url: str, sas_token: str, **kwargs: "Any") -> "AsyncLROPoller":
+    async def begin_restore(self, folder_url: str, sas_token: str, **kwargs) -> "AsyncLROPoller":
         """Restore a Key Vault backup.
 
         This method restores either a complete Key Vault backup or when ``key_name`` has a value, a single key.
 
         :param str folder_url: URL for the blob storage resource, including the path to the blob holding the
             backup. This would be the `folder_url` of a :class:`KeyVaultBackupResult` returned by
             :func:`begin_backup`, for example
             https://<account>.blob.core.windows.net/backup/mhsm-account-2020090117323313
         :param str sas_token: a Shared Access Signature (SAS) token authorizing access to the blob storage resource
+
         :keyword str continuation_token: a continuation token to restart polling from a saved state
         :keyword str key_name: name of a single key in the backup. When set, only this key will be restored.
+
         :rtype: ~azure.core.polling.AsyncLROPoller
 
         Examples:
             .. literalinclude:: ../tests/test_examples_administration_async.py
                 :start-after: [START begin_restore]
                 :end-before: [END begin_restore]
                 :language: python
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/aio/_access_control_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/aio/_access_control_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 
 from .._models import KeyVaultRoleAssignment, KeyVaultRoleDefinition
 from .._internal import AsyncKeyVaultClientBase
 
 if TYPE_CHECKING:
     # pylint:disable=ungrouped-imports
-    from typing import Any, Union
+    from typing import Union
     from uuid import UUID
     from azure.core.async_paging import AsyncItemPaged
     from .._enums import KeyVaultRoleScope
 
 
 class KeyVaultAccessControlClient(AsyncKeyVaultClientBase):
     """Manages role-based access to Azure Key Vault.
@@ -36,26 +36,28 @@
         Vault or Managed HSM domain. Defaults to True.
     """
 
     # pylint:disable=protected-access
 
     @distributed_trace_async
     async def create_role_assignment(
-        self, scope: "Union[str, KeyVaultRoleScope]", definition_id: str, principal_id: str, **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", definition_id: str, principal_id: str, **kwargs
     ) -> KeyVaultRoleAssignment:
         """Create a role assignment.
 
         :param scope: scope the role assignment will apply over. :class:`KeyVaultRoleScope` defines common broad
             scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param str definition_id: ID of the role's definition
         :param str principal_id: Azure Active Directory object ID of the principal which will be assigned the role. The
             principal can be a user, service principal, or security group.
+
         :keyword name: a name for the role assignment. Must be a UUID.
-        :paramtype name: str or uuid.UUID
+        :paramtype name: str or uuid.UUID or None
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleAssignment
         """
         name = kwargs.pop("name", None) or uuid4()
 
         create_parameters = self._client.role_assignments.models.RoleAssignmentCreateParameters(
             properties=self._client.role_assignments.models.RoleAssignmentProperties(
                 principal_id=principal_id, role_definition_id=str(definition_id)
@@ -68,92 +70,99 @@
             parameters=create_parameters,
             **kwargs
         )
         return KeyVaultRoleAssignment._from_generated(assignment)
 
     @distributed_trace_async
     async def delete_role_assignment(
-        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
     ) -> None:
         """Delete a role assignment.
 
         :param scope: the assignment's scope, for example "/", "/keys", or "/keys/<specific key identifier>".
             :class:`KeyVaultRoleScope` defines common broad scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param name: the role assignment's name.
         :type name: str or uuid.UUID
+
         :returns: None
         """
         try:
             await self._client.role_assignments.delete(
                 vault_base_url=self._vault_url, scope=scope, role_assignment_name=str(name), **kwargs
             )
         except ResourceNotFoundError:
             pass
 
     @distributed_trace_async
     async def get_role_assignment(
-        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
     ) -> KeyVaultRoleAssignment:
         """Get a role assignment.
 
         :param scope: the assignment's scope, for example "/", "/keys", or "/keys/<specific key identifier>".
             :class:`KeyVaultRoleScope` defines common broad scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
         :param name: the role assignment's name.
         :type name: str or uuid.UUID
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleAssignment
         """
         assignment = await self._client.role_assignments.get(
             vault_base_url=self._vault_url, scope=scope, role_assignment_name=str(name), **kwargs
         )
         return KeyVaultRoleAssignment._from_generated(assignment)
 
     @distributed_trace
     def list_role_assignments(
-        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
     ) -> "AsyncItemPaged[KeyVaultRoleAssignment]":
         """List all role assignments for a scope.
 
         :param scope: scope of the role assignments. :class:`KeyVaultRoleScope` defines common broad
             scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
+
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.administration.KeyVaultRoleAssignment]
         """
         return self._client.role_assignments.list_for_scope(
             vault_base_url=self._vault_url,
             scope=scope,
             cls=lambda result: [KeyVaultRoleAssignment._from_generated(a) for a in result],
             **kwargs
         )
 
     @distributed_trace_async
     async def set_role_definition(
-        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
     ) -> "KeyVaultRoleDefinition":
         """Creates or updates a custom role definition.
 
         To update a role definition, specify the definition's ``name``.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
+
         :keyword name: the role definition's name, a UUID. When this argument has a value, the client will create a new
             role definition with this name or update an existing role definition, if one exists with the given name.
             When this argument has no value, a new role definition will be created with a generated name.
-        :paramtype name: str or uuid.UUID
-        :keyword str role_name: the role's display name. If unspecified when creating or updating a role definition, the
+        :paramtype name: str or uuid.UUID or None
+        :keyword role_name: the role's display name. If unspecified when creating or updating a role definition, the
             role name will be set to an empty string.
-        :keyword str description: a description of the role definition. If unspecified when creating or updating a role
+        :paramtype role_name: str or None
+        :keyword description: a description of the role definition. If unspecified when creating or updating a role
             definition, the description will be set to an empty string.
+        :paramtype description: str or None
         :keyword permissions: the role definition's permissions. If unspecified when creating or updating a role
             definition, the role definition will have no action permissions.
-        :paramtype permissions: Iterable[KeyVaultPermission]
+        :paramtype permissions: list[KeyVaultPermission] or None
         :keyword assignable_scopes: the scopes for which the role definition can be assigned.
-        :paramtype assignable_scopes: Iterable[str] or Iterable[KeyVaultRoleScope]
+        :paramtype assignable_scopes: list[str] or list[KeyVaultRoleScope] or None
+
         :returns: The created or updated role definition
         :rtype: ~azure.keyvault.administration.KeyVaultRoleDefinition
         """
         permissions = [
             self._client.role_definitions.models.Permission(
                 actions=p.actions,
                 not_actions=p.not_actions,
@@ -178,59 +187,62 @@
             parameters=parameters,
             **kwargs
         )
         return KeyVaultRoleDefinition._from_generated(definition)
 
     @distributed_trace_async
     async def get_role_definition(
-        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
     ) -> "KeyVaultRoleDefinition":
         """Get the specified role definition.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
         :param name: the role definition's name.
         :type name: str or uuid.UUID
+
         :rtype: ~azure.keyvault.administration.KeyVaultRoleDefinition
         """
         definition = await self._client.role_definitions.get(
             vault_base_url=self._vault_url, scope=scope, role_definition_name=str(name), **kwargs
         )
         return KeyVaultRoleDefinition._from_generated(definition)
 
     @distributed_trace_async
     async def delete_role_definition(
-        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", name: "Union[str, UUID]", **kwargs
     ) -> None:
         """Deletes a custom role definition.
 
         :param scope: scope of the role definition. :class:`KeyVaultRoleScope` defines common broad scopes.
             Specify a narrower scope as a string. Managed HSM only supports '/', or KeyVaultRoleScope.GLOBAL.
         :type scope: str or KeyVaultRoleScope
         :param name: the role definition's name.
         :type name: str or uuid.UUID
+
         :returns: None
         """
         try:
             await self._client.role_definitions.delete(
                 vault_base_url=self._vault_url, scope=scope, role_definition_name=str(name), **kwargs
             )
         except ResourceNotFoundError:
             pass
 
     @distributed_trace
     def list_role_definitions(
-        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs: "Any"
+        self, scope: "Union[str, KeyVaultRoleScope]", **kwargs
     ) -> "AsyncItemPaged[KeyVaultRoleDefinition]":
         """List all role definitions applicable at and above a scope.
 
         :param scope: scope of the role definitions. :class:`KeyVaultRoleScope` defines common broad
             scopes. Specify a narrower scope as a string.
         :type scope: str or KeyVaultRoleScope
+
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.administration.KeyVaultRoleDefinition]
         """
         return self._client.role_definitions.list(
             vault_base_url=self._vault_url,
             scope=scope,
             cls=lambda result: [KeyVaultRoleDefinition._from_generated(d) for d in result],
             **kwargs
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,40 +9,38 @@
 # regenerated.
 # --------------------------------------------------------------------------
 from typing import Any
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from ._version import VERSION
+from .._version import VERSION
 
 class KeyVaultClientConfiguration(Configuration):
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
     """
 
     def __init__(
         self,
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+        **kwargs: Any
+    ) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
 
         kwargs.setdefault('sdk_moniker', 'azure-keyvault/{}'.format(VERSION))
         self._configure(**kwargs)
 
     def _configure(
         self,
-        **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+        **kwargs: Any
+    ) -> None:
         self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get('http_logging_policy') or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get('retry_policy') or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get('redirect_policy') or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get('authentication_policy')
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_key_vault_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -39,30 +39,30 @@
     :param api_version: API version to use if no profile is provided, or if missing in profile.
     :type api_version: str
     :param profile: A profile definition, from KnownProfiles to dict.
     :type profile: azure.profiles.KnownProfiles
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
     """
 
-    DEFAULT_API_VERSION = '7.4-preview.1'
+    DEFAULT_API_VERSION = '7.4'
     _PROFILE_TAG = "azure.keyvault.KeyVaultClient"
     LATEST_PROFILE = ProfileDefinition({
         _PROFILE_TAG: {
             None: DEFAULT_API_VERSION,
         }},
         _PROFILE_TAG + " latest"
     )
 
     def __init__(
         self,
-        api_version=None, # type: Optional[str]
-        profile=KnownProfiles.default, # type: KnownProfiles
-        **kwargs  # type: Any
+        api_version: Optional[str]=None,
+        profile: KnownProfiles=KnownProfiles.default,
+        **kwargs: Any
     ):
-        if api_version == '7.2' or api_version == '7.3' or api_version == '7.4-preview.1':
+        if api_version == '7.2' or api_version == '7.3' or api_version == '7.4':
             base_url = '{vaultBaseUrl}'
         else:
             raise ValueError("API version {} is not available".format(api_version))
         self._config = KeyVaultClientConfiguration(**kwargs)
         self._client = PipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(KeyVaultClient, self).__init__(
             api_version=api_version,
@@ -75,62 +75,62 @@
 
     @classmethod
     def models(cls, api_version=DEFAULT_API_VERSION):
         """Module depends on the API version:
 
            * 7.2: :mod:`v7_2.models<azure.keyvault.v7_2.models>`
            * 7.3: :mod:`v7_3.models<azure.keyvault.v7_3.models>`
-           * 7.4-preview.1: :mod:`v7_4_preview_1.models<azure.keyvault.v7_4_preview_1.models>`
+           * 7.4: :mod:`v7_4.models<azure.keyvault.v7_4.models>`
         """
         if api_version == '7.2':
             from .v7_2 import models
             return models
         elif api_version == '7.3':
             from .v7_3 import models
             return models
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1 import models
+        elif api_version == '7.4':
+            from .v7_4 import models
             return models
         raise ValueError("API version {} is not available".format(api_version))
 
     @property
     def role_assignments(self):
         """Instance depends on the API version:
 
            * 7.2: :class:`RoleAssignmentsOperations<azure.keyvault.v7_2.operations.RoleAssignmentsOperations>`
            * 7.3: :class:`RoleAssignmentsOperations<azure.keyvault.v7_3.operations.RoleAssignmentsOperations>`
-           * 7.4-preview.1: :class:`RoleAssignmentsOperations<azure.keyvault.v7_4_preview_1.operations.RoleAssignmentsOperations>`
+           * 7.4: :class:`RoleAssignmentsOperations<azure.keyvault.v7_4.operations.RoleAssignmentsOperations>`
         """
         api_version = self._get_api_version('role_assignments')
         if api_version == '7.2':
             from .v7_2.operations import RoleAssignmentsOperations as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import RoleAssignmentsOperations as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import RoleAssignmentsOperations as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import RoleAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignments'".format(api_version))
         self._config.api_version = api_version
         return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
 
     @property
     def role_definitions(self):
         """Instance depends on the API version:
 
            * 7.2: :class:`RoleDefinitionsOperations<azure.keyvault.v7_2.operations.RoleDefinitionsOperations>`
            * 7.3: :class:`RoleDefinitionsOperations<azure.keyvault.v7_3.operations.RoleDefinitionsOperations>`
-           * 7.4-preview.1: :class:`RoleDefinitionsOperations<azure.keyvault.v7_4_preview_1.operations.RoleDefinitionsOperations>`
+           * 7.4: :class:`RoleDefinitionsOperations<azure.keyvault.v7_4.operations.RoleDefinitionsOperations>`
         """
         api_version = self._get_api_version('role_definitions')
         if api_version == '7.2':
             from .v7_2.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import RoleDefinitionsOperations as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import RoleDefinitionsOperations as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import RoleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_definitions'".format(api_version))
         self._config.api_version = api_version
         return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
 
     def close(self):
         self._client.close()
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_serialization.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_serialization.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,70 +21,87 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 #
 # --------------------------------------------------------------------------
 
 # pylint: skip-file
+# pyright: reportUnnecessaryTypeIgnoreComment=false
 
 from base64 import b64decode, b64encode
 import calendar
 import datetime
 import decimal
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
+
 try:
     from urllib import quote  # type: ignore
 except ImportError:
-    from urllib.parse import quote  # type: ignore
+    from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
-import isodate
-
-from typing import Dict, Any, cast, TYPE_CHECKING
+import isodate  # type: ignore
 
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
-_BOM = codecs.BOM_UTF8.decode(encoding='utf-8')
+_BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
+
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
 
-if TYPE_CHECKING:
-    from typing import Optional, Union, AnyStr, IO, Mapping
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
-    JSON_REGEXP = re.compile(r'^(application|text)/([a-z+.]+\+)?json$')
+    JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
     CONTEXT_NAME = "deserialized_data"
 
     @classmethod
-    def deserialize_from_text(cls, data, content_type=None):
-        # type: (Optional[Union[AnyStr, IO]], Optional[str]) -> Any
+    def deserialize_from_text(cls, data: Optional[Union[AnyStr, IO]], content_type: Optional[str] = None) -> Any:
         """Decode data according to content-type.
 
         Accept a stream of data as well, but will be load at once in memory for now.
 
         If no content-type, will return the string version (not bytes, not stream)
 
         :param data: Input, could be bytes or stream (will be decoded with UTF8) or text
         :type data: str or bytes or IO
         :param str content_type: The content type.
         """
-        if hasattr(data, 'read'):
+        if hasattr(data, "read"):
             # Assume a stream
             data = cast(IO, data).read()
 
         if isinstance(data, bytes):
-            data_as_str = data.decode(encoding='utf-8-sig')
+            data_as_str = data.decode(encoding="utf-8-sig")
         else:
             # Explain to mypy the correct type.
             data_as_str = cast(str, data)
 
             # Remove Byte Order Mark if present in string
             data_as_str = data_as_str.lstrip(_BOM)
 
@@ -112,64 +129,66 @@
                 # content-type XML....
                 # So let's try a JSON load, and if it's still broken
                 # let's flow the initial exception
                 def _json_attemp(data):
                     try:
                         return True, json.loads(data)
                     except ValueError:
-                        return False, None # Don't care about this one
+                        return False, None  # Don't care about this one
+
                 success, json_result = _json_attemp(data)
                 if success:
                     return json_result
                 # If i'm here, it's not JSON, it's not XML, let's scream
                 # and raise the last context in this block (the XML exception)
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
                 raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
-    def deserialize_from_http_generics(cls, body_bytes, headers):
-        # type: (Optional[Union[AnyStr, IO]], Mapping) -> Any
+    def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
         specific implementation.
         Headers will tested for "content-type"
         """
         # Try to use content-type from headers if available
         content_type = None
-        if 'content-type' in headers:
-            content_type = headers['content-type'].split(";")[0].strip().lower()
+        if "content-type" in headers:
+            content_type = headers["content-type"].split(";")[0].strip().lower()
         # Ouch, this server did not declare what it sent...
         # Let's guess it's JSON...
         # Also, since Autorest was considering that an empty body was a valid JSON,
         # need that test as well....
         else:
             content_type = "application/json"
 
         if body_bytes:
             return cls.deserialize_from_text(body_bytes, content_type)
         return None
 
+
 try:
     basestring  # type: ignore
     unicode_str = unicode  # type: ignore
 except NameError:
-    basestring = str  # type: ignore
-    unicode_str = str  # type: ignore
+    basestring = str
+    unicode_str = str
 
 _LOGGER = logging.getLogger(__name__)
 
 try:
-    _long_type = long   # type: ignore
+    _long_type = long  # type: ignore
 except NameError:
     _long_type = int
 
+
 class UTC(datetime.tzinfo):
     """Time Zone info for handling UTC"""
 
     def utcoffset(self, dt):
         """UTF offset for UTC is 0."""
         return datetime.timedelta(0)
 
@@ -177,165 +196,176 @@
         """Timestamp representation."""
         return "Z"
 
     def dst(self, dt):
         """No daylight saving for UTC."""
         return datetime.timedelta(hours=1)
 
+
 try:
-    from datetime import timezone as _FixedOffset
+    from datetime import timezone as _FixedOffset  # type: ignore
 except ImportError:  # Python 2.7
+
     class _FixedOffset(datetime.tzinfo):  # type: ignore
         """Fixed offset in minutes east from UTC.
         Copy/pasted from Python doc
         :param datetime.timedelta offset: offset in timedelta format
         """
 
         def __init__(self, offset):
             self.__offset = offset
 
         def utcoffset(self, dt):
             return self.__offset
 
         def tzname(self, dt):
-            return str(self.__offset.total_seconds()/3600)
+            return str(self.__offset.total_seconds() / 3600)
 
         def __repr__(self):
             return "<FixedOffset {}>".format(self.tzname(None))
 
         def dst(self, dt):
             return datetime.timedelta(0)
 
         def __getinitargs__(self):
             return (self.__offset,)
 
+
 try:
     from datetime import timezone
-    TZ_UTC = timezone.utc  # type: ignore
+
+    TZ_UTC = timezone.utc
 except ImportError:
     TZ_UTC = UTC()  # type: ignore
 
 _FLATTEN = re.compile(r"(?<!\\)\.")
 
+
 def attribute_transformer(key, attr_desc, value):
     """A key transformer that returns the Python attribute.
 
     :param str key: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: A key using attribute name
     """
     return (key, value)
 
+
 def full_restapi_key_transformer(key, attr_desc, value):
     """A key transformer that returns the full RestAPI key path.
 
     :param str _: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: A list of keys using RestAPI syntax.
     """
-    keys = _FLATTEN.split(attr_desc['key'])
+    keys = _FLATTEN.split(attr_desc["key"])
     return ([_decode_attribute_map_key(k) for k in keys], value)
 
+
 def last_restapi_key_transformer(key, attr_desc, value):
     """A key transformer that returns the last RestAPI key.
 
     :param str key: The attribute name
     :param dict attr_desc: The attribute metadata
     :param object value: The value
     :returns: The last RestAPI key.
     """
     key, value = full_restapi_key_transformer(key, attr_desc, value)
     return (key[-1], value)
 
+
 def _create_xml_node(tag, prefix=None, ns=None):
     """Create a XML node."""
     if prefix and ns:
         ET.register_namespace(prefix, ns)
     if ns:
-        return ET.Element("{"+ns+"}"+tag)
+        return ET.Element("{" + ns + "}" + tag)
     else:
         return ET.Element(tag)
 
+
 class Model(object):
     """Mixin for all client request body/response body models to support
     serialization and deserialization.
     """
 
-    _subtype_map = {}  # type: Dict[str, Dict[str, Any]]
-    _attribute_map = {}  # type: Dict[str, Dict[str, Any]]
-    _validation = {}  # type: Dict[str, Dict[str, Any]]
+    _subtype_map: Dict[str, Dict[str, Any]] = {}
+    _attribute_map: Dict[str, Dict[str, Any]] = {}
+    _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
-        cls._attribute_map['additional_properties'] = {'key': '', 'type': '{object}'}
+    def enable_additional_properties_sending(cls) -> None:
+        cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
-            cls._xml_map
+            cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
     def _create_xml_node(cls):
-        """Create XML node.
-        """
+        """Create XML node."""
         try:
-            xml_map = cls._xml_map
+            xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
-        return _create_xml_node(
-            xml_map.get('name', cls.__name__),
-            xml_map.get("prefix", None),
-            xml_map.get("ns", None)
-        )
+        return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[
+            [str, Dict[str, Any], Any], Any
+        ] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -363,169 +393,181 @@
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)
 
     @classmethod
     def _infer_class_models(cls):
         try:
-            str_models = cls.__module__.rsplit('.', 1)[0]
+            str_models = cls.__module__.rsplit(".", 1)[0]
             models = sys.modules[str_models]
             client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
             if cls.__name__ not in client_models:
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = [
-            attribute_key_case_insensitive_extractor,
-            rest_key_case_insensitive_extractor,
-            last_rest_key_case_insensitive_extractor
-        ] if key_extractors is None else key_extractors
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
+                attribute_key_case_insensitive_extractor,
+                rest_key_case_insensitive_extractor,
+                last_rest_key_case_insensitive_extractor,
+            ]
+            if key_extractors is None
+            else key_extractors
+        )
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
     def _flatten_subtype(cls, key, objects):
-        if '_subtype_map' not in cls.__dict__:
+        if "_subtype_map" not in cls.__dict__:
             return {}
         result = dict(cls._subtype_map[key])
         for valuetype in cls._subtype_map[key].values():
             result.update(objects[valuetype]._flatten_subtype(key, objects))
         return result
 
     @classmethod
     def _classify(cls, response, objects):
         """Check the class _subtype_map for any child classes.
         We want to ignore any inherited _subtype_maps.
         Remove the polymorphic key from the initial data.
         """
-        for subtype_key in cls.__dict__.get('_subtype_map', {}).keys():
+        for subtype_key in cls.__dict__.get("_subtype_map", {}).keys():
             subtype_value = None
 
             if not isinstance(response, ET.Element):
                 rest_api_response_key = cls._get_rest_key_parts(subtype_key)[-1]
                 subtype_value = response.pop(rest_api_response_key, None) or response.pop(subtype_key, None)
             else:
-                subtype_value = xml_key_extractor(
-                    subtype_key,
-                    cls._attribute_map[subtype_key],
-                    response
-                )
+                subtype_value = xml_key_extractor(subtype_key, cls._attribute_map[subtype_key], response)
             if subtype_value:
                 # Try to match base class. Can be class name only
                 # (bug to fix in Autorest to support x-ms-discriminator-name)
                 if cls.__name__ == subtype_value:
                     return cls
                 flatten_mapping_type = cls._flatten_subtype(subtype_key, objects)
                 try:
-                    return objects[flatten_mapping_type[subtype_value]]
+                    return objects[flatten_mapping_type[subtype_value]]  # type: ignore
                 except KeyError:
                     _LOGGER.warning(
                         "Subtype value %s has no mapping, use base class %s.",
                         subtype_value,
                         cls.__name__,
                     )
                     break
             else:
-                _LOGGER.warning(
-                    "Discriminator %s is absent or null, use base class %s.",
-                    subtype_key,
-                    cls.__name__
-                )
+                _LOGGER.warning("Discriminator %s is absent or null, use base class %s.", subtype_key, cls.__name__)
                 break
         return cls
 
     @classmethod
     def _get_rest_key_parts(cls, attr_key):
         """Get the RestAPI key of this attr, split it and decode part
         :param str attr_key: Attribute key must be in attribute_map.
         :returns: A list of RestAPI part
         :rtype: list
         """
-        rest_split_key = _FLATTEN.split(cls._attribute_map[attr_key]['key'])
+        rest_split_key = _FLATTEN.split(cls._attribute_map[attr_key]["key"])
         return [_decode_attribute_map_key(key_part) for key_part in rest_split_key]
 
 
 def _decode_attribute_map_key(key):
     """This decode a key in an _attribute_map to the actual key we want to look at
-       inside the received data.
+    inside the received data.
 
-       :param str key: A key string from the generated code
+    :param str key: A key string from the generated code
     """
-    return key.replace('\\.', '.')
+    return key.replace("\\.", ".")
 
 
 class Serializer(object):
     """Request object model serializer."""
 
-    basic_types = {str: 'str', int: 'int', bool: 'bool', float: 'float'}
+    basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
-    _xml_basic_types_serializers = {'bool': lambda x:str(x).lower()}
-    days = {0: "Mon", 1: "Tue", 2: "Wed", 3: "Thu",
-            4: "Fri", 5: "Sat", 6: "Sun"}
-    months = {1: "Jan", 2: "Feb", 3: "Mar", 4: "Apr", 5: "May", 6: "Jun",
-              7: "Jul", 8: "Aug", 9: "Sep", 10: "Oct", 11: "Nov", 12: "Dec"}
+    _xml_basic_types_serializers = {"bool": lambda x: str(x).lower()}
+    days = {0: "Mon", 1: "Tue", 2: "Wed", 3: "Thu", 4: "Fri", 5: "Sat", 6: "Sun"}
+    months = {
+        1: "Jan",
+        2: "Feb",
+        3: "Mar",
+        4: "Apr",
+        5: "May",
+        6: "Jun",
+        7: "Jul",
+        8: "Aug",
+        9: "Sep",
+        10: "Oct",
+        11: "Nov",
+        12: "Dec",
+    }
     validation = {
         "min_length": lambda x, y: len(x) < y,
         "max_length": lambda x, y: len(x) > y,
         "minimum": lambda x, y: x < y,
         "maximum": lambda x, y: x > y,
         "minimum_ex": lambda x, y: x <= y,
         "maximum_ex": lambda x, y: x >= y,
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
-        "multiple": lambda x, y: x % y != 0
-        }
+        "multiple": lambda x, y: x % y != 0,
+    }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]]=None):
         self.serialize_type = {
-            'iso-8601': Serializer.serialize_iso,
-            'rfc-1123': Serializer.serialize_rfc,
-            'unix-time': Serializer.serialize_unix,
-            'duration': Serializer.serialize_duration,
-            'date': Serializer.serialize_date,
-            'time': Serializer.serialize_time,
-            'decimal': Serializer.serialize_decimal,
-            'long': Serializer.serialize_long,
-            'bytearray': Serializer.serialize_bytearray,
-            'base64': Serializer.serialize_base64,
-            'object': self.serialize_object,
-            '[]': self.serialize_iter,
-            '{}': self.serialize_dict
-            }
-        self.dependencies = dict(classes) if classes else {}
+            "iso-8601": Serializer.serialize_iso,
+            "rfc-1123": Serializer.serialize_rfc,
+            "unix-time": Serializer.serialize_unix,
+            "duration": Serializer.serialize_duration,
+            "date": Serializer.serialize_date,
+            "time": Serializer.serialize_time,
+            "decimal": Serializer.serialize_decimal,
+            "long": Serializer.serialize_long,
+            "bytearray": Serializer.serialize_bytearray,
+            "base64": Serializer.serialize_base64,
+            "object": self.serialize_object,
+            "[]": self.serialize_iter,
+            "{}": self.serialize_dict,
+        }
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -538,109 +580,99 @@
         if target_obj is None:
             return None
 
         attr_name = None
         class_name = target_obj.__class__.__name__
 
         if data_type:
-            return self.serialize_data(
-                target_obj, data_type, **kwargs)
+            return self.serialize_data(target_obj, data_type, **kwargs)
 
         if not hasattr(target_obj, "_attribute_map"):
             data_type = type(target_obj).__name__
             if data_type in self.basic_types.values():
-                return self.serialize_data(
-                    target_obj, data_type, **kwargs)
+                return self.serialize_data(target_obj, data_type, **kwargs)
 
         # Force "is_xml" kwargs if we detect a XML model
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             is_xml_model_serialization = kwargs.setdefault("is_xml", target_obj.is_xml_model())
 
         serialized = {}
         if is_xml_model_serialization:
             serialized = target_obj._create_xml_node()
         try:
             attributes = target_obj._attribute_map
             for attr, attr_desc in attributes.items():
                 attr_name = attr
-                if not keep_readonly and target_obj._validation.get(attr_name, {}).get('readonly', False):
+                if not keep_readonly and target_obj._validation.get(attr_name, {}).get("readonly", False):
                     continue
 
-                if attr_name == "additional_properties" and attr_desc["key"] == '':
+                if attr_name == "additional_properties" and attr_desc["key"] == "":
                     if target_obj.additional_properties is not None:
                         serialized.update(target_obj.additional_properties)
                     continue
                 try:
 
                     orig_attr = getattr(target_obj, attr)
                     if is_xml_model_serialization:
-                        pass # Don't provide "transformer" for XML for now. Keep "orig_attr"
-                    else: # JSON
+                        pass  # Don't provide "transformer" for XML for now. Keep "orig_attr"
+                    else:  # JSON
                         keys, orig_attr = key_transformer(attr, attr_desc.copy(), orig_attr)
                         keys = keys if isinstance(keys, list) else [keys]
 
-
                     kwargs["serialization_ctxt"] = attr_desc
-                    new_attr = self.serialize_data(orig_attr, attr_desc['type'], **kwargs)
-
+                    new_attr = self.serialize_data(orig_attr, attr_desc["type"], **kwargs)
 
                     if is_xml_model_serialization:
-                        xml_desc = attr_desc.get('xml', {})
-                        xml_name = xml_desc.get('name', attr_desc['key'])
-                        xml_prefix = xml_desc.get('prefix', None)
-                        xml_ns = xml_desc.get('ns', None)
+                        xml_desc = attr_desc.get("xml", {})
+                        xml_name = xml_desc.get("name", attr_desc["key"])
+                        xml_prefix = xml_desc.get("prefix", None)
+                        xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
                                 xml_name = "{}{}".format(xml_ns, xml_name)
-                            serialized.set(xml_name, new_attr)
+                            serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
-                            serialized.text = new_attr
+                            serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
-                            serialized.extend(new_attr)
+                            serialized.extend(new_attr)  # type: ignore
                         elif isinstance(new_attr, ET.Element):
                             # If the down XML has no XML/Name, we MUST replace the tag with the local tag. But keeping the namespaces.
-                            if 'name' not in getattr(orig_attr, '_xml_map', {}):
+                            if "name" not in getattr(orig_attr, "_xml_map", {}):
                                 splitted_tag = new_attr.tag.split("}")
-                                if len(splitted_tag) == 2: # Namespace
+                                if len(splitted_tag) == 2:  # Namespace
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
-                            serialized.append(new_attr)
+                            serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
-                            local_node = _create_xml_node(
-                                xml_name,
-                                xml_prefix,
-                                xml_ns
-                            )
+                            local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
-                            serialized.append(local_node)
-                    else: # JSON
-                        for k in reversed(keys):
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            serialized.append(local_node)  # type: ignore
+                    else:  # JSON
+                        for k in reversed(keys):  # type: ignore
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
-                        for k in keys:
+                        for k in keys:  # type: ignore
                             if k not in _serialized:
-                                _serialized.update(_new_attr)
-                            _new_attr = _new_attr[k]
+                                _serialized.update(_new_attr)  # type: ignore
+                            _new_attr = _new_attr[k]  # type: ignore
                             _serialized = _serialized[k]
                 except ValueError:
                     continue
 
         except (AttributeError, KeyError, TypeError) as err:
-            msg = "Attribute {} in object {} cannot be serialized.\n{}".format(
-                attr_name, class_name, str(target_obj))
+            msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
             raise_with_traceback(SerializationError, msg, err)
         else:
             return serialized
 
     def body(self, data, data_type, **kwargs):
         """Serialize data intended for a request body.
 
@@ -648,64 +680,63 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip('[]{}')
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
         if internal_data_type and not isinstance(internal_data_type, Enum):
             try:
                 deserializer = Deserializer(self.dependencies)
                 # Since it's on serialization, it's almost sure that format is not JSON REST
                 # We're not able to deal with additional properties for now.
                 deserializer.additional_properties_detection = False
                 if is_xml_model_serialization:
-                    deserializer.key_extractors = [
+                    deserializer.key_extractors = [  # type: ignore
                         attribute_key_case_insensitive_extractor,
                     ]
                 else:
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
-                        last_rest_key_case_insensitive_extractor
+                        last_rest_key_case_insensitive_extractor,
                     ]
                 data = deserializer._deserialize(data_type, data)
             except DeserializationError as err:
-                raise_with_traceback(
-                    SerializationError, "Unable to build a model: "+str(err), err)
+                raise_with_traceback(SerializationError, "Unable to build a model: " + str(err), err)
 
         return self._serialize(data, data_type, **kwargs)
 
     def url(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL path.
 
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :rtype: str
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
 
-            if kwargs.get('skip_quote') is True:
+            if kwargs.get("skip_quote") is True:
                 output = str(output)
             else:
-                output = quote(str(output), safe='')
+                output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return output
 
     def query(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL query.
@@ -716,35 +747,27 @@
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             # Treat the list aside, since we don't want to encode the div separator
             if data_type.startswith("["):
                 internal_data_type = data_type[1:-1]
-                data = [
-                    self.serialize_data(d, internal_data_type, **kwargs) if d is not None else ""
-                    for d
-                    in data
-                ]
-                if not kwargs.get('skip_quote', False):
-                    data = [
-                        quote(str(d), safe='')
-                        for d
-                        in data
-                    ]
+                data = [self.serialize_data(d, internal_data_type, **kwargs) if d is not None else "" for d in data]
+                if not kwargs.get("skip_quote", False):
+                    data = [quote(str(d), safe="") for d in data]
                 return str(self.serialize_iter(data, internal_data_type, **kwargs))
 
             # Not a list, regular serialization
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
-            if kwargs.get('skip_quote') is True:
+            if kwargs.get("skip_quote") is True:
                 output = str(output)
             else:
-                output = quote(str(output), safe='')
+                output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return str(output)
 
     def header(self, name, data, data_type, **kwargs):
         """Serialize data intended for a request header.
@@ -752,19 +775,19 @@
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :rtype: str
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
-            if data_type in ['[str]']:
+            if data_type in ["[str]"]:
                 data = ["" if d is None else d for d in data]
 
             output = self.serialize_data(data, data_type, **kwargs)
-            if data_type == 'bool':
+            if data_type == "bool":
                 output = json.dumps(output)
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return str(output)
 
     def serialize_data(self, data, data_type, **kwargs):
@@ -778,35 +801,35 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
             # It has to be a subclass of Enum anyway
             enum_type = self.dependencies.get(data_type, data.__class__)
             if issubclass(enum_type, Enum):
                 return Serializer.serialize_enum(data, enum_obj=enum_type)
 
             iter_type = data_type[0] + data_type[-1]
             if iter_type in self.serialize_type:
-                return self.serialize_type[iter_type](
-                    data, data_type[1:-1], **kwargs)
+                return self.serialize_type[iter_type](data, data_type[1:-1], **kwargs)
 
         except (ValueError, TypeError) as err:
             msg = "Unable to serialize value: {!r} as type: {!r}."
-            raise_with_traceback(
-                SerializationError, msg.format(data, data_type), err)
+            raise_with_traceback(SerializationError, msg.format(data, data_type), err)
         else:
             return self._serialize(data, **kwargs)
 
     @classmethod
     def _get_custom_serializers(cls, data_type, **kwargs):
         custom_serializer = kwargs.get("basic_types_serializers", {}).get(data_type)
         if custom_serializer:
@@ -825,15 +848,15 @@
 
         :param data: Object to be serialized.
         :param str data_type: Type of object in the iterable.
         """
         custom_serializer = cls._get_custom_serializers(data_type, **kwargs)
         if custom_serializer:
             return custom_serializer(data)
-        if data_type == 'str':
+        if data_type == "str":
             return cls.serialize_unicode(data)
         return eval(data_type)(data)  # nosec
 
     @classmethod
     def serialize_unicode(cls, data):
         """Special handling for serializing unicode strings in Py2.
         Encode to UTF-8 if unicode, otherwise handle as a str.
@@ -843,15 +866,15 @@
         """
         try:  # If I received an enum, return its value
             return data.value
         except AttributeError:
             pass
 
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 # Don't change it, JSON and XML ElementTree are totally able
                 # to serialize correctly u'' strings
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
@@ -882,45 +905,37 @@
         for d in data:
             try:
                 serialized.append(self.serialize_data(d, iter_type, **kwargs))
             except ValueError:
                 serialized.append(None)
 
         if div:
-            serialized = ['' if s is None else str(s) for s in serialized]
+            serialized = ["" if s is None else str(s) for s in serialized]
             serialized = div.join(serialized)
 
-        if 'xml' in serialization_ctxt or is_xml:
+        if "xml" in serialization_ctxt or is_xml:
             # XML serialization is more complicated
-            xml_desc = serialization_ctxt.get('xml', {})
-            xml_name = xml_desc.get('name')
+            xml_desc = serialization_ctxt.get("xml", {})
+            xml_name = xml_desc.get("name")
             if not xml_name:
-                xml_name = serialization_ctxt['key']
+                xml_name = serialization_ctxt["key"]
 
             # Create a wrap node if necessary (use the fact that Element and list have "append")
             is_wrapped = xml_desc.get("wrapped", False)
             node_name = xml_desc.get("itemsName", xml_name)
             if is_wrapped:
-                final_result = _create_xml_node(
-                    xml_name,
-                    xml_desc.get('prefix', None),
-                    xml_desc.get('ns', None)
-                )
+                final_result = _create_xml_node(xml_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
             else:
                 final_result = []
             # All list elements to "local_node"
             for el in serialized:
                 if isinstance(el, ET.Element):
                     el_node = el
                 else:
-                    el_node = _create_xml_node(
-                        node_name,
-                        xml_desc.get('prefix', None),
-                        xml_desc.get('ns', None)
-                    )
+                    el_node = _create_xml_node(node_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
                     if el is not None:  # Otherwise it writes "None" :-p
                         el_node.text = str(el)
                 final_result.append(el_node)
             return final_result
         return serialized
 
     def serialize_dict(self, attr, dict_type, **kwargs):
@@ -932,29 +947,24 @@
          not be None or empty.
         :rtype: dict
         """
         serialization_ctxt = kwargs.get("serialization_ctxt", {})
         serialized = {}
         for key, value in attr.items():
             try:
-                serialized[self.serialize_unicode(key)] = self.serialize_data(
-                    value, dict_type, **kwargs)
+                serialized[self.serialize_unicode(key)] = self.serialize_data(value, dict_type, **kwargs)
             except ValueError:
                 serialized[self.serialize_unicode(key)] = None
 
-        if 'xml' in serialization_ctxt:
+        if "xml" in serialization_ctxt:
             # XML serialization is more complicated
-            xml_desc = serialization_ctxt['xml']
-            xml_name = xml_desc['name']
+            xml_desc = serialization_ctxt["xml"]
+            xml_name = xml_desc["name"]
 
-            final_result = _create_xml_node(
-                xml_name,
-                xml_desc.get('prefix', None),
-                xml_desc.get('ns', None)
-            )
+            final_result = _create_xml_node(xml_name, xml_desc.get("prefix", None), xml_desc.get("ns", None))
             for key, value in serialized.items():
                 ET.SubElement(final_result, key).text = value
             return final_result
 
         return serialized
 
     def serialize_object(self, attr, **kwargs):
@@ -992,42 +1002,40 @@
         elif obj_type in self.dependencies.values() or isinstance(attr, Model):
             return self._serialize(attr)
 
         if obj_type == dict:
             serialized = {}
             for key, value in attr.items():
                 try:
-                    serialized[self.serialize_unicode(key)] = self.serialize_object(
-                        value, **kwargs)
+                    serialized[self.serialize_unicode(key)] = self.serialize_object(value, **kwargs)
                 except ValueError:
                     serialized[self.serialize_unicode(key)] = None
             return serialized
 
         if obj_type == list:
             serialized = []
             for obj in attr:
                 try:
-                    serialized.append(self.serialize_object(
-                        obj, **kwargs))
+                    serialized.append(self.serialize_object(obj, **kwargs))
                 except ValueError:
                     pass
             return serialized
         return str(attr)
 
     @staticmethod
     def serialize_enum(attr, enum_obj=None):
         try:
             result = attr.value
         except AttributeError:
             result = attr
         try:
-            enum_obj(result)
+            enum_obj(result)  # type: ignore
             return result
         except ValueError:
-            for enum_value in enum_obj:
+            for enum_value in enum_obj:  # type: ignore
                 if enum_value.value.lower() == str(attr).lower():
                     return enum_value.value
             error = "{!r} is not valid value for enum {!r}"
             raise SerializationError(error.format(attr, enum_obj))
 
     @staticmethod
     def serialize_bytearray(attr, **kwargs):
@@ -1041,16 +1049,16 @@
     @staticmethod
     def serialize_base64(attr, **kwargs):
         """Serialize str into base-64 string.
 
         :param attr: Object to be serialized.
         :rtype: str
         """
-        encoded = b64encode(attr).decode('ascii')
-        return encoded.strip('=').replace('+', '-').replace('/', '_')
+        encoded = b64encode(attr).decode("ascii")
+        return encoded.strip("=").replace("+", "-").replace("/", "_")
 
     @staticmethod
     def serialize_decimal(attr, **kwargs):
         """Serialize Decimal object to float.
 
         :param attr: Object to be serialized.
         :rtype: float
@@ -1109,50 +1117,53 @@
 
         :param Datetime attr: Object to be serialized.
         :rtype: str
         :raises: TypeError if format invalid.
         """
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             utc = attr.utctimetuple()
         except AttributeError:
             raise TypeError("RFC1123 object must be valid Datetime object.")
 
         return "{}, {:02} {} {:04} {:02}:{:02}:{:02} GMT".format(
-            Serializer.days[utc.tm_wday], utc.tm_mday,
-            Serializer.months[utc.tm_mon], utc.tm_year,
-            utc.tm_hour, utc.tm_min, utc.tm_sec)
+            Serializer.days[utc.tm_wday],
+            utc.tm_mday,
+            Serializer.months[utc.tm_mon],
+            utc.tm_year,
+            utc.tm_hour,
+            utc.tm_min,
+            utc.tm_sec,
+        )
 
     @staticmethod
     def serialize_iso(attr, **kwargs):
         """Serialize Datetime object into ISO-8601 formatted string.
 
         :param Datetime attr: Object to be serialized.
         :rtype: str
         :raises: SerializationError if format invalid.
         """
         if isinstance(attr, str):
             attr = isodate.parse_datetime(attr)
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             utc = attr.utctimetuple()
             if utc.tm_year > 9999 or utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
 
-            microseconds = str(attr.microsecond).rjust(6,'0').rstrip('0').ljust(3, '0')
+            microseconds = str(attr.microsecond).rjust(6, "0").rstrip("0").ljust(3, "0")
             if microseconds:
-                microseconds = '.'+microseconds
+                microseconds = "." + microseconds
             date = "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}".format(
-                utc.tm_year, utc.tm_mon, utc.tm_mday,
-                utc.tm_hour, utc.tm_min, utc.tm_sec)
-            return date + microseconds + 'Z'
+                utc.tm_year, utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec
+            )
+            return date + microseconds + "Z"
         except (ValueError, OverflowError) as err:
             msg = "Unable to serialize datetime object."
             raise_with_traceback(SerializationError, msg, err)
         except AttributeError as err:
             msg = "ISO-8601 object must be valid Datetime object."
             raise_with_traceback(TypeError, msg, err)
 
@@ -1165,124 +1176,130 @@
         :rtype: int
         :raises: SerializationError if format invalid
         """
         if isinstance(attr, int):
             return attr
         try:
             if not attr.tzinfo:
-                _LOGGER.warning(
-                    "Datetime with no tzinfo will be considered UTC.")
+                _LOGGER.warning("Datetime with no tzinfo will be considered UTC.")
             return int(calendar.timegm(attr.utctimetuple()))
         except AttributeError:
             raise TypeError("Unix time object must be valid Datetime object.")
 
+
 def rest_key_extractor(attr, attr_desc, data):
-    key = attr_desc['key']
+    key = attr_desc["key"]
     working_data = data
 
-    while '.' in key:
-        dict_keys = _FLATTEN.split(key)
+    while "." in key:
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
             # https://github.com/Azure/msrest-for-python/issues/197
             return None
-        key = '.'.join(dict_keys[1:])
+        key = ".".join(dict_keys[1:])
 
     return working_data.get(key)
 
+
 def rest_key_case_insensitive_extractor(attr, attr_desc, data):
-    key = attr_desc['key']
+    key = attr_desc["key"]
     working_data = data
 
-    while '.' in key:
+    while "." in key:
         dict_keys = _FLATTEN.split(key)
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = attribute_key_case_insensitive_extractor(working_key, None, working_data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
             # https://github.com/Azure/msrest-for-python/issues/197
             return None
-        key = '.'.join(dict_keys[1:])
+        key = ".".join(dict_keys[1:])
 
     if working_data:
         return attribute_key_case_insensitive_extractor(key, None, working_data)
 
+
 def last_rest_key_extractor(attr, attr_desc, data):
-    """Extract the attribute in "data" based on the last part of the JSON path key.
-    """
-    key = attr_desc['key']
+    """Extract the attribute in "data" based on the last part of the JSON path key."""
+    key = attr_desc["key"]
     dict_keys = _FLATTEN.split(key)
     return attribute_key_extractor(dict_keys[-1], None, data)
 
+
 def last_rest_key_case_insensitive_extractor(attr, attr_desc, data):
     """Extract the attribute in "data" based on the last part of the JSON path key.
 
     This is the case insensitive version of "last_rest_key_extractor"
     """
-    key = attr_desc['key']
+    key = attr_desc["key"]
     dict_keys = _FLATTEN.split(key)
     return attribute_key_case_insensitive_extractor(dict_keys[-1], None, data)
 
+
 def attribute_key_extractor(attr, _, data):
     return data.get(attr)
 
+
 def attribute_key_case_insensitive_extractor(attr, _, data):
     found_key = None
     lower_attr = attr.lower()
     for key in data:
         if lower_attr == key.lower():
             found_key = key
             break
 
     return data.get(found_key)
 
+
 def _extract_name_from_internal_type(internal_type):
     """Given an internal type XML description, extract correct XML name with namespace.
 
     :param dict internal_type: An model type
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
-    xml_name = internal_type_xml_map.get('name', internal_type.__name__)
+    xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
         xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
     # Test if this model is XML ready first
     if not isinstance(data, ET.Element):
         return None
 
-    xml_desc = attr_desc.get('xml', {})
-    xml_name = xml_desc.get('name', attr_desc['key'])
+    xml_desc = attr_desc.get("xml", {})
+    xml_name = xml_desc.get("name", attr_desc["key"])
 
     # Look for a children
-    is_iter_type = attr_desc['type'].startswith("[")
+    is_iter_type = attr_desc["type"].startswith("[")
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
-    xml_ns = xml_desc.get('ns', internal_type_xml_map.get("ns", None))
+    xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
         xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
@@ -1290,91 +1307,88 @@
     if xml_desc.get("text", False):
         return data.text
 
     # Scenario where I take the local name:
     # - Wrapped node
     # - Internal type is an enum (considered basic types)
     # - Internal type has no XML/Name node
-    if is_wrapped or (internal_type and (issubclass(internal_type, Enum) or 'name' not in internal_type_xml_map)):
+    if is_wrapped or (internal_type and (issubclass(internal_type, Enum) or "name" not in internal_type_xml_map)):
         children = data.findall(xml_name)
     # If internal type has a local name and it's not a list, I use that name
-    elif not is_iter_type and internal_type and 'name' in internal_type_xml_map:
+    elif not is_iter_type and internal_type and "name" in internal_type_xml_map:
         xml_name = _extract_name_from_internal_type(internal_type)
         children = data.findall(xml_name)
     # That's an array
     else:
-        if internal_type: # Complex type, ignore itemsName and use the complex type name
+        if internal_type:  # Complex type, ignore itemsName and use the complex type name
             items_name = _extract_name_from_internal_type(internal_type)
         else:
             items_name = xml_desc.get("itemsName", xml_name)
         children = data.findall(items_name)
 
     if len(children) == 0:
         if is_iter_type:
             if is_wrapped:
-                return None # is_wrapped no node, we want None
+                return None  # is_wrapped no node, we want None
             else:
-                return [] # not wrapped, assume empty list
+                return []  # not wrapped, assume empty list
         return None  # Assume it's not there, maybe an optional node.
 
     # If is_iter_type and not wrapped, return all found children
     if is_iter_type:
         if not is_wrapped:
             return children
-        else: # Iter and wrapped, should have found one node only (the wrap one)
+        else:  # Iter and wrapped, should have found one node only (the wrap one)
             if len(children) != 1:
                 raise DeserializationError(
                     "Tried to deserialize an array not wrapped, and found several nodes '{}'. Maybe you should declare this array as wrapped?".format(
                         xml_name
-                    ))
+                    )
+                )
             return list(children[0])  # Might be empty list and that's ok.
 
     # Here it's not a itertype, we should have found one element only or empty
     if len(children) > 1:
         raise DeserializationError("Find several XML '{}' where it was not expected".format(xml_name))
     return children[0]
 
+
 class Deserializer(object):
     """Response object model deserializer.
 
     :param dict classes: Class type dictionary for deserializing complex types.
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
-    basic_types = {str: 'str', int: 'int', bool: 'bool', float: 'float'}
+    basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
-    valid_date = re.compile(
-        r'\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}'
-        r'\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?')
+    valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]]=None):
         self.deserialize_type = {
-            'iso-8601': Deserializer.deserialize_iso,
-            'rfc-1123': Deserializer.deserialize_rfc,
-            'unix-time': Deserializer.deserialize_unix,
-            'duration': Deserializer.deserialize_duration,
-            'date': Deserializer.deserialize_date,
-            'time': Deserializer.deserialize_time,
-            'decimal': Deserializer.deserialize_decimal,
-            'long': Deserializer.deserialize_long,
-            'bytearray': Deserializer.deserialize_bytearray,
-            'base64': Deserializer.deserialize_base64,
-            'object': self.deserialize_object,
-            '[]': self.deserialize_iter,
-            '{}': self.deserialize_dict
-            }
+            "iso-8601": Deserializer.deserialize_iso,
+            "rfc-1123": Deserializer.deserialize_rfc,
+            "unix-time": Deserializer.deserialize_unix,
+            "duration": Deserializer.deserialize_duration,
+            "date": Deserializer.deserialize_date,
+            "time": Deserializer.deserialize_time,
+            "decimal": Deserializer.deserialize_decimal,
+            "long": Deserializer.deserialize_long,
+            "bytearray": Deserializer.deserialize_bytearray,
+            "base64": Deserializer.deserialize_base64,
+            "object": self.deserialize_object,
+            "[]": self.deserialize_iter,
+            "{}": self.deserialize_dict,
+        }
         self.deserialize_expected_types = {
-            'duration': (isodate.Duration, datetime.timedelta),
-            'iso-8601': (datetime.datetime)
+            "duration": (isodate.Duration, datetime.timedelta),
+            "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
-        self.key_extractors = [
-            rest_key_extractor,
-            xml_key_extractor
-        ]
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
         self.additional_properties_detection = True
@@ -1399,138 +1413,132 @@
         :param str target_obj: Target data type to deserialize to.
         :param object data: Object to deserialize.
         :raises: DeserializationError if deserialization fails.
         :return: Deserialized object.
         """
         # This is already a model, go recursive just in case
         if hasattr(data, "_attribute_map"):
-            constants = [name for name, config in getattr(data, '_validation', {}).items()
-                         if config.get('constant')]
+            constants = [name for name, config in getattr(data, "_validation", {}).items() if config.get("constant")]
             try:
                 for attr, mapconfig in data._attribute_map.items():
                     if attr in constants:
                         continue
                     value = getattr(data, attr)
                     if value is None:
                         continue
-                    local_type = mapconfig['type']
-                    internal_data_type = local_type.strip('[]{}')
+                    local_type = mapconfig["type"]
+                    internal_data_type = local_type.strip("[]{}")
                     if internal_data_type not in self.dependencies or isinstance(internal_data_type, Enum):
                         continue
-                    setattr(
-                        data,
-                        attr,
-                        self._deserialize(local_type, value)
-                    )
+                    setattr(data, attr, self._deserialize(local_type, value))
                 return data
             except AttributeError:
                 return
 
         response, class_name = self._classify_target(target_obj, data)
 
         if isinstance(response, basestring):
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
-            attributes = response._attribute_map
+            attributes = response._attribute_map  # type: ignore
             d_attrs = {}
             for attr, attr_desc in attributes.items():
                 # Check empty string. If it's not empty, someone has a real "additionalProperties"...
-                if attr == "additional_properties" and attr_desc["key"] == '':
+                if attr == "additional_properties" and attr_desc["key"] == "":
                     continue
                 raw_value = None
                 # Enhance attr_desc with some dynamic data
-                attr_desc = attr_desc.copy() # Do a copy, do not change the real one
-                internal_data_type = attr_desc["type"].strip('[]{}')
+                attr_desc = attr_desc.copy()  # Do a copy, do not change the real one
+                internal_data_type = attr_desc["type"].strip("[]{}")
                 if internal_data_type in self.dependencies:
                     attr_desc["internalType"] = self.dependencies[internal_data_type]
 
                 for key_extractor in self.key_extractors:
                     found_value = key_extractor(attr, attr_desc, data)
                     if found_value is not None:
                         if raw_value is not None and raw_value != found_value:
-                            msg = ("Ignoring extracted value '%s' from %s for key '%s'"
-                                   " (duplicate extraction, follow extractors order)" )
-                            _LOGGER.warning(
-                                msg,
-                                found_value,
-                                key_extractor,
-                                attr
+                            msg = (
+                                "Ignoring extracted value '%s' from %s for key '%s'"
+                                " (duplicate extraction, follow extractors order)"
                             )
+                            _LOGGER.warning(msg, found_value, key_extractor, attr)
                             continue
                         raw_value = found_value
 
-                value = self.deserialize_data(raw_value, attr_desc['type'])
+                value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
-            msg = "Unable to deserialize to object: " + class_name
+            msg = "Unable to deserialize to object: " + class_name  # type: ignore
             raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
             return None
-        if "additional_properties" in attribute_map and attribute_map.get("additional_properties", {}).get("key") != '':
+        if "additional_properties" in attribute_map and attribute_map.get("additional_properties", {}).get("key") != "":
             # Check empty string. If it's not empty, someone has a real "additionalProperties"
             return None
         if isinstance(data, ET.Element):
             data = {el.tag: el.text for el in data}
 
-        known_keys = {_decode_attribute_map_key(_FLATTEN.split(desc['key'])[0])
-                      for desc in attribute_map.values() if desc['key'] != ''}
+        known_keys = {
+            _decode_attribute_map_key(_FLATTEN.split(desc["key"])[0])
+            for desc in attribute_map.values()
+            if desc["key"] != ""
+        }
         present_keys = set(data.keys())
         missing_keys = present_keys - known_keys
         return {key: data[key] for key in missing_keys}
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
-                "Ran into a deserialization error. Ignoring since this is failsafe deserialization",
-				exc_info=True
+                "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
             )
             return None
 
     @staticmethod
     def _unpack_content(raw_data, content_type=None):
         """Extract the correct structure for deserialization.
 
@@ -1550,56 +1558,46 @@
         # Assume this is enough to detect a Pipeline Response without importing it
         context = getattr(raw_data, "context", {})
         if context:
             if RawDeserializer.CONTEXT_NAME in context:
                 return context[RawDeserializer.CONTEXT_NAME]
             raise ValueError("This pipeline didn't have the RawDeserializer policy; can't deserialize")
 
-        #Assume this is enough to recognize universal_http.ClientResponse without importing it
+        # Assume this is enough to recognize universal_http.ClientResponse without importing it
         if hasattr(raw_data, "body"):
-            return RawDeserializer.deserialize_from_http_generics(
-                raw_data.text(),
-                raw_data.headers
-            )
+            return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
-        if hasattr(raw_data, '_content_consumed'):
-            return RawDeserializer.deserialize_from_http_generics(
-                raw_data.text,
-                raw_data.headers
-            )
+        if hasattr(raw_data, "_content_consumed"):
+            return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
-        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, 'read'):
-            return RawDeserializer.deserialize_from_text(raw_data, content_type)
+        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
+            return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
         :param d_attrs: The deserialized response attributes.
         """
         if callable(response):
-            subtype = getattr(response, '_subtype_map', {})
+            subtype = getattr(response, "_subtype_map", {})
             try:
-                readonly = [k for k, v in response._validation.items()
-                            if v.get('readonly')]
-                const = [k for k, v in response._validation.items()
-                         if v.get('constant')]
-                kwargs = {k: v for k, v in attrs.items()
-                          if k not in subtype and k not in readonly + const}
+                readonly = [k for k, v in response._validation.items() if v.get("readonly")]
+                const = [k for k, v in response._validation.items() if v.get("constant")]
+                kwargs = {k: v for k, v in attrs.items() if k not in subtype and k not in readonly + const}
                 response_obj = response(**kwargs)
                 for attr in readonly:
                     setattr(response_obj, attr, attrs.get(attr))
                 if additional_properties:
                     response_obj.additional_properties = additional_properties
                 return response_obj
             except TypeError as err:
-                msg = "Unable to deserialize {} into model {}. ".format(
-                    kwargs, response)
+                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)  # type: ignore
                 raise DeserializationError(msg + str(err))
         else:
             try:
                 for attr, value in attrs.items():
                     setattr(response, attr, value)
                 return response
             except Exception as exp:
@@ -1655,33 +1653,30 @@
 
         :param list attr: Iterable to be deserialized.
         :param str iter_type: The type of object in the iterable.
         :rtype: list
         """
         if attr is None:
             return None
-        if isinstance(attr, ET.Element): # If I receive an element here, get the children
+        if isinstance(attr, ET.Element):  # If I receive an element here, get the children
             attr = list(attr)
         if not isinstance(attr, (list, set)):
-            raise DeserializationError("Cannot deserialize as [{}] an object of type {}".format(
-                iter_type,
-                type(attr)
-            ))
+            raise DeserializationError("Cannot deserialize as [{}] an object of type {}".format(iter_type, type(attr)))
         return [self.deserialize_data(a, iter_type) for a in attr]
 
     def deserialize_dict(self, attr, dict_type):
         """Deserialize a dictionary.
 
         :param dict/list attr: Dictionary to be deserialized. Also accepts
          a list of key, value pairs.
         :param str dict_type: The object type of the items in the dictionary.
         :rtype: dict
         """
         if isinstance(attr, list):
-            return {x['key']: self.deserialize_data(x['value'], dict_type) for x in attr}
+            return {x["key"]: self.deserialize_data(x["value"], dict_type) for x in attr}
 
         if isinstance(attr, ET.Element):
             # Transform <Key>value</Key> into {"Key": "value"}
             attr = {el.tag: el.text for el in attr}
         return {k: self.deserialize_data(v, dict_type) for k, v in attr.items()}
 
     def deserialize_object(self, attr, **kwargs):
@@ -1694,37 +1689,35 @@
         """
         if attr is None:
             return None
         if isinstance(attr, ET.Element):
             # Do no recurse on XML, just return the tree as-is
             return attr
         if isinstance(attr, basestring):
-            return self.deserialize_basic(attr, 'str')
+            return self.deserialize_basic(attr, "str")
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.deserialize_basic(attr, self.basic_types[obj_type])
         if obj_type is _long_type:
             return self.deserialize_long(attr)
 
         if obj_type == dict:
             deserialized = {}
             for key, value in attr.items():
                 try:
-                    deserialized[key] = self.deserialize_object(
-                        value, **kwargs)
+                    deserialized[key] = self.deserialize_object(value, **kwargs)
                 except ValueError:
                     deserialized[key] = None
             return deserialized
 
         if obj_type == list:
             deserialized = []
             for obj in attr:
                 try:
-                    deserialized.append(self.deserialize_object(
-                        obj, **kwargs))
+                    deserialized.append(self.deserialize_object(obj, **kwargs))
                 except ValueError:
                     pass
             return deserialized
 
         else:
             error = "Cannot deserialize generic object with type: "
             raise TypeError(error + str(obj_type))
@@ -1743,31 +1736,31 @@
         # If we're here, data is supposed to be a basic type.
         # If it's still an XML node, take the text
         if isinstance(attr, ET.Element):
             attr = attr.text
             if not attr:
                 if data_type == "str":
                     # None or '', node <a/> is empty string.
-                    return ''
+                    return ""
                 else:
                     # None or '', node <a/> with a strong type is None.
                     # Don't try to model "empty bool" or "empty int"
                     return None
 
-        if data_type == 'bool':
+        if data_type == "bool":
             if attr in [True, False, 1, 0]:
                 return bool(attr)
             elif isinstance(attr, basestring):
-                if attr.lower() in ['true', '1']:
+                if attr.lower() in ["true", "1"]:
                     return True
-                elif attr.lower() in ['false', '0']:
+                elif attr.lower() in ["false", "0"]:
                     return False
             raise TypeError("Invalid boolean value: {}".format(attr))
 
-        if data_type == 'str':
+        if data_type == "str":
             return self.deserialize_unicode(attr)
         return eval(data_type)(attr)  # nosec
 
     @staticmethod
     def deserialize_unicode(data):
         """Preserve unicode objects in Python 2, otherwise return data
         as a string.
@@ -1778,15 +1771,15 @@
         # We might be here because we have an enum modeled as string,
         # and we try to deserialize a partial dict with enum inside
         if isinstance(data, Enum):
             return data
 
         # Consider this is real string
         try:
-            if isinstance(data, unicode):
+            if isinstance(data, unicode):  # type: ignore
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
 
     @staticmethod
@@ -1829,72 +1822,72 @@
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return bytearray(b64decode(attr))
+        return bytearray(b64decode(attr))  # type: ignore
 
     @staticmethod
     def deserialize_base64(attr):
         """Deserialize base64 encoded string into string.
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        padding = '=' * (3 - (len(attr) + 3) % 4)
-        attr = attr + padding
-        encoded = attr.replace('-', '+').replace('_', '/')
+        padding = "=" * (3 - (len(attr) + 3) % 4)  # type: ignore
+        attr = attr + padding  # type: ignore
+        encoded = attr.replace("-", "+").replace("_", "/")
         return b64decode(encoded)
 
     @staticmethod
     def deserialize_decimal(attr):
         """Deserialize string into Decimal object.
 
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)
+            return decimal.Decimal(attr)  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
             raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
         :raises: ValueError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return _long_type(attr)
+        return _long_type(attr)  # type: ignore
 
     @staticmethod
     def deserialize_duration(attr):
         """Deserialize ISO-8601 formatted string into TimeDelta object.
 
         :param str attr: response string to be deserialized.
         :rtype: TimeDelta
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
             duration = isodate.parse_duration(attr)
-        except(ValueError, OverflowError, AttributeError) as err:
+        except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize duration object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return duration
 
     @staticmethod
     def deserialize_date(attr):
@@ -1902,48 +1895,47 @@
 
         :param str attr: response string to be deserialized.
         :rtype: Date
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
         return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         return isodate.parse_time(attr)
 
     @staticmethod
     def deserialize_rfc(attr):
         """Deserialize RFC-1123 formatted string into Datetime object.
 
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            parsed_date = email.utils.parsedate_tz(attr)
+            parsed_date = email.utils.parsedate_tz(attr)  # type: ignore
             date_obj = datetime.datetime(
-                *parsed_date[:6],
-                tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0)/60))
+                *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
@@ -1956,35 +1948,35 @@
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            attr = attr.upper()
+            attr = attr.upper()  # type: ignore
             match = Deserializer.valid_date.match(attr)
             if not match:
                 raise ValueError("Invalid datetime string: " + attr)
 
-            check_decimal = attr.split('.')
+            check_decimal = attr.split(".")
             if len(check_decimal) > 1:
                 decimal_str = ""
                 for digit in check_decimal[1]:
                     if digit.isdigit():
                         decimal_str += digit
                     else:
                         break
                 if len(decimal_str) > 6:
                     attr = attr.replace(decimal_str, decimal_str[0:6])
 
             date_obj = isodate.parse_datetime(attr)
             test_utc = date_obj.utctimetuple()
             if test_utc.tm_year > 9999 or test_utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
-        except(ValueError, OverflowError, AttributeError) as err:
+        except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
 
     @staticmethod
     def deserialize_unix(attr):
@@ -1992,15 +1984,15 @@
         This is represented as seconds.
 
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
-            attr = int(attr.text)
+            attr = int(attr.text)  # type: ignore
         try:
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/_operations_mixin.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_operations_mixin.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,42 +26,40 @@
     ) -> LROPoller[_models.FullBackupOperation]:
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
-         or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_full_backup')
         if api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_full_backup'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -77,40 +75,40 @@
     ) -> LROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters or
-         IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_full_restore_operation')
         if api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_full_restore_operation'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -129,41 +127,41 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters or IO
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
+         or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_selective_key_restore_operation')
         if api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_selective_key_restore_operation'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -181,88 +179,88 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_4.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('full_backup_status')
         if api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'full_backup_status'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
         return mixin_instance.full_backup_status(vault_base_url, job_id, **kwargs)
 
-    def get_setting_value(
+    def get_setting(
         self,
         vault_base_url: str,
         setting_name: str,
         **kwargs: Any
     ) -> _models.Setting:
-        """Get specified account setting value.
+        """Get specified account setting object.
 
-        Retrieves the value of a specified, value account setting.
+        Retrieves the setting object of a specified setting name.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        api_version = self._get_api_version('get_setting_value')
-        if api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        api_version = self._get_api_version('get_setting')
+        if api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
-            raise ValueError("API version {} does not have operation 'get_setting_value'".format(api_version))
+            raise ValueError("API version {} does not have operation 'get_setting'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
-        return mixin_instance.get_setting_value(vault_base_url, setting_name, **kwargs)
+        return mixin_instance.get_setting(vault_base_url, setting_name, **kwargs)
 
     def get_settings(
         self,
         vault_base_url: str,
         **kwargs: Any
     ) -> _models.SettingsListResult:
         """List account settings.
 
         Retrieves a list of all the available account settings that can be configured.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SettingsListResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.SettingsListResult
+        :rtype: ~azure.keyvault.v7_4.models.SettingsListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_settings')
-        if api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        if api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_settings'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -280,69 +278,69 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_4.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('restore_status')
         if api_version == '7.2':
             from .v7_2.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from .v7_3.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'restore_status'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
         return mixin_instance.restore_status(vault_base_url, job_id, **kwargs)
 
-    def update_settings(
+    def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
-        parameters: Union[_models.UpdateSettingsRequest, IO],
+        parameters: Union[_models.UpdateSettingRequest, IO],
         **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
         Description of the pool setting to be updated.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
-        :param parameters: The parameters to update an account setting. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest or IO
+        :param parameters: The parameters to update an account setting. Is either a
+         UpdateSettingRequest type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        api_version = self._get_api_version('update_settings')
-        if api_version == '7.4-preview.1':
-            from .v7_4_preview_1.operations import KeyVaultClientOperationsMixin as OperationClass
+        api_version = self._get_api_version('update_setting')
+        if api_version == '7.4':
+            from .v7_4.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
-            raise ValueError("API version {} does not have operation 'update_settings'".format(api_version))
+            raise ValueError("API version {} does not have operation 'update_setting'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
-        return mixin_instance.update_settings(vault_base_url, setting_name, parameters, **kwargs)
+        return mixin_instance.update_setting(vault_base_url, setting_name, parameters, **kwargs)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,38 +9,38 @@
 # regenerated.
 # --------------------------------------------------------------------------
 from typing import Any
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 
-from .._version import VERSION
+from ._version import VERSION
 
 class KeyVaultClientConfiguration(Configuration):
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
     """
 
     def __init__(
         self,
-        **kwargs  # type: Any
-    ) -> None:
+        **kwargs: Any
+    ):
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
 
         kwargs.setdefault('sdk_moniker', 'azure-keyvault/{}'.format(VERSION))
         self._configure(**kwargs)
 
     def _configure(
         self,
         **kwargs: Any
-    ) -> None:
+    ):
         self.user_agent_policy = kwargs.get('user_agent_policy') or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get('headers_policy') or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get('proxy_policy') or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get('logging_policy') or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get('http_logging_policy') or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get('retry_policy') or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get('retry_policy') or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get('custom_hook_policy') or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get('redirect_policy') or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get('redirect_policy') or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get('authentication_policy')
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_key_vault_client.py`

 * *Files 8% similar despite different names*

```diff
@@ -39,30 +39,30 @@
     :param api_version: API version to use if no profile is provided, or if missing in profile.
     :type api_version: str
     :param profile: A profile definition, from KnownProfiles to dict.
     :type profile: azure.profiles.KnownProfiles
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
     """
 
-    DEFAULT_API_VERSION = '7.4-preview.1'
+    DEFAULT_API_VERSION = '7.4'
     _PROFILE_TAG = "azure.keyvault.KeyVaultClient"
     LATEST_PROFILE = ProfileDefinition({
         _PROFILE_TAG: {
             None: DEFAULT_API_VERSION,
         }},
         _PROFILE_TAG + " latest"
     )
 
     def __init__(
         self,
         api_version: Optional[str] = None,
         profile: KnownProfiles = KnownProfiles.default,
-        **kwargs  # type: Any
+        **kwargs: Any
     ) -> None:
-        if api_version == '7.2' or api_version == '7.3' or api_version == '7.4-preview.1':
+        if api_version == '7.2' or api_version == '7.3' or api_version == '7.4':
             base_url = '{vaultBaseUrl}'
         else:
             raise ValueError("API version {} is not available".format(api_version))
         self._config = KeyVaultClientConfiguration(**kwargs)
         self._client = AsyncPipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(KeyVaultClient, self).__init__(
             api_version=api_version,
@@ -75,62 +75,62 @@
 
     @classmethod
     def models(cls, api_version=DEFAULT_API_VERSION):
         """Module depends on the API version:
 
            * 7.2: :mod:`v7_2.models<azure.keyvault.v7_2.models>`
            * 7.3: :mod:`v7_3.models<azure.keyvault.v7_3.models>`
-           * 7.4-preview.1: :mod:`v7_4_preview_1.models<azure.keyvault.v7_4_preview_1.models>`
+           * 7.4: :mod:`v7_4.models<azure.keyvault.v7_4.models>`
         """
         if api_version == '7.2':
             from ..v7_2 import models
             return models
         elif api_version == '7.3':
             from ..v7_3 import models
             return models
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1 import models
+        elif api_version == '7.4':
+            from ..v7_4 import models
             return models
         raise ValueError("API version {} is not available".format(api_version))
 
     @property
     def role_assignments(self):
         """Instance depends on the API version:
 
            * 7.2: :class:`RoleAssignmentsOperations<azure.keyvault.v7_2.aio.operations.RoleAssignmentsOperations>`
            * 7.3: :class:`RoleAssignmentsOperations<azure.keyvault.v7_3.aio.operations.RoleAssignmentsOperations>`
-           * 7.4-preview.1: :class:`RoleAssignmentsOperations<azure.keyvault.v7_4_preview_1.aio.operations.RoleAssignmentsOperations>`
+           * 7.4: :class:`RoleAssignmentsOperations<azure.keyvault.v7_4.aio.operations.RoleAssignmentsOperations>`
         """
         api_version = self._get_api_version('role_assignments')
         if api_version == '7.2':
             from ..v7_2.aio.operations import RoleAssignmentsOperations as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import RoleAssignmentsOperations as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import RoleAssignmentsOperations as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import RoleAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignments'".format(api_version))
         self._config.api_version = api_version
         return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
 
     @property
     def role_definitions(self):
         """Instance depends on the API version:
 
            * 7.2: :class:`RoleDefinitionsOperations<azure.keyvault.v7_2.aio.operations.RoleDefinitionsOperations>`
            * 7.3: :class:`RoleDefinitionsOperations<azure.keyvault.v7_3.aio.operations.RoleDefinitionsOperations>`
-           * 7.4-preview.1: :class:`RoleDefinitionsOperations<azure.keyvault.v7_4_preview_1.aio.operations.RoleDefinitionsOperations>`
+           * 7.4: :class:`RoleDefinitionsOperations<azure.keyvault.v7_4.aio.operations.RoleDefinitionsOperations>`
         """
         api_version = self._get_api_version('role_definitions')
         if api_version == '7.2':
             from ..v7_2.aio.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import RoleDefinitionsOperations as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import RoleDefinitionsOperations as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import RoleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_definitions'".format(api_version))
         self._config.api_version = api_version
         return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
 
     async def close(self):
         await self._client.close()
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/aio/_operations_mixin.py`

 * *Files 4% similar despite different names*

```diff
@@ -26,42 +26,40 @@
     ) -> AsyncLROPoller[_models.FullBackupOperation]:
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
-         or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_full_backup')
         if api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_full_backup'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -77,41 +75,40 @@
     ) -> AsyncLROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters or
-         IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_full_restore_operation')
         if api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_full_restore_operation'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -130,41 +127,42 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters or IO
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
+         or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('begin_selective_key_restore_operation')
         if api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'begin_selective_key_restore_operation'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -182,88 +180,88 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_4.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('full_backup_status')
         if api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'full_backup_status'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
         return await mixin_instance.full_backup_status(vault_base_url, job_id, **kwargs)
 
-    async def get_setting_value(
+    async def get_setting(
         self,
         vault_base_url: str,
         setting_name: str,
         **kwargs: Any
     ) -> _models.Setting:
-        """Get specified account setting value.
+        """Get specified account setting object.
 
-        Retrieves the value of a specified, value account setting.
+        Retrieves the setting object of a specified setting name.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        api_version = self._get_api_version('get_setting_value')
-        if api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        api_version = self._get_api_version('get_setting')
+        if api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
-            raise ValueError("API version {} does not have operation 'get_setting_value'".format(api_version))
+            raise ValueError("API version {} does not have operation 'get_setting'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
-        return await mixin_instance.get_setting_value(vault_base_url, setting_name, **kwargs)
+        return await mixin_instance.get_setting(vault_base_url, setting_name, **kwargs)
 
     async def get_settings(
         self,
         vault_base_url: str,
         **kwargs: Any
     ) -> _models.SettingsListResult:
         """List account settings.
 
         Retrieves a list of all the available account settings that can be configured.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SettingsListResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.SettingsListResult
+        :rtype: ~azure.keyvault.v7_4.models.SettingsListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('get_settings')
-        if api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        if api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'get_settings'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
@@ -281,69 +279,69 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_4.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         api_version = self._get_api_version('restore_status')
         if api_version == '7.2':
             from ..v7_2.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         elif api_version == '7.3':
             from ..v7_3.aio.operations import KeyVaultClientOperationsMixin as OperationClass
-        elif api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        elif api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
             raise ValueError("API version {} does not have operation 'restore_status'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
         return await mixin_instance.restore_status(vault_base_url, job_id, **kwargs)
 
-    async def update_settings(
+    async def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
-        parameters: Union[_models.UpdateSettingsRequest, IO],
+        parameters: Union[_models.UpdateSettingRequest, IO],
         **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
         Description of the pool setting to be updated.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
-        :param parameters: The parameters to update an account setting. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest or IO
+        :param parameters: The parameters to update an account setting. Is either a
+         UpdateSettingRequest type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        api_version = self._get_api_version('update_settings')
-        if api_version == '7.4-preview.1':
-            from ..v7_4_preview_1.aio.operations import KeyVaultClientOperationsMixin as OperationClass
+        api_version = self._get_api_version('update_setting')
+        if api_version == '7.4':
+            from ..v7_4.aio.operations import KeyVaultClientOperationsMixin as OperationClass
         else:
-            raise ValueError("API version {} does not have operation 'update_settings'".format(api_version))
+            raise ValueError("API version {} does not have operation 'update_setting'".format(api_version))
         mixin_instance = OperationClass()
         mixin_instance._client = self._client
         mixin_instance._config = self._config
         mixin_instance._config.api_version = api_version
         mixin_instance._serialize = Serializer(self._models_dict(api_version))
         mixin_instance._serialize.client_side_validation = False
         mixin_instance._deserialize = Deserializer(self._models_dict(api_version))
-        return await mixin_instance.update_settings(vault_base_url, setting_name, parameters, **kwargs)
+        return await mixin_instance.update_setting(vault_base_url, setting_name, parameters, **kwargs)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,26 +29,23 @@
     :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.2")  # type: Literal["7.2"]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", "7.2")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_key_vault_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -32,17 +32,17 @@
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -67,19 +67,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -40,51 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -93,49 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -146,15 +146,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_2.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_3.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -173,46 +173,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -222,15 +222,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -245,21 +245,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create(
         self,
         vault_base_url: str,
@@ -282,15 +282,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create(
         self,
         vault_base_url: str,
@@ -304,39 +304,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -353,17 +353,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -373,60 +373,60 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -436,15 +436,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -454,22 +454,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.RoleAssignment]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -486,15 +486,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -505,36 +505,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
     "KeyVaultClientOperationsMixin",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -40,16 +40,16 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_full_backup_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -62,40 +62,40 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_backup_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_restore_operation_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -108,49 +108,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_selective_key_restore_operation_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{keyName}/restore")
     path_format_arguments = {
         "keyName": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -173,17 +173,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -201,17 +201,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -227,15 +227,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -246,29 +246,29 @@
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
          for at least next 24 hours from the time of making this call. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_2.models.SASTokenParameter
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_3.models.SASTokenParameter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -295,15 +295,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -313,44 +313,44 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container. This
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_2.models.SASTokenParameter or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_3.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_backup_initial(  # type: ignore
+            raw_result = self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -372,79 +372,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace
     def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_3.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -454,15 +454,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -473,17 +473,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -501,17 +501,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -527,15 +527,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -545,29 +545,29 @@
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_2.models.RestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_3.models.RestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -593,15 +593,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -610,43 +610,44 @@
     ) -> LROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_2.models.RestoreOperationParameters or IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_3.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_restore_operation_initial(  # type: ignore
+            raw_result = self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -668,79 +669,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace
     def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_3.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -750,15 +751,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -770,17 +771,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -799,17 +800,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -825,15 +826,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -846,29 +847,29 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -897,15 +898,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -917,44 +918,45 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperationParameters
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperationParameters
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -977,30 +979,30 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -40,51 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -93,49 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -188,32 +188,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -223,15 +223,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -308,16 +308,16 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.RoleDefinition
@@ -330,17 +330,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -357,17 +357,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -377,15 +377,17 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any) -> _models.RoleDefinition:
         """Get the specified role definition.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -405,32 +407,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -440,15 +442,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -463,16 +465,16 @@
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -489,15 +491,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -508,36 +510,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -22,22 +22,22 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.2")  # type: Literal["7.2"]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", "7.4")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_key_vault_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -32,17 +32,17 @@
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -74,9 +74,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -46,15 +46,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_2.aio.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_3.aio.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -73,46 +73,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -122,15 +122,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     async def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -145,21 +145,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         vault_base_url: str,
@@ -182,15 +182,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         vault_base_url: str,
@@ -204,39 +204,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -253,17 +253,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -273,15 +273,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any
     ) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
@@ -289,46 +289,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -338,15 +338,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -356,22 +356,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.RoleAssignment]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -388,15 +388,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -407,36 +407,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
     "KeyVaultClientOperationsMixin",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -58,17 +58,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -86,17 +86,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -112,15 +112,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     async def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -198,16 +198,16 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container. This
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
         :type azure_storage_blob_container_uri: ~azure.keyvault.v7_2.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
@@ -220,22 +220,22 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_backup_initial(  # type: ignore
+            raw_result = await self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -257,37 +257,37 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace_async
     async def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -305,31 +305,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -339,15 +339,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     async def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -358,17 +358,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -386,17 +386,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -412,15 +412,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     async def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -495,15 +495,16 @@
     ) -> AsyncLROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
         :type restore_blob_details: ~azure.keyvault.v7_2.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
@@ -516,22 +517,22 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_restore_operation_initial(  # type: ignore
+            raw_result = await self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -553,37 +554,37 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace_async
     async def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -601,31 +602,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -635,15 +636,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     async def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -655,17 +656,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -684,17 +685,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -710,15 +711,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     async def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -804,15 +805,16 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
         :type restore_blob_details: ~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperationParameters
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -827,22 +829,22 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = await self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -865,30 +867,30 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_definitions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -88,32 +88,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -123,15 +123,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     async def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -208,16 +208,16 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_2.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
         :rtype: ~azure.keyvault.v7_2.models.RoleDefinition
@@ -230,17 +230,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -257,17 +257,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -277,15 +277,17 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any
     ) -> _models.RoleDefinition:
         """Get the specified role definition.
 
@@ -307,32 +309,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -342,15 +344,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -365,16 +367,16 @@
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.2"))  # type: Literal["7.2"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -391,15 +393,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -410,36 +412,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,93 +9,99 @@
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
 class DataAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported permissions for data actions."""
 
-    #: Read HSM key metadata.
     READ_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/read/action"
-    #: Update an HSM key.
+    """Read HSM key metadata."""
     WRITE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/write/action"
-    #: Read deleted HSM key.
+    """Update an HSM key."""
     READ_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/read/action"
-    #: Recover deleted HSM key.
+    """Read deleted HSM key."""
     RECOVER_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/recover/action"
-    #: Backup HSM keys.
+    """Recover deleted HSM key."""
     BACKUP_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/backup/action"
-    #: Restore HSM keys.
+    """Backup HSM keys."""
     RESTORE_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/restore/action"
-    #: Delete role assignment.
+    """Restore HSM keys."""
     DELETE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/delete/action"
-    #: Get role assignment.
+    """Delete role assignment."""
     GET_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/read/action"
-    #: Create or update role assignment.
+    """Get role assignment."""
     WRITE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/write/action"
-    #: Get role definition.
+    """Create or update role assignment."""
     READ_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/read/action"
-    #: Create or update role definition.
+    """Get role definition."""
     WRITE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/write/action"
-    #: Delete role definition.
+    """Create or update role definition."""
     DELETE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/delete/action"
-    #: Encrypt using an HSM key.
+    """Delete role definition."""
     ENCRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/encrypt/action"
-    #: Decrypt using an HSM key.
+    """Encrypt using an HSM key."""
     DECRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/decrypt/action"
-    #: Wrap using an HSM key.
+    """Decrypt using an HSM key."""
     WRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/wrap/action"
-    #: Unwrap using an HSM key.
+    """Wrap using an HSM key."""
     UNWRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/unwrap/action"
-    #: Sign using an HSM key.
+    """Unwrap using an HSM key."""
     SIGN_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/sign/action"
-    #: Verify using an HSM key.
+    """Sign using an HSM key."""
     VERIFY_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/verify/action"
-    #: Create an HSM key.
+    """Verify using an HSM key."""
     CREATE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/create"
-    #: Delete an HSM key.
+    """Create an HSM key."""
     DELETE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/delete"
-    #: Export an HSM key.
+    """Delete an HSM key."""
     EXPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/export/action"
-    #: Import an HSM key.
+    """Export an HSM key."""
+    RELEASE_KEY = "Microsoft.KeyVault/managedHsm/keys/release/action"
+    """Release an HSM key using Secure Key Release."""
     IMPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/import/action"
-    #: Purge a deleted HSM key.
+    """Import an HSM key."""
     PURGE_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/delete"
-    #: Download an HSM security domain.
+    """Purge a deleted HSM key."""
     DOWNLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/download/action"
-    #: Upload an HSM security domain.
+    """Download an HSM security domain."""
+    DOWNLOAD_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/download/read"
+    """Check status of HSM security domain download."""
     UPLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/upload/action"
-    #: Check the status of the HSM security domain exchange file.
+    """Upload an HSM security domain."""
     READ_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/upload/read"
-    #: Download an HSM security domain transfer key.
+    """Check the status of the HSM security domain exchange file."""
     READ_HSM_SECURITY_DOMAIN_TRANSFER_KEY = "Microsoft.KeyVault/managedHsm/securitydomain/transferkey/read"
-    #: Start an HSM backup.
+    """Download an HSM security domain transfer key."""
     START_HSM_BACKUP = "Microsoft.KeyVault/managedHsm/backup/start/action"
-    #: Start an HSM restore.
+    """Start an HSM backup."""
     START_HSM_RESTORE = "Microsoft.KeyVault/managedHsm/restore/start/action"
-    #: Read an HSM backup status.
+    """Start an HSM restore."""
     READ_HSM_BACKUP_STATUS = "Microsoft.KeyVault/managedHsm/backup/status/action"
-    #: Read an HSM restore status.
+    """Read an HSM backup status."""
     READ_HSM_RESTORE_STATUS = "Microsoft.KeyVault/managedHsm/restore/status/action"
+    """Read an HSM restore status."""
+    RANDOM_NUMBERS_GENERATE = "Microsoft.KeyVault/managedHsm/rng/action"
+    """Generate random numbers."""
 
 
 class RoleDefinitionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role definition type."""
 
     MICROSOFT_AUTHORIZATION_ROLE_DEFINITIONS = "Microsoft.Authorization/roleDefinitions"
 
 
 class RoleScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role scope."""
 
-    #: Global scope
     GLOBAL = "/"
-    #: Keys scope
+    """Global scope"""
     KEYS = "/keys"
+    """Keys scope"""
 
 
 class RoleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role type."""
 
-    #: Built in role.
     BUILT_IN_ROLE = "AKVBuiltInRole"
-    #: Custom role.
+    """Built in role."""
     CUSTOM_ROLE = "CustomRole"
+    """Custom role."""
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 from ._models_py3 import SelectiveKeyRestoreOperationParameters
 
 from ._key_vault_client_enums import DataAction
 from ._key_vault_client_enums import RoleDefinitionType
 from ._key_vault_client_enums import RoleScope
 from ._key_vault_client_enums import RoleType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "Error",
     "FullBackupOperation",
     "KeyVaultError",
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_models_py3.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import List, Optional, TYPE_CHECKING, Union
+from typing import Any, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -92,15 +92,15 @@
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -140,16 +140,16 @@
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         job_id: Optional[str] = None,
         azure_storage_blob_container_uri: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the backup operation.
         :paramtype status: str
         :keyword status_details: The status details of backup operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the full backup operation.
         :paramtype error: ~azure.keyvault.v7_2.models.Error
@@ -186,15 +186,15 @@
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class Permission(_serialization.Model):
     """Role definition permissions.
@@ -221,16 +221,16 @@
     def __init__(
         self,
         *,
         actions: Optional[List[str]] = None,
         not_actions: Optional[List[str]] = None,
         data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
         not_data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword actions: Action permissions that are granted.
         :paramtype actions: list[str]
         :keyword not_actions: Action permissions that are excluded but not denied. They may be granted
          by other role definitions assigned to a principal.
         :paramtype not_actions: list[str]
         :keyword data_actions: Data action permissions that are granted.
@@ -277,16 +277,16 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the restore operation.
         :paramtype error: ~azure.keyvault.v7_2.models.Error
@@ -325,15 +325,17 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder_to_restore": {"key": "folderToRestore", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs):
+    def __init__(
+        self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs: Any
+    ) -> None:
         """
         :keyword sas_token_parameters: SAS token parameter object containing Azure storage resourceUri
          and token. Required.
         :paramtype sas_token_parameters: ~azure.keyvault.v7_2.models.SASTokenParameter
         :keyword folder_to_restore: The Folder name of the blob where the previous successful full
          backup was stored. Required.
         :paramtype folder_to_restore: str
@@ -367,15 +369,17 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "properties": {"key": "properties", "type": "RoleAssignmentPropertiesWithScope"},
     }
 
-    def __init__(self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs):
+    def __init__(
+        self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword properties: Role assignment properties.
         :paramtype properties: ~azure.keyvault.v7_2.models.RoleAssignmentPropertiesWithScope
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
@@ -396,15 +400,15 @@
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleAssignmentProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role assignment properties. Required.
         :paramtype properties: ~azure.keyvault.v7_2.models.RoleAssignmentProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
@@ -416,15 +420,15 @@
     :vartype principal_id: str
     """
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, principal_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, principal_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword principal_id: Returns role assignment of the specific principal.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.principal_id = principal_id
 
@@ -440,16 +444,16 @@
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleAssignment]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role assignment list.
         :paramtype value: list[~azure.keyvault.v7_2.models.RoleAssignment]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -475,15 +479,15 @@
     }
 
     _attribute_map = {
         "role_definition_id": {"key": "roleDefinitionId", "type": "str"},
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs):
+    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs: Any) -> None:
         """
         :keyword role_definition_id: The role definition ID used in the role assignment. Required.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID assigned to the role. This maps to the ID inside the
          Active Directory. It can point to a user, service principal, or security group. Required.
         :paramtype principal_id: str
         """
@@ -511,16 +515,16 @@
 
     def __init__(
         self,
         *,
         scope: Optional[Union[str, "_models.RoleScope"]] = None,
         role_definition_id: Optional[str] = None,
         principal_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword scope: The role scope. Known values are: "/" and "/keys".
         :paramtype scope: str or ~azure.keyvault.v7_2.models.RoleScope
         :keyword role_definition_id: The role definition ID.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID.
         :paramtype principal_id: str
@@ -575,16 +579,16 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
         :paramtype role_type: str or ~azure.keyvault.v7_2.models.RoleType
@@ -617,15 +621,15 @@
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleDefinitionProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role definition properties. Required.
         :paramtype properties: ~azure.keyvault.v7_2.models.RoleDefinitionProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
@@ -637,15 +641,15 @@
     :vartype role_name: str
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
     }
 
-    def __init__(self, *, role_name: Optional[str] = None, **kwargs):
+    def __init__(self, *, role_name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword role_name: Returns role definition with the specific name.
         :paramtype role_name: str
         """
         super().__init__(**kwargs)
         self.role_name = role_name
 
@@ -661,16 +665,16 @@
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleDefinition]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role definition list.
         :paramtype value: list[~azure.keyvault.v7_2.models.RoleDefinition]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -705,16 +709,16 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
         :paramtype role_type: str or ~azure.keyvault.v7_2.models.RoleType
@@ -748,15 +752,15 @@
     }
 
     _attribute_map = {
         "storage_resource_uri": {"key": "storageResourceUri", "type": "str"},
         "token": {"key": "token", "type": "str"},
     }
 
-    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs):
+    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs: Any) -> None:
         """
         :keyword storage_resource_uri: Azure Blob storage container Uri. Required.
         :paramtype storage_resource_uri: str
         :keyword token: The SAS token pointing to an Azure Blob storage container. Required.
         :paramtype token: str
         """
         super().__init__(**kwargs)
@@ -795,16 +799,16 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the selective key restore operation.
         :paramtype error: ~azure.keyvault.v7_2.models.Error
@@ -843,15 +847,15 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder": {"key": "folder", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs):
+    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs: Any) -> None:
         """
         :keyword sas_token_parameters: SAS token parameter object containing Azure storage resourceUri
          and token. Required.
         :paramtype sas_token_parameters: ~azure.keyvault.v7_2.models.SASTokenParameter
         :keyword folder: The Folder name of the blob where the previous successful full backup was
          stored. Required.
         :paramtype folder: str
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -22,33 +22,30 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.4-preview.1")  # type: Literal["7.4-preview.1"]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", "7.3")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_key_vault_client.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,41 +8,41 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
     :ivar role_definitions: RoleDefinitionsOperations operations
-    :vartype role_definitions: azure.keyvault.v7_4_preview_1.operations.RoleDefinitionsOperations
+    :vartype role_definitions: azure.keyvault.v7_4.operations.RoleDefinitionsOperations
     :ivar role_assignments: RoleAssignmentsOperations operations
-    :vartype role_assignments: azure.keyvault.v7_4_preview_1.operations.RoleAssignmentsOperations
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :vartype role_assignments: azure.keyvault.v7_4.operations.RoleAssignmentsOperations
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -67,19 +67,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -40,55 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -97,53 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -154,15 +146,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_4_preview_1.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_4.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -181,48 +173,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -232,15 +222,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -255,21 +245,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create(
         self,
         vault_base_url: str,
@@ -292,15 +282,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create(
         self,
         vault_base_url: str,
@@ -314,41 +304,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -365,17 +353,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -385,62 +373,60 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -450,15 +436,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -468,24 +454,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4_preview_1.models.RoleAssignment]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -502,15 +486,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -521,36 +505,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_key_vault_client_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -40,18 +40,16 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_full_backup_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -64,44 +62,40 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_backup_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_restore_operation_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -114,127 +108,117 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_selective_key_restore_operation_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{keyName}/restore")
     path_format_arguments = {
         "keyName": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_settings_request(setting_name: str, **kwargs: Any) -> HttpRequest:
+def build_update_setting_request(setting_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/settings/{setting-name}")
     path_format_arguments = {
         "setting-name": _SERIALIZER.url("setting_name", setting_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_setting_value_request(setting_name: str, **kwargs: Any) -> HttpRequest:
+def build_get_setting_request(setting_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/settings/{setting-name}")
     path_format_arguments = {
         "setting-name": _SERIALIZER.url("setting_name", setting_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_settings_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/settings")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -259,19 +243,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -289,17 +271,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -315,15 +297,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -333,30 +315,29 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
          for at least next 24 hours from the time of making this call. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -382,16 +363,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -400,48 +380,44 @@
     ) -> LROPoller[_models.FullBackupOperation]:
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
-         or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_backup_initial(  # type: ignore
+            raw_result = self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -463,81 +439,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace
     def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_4.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -547,15 +521,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -566,19 +540,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -596,17 +568,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -622,15 +594,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -640,29 +612,29 @@
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -688,15 +660,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -705,46 +677,44 @@
     ) -> LROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters or
-         IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_restore_operation_initial(  # type: ignore
+            raw_result = self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -766,81 +736,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace
     def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_4.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -850,15 +818,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -870,19 +838,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -901,17 +867,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -927,15 +893,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -948,31 +914,29 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -1001,16 +965,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -1022,47 +985,45 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters or IO
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
+         or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -1085,44 +1046,44 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
-    def update_settings(
+    def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
-        parameters: _models.UpdateSettingsRequest,
+        parameters: _models.UpdateSettingRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
@@ -1130,26 +1091,26 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :param parameters: The parameters to update an account setting. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def update_settings(
+    def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
@@ -1167,89 +1128,83 @@
         :param parameters: The parameters to update an account setting. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def update_settings(
-        self,
-        vault_base_url: str,
-        setting_name: str,
-        parameters: Union[_models.UpdateSettingsRequest, IO],
-        **kwargs: Any
+    def update_setting(
+        self, vault_base_url: str, setting_name: str, parameters: Union[_models.UpdateSettingRequest, IO], **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
         Description of the pool setting to be updated.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
-        :param parameters: The parameters to update an account setting. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest or IO
+        :param parameters: The parameters to update an account setting. Is either a
+         UpdateSettingRequest type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Setting]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Setting] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "UpdateSettingsRequest")
+            _json = self._serialize.body(parameters, "UpdateSettingRequest")
 
-        request = build_update_settings_request(
+        request = build_update_setting_request(
             setting_name=setting_name,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update_settings.metadata["url"],
+            template_url=self.update_setting.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1259,62 +1214,60 @@
         deserialized = self._deserialize("Setting", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_settings.metadata = {"url": "/settings/{setting-name}"}  # type: ignore
+    update_setting.metadata = {"url": "/settings/{setting-name}"}
 
     @distributed_trace
-    def get_setting_value(self, vault_base_url: str, setting_name: str, **kwargs: Any) -> _models.Setting:
-        """Get specified account setting value.
+    def get_setting(self, vault_base_url: str, setting_name: str, **kwargs: Any) -> _models.Setting:
+        """Get specified account setting object.
 
-        Retrieves the value of a specified, value account setting.
+        Retrieves the setting object of a specified setting name.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Setting]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.Setting] = kwargs.pop("cls", None)
 
-        request = build_get_setting_value_request(
+        request = build_get_setting_request(
             setting_name=setting_name,
             api_version=api_version,
-            template_url=self.get_setting_value.metadata["url"],
+            template_url=self.get_setting.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1324,58 +1277,56 @@
         deserialized = self._deserialize("Setting", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_setting_value.metadata = {"url": "/settings/{setting-name}"}  # type: ignore
+    get_setting.metadata = {"url": "/settings/{setting-name}"}
 
     @distributed_trace
     def get_settings(self, vault_base_url: str, **kwargs: Any) -> _models.SettingsListResult:
         """List account settings.
 
         Retrieves a list of all the available account settings that can be configured.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SettingsListResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.SettingsListResult
+        :rtype: ~azure.keyvault.v7_4.models.SettingsListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SettingsListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.SettingsListResult] = kwargs.pop("cls", None)
 
         request = build_get_settings_request(
             api_version=api_version,
             template_url=self.get_settings.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1385,8 +1336,8 @@
         deserialized = self._deserialize("SettingsListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_settings.metadata = {"url": "/settings"}  # type: ignore
+    get_settings.metadata = {"url": "/settings"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_role_definitions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -40,55 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -97,53 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop(
-        "api_version", _params.pop("api-version", "7.4-preview.1")
-    )  # type: Literal["7.4-preview.1"]
+    api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -154,15 +146,15 @@
 
 class RoleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_4_preview_1.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_4.KeyVaultClient`'s
         :attr:`role_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -182,48 +174,46 @@
         :param scope: The scope of the role definition to delete. Managed HSM only supports '/'.
          Required.
         :type scope: str
         :param role_definition_name: The name (GUID) of the role definition to delete. Required.
         :type role_definition_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -233,15 +223,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -257,21 +247,21 @@
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
         :param parameters: Parameters for the role definition. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.RoleDefinitionCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         vault_base_url: str,
@@ -295,15 +285,15 @@
         :param parameters: Parameters for the role definition. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         vault_base_url: str,
@@ -318,41 +308,39 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionCreateParameters or IO
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -369,17 +357,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -389,62 +377,62 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any) -> _models.RoleDefinition:
         """Get the specified role definition.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role definition to get. Managed HSM only supports '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to get. Required.
         :type role_definition_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -454,15 +442,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -471,24 +459,22 @@
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use atScopeAndBelow filter to search below
          the given scope as well. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4_preview_1.models.RoleDefinition]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_4.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -505,15 +491,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -524,36 +510,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -22,30 +22,30 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.4-preview.1")  # type: Literal["7.4-preview.1"]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", "7.4")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py`

 * *Files 17% similar despite different names*

```diff
@@ -8,43 +8,41 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
     :ivar role_definitions: RoleDefinitionsOperations operations
-    :vartype role_definitions:
-     azure.keyvault.v7_4_preview_1.aio.operations.RoleDefinitionsOperations
+    :vartype role_definitions: azure.keyvault.v7_3.aio.operations.RoleDefinitionsOperations
     :ivar role_assignments: RoleAssignmentsOperations operations
-    :vartype role_assignments:
-     azure.keyvault.v7_4_preview_1.aio.operations.RoleAssignmentsOperations
-    :keyword api_version: Api Version. Default value is "7.4-preview.1". Note that overriding this
-     default value may result in unsupported behavior.
+    :vartype role_assignments: azure.keyvault.v7_3.aio.operations.RoleAssignmentsOperations
+    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+     value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -76,9 +74,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/aio/operations/_role_assignments_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -46,15 +46,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_4_preview_1.aio.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_2.aio.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -73,48 +73,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -124,15 +122,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     async def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -147,21 +145,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         vault_base_url: str,
@@ -184,15 +182,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         vault_base_url: str,
@@ -206,41 +204,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -257,17 +253,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -277,15 +273,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any
     ) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
@@ -293,48 +289,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -344,15 +338,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -362,25 +356,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4_preview_1.models.RoleAssignment]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_2.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -397,15 +388,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -416,36 +407,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_key_vault_client_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -27,19 +27,19 @@
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._key_vault_client_operations import (
     build_full_backup_request,
     build_full_backup_status_request,
     build_full_restore_operation_request,
-    build_get_setting_value_request,
+    build_get_setting_request,
     build_get_settings_request,
     build_restore_status_request,
     build_selective_key_restore_operation_request,
-    build_update_settings_request,
+    build_update_setting_request,
 )
 from .._vendor import KeyVaultClientMixinABC
 
 if sys.version_info >= (3, 8):
     from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
 else:
     from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
@@ -61,19 +61,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -91,17 +89,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -117,15 +115,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     async def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -135,30 +133,29 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
          for at least next 24 hours from the time of making this call. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_full_backup(
         self,
         vault_base_url: str,
@@ -184,16 +181,15 @@
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_full_backup(
         self,
         vault_base_url: str,
@@ -202,48 +198,44 @@
     ) -> AsyncLROPoller[_models.FullBackupOperation]:
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
-         or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_4.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_backup_initial(  # type: ignore
+            raw_result = await self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -265,81 +257,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace_async
     async def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_4.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -349,15 +339,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     async def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -368,19 +358,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -398,17 +386,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -424,15 +412,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     async def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -442,30 +430,29 @@
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -491,16 +478,15 @@
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -509,47 +495,44 @@
     ) -> AsyncLROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_4_preview_1.models.RestoreOperationParameters or
-         IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.RestoreOperation]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_restore_operation_initial(  # type: ignore
+            raw_result = await self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -571,81 +554,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace_async
     async def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_4.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -655,15 +636,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     async def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -675,19 +656,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -706,17 +685,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -732,15 +711,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     async def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -753,31 +732,30 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -807,15 +785,15 @@
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -827,47 +805,46 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details:
-         ~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperationParameters or IO
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperationParameters
+         or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
          for this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4_preview_1.models.SelectiveKeyRestoreOperation]
+         ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_4.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = await self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -890,44 +867,44 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
-    async def update_settings(
+    async def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
-        parameters: _models.UpdateSettingsRequest,
+        parameters: _models.UpdateSettingRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
@@ -935,26 +912,26 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :param parameters: The parameters to update an account setting. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def update_settings(
+    async def update_setting(
         self,
         vault_base_url: str,
         setting_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
@@ -972,89 +949,83 @@
         :param parameters: The parameters to update an account setting. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def update_settings(
-        self,
-        vault_base_url: str,
-        setting_name: str,
-        parameters: Union[_models.UpdateSettingsRequest, IO],
-        **kwargs: Any
+    async def update_setting(
+        self, vault_base_url: str, setting_name: str, parameters: Union[_models.UpdateSettingRequest, IO], **kwargs: Any
     ) -> _models.Setting:
         """Updates key vault account setting, stores it, then returns the setting name and value to the
         client.
 
         Description of the pool setting to be updated.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
-        :param parameters: The parameters to update an account setting. Is either a model type or a IO
-         type. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.UpdateSettingsRequest or IO
+        :param parameters: The parameters to update an account setting. Is either a
+         UpdateSettingRequest type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.UpdateSettingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Setting]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.Setting] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "UpdateSettingsRequest")
+            _json = self._serialize.body(parameters, "UpdateSettingRequest")
 
-        request = build_update_settings_request(
+        request = build_update_setting_request(
             setting_name=setting_name,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self.update_settings.metadata["url"],
+            template_url=self.update_setting.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1064,62 +1035,60 @@
         deserialized = self._deserialize("Setting", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update_settings.metadata = {"url": "/settings/{setting-name}"}  # type: ignore
+    update_setting.metadata = {"url": "/settings/{setting-name}"}
 
     @distributed_trace_async
-    async def get_setting_value(self, vault_base_url: str, setting_name: str, **kwargs: Any) -> _models.Setting:
-        """Get specified account setting value.
+    async def get_setting(self, vault_base_url: str, setting_name: str, **kwargs: Any) -> _models.Setting:
+        """Get specified account setting object.
 
-        Retrieves the value of a specified, value account setting.
+        Retrieves the setting object of a specified setting name.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param setting_name: The name of the account setting. Must be a valid settings option.
          Required.
         :type setting_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Setting or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.Setting
+        :rtype: ~azure.keyvault.v7_4.models.Setting
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Setting]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.Setting] = kwargs.pop("cls", None)
 
-        request = build_get_setting_value_request(
+        request = build_get_setting_request(
             setting_name=setting_name,
             api_version=api_version,
-            template_url=self.get_setting_value.metadata["url"],
+            template_url=self.get_setting.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1129,58 +1098,56 @@
         deserialized = self._deserialize("Setting", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_setting_value.metadata = {"url": "/settings/{setting-name}"}  # type: ignore
+    get_setting.metadata = {"url": "/settings/{setting-name}"}
 
     @distributed_trace_async
     async def get_settings(self, vault_base_url: str, **kwargs: Any) -> _models.SettingsListResult:
         """List account settings.
 
         Retrieves a list of all the available account settings that can be configured.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SettingsListResult or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.SettingsListResult
+        :rtype: ~azure.keyvault.v7_4.models.SettingsListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SettingsListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.SettingsListResult] = kwargs.pop("cls", None)
 
         request = build_get_settings_request(
             api_version=api_version,
             template_url=self.get_settings.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -1190,8 +1157,8 @@
         deserialized = self._deserialize("SettingsListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_settings.metadata = {"url": "/settings"}  # type: ignore
+    get_settings.metadata = {"url": "/settings"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_definitions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -46,15 +46,15 @@
 
 class RoleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_4_preview_1.aio.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_4.aio.KeyVaultClient`'s
         :attr:`role_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -74,48 +74,46 @@
         :param scope: The scope of the role definition to delete. Managed HSM only supports '/'.
          Required.
         :type scope: str
         :param role_definition_name: The name (GUID) of the role definition to delete. Required.
         :type role_definition_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -125,15 +123,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     async def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -149,21 +147,21 @@
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
         :param parameters: Parameters for the role definition. Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.RoleDefinitionCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         vault_base_url: str,
@@ -187,15 +185,15 @@
         :param parameters: Parameters for the role definition. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self,
         vault_base_url: str,
@@ -210,41 +208,39 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionCreateParameters or IO
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -261,17 +257,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -281,15 +277,17 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any
     ) -> _models.RoleDefinition:
         """Get the specified role definition.
 
@@ -297,48 +295,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to get. Managed HSM only supports '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to get. Required.
         :type role_definition_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_4_preview_1.models.RoleDefinition
+        :rtype: ~azure.keyvault.v7_4.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -348,15 +344,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -365,25 +361,22 @@
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use atScopeAndBelow filter to search below
          the given scope as well. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4_preview_1.models.RoleDefinition]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop(
-            "api_version", _params.pop("api-version", "7.4-preview.1")
-        )  # type: Literal["7.4-preview.1"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -400,15 +393,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -419,36 +412,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_key_vault_client_enums.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_key_vault_client_enums.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,105 +9,105 @@
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
 class DataAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported permissions for data actions."""
 
-    #: Read HSM key metadata.
     READ_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/read/action"
-    #: Update an HSM key.
+    """Read HSM key metadata."""
     WRITE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/write/action"
-    #: Read deleted HSM key.
+    """Update an HSM key."""
     READ_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/read/action"
-    #: Recover deleted HSM key.
+    """Read deleted HSM key."""
     RECOVER_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/recover/action"
-    #: Backup HSM keys.
+    """Recover deleted HSM key."""
     BACKUP_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/backup/action"
-    #: Restore HSM keys.
+    """Backup HSM keys."""
     RESTORE_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/restore/action"
-    #: Delete role assignment.
+    """Restore HSM keys."""
     DELETE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/delete/action"
-    #: Get role assignment.
+    """Delete role assignment."""
     GET_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/read/action"
-    #: Create or update role assignment.
+    """Get role assignment."""
     WRITE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/write/action"
-    #: Get role definition.
+    """Create or update role assignment."""
     READ_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/read/action"
-    #: Create or update role definition.
+    """Get role definition."""
     WRITE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/write/action"
-    #: Delete role definition.
+    """Create or update role definition."""
     DELETE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/delete/action"
-    #: Encrypt using an HSM key.
+    """Delete role definition."""
     ENCRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/encrypt/action"
-    #: Decrypt using an HSM key.
+    """Encrypt using an HSM key."""
     DECRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/decrypt/action"
-    #: Wrap using an HSM key.
+    """Decrypt using an HSM key."""
     WRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/wrap/action"
-    #: Unwrap using an HSM key.
+    """Wrap using an HSM key."""
     UNWRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/unwrap/action"
-    #: Sign using an HSM key.
+    """Unwrap using an HSM key."""
     SIGN_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/sign/action"
-    #: Verify using an HSM key.
+    """Sign using an HSM key."""
     VERIFY_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/verify/action"
-    #: Create an HSM key.
+    """Verify using an HSM key."""
     CREATE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/create"
-    #: Delete an HSM key.
+    """Create an HSM key."""
     DELETE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/delete"
-    #: Export an HSM key.
+    """Delete an HSM key."""
     EXPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/export/action"
-    #: Release an HSM key using Secure Key Release.
+    """Export an HSM key."""
     RELEASE_KEY = "Microsoft.KeyVault/managedHsm/keys/release/action"
-    #: Import an HSM key.
+    """Release an HSM key using Secure Key Release."""
     IMPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/import/action"
-    #: Purge a deleted HSM key.
+    """Import an HSM key."""
     PURGE_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/delete"
-    #: Download an HSM security domain.
+    """Purge a deleted HSM key."""
     DOWNLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/download/action"
-    #: Check status of HSM security domain download.
+    """Download an HSM security domain."""
     DOWNLOAD_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/download/read"
-    #: Upload an HSM security domain.
+    """Check status of HSM security domain download."""
     UPLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/upload/action"
-    #: Check the status of the HSM security domain exchange file.
+    """Upload an HSM security domain."""
     READ_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/upload/read"
-    #: Download an HSM security domain transfer key.
+    """Check the status of the HSM security domain exchange file."""
     READ_HSM_SECURITY_DOMAIN_TRANSFER_KEY = "Microsoft.KeyVault/managedHsm/securitydomain/transferkey/read"
-    #: Start an HSM backup.
+    """Download an HSM security domain transfer key."""
     START_HSM_BACKUP = "Microsoft.KeyVault/managedHsm/backup/start/action"
-    #: Start an HSM restore.
+    """Start an HSM backup."""
     START_HSM_RESTORE = "Microsoft.KeyVault/managedHsm/restore/start/action"
-    #: Read an HSM backup status.
+    """Start an HSM restore."""
     READ_HSM_BACKUP_STATUS = "Microsoft.KeyVault/managedHsm/backup/status/action"
-    #: Read an HSM restore status.
+    """Read an HSM backup status."""
     READ_HSM_RESTORE_STATUS = "Microsoft.KeyVault/managedHsm/restore/status/action"
-    #: Generate random numbers.
+    """Read an HSM restore status."""
     RANDOM_NUMBERS_GENERATE = "Microsoft.KeyVault/managedHsm/rng/action"
+    """Generate random numbers."""
 
 
 class RoleDefinitionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role definition type."""
 
     MICROSOFT_AUTHORIZATION_ROLE_DEFINITIONS = "Microsoft.Authorization/roleDefinitions"
 
 
 class RoleScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role scope."""
 
-    #: Global scope
     GLOBAL = "/"
-    #: Keys scope
+    """Global scope"""
     KEYS = "/keys"
+    """Keys scope"""
 
 
 class RoleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role type."""
 
-    #: Built in role.
     BUILT_IN_ROLE = "AKVBuiltInRole"
-    #: Custom role.
+    """Built in role."""
     CUSTOM_ROLE = "CustomRole"
+    """Custom role."""
 
 
 class SettingTypeEnum(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type specifier of the value."""
 
     BOOLEAN = "boolean"
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,23 +25,23 @@
 from ._models_py3 import RoleDefinitionListResult
 from ._models_py3 import RoleDefinitionProperties
 from ._models_py3 import SASTokenParameter
 from ._models_py3 import SelectiveKeyRestoreOperation
 from ._models_py3 import SelectiveKeyRestoreOperationParameters
 from ._models_py3 import Setting
 from ._models_py3 import SettingsListResult
-from ._models_py3 import UpdateSettingsRequest
+from ._models_py3 import UpdateSettingRequest
 
 from ._key_vault_client_enums import DataAction
 from ._key_vault_client_enums import RoleDefinitionType
 from ._key_vault_client_enums import RoleScope
 from ._key_vault_client_enums import RoleType
 from ._key_vault_client_enums import SettingTypeEnum
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "Error",
     "FullBackupOperation",
     "KeyVaultError",
@@ -60,15 +60,15 @@
     "RoleDefinitionListResult",
     "RoleDefinitionProperties",
     "SASTokenParameter",
     "SelectiveKeyRestoreOperation",
     "SelectiveKeyRestoreOperationParameters",
     "Setting",
     "SettingsListResult",
-    "UpdateSettingsRequest",
+    "UpdateSettingRequest",
     "DataAction",
     "RoleDefinitionType",
     "RoleScope",
     "RoleType",
     "SettingTypeEnum",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_4_preview_1/models/_models_py3.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import List, Optional, TYPE_CHECKING, Union
+from typing import Any, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -77,30 +77,30 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar code: The error code.
     :vartype code: str
     :ivar message: The error message.
     :vartype message: str
     :ivar inner_error: The key vault server error.
-    :vartype inner_error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype inner_error: ~azure.keyvault.v7_3.models.Error
     """
 
     _validation = {
         "code": {"readonly": True},
         "message": {"readonly": True},
         "inner_error": {"readonly": True},
     }
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -108,15 +108,15 @@
     """Full backup operation.
 
     :ivar status: Status of the backup operation.
     :vartype status: str
     :ivar status_details: The status details of backup operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the full backup operation.
-    :vartype error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype error: ~azure.keyvault.v7_3.models.Error
     :ivar start_time: The start time of the backup operation in UTC.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the backup operation in UTC.
     :vartype end_time: ~datetime.datetime
     :ivar job_id: Identifier for the full backup operation.
     :vartype job_id: str
     :ivar azure_storage_blob_container_uri: The Azure blob storage container Uri which contains the
@@ -140,23 +140,23 @@
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         job_id: Optional[str] = None,
         azure_storage_blob_container_uri: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the backup operation.
         :paramtype status: str
         :keyword status_details: The status details of backup operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the full backup operation.
-        :paramtype error: ~azure.keyvault.v7_4_preview_1.models.Error
+        :paramtype error: ~azure.keyvault.v7_3.models.Error
         :keyword start_time: The start time of the backup operation in UTC.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the backup operation in UTC.
         :paramtype end_time: ~datetime.datetime
         :keyword job_id: Identifier for the full backup operation.
         :paramtype job_id: str
         :keyword azure_storage_blob_container_uri: The Azure blob storage container Uri which contains
@@ -175,44 +175,44 @@
 
 class KeyVaultError(_serialization.Model):
     """The key vault error exception.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar error: The key vault server error.
-    :vartype error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype error: ~azure.keyvault.v7_3.models.Error
     """
 
     _validation = {
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class Permission(_serialization.Model):
     """Role definition permissions.
 
     :ivar actions: Action permissions that are granted.
     :vartype actions: list[str]
     :ivar not_actions: Action permissions that are excluded but not denied. They may be granted by
      other role definitions assigned to a principal.
     :vartype not_actions: list[str]
     :ivar data_actions: Data action permissions that are granted.
-    :vartype data_actions: list[str or ~azure.keyvault.v7_4_preview_1.models.DataAction]
+    :vartype data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
     :ivar not_data_actions: Data action permissions that are excluded but not denied. They may be
      granted by other role definitions assigned to a principal.
-    :vartype not_data_actions: list[str or ~azure.keyvault.v7_4_preview_1.models.DataAction]
+    :vartype not_data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
     """
 
     _attribute_map = {
         "actions": {"key": "actions", "type": "[str]"},
         "not_actions": {"key": "notActions", "type": "[str]"},
         "data_actions": {"key": "dataActions", "type": "[str]"},
         "not_data_actions": {"key": "notDataActions", "type": "[str]"},
@@ -221,27 +221,27 @@
     def __init__(
         self,
         *,
         actions: Optional[List[str]] = None,
         not_actions: Optional[List[str]] = None,
         data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
         not_data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword actions: Action permissions that are granted.
         :paramtype actions: list[str]
         :keyword not_actions: Action permissions that are excluded but not denied. They may be granted
          by other role definitions assigned to a principal.
         :paramtype not_actions: list[str]
         :keyword data_actions: Data action permissions that are granted.
-        :paramtype data_actions: list[str or ~azure.keyvault.v7_4_preview_1.models.DataAction]
+        :paramtype data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
         :keyword not_data_actions: Data action permissions that are excluded but not denied. They may
          be granted by other role definitions assigned to a principal.
-        :paramtype not_data_actions: list[str or ~azure.keyvault.v7_4_preview_1.models.DataAction]
+        :paramtype not_data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
         """
         super().__init__(**kwargs)
         self.actions = actions
         self.not_actions = not_actions
         self.data_actions = data_actions
         self.not_data_actions = not_data_actions
 
@@ -250,15 +250,15 @@
     """Restore operation.
 
     :ivar status: Status of the restore operation.
     :vartype status: str
     :ivar status_details: The status details of restore operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the restore operation.
-    :vartype error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype error: ~azure.keyvault.v7_3.models.Error
     :ivar job_id: Identifier for the restore operation.
     :vartype job_id: str
     :ivar start_time: The start time of the restore operation.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the restore operation.
     :vartype end_time: ~datetime.datetime
     """
@@ -277,23 +277,23 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the restore operation.
-        :paramtype error: ~azure.keyvault.v7_4_preview_1.models.Error
+        :paramtype error: ~azure.keyvault.v7_3.models.Error
         :keyword job_id: Identifier for the restore operation.
         :paramtype job_id: str
         :keyword start_time: The start time of the restore operation.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the restore operation.
         :paramtype end_time: ~datetime.datetime
         """
@@ -308,15 +308,15 @@
 
 class RestoreOperationParameters(_serialization.Model):
     """RestoreOperationParameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar sas_token_parameters: Required.
-    :vartype sas_token_parameters: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+    :vartype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
     :ivar folder_to_restore: The Folder name of the blob where the previous successful full backup
      was stored. Required.
     :vartype folder_to_restore: str
     """
 
     _validation = {
         "sas_token_parameters": {"required": True},
@@ -324,18 +324,20 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder_to_restore": {"key": "folderToRestore", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs):
+    def __init__(
+        self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs: Any
+    ) -> None:
         """
         :keyword sas_token_parameters: Required.
-        :paramtype sas_token_parameters: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+        :paramtype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
         :keyword folder_to_restore: The Folder name of the blob where the previous successful full
          backup was stored. Required.
         :paramtype folder_to_restore: str
         """
         super().__init__(**kwargs)
         self.sas_token_parameters = sas_token_parameters
         self.folder_to_restore = folder_to_restore
@@ -349,15 +351,15 @@
     :ivar id: The role assignment ID.
     :vartype id: str
     :ivar name: The role assignment name.
     :vartype name: str
     :ivar type: The role assignment type.
     :vartype type: str
     :ivar properties: Role assignment properties.
-    :vartype properties: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentPropertiesWithScope
+    :vartype properties: ~azure.keyvault.v7_3.models.RoleAssignmentPropertiesWithScope
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
     }
@@ -365,47 +367,49 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "properties": {"key": "properties", "type": "RoleAssignmentPropertiesWithScope"},
     }
 
-    def __init__(self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs):
+    def __init__(
+        self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword properties: Role assignment properties.
-        :paramtype properties: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentPropertiesWithScope
+        :paramtype properties: ~azure.keyvault.v7_3.models.RoleAssignmentPropertiesWithScope
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
         self.properties = properties
 
 
 class RoleAssignmentCreateParameters(_serialization.Model):
     """Role assignment create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar properties: Role assignment properties. Required.
-    :vartype properties: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentProperties
+    :vartype properties: ~azure.keyvault.v7_3.models.RoleAssignmentProperties
     """
 
     _validation = {
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleAssignmentProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role assignment properties. Required.
-        :paramtype properties: ~azure.keyvault.v7_4_preview_1.models.RoleAssignmentProperties
+        :paramtype properties: ~azure.keyvault.v7_3.models.RoleAssignmentProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
 
 class RoleAssignmentFilter(_serialization.Model):
     """Role Assignments filter.
@@ -414,43 +418,43 @@
     :vartype principal_id: str
     """
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, principal_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, principal_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword principal_id: Returns role assignment of the specific principal.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.principal_id = principal_id
 
 
 class RoleAssignmentListResult(_serialization.Model):
     """Role assignment list operation result.
 
     :ivar value: Role assignment list.
-    :vartype value: list[~azure.keyvault.v7_4_preview_1.models.RoleAssignment]
+    :vartype value: list[~azure.keyvault.v7_3.models.RoleAssignment]
     :ivar next_link: The URL to use for getting the next set of results.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleAssignment]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role assignment list.
-        :paramtype value: list[~azure.keyvault.v7_4_preview_1.models.RoleAssignment]
+        :paramtype value: list[~azure.keyvault.v7_3.models.RoleAssignment]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
@@ -473,15 +477,15 @@
     }
 
     _attribute_map = {
         "role_definition_id": {"key": "roleDefinitionId", "type": "str"},
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs):
+    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs: Any) -> None:
         """
         :keyword role_definition_id: The role definition ID used in the role assignment. Required.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID assigned to the role. This maps to the ID inside the
          Active Directory. It can point to a user, service principal, or security group. Required.
         :paramtype principal_id: str
         """
@@ -490,15 +494,15 @@
         self.principal_id = principal_id
 
 
 class RoleAssignmentPropertiesWithScope(_serialization.Model):
     """Role assignment properties with scope.
 
     :ivar scope: The role scope. Known values are: "/" and "/keys".
-    :vartype scope: str or ~azure.keyvault.v7_4_preview_1.models.RoleScope
+    :vartype scope: str or ~azure.keyvault.v7_3.models.RoleScope
     :ivar role_definition_id: The role definition ID.
     :vartype role_definition_id: str
     :ivar principal_id: The principal ID.
     :vartype principal_id: str
     """
 
     _attribute_map = {
@@ -509,19 +513,19 @@
 
     def __init__(
         self,
         *,
         scope: Optional[Union[str, "_models.RoleScope"]] = None,
         role_definition_id: Optional[str] = None,
         principal_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword scope: The role scope. Known values are: "/" and "/keys".
-        :paramtype scope: str or ~azure.keyvault.v7_4_preview_1.models.RoleScope
+        :paramtype scope: str or ~azure.keyvault.v7_3.models.RoleScope
         :keyword role_definition_id: The role definition ID.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.scope = scope
@@ -535,25 +539,25 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The role definition ID.
     :vartype id: str
     :ivar name: The role definition name.
     :vartype name: str
     :ivar type: The role definition type. "Microsoft.Authorization/roleDefinitions"
-    :vartype type: str or ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionType
+    :vartype type: str or ~azure.keyvault.v7_3.models.RoleDefinitionType
     :ivar role_name: The role name.
     :vartype role_name: str
     :ivar description: The role definition description.
     :vartype description: str
     :ivar role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-    :vartype role_type: str or ~azure.keyvault.v7_4_preview_1.models.RoleType
+    :vartype role_type: str or ~azure.keyvault.v7_3.models.RoleType
     :ivar permissions: Role definition permissions.
-    :vartype permissions: list[~azure.keyvault.v7_4_preview_1.models.Permission]
+    :vartype permissions: list[~azure.keyvault.v7_3.models.Permission]
     :ivar assignable_scopes: Role definition assignable scopes.
-    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_4_preview_1.models.RoleScope]
+    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
     }
@@ -573,27 +577,27 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-        :paramtype role_type: str or ~azure.keyvault.v7_4_preview_1.models.RoleType
+        :paramtype role_type: str or ~azure.keyvault.v7_3.models.RoleType
         :keyword permissions: Role definition permissions.
-        :paramtype permissions: list[~azure.keyvault.v7_4_preview_1.models.Permission]
+        :paramtype permissions: list[~azure.keyvault.v7_3.models.Permission]
         :keyword assignable_scopes: Role definition assignable scopes.
-        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_4_preview_1.models.RoleScope]
+        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
         self.role_name = role_name
         self.description = description
@@ -604,29 +608,29 @@
 
 class RoleDefinitionCreateParameters(_serialization.Model):
     """Role definition create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar properties: Role definition properties. Required.
-    :vartype properties: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionProperties
+    :vartype properties: ~azure.keyvault.v7_3.models.RoleDefinitionProperties
     """
 
     _validation = {
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleDefinitionProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role definition properties. Required.
-        :paramtype properties: ~azure.keyvault.v7_4_preview_1.models.RoleDefinitionProperties
+        :paramtype properties: ~azure.keyvault.v7_3.models.RoleDefinitionProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
 
 class RoleDefinitionFilter(_serialization.Model):
     """Role Definitions filter.
@@ -635,43 +639,43 @@
     :vartype role_name: str
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
     }
 
-    def __init__(self, *, role_name: Optional[str] = None, **kwargs):
+    def __init__(self, *, role_name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword role_name: Returns role definition with the specific name.
         :paramtype role_name: str
         """
         super().__init__(**kwargs)
         self.role_name = role_name
 
 
 class RoleDefinitionListResult(_serialization.Model):
     """Role definition list operation result.
 
     :ivar value: Role definition list.
-    :vartype value: list[~azure.keyvault.v7_4_preview_1.models.RoleDefinition]
+    :vartype value: list[~azure.keyvault.v7_3.models.RoleDefinition]
     :ivar next_link: The URL to use for getting the next set of results.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleDefinition]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role definition list.
-        :paramtype value: list[~azure.keyvault.v7_4_preview_1.models.RoleDefinition]
+        :paramtype value: list[~azure.keyvault.v7_3.models.RoleDefinition]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
@@ -680,19 +684,19 @@
     """Role definition properties.
 
     :ivar role_name: The role name.
     :vartype role_name: str
     :ivar description: The role definition description.
     :vartype description: str
     :ivar role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-    :vartype role_type: str or ~azure.keyvault.v7_4_preview_1.models.RoleType
+    :vartype role_type: str or ~azure.keyvault.v7_3.models.RoleType
     :ivar permissions: Role definition permissions.
-    :vartype permissions: list[~azure.keyvault.v7_4_preview_1.models.Permission]
+    :vartype permissions: list[~azure.keyvault.v7_3.models.Permission]
     :ivar assignable_scopes: Role definition assignable scopes.
-    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_4_preview_1.models.RoleScope]
+    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "role_type": {"key": "type", "type": "str"},
         "permissions": {"key": "permissions", "type": "[Permission]"},
@@ -703,27 +707,27 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-        :paramtype role_type: str or ~azure.keyvault.v7_4_preview_1.models.RoleType
+        :paramtype role_type: str or ~azure.keyvault.v7_3.models.RoleType
         :keyword permissions: Role definition permissions.
-        :paramtype permissions: list[~azure.keyvault.v7_4_preview_1.models.Permission]
+        :paramtype permissions: list[~azure.keyvault.v7_3.models.Permission]
         :keyword assignable_scopes: Role definition assignable scopes.
-        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_4_preview_1.models.RoleScope]
+        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
         """
         super().__init__(**kwargs)
         self.role_name = role_name
         self.description = description
         self.role_type = role_type
         self.permissions = permissions
         self.assignable_scopes = assignable_scopes
@@ -746,15 +750,15 @@
     }
 
     _attribute_map = {
         "storage_resource_uri": {"key": "storageResourceUri", "type": "str"},
         "token": {"key": "token", "type": "str"},
     }
 
-    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs):
+    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs: Any) -> None:
         """
         :keyword storage_resource_uri: Azure Blob storage container Uri. Required.
         :paramtype storage_resource_uri: str
         :keyword token: The SAS token pointing to an Azure Blob storage container. Required.
         :paramtype token: str
         """
         super().__init__(**kwargs)
@@ -766,15 +770,15 @@
     """Selective Key Restore operation.
 
     :ivar status: Status of the restore operation.
     :vartype status: str
     :ivar status_details: The status details of restore operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the selective key restore operation.
-    :vartype error: ~azure.keyvault.v7_4_preview_1.models.Error
+    :vartype error: ~azure.keyvault.v7_3.models.Error
     :ivar job_id: Identifier for the selective key restore operation.
     :vartype job_id: str
     :ivar start_time: The start time of the restore operation.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the restore operation.
     :vartype end_time: ~datetime.datetime
     """
@@ -793,23 +797,23 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the selective key restore operation.
-        :paramtype error: ~azure.keyvault.v7_4_preview_1.models.Error
+        :paramtype error: ~azure.keyvault.v7_3.models.Error
         :keyword job_id: Identifier for the selective key restore operation.
         :paramtype job_id: str
         :keyword start_time: The start time of the restore operation.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the restore operation.
         :paramtype end_time: ~datetime.datetime
         """
@@ -824,15 +828,15 @@
 
 class SelectiveKeyRestoreOperationParameters(_serialization.Model):
     """SelectiveKeyRestoreOperationParameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar sas_token_parameters: Required.
-    :vartype sas_token_parameters: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+    :vartype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
     :ivar folder: The Folder name of the blob where the previous successful full backup was stored.
      Required.
     :vartype folder: str
     """
 
     _validation = {
         "sas_token_parameters": {"required": True},
@@ -840,109 +844,18 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder": {"key": "folder", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs):
+    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs: Any) -> None:
         """
         :keyword sas_token_parameters: Required.
-        :paramtype sas_token_parameters: ~azure.keyvault.v7_4_preview_1.models.SASTokenParameter
+        :paramtype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
         :keyword folder: The Folder name of the blob where the previous successful full backup was
          stored. Required.
         :paramtype folder: str
         """
         super().__init__(**kwargs)
         self.sas_token_parameters = sas_token_parameters
         self.folder = folder
-
-
-class Setting(_serialization.Model):
-    """Setting.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar name: The account setting to be updated. Required.
-    :vartype name: str
-    :ivar value: The value of the pool setting. Required.
-    :vartype value: str
-    :ivar type: The type specifier of the value. "boolean"
-    :vartype type: str or ~azure.keyvault.v7_4_preview_1.models.SettingTypeEnum
-    """
-
-    _validation = {
-        "name": {"required": True},
-        "value": {"required": True},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "value": {"key": "value", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-    }
-
-    def __init__(
-        self, *, name: str, value: str, type: Optional[Union[str, "_models.SettingTypeEnum"]] = None, **kwargs
-    ):
-        """
-        :keyword name: The account setting to be updated. Required.
-        :paramtype name: str
-        :keyword value: The value of the pool setting. Required.
-        :paramtype value: str
-        :keyword type: The type specifier of the value. "boolean"
-        :paramtype type: str or ~azure.keyvault.v7_4_preview_1.models.SettingTypeEnum
-        """
-        super().__init__(**kwargs)
-        self.name = name
-        self.value = value
-        self.type = type
-
-
-class SettingsListResult(_serialization.Model):
-    """The settings list result.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar settings: A response message containing a list of account settings with their associated
-     value.
-    :vartype settings: list[~azure.keyvault.v7_4_preview_1.models.Setting]
-    """
-
-    _validation = {
-        "settings": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "settings": {"key": "settings", "type": "[Setting]"},
-    }
-
-    def __init__(self, **kwargs):
-        """ """
-        super().__init__(**kwargs)
-        self.settings = None
-
-
-class UpdateSettingsRequest(_serialization.Model):
-    """The update settings request object.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar value: The value of the pool setting. Required.
-    :vartype value: str
-    """
-
-    _validation = {
-        "value": {"required": True},
-    }
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "str"},
-    }
-
-    def __init__(self, *, value: str, **kwargs):
-        """
-        :keyword value: The value of the pool setting. Required.
-        :paramtype value: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/_vendor.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from abc import ABC
-from typing import TYPE_CHECKING
+from typing import List, TYPE_CHECKING, cast
 
 from azure.core.pipeline.transport import HttpRequest
 
 from ._configuration import KeyVaultClientConfiguration
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -29,15 +29,16 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
 
 
 class KeyVaultClientMixinABC(ABC):
     """DO NOT use this class. It is for internal typing use only."""
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,31 +22,28 @@
 
 class KeyVaultClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KeyVaultClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
-    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+    :keyword api_version: Api Version. Default value is "7.2". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.3")  # type: Literal["7.3"]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", "7.2")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(
-        self, **kwargs  # type: Any
-    ):
-        # type: (...) -> None
+    def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
         self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_key_vault_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any
 
 from azure.core import PipelineClient
 from azure.core.rest import HttpRequest, HttpResponse
 
-from . import models
+from . import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
@@ -32,17 +32,17 @@
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: PipelineClient = PipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -67,19 +67,16 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self):
-        # type: () -> None
+    def close(self) -> None:
         self._client.close()
 
-    def __enter__(self):
-        # type: () -> KeyVaultClient
+    def __enter__(self) -> "KeyVaultClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details):
-        # type: (Any) -> None
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_role_assignments_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -40,51 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -93,49 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -146,15 +146,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_3.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_2.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
@@ -173,46 +173,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -222,15 +222,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -245,21 +245,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create(
         self,
         vault_base_url: str,
@@ -282,15 +282,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create(
         self,
         vault_base_url: str,
@@ -304,39 +304,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_2.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -353,17 +353,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -373,60 +373,60 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_2.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -436,15 +436,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -454,22 +454,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.RoleAssignment]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_2.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -486,15 +486,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -505,36 +505,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,16 +40,16 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_full_backup_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -62,40 +62,40 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_backup_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/backup/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_full_restore_operation_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -108,49 +108,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_restore_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/restore/{jobId}/pending")
     path_format_arguments = {
         "jobId": _SERIALIZER.url("job_id", job_id, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_selective_key_restore_operation_request(key_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/keys/{keyName}/restore")
     path_format_arguments = {
         "keyName": _SERIALIZER.url("key_name", key_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -173,17 +173,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -201,17 +201,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -227,15 +227,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -246,29 +246,29 @@
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
          for at least next 24 hours from the time of making this call. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_3.models.SASTokenParameter
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_2.models.SASTokenParameter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -295,15 +295,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_backup(
         self,
         vault_base_url: str,
@@ -313,44 +313,44 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container. This
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
-        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_3.models.SASTokenParameter or IO
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
+        :type azure_storage_blob_container_uri: ~azure.keyvault.v7_2.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either FullBackupOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_backup_initial(  # type: ignore
+            raw_result = self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -372,79 +372,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace
     def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The id returned as part of the backup request. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: FullBackupOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.FullBackupOperation
+        :rtype: ~azure.keyvault.v7_2.models.FullBackupOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -454,15 +454,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -473,17 +473,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -501,17 +501,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -527,15 +527,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -545,29 +545,29 @@
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_3.models.RestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_2.models.RestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -593,15 +593,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_full_restore_operation(
         self,
         vault_base_url: str,
@@ -610,43 +610,44 @@
     ) -> LROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_3.models.RestoreOperationParameters or IO
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_2.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either RestoreOperation or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._full_restore_operation_initial(  # type: ignore
+            raw_result = self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -668,79 +669,79 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace
     def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param job_id: The Job Id returned part of the restore operation. Required.
         :type job_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RestoreOperation or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RestoreOperation
+        :rtype: ~azure.keyvault.v7_2.models.RestoreOperation
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -750,15 +751,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -770,17 +771,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -799,17 +800,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -825,15 +826,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -846,29 +847,29 @@
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
          successful full backup was stored. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperationParameters
+        :type restore_blob_details: ~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperationParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -897,15 +898,15 @@
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
@@ -917,44 +918,45 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
-        :type restore_blob_details: ~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperationParameters
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
+        :type restore_blob_details: ~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperationParameters
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either SelectiveKeyRestoreOperation or the
          result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
+        :rtype: ~azure.core.polling.LROPoller[~azure.keyvault.v7_2.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
+        api_version: Literal["7.2"] = kwargs.pop("api_version", _params.pop("api-version", "7.2"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -977,30 +979,30 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: PollingMethod = cast(
                 PollingMethod,
                 LROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: PollingMethod
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -40,51 +40,51 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
@@ -93,49 +93,49 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionName": _SERIALIZER.url("role_definition_name", role_definition_name, "str"),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
+    api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
 
-    _url = _format_url_section(_url, **path_format_arguments)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     if filter is not None:
         _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -188,32 +188,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -223,15 +223,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -308,16 +308,16 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.RoleDefinition
@@ -330,17 +330,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -357,17 +357,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -377,15 +377,17 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace
     def get(self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any) -> _models.RoleDefinition:
         """Get the specified role definition.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -405,32 +407,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -440,15 +442,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -463,16 +465,16 @@
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.keyvault.v7_3.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -489,15 +491,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -508,36 +510,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_vendor.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_configuration.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -29,23 +29,23 @@
     :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, **kwargs: Any) -> None:
         super(KeyVaultClientConfiguration, self).__init__(**kwargs)
-        api_version = kwargs.pop("api_version", "7.3")  # type: Literal["7.3"]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", "7.3")
 
         self.api_version = api_version
         kwargs.setdefault("sdk_moniker", "keyvault/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or policies.HttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._key_vault_client import KeyVaultClient
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+    from ._patch import *  # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClient",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/_key_vault_client.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_key_vault_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,41 +8,41 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable
 
 from azure.core import AsyncPipelineClient
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 
-from .. import models
+from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import KeyVaultClientConfiguration
 from .operations import KeyVaultClientOperationsMixin, RoleAssignmentsOperations, RoleDefinitionsOperations
 
 
 class KeyVaultClient(KeyVaultClientOperationsMixin):  # pylint: disable=client-accepts-api-version-keyword
     """The key vault client performs cryptographic key operations and vault operations against the Key
     Vault service.
 
     :ivar role_definitions: RoleDefinitionsOperations operations
-    :vartype role_definitions: azure.keyvault.v7_3.aio.operations.RoleDefinitionsOperations
+    :vartype role_definitions: azure.keyvault.v7_4.aio.operations.RoleDefinitionsOperations
     :ivar role_assignments: RoleAssignmentsOperations operations
-    :vartype role_assignments: azure.keyvault.v7_3.aio.operations.RoleAssignmentsOperations
-    :keyword api_version: Api Version. Default value is "7.3". Note that overriding this default
+    :vartype role_assignments: azure.keyvault.v7_4.aio.operations.RoleAssignmentsOperations
+    :keyword api_version: Api Version. Default value is "7.4". Note that overriding this default
      value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=missing-client-constructor-parameter-credential
         _endpoint = "{vaultBaseUrl}"
         self._config = KeyVaultClientConfiguration(**kwargs)
-        self._client = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
+        self._client: AsyncPipelineClient = AsyncPipelineClient(base_url=_endpoint, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_definitions = RoleDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.role_assignments = RoleAssignmentsOperations(
@@ -74,9 +74,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KeyVaultClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_assignments_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_role_assignments_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -46,15 +46,15 @@
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.keyvault.v7_3.aio.KeyVaultClient`'s
+        :class:`~azure.keyvault.v7_4.aio.KeyVaultClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
@@ -73,46 +73,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -122,15 +122,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @overload
     async def create(
         self,
         vault_base_url: str,
         scope: str,
         role_assignment_name: str,
@@ -145,21 +145,21 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
-        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters
+        :type parameters: ~azure.keyvault.v7_4.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         vault_base_url: str,
@@ -182,15 +182,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         vault_base_url: str,
@@ -204,39 +204,39 @@
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param scope: The scope of the role assignment to create. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to create. It can be any valid
          GUID. Required.
         :type role_assignment_name: str
-        :param parameters: Parameters for the role assignment. Is either a model type or a IO type.
-         Required.
-        :type parameters: ~azure.keyvault.v7_3.models.RoleAssignmentCreateParameters or IO
+        :param parameters: Parameters for the role assignment. Is either a
+         RoleAssignmentCreateParameters type or a IO type. Required.
+        :type parameters: ~azure.keyvault.v7_4.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -253,17 +253,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -273,15 +273,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    create.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_assignment_name: str, **kwargs: Any
     ) -> _models.RoleAssignment:
         """Get the specified role assignment.
 
@@ -289,46 +289,46 @@
         :type vault_base_url: str
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.keyvault.v7_3.models.RoleAssignment
+        :rtype: ~azure.keyvault.v7_4.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignment]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -338,15 +338,15 @@
         deserialized = self._deserialize("RoleAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"}
 
     @distributed_trace
     def list_for_scope(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignment"]:
         """Gets role assignments for a scope.
 
@@ -356,22 +356,22 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.RoleAssignment]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_4.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleAssignmentListResult]
+        api_version: Literal["7.4"] = kwargs.pop("api_version", _params.pop("api-version", "7.4"))
+        cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -388,15 +388,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -407,36 +407,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}  # type: ignore
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignments"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._key_vault_client_operations import KeyVaultClientOperationsMixin
 from ._role_definitions_operations import RoleDefinitionsOperations
 from ._role_assignments_operations import RoleAssignmentsOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "KeyVaultClientOperationsMixin",
     "RoleDefinitionsOperations",
     "RoleAssignmentsOperations",
 ]
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_key_vault_client_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -58,17 +58,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(azure_storage_blob_container_uri, (IO, bytes)):
             _content = azure_storage_blob_container_uri
         else:
@@ -86,17 +86,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -112,15 +112,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_backup_initial.metadata = {"url": "/backup"}  # type: ignore
+    _full_backup_initial.metadata = {"url": "/backup"}
 
     @overload
     async def begin_full_backup(
         self,
         vault_base_url: str,
         azure_storage_blob_container_uri: Optional[_models.SASTokenParameter] = None,
         *,
@@ -198,16 +198,16 @@
         """Creates a full backup using a user-provided SAS token to an Azure blob storage container. This
         operation is supported only by the Managed HSM service.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
          valid Azure blob container where full backup needs to be stored. This token needs to be valid
-         for at least next 24 hours from the time of making this call. Is either a model type or a IO
-         type. Default value is None.
+         for at least next 24 hours from the time of making this call. Is either a SASTokenParameter
+         type or a IO type. Default value is None.
         :type azure_storage_blob_container_uri: ~azure.keyvault.v7_3.models.SASTokenParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
@@ -220,22 +220,22 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_3.models.FullBackupOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_backup_initial(  # type: ignore
+            raw_result = await self._full_backup_initial(
                 vault_base_url=vault_base_url,
                 azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -257,37 +257,37 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_backup.metadata = {"url": "/backup"}  # type: ignore
+    begin_full_backup.metadata = {"url": "/backup"}
 
     @distributed_trace_async
     async def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.FullBackupOperation:
         """Returns the status of full backup operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -305,31 +305,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FullBackupOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.FullBackupOperation] = kwargs.pop("cls", None)
 
         request = build_full_backup_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.full_backup_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -339,15 +339,15 @@
         deserialized = self._deserialize("FullBackupOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}  # type: ignore
+    full_backup_status.metadata = {"url": "/backup/{jobId}/pending"}
 
     async def _full_restore_operation_initial(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[Union[_models.RestoreOperationParameters, IO]] = None,
         **kwargs: Any
     ) -> _models.RestoreOperation:
@@ -358,17 +358,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -386,17 +386,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -412,15 +412,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _full_restore_operation_initial.metadata = {"url": "/restore"}  # type: ignore
+    _full_restore_operation_initial.metadata = {"url": "/restore"}
 
     @overload
     async def begin_full_restore_operation(
         self,
         vault_base_url: str,
         restore_blob_details: Optional[_models.RestoreOperationParameters] = None,
         *,
@@ -495,15 +495,16 @@
     ) -> AsyncLROPoller[_models.RestoreOperation]:
         """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
         storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
+         successful full backup was stored. Is either a RestoreOperationParameters type or a IO type.
+         Default value is None.
         :type restore_blob_details: ~azure.keyvault.v7_3.models.RestoreOperationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncLROBasePolling. Pass in False
@@ -516,22 +517,22 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_3.models.RestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._full_restore_operation_initial(  # type: ignore
+            raw_result = await self._full_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -553,37 +554,37 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_full_restore_operation.metadata = {"url": "/restore"}  # type: ignore
+    begin_full_restore_operation.metadata = {"url": "/restore"}
 
     @distributed_trace_async
     async def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> _models.RestoreOperation:
         """Returns the status of restore operation.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
@@ -601,31 +602,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RestoreOperation] = kwargs.pop("cls", None)
 
         request = build_restore_status_request(
             job_id=job_id,
             api_version=api_version,
             template_url=self.restore_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -635,15 +636,15 @@
         deserialized = self._deserialize("RestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    restore_status.metadata = {"url": "/restore/{jobId}/pending"}  # type: ignore
+    restore_status.metadata = {"url": "/restore/{jobId}/pending"}
 
     async def _selective_key_restore_operation_initial(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[Union[_models.SelectiveKeyRestoreOperationParameters, IO]] = None,
         **kwargs: Any
@@ -655,17 +656,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(restore_blob_details, (IO, bytes)):
             _content = restore_blob_details
         else:
@@ -684,17 +685,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -710,15 +711,15 @@
         deserialized = self._deserialize("SelectiveKeyRestoreOperation", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
-    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    _selective_key_restore_operation_initial.metadata = {"url": "/keys/{keyName}/restore"}
 
     @overload
     async def begin_selective_key_restore_operation(
         self,
         vault_base_url: str,
         key_name: str,
         restore_blob_details: Optional[_models.SelectiveKeyRestoreOperationParameters] = None,
@@ -804,15 +805,16 @@
         stored Azure Blob storage backup folder.
 
         :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
         :type vault_base_url: str
         :param key_name: The name of the key to be restored from the user supplied backup. Required.
         :type key_name: str
         :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
-         successful full backup was stored. Is either a model type or a IO type. Default value is None.
+         successful full backup was stored. Is either a SelectiveKeyRestoreOperationParameters type or a
+         IO type. Default value is None.
         :type restore_blob_details: ~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperationParameters
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -827,22 +829,22 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.keyvault.v7_3.models.SelectiveKeyRestoreOperation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SelectiveKeyRestoreOperation]
-        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.SelectiveKeyRestoreOperation] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._selective_key_restore_operation_initial(  # type: ignore
+            raw_result = await self._selective_key_restore_operation_initial(
                 vault_base_url=vault_base_url,
                 key_name=key_name,
                 restore_blob_details=restore_blob_details,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -865,30 +867,30 @@
             return deserialized
 
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
 
         if polling is True:
-            polling_method = cast(
+            polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncLROBasePolling(
                     lro_delay,
                     lro_options={"final-state-via": "azure-async-operation"},
                     path_format_arguments=path_format_arguments,
                     **kwargs
                 ),
-            )  # type: AsyncPollingMethod
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}  # type: ignore
+    begin_selective_key_restore_operation.metadata = {"url": "/keys/{keyName}/restore"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/aio/operations/_role_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -88,32 +88,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -123,15 +123,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @overload
     async def create_or_update(
         self,
         vault_base_url: str,
         scope: str,
         role_definition_name: str,
@@ -208,16 +208,16 @@
         :type vault_base_url: str
         :param scope: The scope of the role definition to create or update. Managed HSM only supports
          '/'. Required.
         :type scope: str
         :param role_definition_name: The name of the role definition to create or update. It can be any
          valid GUID. Required.
         :type role_definition_name: str
-        :param parameters: Parameters for the role definition. Is either a model type or a IO type.
-         Required.
+        :param parameters: Parameters for the role definition. Is either a
+         RoleDefinitionCreateParameters type or a IO type. Required.
         :type parameters: ~azure.keyvault.v7_3.models.RoleDefinitionCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
         :rtype: ~azure.keyvault.v7_3.models.RoleDefinition
@@ -230,17 +230,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -257,17 +257,17 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -277,15 +277,17 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    create_or_update.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
+    }
 
     @distributed_trace_async
     async def get(
         self, vault_base_url: str, scope: str, role_definition_name: str, **kwargs: Any
     ) -> _models.RoleDefinition:
         """Get the specified role definition.
 
@@ -307,32 +309,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinition]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_name=role_definition_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         path_format_arguments = {
             "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
         }
-        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+        request.url = self._client.format_url(request.url, **path_format_arguments)
 
-        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -342,15 +344,15 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}  # type: ignore
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"}
 
     @distributed_trace
     def list(
         self, vault_base_url: str, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleDefinition"]:
         """Get all role definitions that are applicable at scope and above.
 
@@ -365,16 +367,16 @@
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.keyvault.v7_3.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version = kwargs.pop("api_version", _params.pop("api-version", "7.3"))  # type: Literal["7.3"]
-        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RoleDefinitionListResult]
+        api_version: Literal["7.3"] = kwargs.pop("api_version", _params.pop("api-version", "7.3"))
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -391,15 +393,15 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -410,36 +412,36 @@
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 path_format_arguments = {
                     "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                 }
-                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore
+                request.url = self._client.format_url(request.url, **path_format_arguments)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)
+                list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.KeyVaultError, pipeline_response)
                 raise HttpResponseError(response=response, model=error)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}  # type: ignore
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_patch.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_key_vault_client_enums.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_2/models/_key_vault_client_enums.py`

 * *Files 23% similar despite different names*

```diff
@@ -9,99 +9,93 @@
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
 class DataAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Supported permissions for data actions."""
 
-    #: Read HSM key metadata.
     READ_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/read/action"
-    #: Update an HSM key.
+    """Read HSM key metadata."""
     WRITE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/write/action"
-    #: Read deleted HSM key.
+    """Update an HSM key."""
     READ_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/read/action"
-    #: Recover deleted HSM key.
+    """Read deleted HSM key."""
     RECOVER_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/recover/action"
-    #: Backup HSM keys.
+    """Recover deleted HSM key."""
     BACKUP_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/backup/action"
-    #: Restore HSM keys.
+    """Backup HSM keys."""
     RESTORE_HSM_KEYS = "Microsoft.KeyVault/managedHsm/keys/restore/action"
-    #: Delete role assignment.
+    """Restore HSM keys."""
     DELETE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/delete/action"
-    #: Get role assignment.
+    """Delete role assignment."""
     GET_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/read/action"
-    #: Create or update role assignment.
+    """Get role assignment."""
     WRITE_ROLE_ASSIGNMENT = "Microsoft.KeyVault/managedHsm/roleAssignments/write/action"
-    #: Get role definition.
+    """Create or update role assignment."""
     READ_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/read/action"
-    #: Create or update role definition.
+    """Get role definition."""
     WRITE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/write/action"
-    #: Delete role definition.
+    """Create or update role definition."""
     DELETE_ROLE_DEFINITION = "Microsoft.KeyVault/managedHsm/roleDefinitions/delete/action"
-    #: Encrypt using an HSM key.
+    """Delete role definition."""
     ENCRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/encrypt/action"
-    #: Decrypt using an HSM key.
+    """Encrypt using an HSM key."""
     DECRYPT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/decrypt/action"
-    #: Wrap using an HSM key.
+    """Decrypt using an HSM key."""
     WRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/wrap/action"
-    #: Unwrap using an HSM key.
+    """Wrap using an HSM key."""
     UNWRAP_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/unwrap/action"
-    #: Sign using an HSM key.
+    """Unwrap using an HSM key."""
     SIGN_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/sign/action"
-    #: Verify using an HSM key.
+    """Sign using an HSM key."""
     VERIFY_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/verify/action"
-    #: Create an HSM key.
+    """Verify using an HSM key."""
     CREATE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/create"
-    #: Delete an HSM key.
+    """Create an HSM key."""
     DELETE_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/delete"
-    #: Export an HSM key.
+    """Delete an HSM key."""
     EXPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/export/action"
-    #: Release an HSM key using Secure Key Release.
-    RELEASE_KEY = "Microsoft.KeyVault/managedHsm/keys/release/action"
-    #: Import an HSM key.
+    """Export an HSM key."""
     IMPORT_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/import/action"
-    #: Purge a deleted HSM key.
+    """Import an HSM key."""
     PURGE_DELETED_HSM_KEY = "Microsoft.KeyVault/managedHsm/keys/deletedKeys/delete"
-    #: Download an HSM security domain.
+    """Purge a deleted HSM key."""
     DOWNLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/download/action"
-    #: Check status of HSM security domain download.
-    DOWNLOAD_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/download/read"
-    #: Upload an HSM security domain.
+    """Download an HSM security domain."""
     UPLOAD_HSM_SECURITY_DOMAIN = "Microsoft.KeyVault/managedHsm/securitydomain/upload/action"
-    #: Check the status of the HSM security domain exchange file.
+    """Upload an HSM security domain."""
     READ_HSM_SECURITY_DOMAIN_STATUS = "Microsoft.KeyVault/managedHsm/securitydomain/upload/read"
-    #: Download an HSM security domain transfer key.
+    """Check the status of the HSM security domain exchange file."""
     READ_HSM_SECURITY_DOMAIN_TRANSFER_KEY = "Microsoft.KeyVault/managedHsm/securitydomain/transferkey/read"
-    #: Start an HSM backup.
+    """Download an HSM security domain transfer key."""
     START_HSM_BACKUP = "Microsoft.KeyVault/managedHsm/backup/start/action"
-    #: Start an HSM restore.
+    """Start an HSM backup."""
     START_HSM_RESTORE = "Microsoft.KeyVault/managedHsm/restore/start/action"
-    #: Read an HSM backup status.
+    """Start an HSM restore."""
     READ_HSM_BACKUP_STATUS = "Microsoft.KeyVault/managedHsm/backup/status/action"
-    #: Read an HSM restore status.
+    """Read an HSM backup status."""
     READ_HSM_RESTORE_STATUS = "Microsoft.KeyVault/managedHsm/restore/status/action"
-    #: Generate random numbers.
-    RANDOM_NUMBERS_GENERATE = "Microsoft.KeyVault/managedHsm/rng/action"
+    """Read an HSM restore status."""
 
 
 class RoleDefinitionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role definition type."""
 
     MICROSOFT_AUTHORIZATION_ROLE_DEFINITIONS = "Microsoft.Authorization/roleDefinitions"
 
 
 class RoleScope(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role scope."""
 
-    #: Global scope
     GLOBAL = "/"
-    #: Keys scope
+    """Global scope"""
     KEYS = "/keys"
+    """Keys scope"""
 
 
 class RoleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The role type."""
 
-    #: Built in role.
     BUILT_IN_ROLE = "AKVBuiltInRole"
-    #: Custom role.
+    """Built in role."""
     CUSTOM_ROLE = "CustomRole"
+    """Custom role."""
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_3/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 from ._models_py3 import SelectiveKeyRestoreOperationParameters
 
 from ._key_vault_client_enums import DataAction
 from ._key_vault_client_enums import RoleDefinitionType
 from ._key_vault_client_enums import RoleScope
 from ._key_vault_client_enums import RoleType
 from ._patch import __all__ as _patch_all
-from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
+from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Attributes",
     "Error",
     "FullBackupOperation",
     "KeyVaultError",
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_generated/v7_3/models/_models_py3.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_generated/v7_4/models/_models_py3.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import List, Optional, TYPE_CHECKING, Union
+from typing import Any, List, Optional, TYPE_CHECKING, Union
 
 from ... import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -49,16 +49,16 @@
 
     def __init__(
         self,
         *,
         enabled: Optional[bool] = None,
         not_before: Optional[datetime.datetime] = None,
         expires: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword enabled: Determines whether the object is enabled.
         :paramtype enabled: bool
         :keyword not_before: Not before date in UTC.
         :paramtype not_before: ~datetime.datetime
         :keyword expires: Expiry date in UTC.
         :paramtype expires: ~datetime.datetime
@@ -77,30 +77,30 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar code: The error code.
     :vartype code: str
     :ivar message: The error message.
     :vartype message: str
     :ivar inner_error: The key vault server error.
-    :vartype inner_error: ~azure.keyvault.v7_3.models.Error
+    :vartype inner_error: ~azure.keyvault.v7_4.models.Error
     """
 
     _validation = {
         "code": {"readonly": True},
         "message": {"readonly": True},
         "inner_error": {"readonly": True},
     }
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "inner_error": {"key": "innererror", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.inner_error = None
 
 
@@ -108,15 +108,15 @@
     """Full backup operation.
 
     :ivar status: Status of the backup operation.
     :vartype status: str
     :ivar status_details: The status details of backup operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the full backup operation.
-    :vartype error: ~azure.keyvault.v7_3.models.Error
+    :vartype error: ~azure.keyvault.v7_4.models.Error
     :ivar start_time: The start time of the backup operation in UTC.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the backup operation in UTC.
     :vartype end_time: ~datetime.datetime
     :ivar job_id: Identifier for the full backup operation.
     :vartype job_id: str
     :ivar azure_storage_blob_container_uri: The Azure blob storage container Uri which contains the
@@ -140,23 +140,23 @@
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         job_id: Optional[str] = None,
         azure_storage_blob_container_uri: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the backup operation.
         :paramtype status: str
         :keyword status_details: The status details of backup operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the full backup operation.
-        :paramtype error: ~azure.keyvault.v7_3.models.Error
+        :paramtype error: ~azure.keyvault.v7_4.models.Error
         :keyword start_time: The start time of the backup operation in UTC.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the backup operation in UTC.
         :paramtype end_time: ~datetime.datetime
         :keyword job_id: Identifier for the full backup operation.
         :paramtype job_id: str
         :keyword azure_storage_blob_container_uri: The Azure blob storage container Uri which contains
@@ -175,44 +175,44 @@
 
 class KeyVaultError(_serialization.Model):
     """The key vault error exception.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar error: The key vault server error.
-    :vartype error: ~azure.keyvault.v7_3.models.Error
+    :vartype error: ~azure.keyvault.v7_4.models.Error
     """
 
     _validation = {
         "error": {"readonly": True},
     }
 
     _attribute_map = {
         "error": {"key": "error", "type": "Error"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.error = None
 
 
 class Permission(_serialization.Model):
     """Role definition permissions.
 
     :ivar actions: Action permissions that are granted.
     :vartype actions: list[str]
     :ivar not_actions: Action permissions that are excluded but not denied. They may be granted by
      other role definitions assigned to a principal.
     :vartype not_actions: list[str]
     :ivar data_actions: Data action permissions that are granted.
-    :vartype data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
+    :vartype data_actions: list[str or ~azure.keyvault.v7_4.models.DataAction]
     :ivar not_data_actions: Data action permissions that are excluded but not denied. They may be
      granted by other role definitions assigned to a principal.
-    :vartype not_data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
+    :vartype not_data_actions: list[str or ~azure.keyvault.v7_4.models.DataAction]
     """
 
     _attribute_map = {
         "actions": {"key": "actions", "type": "[str]"},
         "not_actions": {"key": "notActions", "type": "[str]"},
         "data_actions": {"key": "dataActions", "type": "[str]"},
         "not_data_actions": {"key": "notDataActions", "type": "[str]"},
@@ -221,27 +221,27 @@
     def __init__(
         self,
         *,
         actions: Optional[List[str]] = None,
         not_actions: Optional[List[str]] = None,
         data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
         not_data_actions: Optional[List[Union[str, "_models.DataAction"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword actions: Action permissions that are granted.
         :paramtype actions: list[str]
         :keyword not_actions: Action permissions that are excluded but not denied. They may be granted
          by other role definitions assigned to a principal.
         :paramtype not_actions: list[str]
         :keyword data_actions: Data action permissions that are granted.
-        :paramtype data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
+        :paramtype data_actions: list[str or ~azure.keyvault.v7_4.models.DataAction]
         :keyword not_data_actions: Data action permissions that are excluded but not denied. They may
          be granted by other role definitions assigned to a principal.
-        :paramtype not_data_actions: list[str or ~azure.keyvault.v7_3.models.DataAction]
+        :paramtype not_data_actions: list[str or ~azure.keyvault.v7_4.models.DataAction]
         """
         super().__init__(**kwargs)
         self.actions = actions
         self.not_actions = not_actions
         self.data_actions = data_actions
         self.not_data_actions = not_data_actions
 
@@ -250,15 +250,15 @@
     """Restore operation.
 
     :ivar status: Status of the restore operation.
     :vartype status: str
     :ivar status_details: The status details of restore operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the restore operation.
-    :vartype error: ~azure.keyvault.v7_3.models.Error
+    :vartype error: ~azure.keyvault.v7_4.models.Error
     :ivar job_id: Identifier for the restore operation.
     :vartype job_id: str
     :ivar start_time: The start time of the restore operation.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the restore operation.
     :vartype end_time: ~datetime.datetime
     """
@@ -277,23 +277,23 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the restore operation.
-        :paramtype error: ~azure.keyvault.v7_3.models.Error
+        :paramtype error: ~azure.keyvault.v7_4.models.Error
         :keyword job_id: Identifier for the restore operation.
         :paramtype job_id: str
         :keyword start_time: The start time of the restore operation.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the restore operation.
         :paramtype end_time: ~datetime.datetime
         """
@@ -308,15 +308,15 @@
 
 class RestoreOperationParameters(_serialization.Model):
     """RestoreOperationParameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar sas_token_parameters: Required.
-    :vartype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
+    :vartype sas_token_parameters: ~azure.keyvault.v7_4.models.SASTokenParameter
     :ivar folder_to_restore: The Folder name of the blob where the previous successful full backup
      was stored. Required.
     :vartype folder_to_restore: str
     """
 
     _validation = {
         "sas_token_parameters": {"required": True},
@@ -324,18 +324,20 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder_to_restore": {"key": "folderToRestore", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs):
+    def __init__(
+        self, *, sas_token_parameters: "_models.SASTokenParameter", folder_to_restore: str, **kwargs: Any
+    ) -> None:
         """
         :keyword sas_token_parameters: Required.
-        :paramtype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
+        :paramtype sas_token_parameters: ~azure.keyvault.v7_4.models.SASTokenParameter
         :keyword folder_to_restore: The Folder name of the blob where the previous successful full
          backup was stored. Required.
         :paramtype folder_to_restore: str
         """
         super().__init__(**kwargs)
         self.sas_token_parameters = sas_token_parameters
         self.folder_to_restore = folder_to_restore
@@ -349,15 +351,15 @@
     :ivar id: The role assignment ID.
     :vartype id: str
     :ivar name: The role assignment name.
     :vartype name: str
     :ivar type: The role assignment type.
     :vartype type: str
     :ivar properties: Role assignment properties.
-    :vartype properties: ~azure.keyvault.v7_3.models.RoleAssignmentPropertiesWithScope
+    :vartype properties: ~azure.keyvault.v7_4.models.RoleAssignmentPropertiesWithScope
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
     }
@@ -365,47 +367,49 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "properties": {"key": "properties", "type": "RoleAssignmentPropertiesWithScope"},
     }
 
-    def __init__(self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs):
+    def __init__(
+        self, *, properties: Optional["_models.RoleAssignmentPropertiesWithScope"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword properties: Role assignment properties.
-        :paramtype properties: ~azure.keyvault.v7_3.models.RoleAssignmentPropertiesWithScope
+        :paramtype properties: ~azure.keyvault.v7_4.models.RoleAssignmentPropertiesWithScope
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
         self.properties = properties
 
 
 class RoleAssignmentCreateParameters(_serialization.Model):
     """Role assignment create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar properties: Role assignment properties. Required.
-    :vartype properties: ~azure.keyvault.v7_3.models.RoleAssignmentProperties
+    :vartype properties: ~azure.keyvault.v7_4.models.RoleAssignmentProperties
     """
 
     _validation = {
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleAssignmentProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleAssignmentProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role assignment properties. Required.
-        :paramtype properties: ~azure.keyvault.v7_3.models.RoleAssignmentProperties
+        :paramtype properties: ~azure.keyvault.v7_4.models.RoleAssignmentProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
 
 class RoleAssignmentFilter(_serialization.Model):
     """Role Assignments filter.
@@ -414,43 +418,43 @@
     :vartype principal_id: str
     """
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, principal_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, principal_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword principal_id: Returns role assignment of the specific principal.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.principal_id = principal_id
 
 
 class RoleAssignmentListResult(_serialization.Model):
     """Role assignment list operation result.
 
     :ivar value: Role assignment list.
-    :vartype value: list[~azure.keyvault.v7_3.models.RoleAssignment]
+    :vartype value: list[~azure.keyvault.v7_4.models.RoleAssignment]
     :ivar next_link: The URL to use for getting the next set of results.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleAssignment]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleAssignment"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role assignment list.
-        :paramtype value: list[~azure.keyvault.v7_3.models.RoleAssignment]
+        :paramtype value: list[~azure.keyvault.v7_4.models.RoleAssignment]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
@@ -473,15 +477,15 @@
     }
 
     _attribute_map = {
         "role_definition_id": {"key": "roleDefinitionId", "type": "str"},
         "principal_id": {"key": "principalId", "type": "str"},
     }
 
-    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs):
+    def __init__(self, *, role_definition_id: str, principal_id: str, **kwargs: Any) -> None:
         """
         :keyword role_definition_id: The role definition ID used in the role assignment. Required.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID assigned to the role. This maps to the ID inside the
          Active Directory. It can point to a user, service principal, or security group. Required.
         :paramtype principal_id: str
         """
@@ -490,15 +494,15 @@
         self.principal_id = principal_id
 
 
 class RoleAssignmentPropertiesWithScope(_serialization.Model):
     """Role assignment properties with scope.
 
     :ivar scope: The role scope. Known values are: "/" and "/keys".
-    :vartype scope: str or ~azure.keyvault.v7_3.models.RoleScope
+    :vartype scope: str or ~azure.keyvault.v7_4.models.RoleScope
     :ivar role_definition_id: The role definition ID.
     :vartype role_definition_id: str
     :ivar principal_id: The principal ID.
     :vartype principal_id: str
     """
 
     _attribute_map = {
@@ -509,19 +513,19 @@
 
     def __init__(
         self,
         *,
         scope: Optional[Union[str, "_models.RoleScope"]] = None,
         role_definition_id: Optional[str] = None,
         principal_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword scope: The role scope. Known values are: "/" and "/keys".
-        :paramtype scope: str or ~azure.keyvault.v7_3.models.RoleScope
+        :paramtype scope: str or ~azure.keyvault.v7_4.models.RoleScope
         :keyword role_definition_id: The role definition ID.
         :paramtype role_definition_id: str
         :keyword principal_id: The principal ID.
         :paramtype principal_id: str
         """
         super().__init__(**kwargs)
         self.scope = scope
@@ -535,25 +539,25 @@
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: The role definition ID.
     :vartype id: str
     :ivar name: The role definition name.
     :vartype name: str
     :ivar type: The role definition type. "Microsoft.Authorization/roleDefinitions"
-    :vartype type: str or ~azure.keyvault.v7_3.models.RoleDefinitionType
+    :vartype type: str or ~azure.keyvault.v7_4.models.RoleDefinitionType
     :ivar role_name: The role name.
     :vartype role_name: str
     :ivar description: The role definition description.
     :vartype description: str
     :ivar role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-    :vartype role_type: str or ~azure.keyvault.v7_3.models.RoleType
+    :vartype role_type: str or ~azure.keyvault.v7_4.models.RoleType
     :ivar permissions: Role definition permissions.
-    :vartype permissions: list[~azure.keyvault.v7_3.models.Permission]
+    :vartype permissions: list[~azure.keyvault.v7_4.models.Permission]
     :ivar assignable_scopes: Role definition assignable scopes.
-    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
+    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_4.models.RoleScope]
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
     }
@@ -573,27 +577,27 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-        :paramtype role_type: str or ~azure.keyvault.v7_3.models.RoleType
+        :paramtype role_type: str or ~azure.keyvault.v7_4.models.RoleType
         :keyword permissions: Role definition permissions.
-        :paramtype permissions: list[~azure.keyvault.v7_3.models.Permission]
+        :paramtype permissions: list[~azure.keyvault.v7_4.models.Permission]
         :keyword assignable_scopes: Role definition assignable scopes.
-        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
+        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_4.models.RoleScope]
         """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
         self.role_name = role_name
         self.description = description
@@ -604,29 +608,29 @@
 
 class RoleDefinitionCreateParameters(_serialization.Model):
     """Role definition create parameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar properties: Role definition properties. Required.
-    :vartype properties: ~azure.keyvault.v7_3.models.RoleDefinitionProperties
+    :vartype properties: ~azure.keyvault.v7_4.models.RoleDefinitionProperties
     """
 
     _validation = {
         "properties": {"required": True},
     }
 
     _attribute_map = {
         "properties": {"key": "properties", "type": "RoleDefinitionProperties"},
     }
 
-    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs):
+    def __init__(self, *, properties: "_models.RoleDefinitionProperties", **kwargs: Any) -> None:
         """
         :keyword properties: Role definition properties. Required.
-        :paramtype properties: ~azure.keyvault.v7_3.models.RoleDefinitionProperties
+        :paramtype properties: ~azure.keyvault.v7_4.models.RoleDefinitionProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
 
 
 class RoleDefinitionFilter(_serialization.Model):
     """Role Definitions filter.
@@ -635,43 +639,43 @@
     :vartype role_name: str
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
     }
 
-    def __init__(self, *, role_name: Optional[str] = None, **kwargs):
+    def __init__(self, *, role_name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword role_name: Returns role definition with the specific name.
         :paramtype role_name: str
         """
         super().__init__(**kwargs)
         self.role_name = role_name
 
 
 class RoleDefinitionListResult(_serialization.Model):
     """Role definition list operation result.
 
     :ivar value: Role definition list.
-    :vartype value: list[~azure.keyvault.v7_3.models.RoleDefinition]
+    :vartype value: list[~azure.keyvault.v7_4.models.RoleDefinition]
     :ivar next_link: The URL to use for getting the next set of results.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoleDefinition]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs
-    ):
+        self, *, value: Optional[List["_models.RoleDefinition"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: Role definition list.
-        :paramtype value: list[~azure.keyvault.v7_3.models.RoleDefinition]
+        :paramtype value: list[~azure.keyvault.v7_4.models.RoleDefinition]
         :keyword next_link: The URL to use for getting the next set of results.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
@@ -680,19 +684,19 @@
     """Role definition properties.
 
     :ivar role_name: The role name.
     :vartype role_name: str
     :ivar description: The role definition description.
     :vartype description: str
     :ivar role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-    :vartype role_type: str or ~azure.keyvault.v7_3.models.RoleType
+    :vartype role_type: str or ~azure.keyvault.v7_4.models.RoleType
     :ivar permissions: Role definition permissions.
-    :vartype permissions: list[~azure.keyvault.v7_3.models.Permission]
+    :vartype permissions: list[~azure.keyvault.v7_4.models.Permission]
     :ivar assignable_scopes: Role definition assignable scopes.
-    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
+    :vartype assignable_scopes: list[str or ~azure.keyvault.v7_4.models.RoleScope]
     """
 
     _attribute_map = {
         "role_name": {"key": "roleName", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "role_type": {"key": "type", "type": "str"},
         "permissions": {"key": "permissions", "type": "[Permission]"},
@@ -703,27 +707,27 @@
         self,
         *,
         role_name: Optional[str] = None,
         description: Optional[str] = None,
         role_type: Optional[Union[str, "_models.RoleType"]] = None,
         permissions: Optional[List["_models.Permission"]] = None,
         assignable_scopes: Optional[List[Union[str, "_models.RoleScope"]]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role_name: The role name.
         :paramtype role_name: str
         :keyword description: The role definition description.
         :paramtype description: str
         :keyword role_type: The role type. Known values are: "AKVBuiltInRole" and "CustomRole".
-        :paramtype role_type: str or ~azure.keyvault.v7_3.models.RoleType
+        :paramtype role_type: str or ~azure.keyvault.v7_4.models.RoleType
         :keyword permissions: Role definition permissions.
-        :paramtype permissions: list[~azure.keyvault.v7_3.models.Permission]
+        :paramtype permissions: list[~azure.keyvault.v7_4.models.Permission]
         :keyword assignable_scopes: Role definition assignable scopes.
-        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_3.models.RoleScope]
+        :paramtype assignable_scopes: list[str or ~azure.keyvault.v7_4.models.RoleScope]
         """
         super().__init__(**kwargs)
         self.role_name = role_name
         self.description = description
         self.role_type = role_type
         self.permissions = permissions
         self.assignable_scopes = assignable_scopes
@@ -746,15 +750,15 @@
     }
 
     _attribute_map = {
         "storage_resource_uri": {"key": "storageResourceUri", "type": "str"},
         "token": {"key": "token", "type": "str"},
     }
 
-    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs):
+    def __init__(self, *, storage_resource_uri: str, token: str, **kwargs: Any) -> None:
         """
         :keyword storage_resource_uri: Azure Blob storage container Uri. Required.
         :paramtype storage_resource_uri: str
         :keyword token: The SAS token pointing to an Azure Blob storage container. Required.
         :paramtype token: str
         """
         super().__init__(**kwargs)
@@ -766,15 +770,15 @@
     """Selective Key Restore operation.
 
     :ivar status: Status of the restore operation.
     :vartype status: str
     :ivar status_details: The status details of restore operation.
     :vartype status_details: str
     :ivar error: Error encountered, if any, during the selective key restore operation.
-    :vartype error: ~azure.keyvault.v7_3.models.Error
+    :vartype error: ~azure.keyvault.v7_4.models.Error
     :ivar job_id: Identifier for the selective key restore operation.
     :vartype job_id: str
     :ivar start_time: The start time of the restore operation.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the restore operation.
     :vartype end_time: ~datetime.datetime
     """
@@ -793,23 +797,23 @@
         *,
         status: Optional[str] = None,
         status_details: Optional[str] = None,
         error: Optional["_models.Error"] = None,
         job_id: Optional[str] = None,
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Status of the restore operation.
         :paramtype status: str
         :keyword status_details: The status details of restore operation.
         :paramtype status_details: str
         :keyword error: Error encountered, if any, during the selective key restore operation.
-        :paramtype error: ~azure.keyvault.v7_3.models.Error
+        :paramtype error: ~azure.keyvault.v7_4.models.Error
         :keyword job_id: Identifier for the selective key restore operation.
         :paramtype job_id: str
         :keyword start_time: The start time of the restore operation.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The end time of the restore operation.
         :paramtype end_time: ~datetime.datetime
         """
@@ -824,15 +828,15 @@
 
 class SelectiveKeyRestoreOperationParameters(_serialization.Model):
     """SelectiveKeyRestoreOperationParameters.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar sas_token_parameters: Required.
-    :vartype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
+    :vartype sas_token_parameters: ~azure.keyvault.v7_4.models.SASTokenParameter
     :ivar folder: The Folder name of the blob where the previous successful full backup was stored.
      Required.
     :vartype folder: str
     """
 
     _validation = {
         "sas_token_parameters": {"required": True},
@@ -840,18 +844,109 @@
     }
 
     _attribute_map = {
         "sas_token_parameters": {"key": "sasTokenParameters", "type": "SASTokenParameter"},
         "folder": {"key": "folder", "type": "str"},
     }
 
-    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs):
+    def __init__(self, *, sas_token_parameters: "_models.SASTokenParameter", folder: str, **kwargs: Any) -> None:
         """
         :keyword sas_token_parameters: Required.
-        :paramtype sas_token_parameters: ~azure.keyvault.v7_3.models.SASTokenParameter
+        :paramtype sas_token_parameters: ~azure.keyvault.v7_4.models.SASTokenParameter
         :keyword folder: The Folder name of the blob where the previous successful full backup was
          stored. Required.
         :paramtype folder: str
         """
         super().__init__(**kwargs)
         self.sas_token_parameters = sas_token_parameters
         self.folder = folder
+
+
+class Setting(_serialization.Model):
+    """Setting.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar name: The account setting to be updated. Required.
+    :vartype name: str
+    :ivar value: The value of the pool setting. Required.
+    :vartype value: str
+    :ivar type: The type specifier of the value. "boolean"
+    :vartype type: str or ~azure.keyvault.v7_4.models.SettingTypeEnum
+    """
+
+    _validation = {
+        "name": {"required": True},
+        "value": {"required": True},
+    }
+
+    _attribute_map = {
+        "name": {"key": "name", "type": "str"},
+        "value": {"key": "value", "type": "str"},
+        "type": {"key": "type", "type": "str"},
+    }
+
+    def __init__(
+        self, *, name: str, value: str, type: Optional[Union[str, "_models.SettingTypeEnum"]] = None, **kwargs: Any
+    ) -> None:
+        """
+        :keyword name: The account setting to be updated. Required.
+        :paramtype name: str
+        :keyword value: The value of the pool setting. Required.
+        :paramtype value: str
+        :keyword type: The type specifier of the value. "boolean"
+        :paramtype type: str or ~azure.keyvault.v7_4.models.SettingTypeEnum
+        """
+        super().__init__(**kwargs)
+        self.name = name
+        self.value = value
+        self.type = type
+
+
+class SettingsListResult(_serialization.Model):
+    """The settings list result.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar settings: A response message containing a list of account settings with their associated
+     value.
+    :vartype settings: list[~azure.keyvault.v7_4.models.Setting]
+    """
+
+    _validation = {
+        "settings": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "settings": {"key": "settings", "type": "[Setting]"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.settings = None
+
+
+class UpdateSettingRequest(_serialization.Model):
+    """The update settings request object.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar value: The value of the pool setting. Required.
+    :vartype value: str
+    """
+
+    _validation = {
+        "value": {"required": True},
+    }
+
+    _attribute_map = {
+        "value": {"key": "value", "type": "str"},
+    }
+
+    def __init__(self, *, value: str, **kwargs: Any) -> None:
+        """
+        :keyword value: The value of the pool setting. Required.
+        :paramtype value: str
+        """
+        super().__init__(**kwargs)
+        self.value = value
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge_cache.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,89 +1,91 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import threading
-
-try:
-    import urllib.parse as parse
-except ImportError:
-    import urlparse as parse  # type: ignore
+from urllib import parse
 
 try:
     from typing import TYPE_CHECKING
 except ImportError:
     TYPE_CHECKING = False
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import
-    from typing import Dict
+    from typing import Dict, Optional
     from .http_challenge import HttpChallenge
 
 
 _cache = {}  # type: Dict[str, HttpChallenge]
 _lock = threading.Lock()
 
 
-def get_challenge_for_url(url):
-    """ Gets the challenge for the cached URL.
-    :param url: the URL the challenge is cached for.
-    :rtype: HttpBearerChallenge """
+def get_challenge_for_url(url: str) -> "Optional[HttpChallenge]":
+    """Gets the challenge for the cached URL.
+
+    :param str url: the URL the challenge is cached for.
+    """
 
     if not url:
         raise ValueError("URL cannot be None")
 
     key = _get_cache_key(url)
 
     with _lock:
         return _cache.get(key)
 
 
-def _get_cache_key(url):
+def _get_cache_key(url: str) -> str:
     """Use the URL's netloc as cache key except when the URL specifies the default port for its scheme. In that case
     use the netloc without the port. That is to say, https://foo.bar and https://foo.bar:443 are considered equivalent.
 
     This equivalency prevents an unnecessary challenge when using Key Vault's paging API. The Key Vault client doesn't
     specify ports, but Key Vault's next page links do, so a redundant challenge would otherwise be executed when the
     client requests the next page."""
 
     parsed = parse.urlparse(url)
     if parsed.scheme == "https" and parsed.port == 443:
         return parsed.netloc[:-4]
     return parsed.netloc
 
 
-def remove_challenge_for_url(url):
-    """ Removes the cached challenge for the specified URL.
-    :param url: the URL for which to remove the cached challenge """
+def remove_challenge_for_url(url: str) -> None:
+    """Removes the cached challenge for the specified URL.
+
+    :param str url: the URL for which to remove the cached challenge
+    """
     if not url:
         raise ValueError("URL cannot be empty")
 
-    url = parse.urlparse(url)
+    parsed = parse.urlparse(url)
 
     with _lock:
-        del _cache[url.netloc]
+        del _cache[parsed.netloc]
+
 
+def set_challenge_for_url(url: str, challenge: "HttpChallenge") -> None:
+    """Caches the challenge for the specified URL.
 
-def set_challenge_for_url(url, challenge):
-    """ Caches the challenge for the specified URL.
-    :param url: the URL for which to cache the challenge
-    :param challenge: the challenge to cache """
+    :param str url: the URL for which to cache the challenge
+    :param challenge: the challenge to cache
+    :type challenge: HttpChallenge
+    """
     if not url:
         raise ValueError("URL cannot be empty")
 
     if not challenge:
         raise ValueError("Challenge cannot be empty")
 
     src_url = parse.urlparse(url)
     if src_url.netloc != challenge.source_authority:
         raise ValueError("Source URL and Challenge URL do not match")
 
     with _lock:
         _cache[src_url.netloc] = challenge
 
 
-def clear():
-    """ Clears the cache. """
+def clear() -> None:
+    """Clears the cache."""
 
     with _lock:
         _cache.clear()
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/polling.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/polling.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,33 +1,37 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import base64
+from typing import TYPE_CHECKING
 
 from azure.core.polling.base_polling import LROBasePolling, OperationFailed, OperationResourcePolling
 
+if TYPE_CHECKING:
+    from azure.core.pipeline import PipelineResponse
+    from azure.core.rest import HttpResponse
+
 
 class KeyVaultBackupClientPolling(OperationResourcePolling):
-    def __init__(self):
-        self._polling_url = None
+    def __init__(self) -> None:
+        self._polling_url = ""
         super(KeyVaultBackupClientPolling, self).__init__(operation_location_header="azure-asyncoperation")
 
-    def get_polling_url(self):
+    def get_polling_url(self) -> str:
         return self._polling_url
 
-    def get_final_get_url(self, pipeline_response):
+    def get_final_get_url(self, pipeline_response: "PipelineResponse") -> None:
         return None
 
-    def set_initial_status(self, pipeline_response):
-        response = pipeline_response.http_response
+    def set_initial_status(self, pipeline_response: "PipelineResponse") -> str:
+        response = pipeline_response.http_response  # type: HttpResponse
         self._polling_url = response.headers["azure-asyncoperation"]
 
         if response.status_code in {200, 201, 202, 204}:
             return self.get_status(pipeline_response)
         raise OperationFailed("Operation failed or canceled")
 
 
 class KeyVaultBackupClientPollingMethod(LROBasePolling):
-    def get_continuation_token(self):
-        # type: () -> str
+    def get_continuation_token(self) -> str:
         return base64.b64encode(self._operation.get_polling_url().encode()).decode("ascii")
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/client_base.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_client_base.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,99 +1,111 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-
 from typing import TYPE_CHECKING
-from enum import Enum
 
-from azure.core import CaseInsensitiveEnumMeta
 from azure.core.pipeline.policies import HttpLoggingPolicy
+from azure.core.tracing.decorator_async import distributed_trace_async
 
-from . import ChallengeAuthPolicy
-from .._generated import KeyVaultClient as _KeyVaultClient
+from . import AsyncChallengeAuthPolicy
+from .client_base import ApiVersion, DEFAULT_VERSION, _format_api_version, _SERIALIZER
 from .._sdk_moniker import SDK_MONIKER
+from .._generated.aio import KeyVaultClient as _KeyVaultClient
 
 if TYPE_CHECKING:
-    # pylint:disable=unused-import,ungrouped-imports
-    from typing import Any
-    from azure.core.credentials import TokenCredential
-
-
-class ApiVersion(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Key Vault API versions supported by this package"""
-
-    #: this is the default version
-    V7_4_PREVIEW_1 = "7.4-preview.1"
-    V7_3 = "7.3"
-    V7_2 = "7.2"
-
-
-DEFAULT_VERSION = ApiVersion.V7_4_PREVIEW_1
+    # pylint:disable=unused-import
+    from typing import Any, Awaitable
+    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.rest import AsyncHttpResponse, HttpRequest
 
 
-class KeyVaultClientBase(object):
-    def __init__(self, vault_url, credential, **kwargs):
-        # type: (str, TokenCredential, **Any) -> None
+class AsyncKeyVaultClientBase(object):
+    # pylint:disable=protected-access
+    def __init__(self, vault_url: str, credential: "AsyncTokenCredential", **kwargs) -> None:
         if not credential:
             raise ValueError(
-                "credential should be an object supporting the TokenCredential protocol, "
+                "credential should be an object supporting the AsyncTokenCredential protocol, "
                 "such as a credential from azure-identity"
             )
         if not vault_url:
             raise ValueError("vault_url must be the URL of an Azure Key Vault")
 
         try:
-            api_version = kwargs.pop("api_version", DEFAULT_VERSION)
+            self.api_version = kwargs.pop("api_version", DEFAULT_VERSION)
             # If API version was provided as an enum value, need to make a plain string for 3.11 compatibility
-            if hasattr(api_version, "value"):
-                api_version = api_version.value
+            if hasattr(self.api_version, "value"):
+                self.api_version = self.api_version.value
             self._vault_url = vault_url.strip(" /")
             client = kwargs.get("generated_client")
             if client:
                 # caller provided a configured client -> only models left to initialize
                 self._client = client
                 models = kwargs.get("generated_models")
-                self._models = models or _KeyVaultClient.models(api_version=api_version)
+                self._models = models or _KeyVaultClient.models(api_version=self.api_version)
                 return
 
             http_logging_policy = HttpLoggingPolicy(**kwargs)
             http_logging_policy.allowed_header_names.update(
-                {"x-ms-keyvault-network-info", "x-ms-keyvault-region", "x-ms-keyvault-service-version"}
+                {
+                    "x-ms-keyvault-network-info",
+                    "x-ms-keyvault-region",
+                    "x-ms-keyvault-service-version"
+                }
             )
 
             verify_challenge = kwargs.pop("verify_challenge_resource", True)
             self._client = _KeyVaultClient(
-                api_version=api_version,
-                authentication_policy=ChallengeAuthPolicy(credential, verify_challenge_resource=verify_challenge),
+                api_version=self.api_version,
+                authentication_policy=AsyncChallengeAuthPolicy(credential, verify_challenge_resource=verify_challenge),
                 sdk_moniker=SDK_MONIKER,
                 http_logging_policy=http_logging_policy,
                 **kwargs
             )
-            self._models = _KeyVaultClient.models(api_version=api_version)
+            self._models = _KeyVaultClient.models(api_version=self.api_version)
         except ValueError:
             raise NotImplementedError(
-                "This package doesn't support API version '{}'. ".format(api_version)
-                + "Supported versions: {}".format(", ".join(v.value for v in ApiVersion))
+                f"This package doesn't support API version '{self.api_version}'. "
+                + f"Supported versions: {', '.join(v.value for v in ApiVersion)}"
             )
 
     @property
-    def vault_url(self):
-        # type: () -> str
+    def vault_url(self) -> str:
         return self._vault_url
 
-    def __enter__(self):
-        # type: () -> KeyVaultClientBase
-        self._client.__enter__()
+    async def __aenter__(self) -> "AsyncKeyVaultClientBase":
+        await self._client.__aenter__()
         return self
 
-    def __exit__(self, *args):
-        # type: (*Any) -> None
-        self._client.__exit__(*args)
+    async def __aexit__(self, *args: "Any") -> None:
+        await self._client.__aexit__(*args)
 
-    def close(self):
-        # type: () -> None
+    async def close(self) -> None:
         """Close sockets opened by the client.
 
         Calling this method is unnecessary when using the client as a context manager.
         """
-        self._client.close()
+        await self._client.close()
+
+    @distributed_trace_async
+    def send_request(self, request: "HttpRequest", *, stream: bool = False, **kwargs) -> "Awaitable[AsyncHttpResponse]":
+        """Runs a network request using the client's existing pipeline.
+
+        The request URL can be relative to the vault URL. The service API version used for the request is the same as
+        the client's unless otherwise specified. This method does not raise if the response is an error; to raise an
+        exception, call `raise_for_status()` on the returned response object. For more information about how to send
+        custom requests with this method, see https://aka.ms/azsdk/dpcodegen/python/send_request.
+
+        :param request: The network request you want to make.
+        :type request: ~azure.core.rest.HttpRequest
+
+        :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
+
+        :return: The response of your network call. Does not do error handling on your response.
+        :rtype: ~azure.core.rest.AsyncHttpResponse
+        """
+        request_copy = _format_api_version(request, self.api_version)
+        path_format_arguments = {
+            "vaultBaseUrl": _SERIALIZER.url("vault_base_url", self._vault_url, "str", skip_quote=True),
+        }
+        request_copy.url = self._client._client.format_url(request_copy.url, **path_format_arguments)
+        return self._client._client.send_request(request_copy, stream=stream, **kwargs)
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/challenge_auth_policy.py`

 * *Files 5% similar despite different names*

```diff
@@ -31,71 +31,66 @@
 
 if TYPE_CHECKING:
     from typing import Any, Optional
     from azure.core.credentials import AccessToken, TokenCredential
     from azure.core.pipeline import PipelineResponse
 
 
-def _enforce_tls(request):
-    # type: (PipelineRequest) -> None
+def _enforce_tls(request: PipelineRequest) -> None:
     if not request.http_request.url.lower().startswith("https"):
         raise ServiceRequestError(
             "Bearer token authentication is not permitted for non-TLS protected (non-https) URLs."
         )
 
 
-def _update_challenge(request, challenger):
-    # type: (PipelineRequest, PipelineResponse) -> HttpChallenge
-    """parse challenge from challenger, cache it, return it"""
+def _update_challenge(request: PipelineRequest, challenger: "PipelineResponse") -> HttpChallenge:
+    """Parse challenge from challenger, cache it, return it"""
 
     challenge = HttpChallenge(
         request.http_request.url,
         challenger.http_response.headers.get("WWW-Authenticate"),
         response_headers=challenger.http_response.headers,
     )
     ChallengeCache.set_challenge_for_url(request.http_request.url, challenge)
     return challenge
 
 
 class ChallengeAuthPolicy(BearerTokenCredentialPolicy):
-    """policy for handling HTTP authentication challenges"""
+    """Policy for handling HTTP authentication challenges"""
 
-    def __init__(self, credential, *scopes, **kwargs):
-        # type: (TokenCredential, *str, **Any) -> None
+    def __init__(self, credential: "TokenCredential", *scopes: str, **kwargs) -> None:
         super(ChallengeAuthPolicy, self).__init__(credential, *scopes, **kwargs)
         self._credential = credential
         self._token = None  # type: Optional[AccessToken]
         self._verify_challenge_resource = kwargs.pop("verify_challenge_resource", True)
 
-    def on_request(self, request):
-        # type: (PipelineRequest) -> None
+    def on_request(self, request: PipelineRequest) -> None:
         _enforce_tls(request)
         challenge = ChallengeCache.get_challenge_for_url(request.http_request.url)
         if challenge:
             # Note that if the vault has moved to a new tenant since our last request for it, this request will fail.
             if self._need_new_token:
                 # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
                 scope = challenge.get_scope() or challenge.get_resource() + "/.default"
                 self._token = self._credential.get_token(scope, tenant_id=challenge.tenant_id)
 
             # ignore mypy's warning -- although self._token is Optional, get_token raises when it fails to get a token
-            request.http_request.headers["Authorization"] = "Bearer {}".format(self._token.token)  # type: ignore
+            request.http_request.headers["Authorization"] = f"Bearer {self._token.token}"  # type: ignore
             return
 
         # else: discover authentication information by eliciting a challenge from Key Vault. Remove any request data,
         # saving it for later. Key Vault will reject the request as unauthorized and respond with a challenge.
         # on_challenge will parse that challenge, reattach any body removed here, authorize the request, and tell
         # super to send it again.
         if request.http_request.body:
             request.context["key_vault_request_data"] = request.http_request.body
             request.http_request.set_json_body(None)
             request.http_request.headers["Content-Length"] = "0"
 
-    def on_challenge(self, request, response):
-        # type: (PipelineRequest, PipelineResponse) -> bool
+    def on_challenge(self, request: PipelineRequest, response: "PipelineResponse") -> bool:
         try:
             challenge = _update_challenge(request, response)
             # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
             scope = challenge.get_scope() or challenge.get_resource() + "/.default"
         except ValueError:
             return False
 
@@ -110,15 +105,20 @@
                     f"The challenge resource '{resource_domain}' does not match the requested domain. Pass "
                     "`verify_challenge_resource=False` to your client's constructor to disable this verification. "
                     "See https://aka.ms/azsdk/blog/vault-uri for more information."
                 )
 
         body = request.context.pop("key_vault_request_data", None)
         request.http_request.set_text_body(body)  # no-op when text is None
-        self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        # The tenant parsed from AD FS challenges is "adfs"; we don't actually need a tenant for AD FS authentication
+        # For AD FS we skip cross-tenant authentication per https://github.com/Azure/azure-sdk-for-python/issues/28648
+        if challenge.tenant_id and challenge.tenant_id.lower().endswith("adfs"):
+            self.authorize_request(request, scope)
+        else:
+            self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
 
         return True
 
     @property
-    def _need_new_token(self):
-        # type: () -> bool
+    def _need_new_token(self) -> bool:
         return not self._token or self._token.expires_on - time.time() < 300
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/http_challenge.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/http_challenge.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,26 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
-try:
-    import urllib.parse as parse
-except ImportError:
-    import urlparse as parse  # type: ignore
+from typing import TYPE_CHECKING
+from urllib import parse
+
+if TYPE_CHECKING:
+    from typing import Dict, MutableMapping, Optional
 
 
 class HttpChallenge(object):
-    def __init__(self, request_uri, challenge, response_headers=None):
-        """ Parses an HTTP WWW-Authentication Bearer challenge from a server. """
+    def __init__(
+        self, request_uri: str, challenge: str, response_headers: "Optional[MutableMapping[str, str]]" = None
+    ) -> None:
+        """Parses an HTTP WWW-Authentication Bearer challenge from a server."""
         self.source_authority = self._validate_request_uri(request_uri)
         self.source_uri = request_uri
-        self._parameters = {}
+        self._parameters = {}  # type: Dict[str, str]
 
         # get the scheme of the challenge and remove from the challenge string
         trimmed_challenge = self._validate_challenge(challenge)
         split_challenge = trimmed_challenge.split(" ", 1)
         self.scheme = split_challenge[0]
         trimmed_challenge = split_challenge[1]
 
@@ -38,82 +41,81 @@
 
         # must specify authorization or authorization_uri
         if "authorization" not in self._parameters and "authorization_uri" not in self._parameters:
             raise ValueError("Invalid challenge parameters")
 
         authorization_uri = self.get_authorization_server()
         # the authorization server URI should look something like https://login.windows.net/tenant-id
-        uri_path = parse.urlparse(authorization_uri).path.lstrip("/")
+        raw_uri_path = str(parse.urlparse(authorization_uri).path)
+        uri_path = raw_uri_path.lstrip("/")
         self.tenant_id = uri_path.split("/")[0] or None
 
         # if the response headers were supplied
         if response_headers:
             # get the message signing key and message key encryption key from the headers
             self.server_signature_key = response_headers.get("x-ms-message-signing-key", None)
             self.server_encryption_key = response_headers.get("x-ms-message-encryption-key", None)
 
-    def is_bearer_challenge(self):
-        """ Tests whether the HttpChallenge a Bearer challenge.
-        rtype: bool """
+    def is_bearer_challenge(self) -> bool:
+        """Tests whether the HttpChallenge a Bearer challenge."""
         if not self.scheme:
             return False
 
         return self.scheme.lower() == "bearer"
 
-    def is_pop_challenge(self):
-        """ Tests whether the HttpChallenge is a proof of possession challenge.
-        rtype: bool """
+    def is_pop_challenge(self) -> bool:
+        """Tests whether the HttpChallenge is a proof of possession challenge."""
         if not self.scheme:
             return False
 
         return self.scheme.lower() == "pop"
 
-    def get_value(self, key):
+    def get_value(self, key: str) -> "Optional[str]":
         return self._parameters.get(key)
 
-    def get_authorization_server(self):
-        """ Returns the URI for the authorization server if present, otherwise empty string. """
+    def get_authorization_server(self) -> "Optional[str]":
+        """Returns the URI for the authorization server if present, otherwise empty string."""
         value = ""
         for key in ["authorization_uri", "authorization"]:
             value = self.get_value(key) or ""
             if value:
                 break
         return value
 
-    def get_resource(self):
-        """ Returns the resource if present, otherwise empty string. """
+    def get_resource(self) -> str:
+        """Returns the resource if present, otherwise empty string."""
         return self.get_value("resource") or ""
 
-    def get_scope(self):
-        """ Returns the scope if present, otherwise empty string. """
+    def get_scope(self) -> str:
+        """Returns the scope if present, otherwise empty string."""
         return self.get_value("scope") or ""
 
-    def supports_pop(self):
-        """ Returns True if challenge supports pop token auth else False """
+    def supports_pop(self) -> bool:
+        """Returns True if challenge supports pop token auth else False."""
         return self._parameters.get("supportspop", "").lower() == "true"
 
-    def supports_message_protection(self):
-        """ Returns True if challenge vault supports message protection """
-        return self.supports_pop() and self.server_encryption_key and self.server_signature_key
+    def supports_message_protection(self) -> bool:
+        """Returns True if challenge vault supports message protection."""
+        return self.supports_pop() and self.server_encryption_key and self.server_signature_key  # type: ignore
 
     # pylint:disable=no-self-use
-    def _validate_challenge(self, challenge):
-        """ Verifies that the challenge is a valid auth challenge and returns the key=value pairs. """
+    def _validate_challenge(self, challenge: str) -> str:
+        """Verifies that the challenge is a valid auth challenge and returns the key=value pairs."""
         if not challenge:
             raise ValueError("Challenge cannot be empty")
 
         return challenge.strip()
 
     # pylint:disable=no-self-use
-    def _validate_request_uri(self, uri):
-        """ Extracts the host authority from the given URI. """
+    def _validate_request_uri(self, uri: str) -> str:
+        """Extracts the host authority from the given URI."""
         if not uri:
             raise ValueError("request_uri cannot be empty")
 
-        uri = parse.urlparse(uri)
-        if not uri.netloc:
+        parsed = parse.urlparse(uri)
+        if not parsed.netloc:
             raise ValueError("request_uri must be an absolute URI")
 
-        if uri.scheme.lower() not in ["http", "https"]:
+        if parsed.scheme.lower() not in ["http", "https"]:
             raise ValueError("request_uri must be HTTP or HTTPS")
 
-        return uri.netloc
+        return parsed.netloc
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/async_challenge_auth_policy.py`

 * *Files 3% similar despite different names*

```diff
@@ -29,32 +29,32 @@
     from azure.core.credentials_async import AsyncTokenCredential
     from azure.core.pipeline import PipelineRequest, PipelineResponse
 
 
 class AsyncChallengeAuthPolicy(AsyncBearerTokenCredentialPolicy):
     """policy for handling HTTP authentication challenges"""
 
-    def __init__(self, credential: "AsyncTokenCredential", *scopes: str, **kwargs: "Any") -> None:
+    def __init__(self, credential: "AsyncTokenCredential", *scopes: str, **kwargs) -> None:
         super().__init__(credential, *scopes, **kwargs)
         self._credential = credential
         self._token = None  # type: Optional[AccessToken]
         self._verify_challenge_resource = kwargs.pop("verify_challenge_resource", True)
 
     async def on_request(self, request: "PipelineRequest") -> None:
         _enforce_tls(request)
         challenge = ChallengeCache.get_challenge_for_url(request.http_request.url)
         if challenge:
             # Note that if the vault has moved to a new tenant since our last request for it, this request will fail.
-            if self._need_new_token:
+            if self._need_new_token():
                 # azure-identity credentials require an AADv2 scope but the challenge may specify an AADv1 resource
                 scope = challenge.get_scope() or challenge.get_resource() + "/.default"
                 self._token = await self._credential.get_token(scope, tenant_id=challenge.tenant_id)
 
             # ignore mypy's warning -- although self._token is Optional, get_token raises when it fails to get a token
-            request.http_request.headers["Authorization"] = "Bearer {}".format(self._token.token)  # type: ignore
+            request.http_request.headers["Authorization"] = f"Bearer {self._token.token}"  # type: ignore
             return
 
         # else: discover authentication information by eliciting a challenge from Key Vault. Remove any request data,
         # saving it for later. Key Vault will reject the request as unauthorized and respond with a challenge.
         # on_challenge will parse that challenge, reattach any body removed here, authorize the request, and tell
         # super to send it again.
         if request.http_request.body:
@@ -82,15 +82,19 @@
                     f"The challenge resource '{resource_domain}' does not match the requested domain. Pass "
                     "`verify_challenge_resource=False` to your client's constructor to disable this verification. "
                     "See https://aka.ms/azsdk/blog/vault-uri for more information."
                 )
 
         body = request.context.pop("key_vault_request_data", None)
         request.http_request.set_text_body(body)  # no-op when text is None
-        await self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
+
+        # The tenant parsed from AD FS challenges is "adfs"; we don't actually need a tenant for AD FS authentication
+        # For AD FS we skip cross-tenant authentication per https://github.com/Azure/azure-sdk-for-python/issues/28648
+        if challenge.tenant_id and challenge.tenant_id.lower().endswith("adfs"):
+            await self.authorize_request(request, scope)
+        else:
+            await self.authorize_request(request, scope, tenant_id=challenge.tenant_id)
 
         return True
 
-    @property
     def _need_new_token(self) -> bool:
-        # pylint:disable=invalid-overridden-method
         return not self._token or self._token.expires_on - time.time() < 300
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/__init__.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -19,40 +19,39 @@
     "HttpChallengeCache",
     "KeyVaultClientBase",
 ]
 
 _VaultId = namedtuple("_VaultId", ["vault_url", "collection", "name", "version"])
 
 
-def parse_vault_id(url):
+def parse_vault_id(url: str) -> "_VaultId":
     try:
         parsed_uri = urlparse(url)
     except Exception:  # pylint: disable=broad-except
-        raise ValueError("'{}' is not a valid url".format(url))
+        raise ValueError(f"'{url}' is not a valid url")
     if not (parsed_uri.scheme and parsed_uri.hostname):
-        raise ValueError("'{}' is not a valid url".format(url))
+        raise ValueError(f"'{url}' is not a valid url")
 
     path = list(filter(None, parsed_uri.path.split("/")))
 
     if len(path) < 2 or len(path) > 3:
-        raise ValueError("'{}' is not a valid vault url".format(url))
+        raise ValueError(f"'{url}' is not a valid vault url")
 
     return _VaultId(
-        vault_url="{}://{}".format(parsed_uri.scheme, parsed_uri.hostname),
+        vault_url=f"{parsed_uri.scheme}://{parsed_uri.hostname}",
         collection=path[0],
         name=path[1],
         version=path[2] if len(path) == 3 else None,
     )
 
 
 BackupLocation = namedtuple("BackupLocation", ["container_url", "folder_name"])
 
 
-def parse_folder_url(folder_url):
-    # type: (str) -> BackupLocation
+def parse_folder_url(folder_url: str) -> "BackupLocation":
     """Parse the blob container URL and folder name from a backup's blob storage URL.
 
     For example, https://<account>.blob.core.windows.net/backup/mhsm-account-2020090117323313 parses to
     (container_url="https://<account>.blob.core.windows.net/backup", folder_name="mhsm-account-2020090117323313").
     """
 
     try:
@@ -62,15 +61,15 @@
         stripped_path = parsed.path.strip("/")
         container = stripped_path.split("/")[0]
 
         # the rest of the path is the folder name
         folder_name = stripped_path[len(container) + 1 :]
 
         # this intentionally discards any SAS token in the URL--methods require the SAS token as a separate parameter
-        container_url = "{}://{}/{}".format(parsed.scheme, parsed.netloc, container)
+        container_url = f"{parsed.scheme}://{parsed.netloc}/{container}"
 
         return BackupLocation(container_url, folder_name)
     except:  # pylint:disable=broad-except
         raise ValueError(
             '"folder_url" should be the URL of a blob holding a Key Vault backup, for example '
             '"https://<account>.blob.core.windows.net/backup/mhsm-account-2020090117323313"'
         )
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure/keyvault/administration/_internal/exceptions.py` & `azure-keyvault-administration-4.4.0b1/azure/keyvault/administration/_internal/exceptions.py`

 * *Files 14% similar despite different names*

```diff
@@ -8,24 +8,23 @@
 
 from azure.core.exceptions import DecodeError, HttpResponseError, ResourceExistsError, ResourceNotFoundError
 from azure.core.pipeline.policies import ContentDecodePolicy
 
 if TYPE_CHECKING:
     # pylint:disable=unused-import,ungrouped-imports
     from typing import Optional, Type
-    from azure.core.pipeline.transport import HttpResponse
+    from azure.core.rest import HttpResponse
 
 
-def _get_exception_for_key_vault_error(cls, response):
-    # type: (Type[HttpResponseError], HttpResponse) -> HttpResponseError
+def _get_exception_for_key_vault_error(cls: "Type[HttpResponseError]", response: "HttpResponse") -> HttpResponseError:
     """Construct cls (HttpResponseError or subclass thereof) with Key Vault's error message."""
 
     try:
         body = ContentDecodePolicy.deserialize_from_http_generics(response)
-        message = "({}) {}".format(body["error"]["code"], body["error"]["message"])  # type: Optional[str]
+        message = f"({body['error']['code']}) {body['error']['message']}"  # type: Optional[str]
     except (DecodeError, KeyError):
         # Key Vault error response bodies should have the expected shape and be de-serializable.
         # If we somehow land here, we'll take HttpResponse's default message.
         message = None
 
     return cls(message=message, response=response)
```

## Comparing `azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations.py` & `azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import os
 
-from azure.keyvault.administration import KeyVaultBackupClient
-from azure.identity import DefaultAzureCredential
-
 # ----------------------------------------------------------------------------------------------------------
 # Prerequisites:
 # 1. A managed HSM (https://docs.microsoft.com/azure/key-vault/managed-hsm/quick-create-cli)
 #
 # 2. azure-keyvault-administration and azure-identity libraries (pip install these)
 #
 # 3. Set environment variable MANAGED_HSM_URL with the URL of your managed HSM
@@ -30,29 +27,39 @@
 # Sample - demonstrates full backup and restore operations for Managed HSM
 #
 # 1. Perform a full backup (begin_backup)
 #
 # 2. Perform a full restore (begin_restore)
 # ----------------------------------------------------------------------------------------------------------
 
-MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
-CONTAINER_URL = os.environ["CONTAINER_URL"]
-SAS_TOKEN = os.environ["SAS_TOKEN"]
-
 # Instantiate a backup client that will be used to call the service.
 # Here we use the DefaultAzureCredential, but any azure-identity credential can be used.
+# [START create_a_backup_restore_client]
+from azure.identity import DefaultAzureCredential
+from azure.keyvault.administration import KeyVaultBackupClient
+
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
 client = KeyVaultBackupClient(vault_url=MANAGED_HSM_URL, credential=credential)
+# [END create_a_backup_restore_client]
 
 # Let's back up the vault with begin_backup, which returns a poller. Calling result() on the poller will return a
 # KeyVaultBackupResult that contains the URL of the backup after the operation completes. Calling wait() on the
 # poller will wait until the operation is complete.
 print("\n.. Back up the vault")
+# [START begin_backup]
+CONTAINER_URL = os.environ["CONTAINER_URL"]
+SAS_TOKEN = os.environ["SAS_TOKEN"]
+
 backup_result = client.begin_backup(CONTAINER_URL, SAS_TOKEN).result()
+print(f"Azure Storage Blob URL of the backup: {backup_result.folder_url}")
+# [END begin_backup]
 print("Vault backed up successfully.")
 
 # Now let's the vault by calling begin_restore, which also returns a poller. Calling result() on the poller will
 # return None after the operation completes. Calling wait() on the poller will wait until the operation is complete.
 # To restore a single key from the backed up vault instead, pass the key_name keyword argument.
 print("\n.. Restore the full vault")
+# [START begin_restore]
 client.begin_restore(backup_result.folder_url, SAS_TOKEN).wait()
+# [END begin_restore]
 print("Vault restored successfully.")
```

## Comparing `azure-keyvault-administration-4.3.0b1/samples/access_control_operations_async.py` & `azure-keyvault-administration-4.4.0b1/samples/access_control_operations_async.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,15 +45,15 @@
     # Let's first create a custom role definition. This role permits creating keys in a Managed HSM.
     # We'll provide a friendly role name, and let a unique role definition name (a GUID) be generated for us.
     print("\n.. Create a role definition")
     role_name = "customRole"
     scope = KeyVaultRoleScope.GLOBAL
     permissions = [KeyVaultPermission(data_actions=[KeyVaultDataAction.CREATE_HSM_KEY])]
     role_definition = await client.set_role_definition(scope=scope, role_name=role_name, permissions=permissions)
-    print("Role definition '{}' created successfully.".format(role_definition.role_name))
+    print(f"Role definition '{role_definition.role_name}' created successfully.")
 
     # Let's update our role definition to allow reading keys, but not allow creating keys.
     # To update an existing definition, pass the name keyword argument to set_role_definition. This is the unique
     # name of the role definition, which is stored in KeyVaultRoleDefinition.name.
     print("\n.. Update a role definition")
     new_permissions = [
         KeyVaultPermission(
@@ -61,15 +61,15 @@
             not_data_actions=[KeyVaultDataAction.CREATE_HSM_KEY]
         )
     ]
     unique_definition_name = role_definition.name
     updated_definition = await client.set_role_definition(
         scope=scope, name=unique_definition_name, role_name=role_name, permissions=new_permissions
     )
-    print("Role definition '{}' updated successfully.".format(updated_definition.role_name))
+    print(f"Role definition '{updated_definition.role_name}' updated successfully.")
 
     # Now let's create a role assignment to apply our role definition to our service principal.
     # Since we don't provide the name keyword argument to create_role_definition, a unique role assignment name
     # (a GUID) is generated for us.
     print("\n.. Create a role assignment")
     principal_id = os.environ["AZURE_CLIENT_ID"]
     definition_id = updated_definition.id
```

## Comparing `azure-keyvault-administration-4.3.0b1/samples/backup_restore_operations_async.py` & `azure-keyvault-administration-4.4.0b1/samples/backup_restore_operations_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/PKG-INFO` & `azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-keyvault-administration
-Version: 4.3.0b1
+Version: 4.4.0b1
 Summary: Microsoft Azure Key Vault Administration Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration
 Author: Microsoft Corporation
 Author-email: azurekeyvault@microsoft.com
 License: MIT License
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
@@ -32,15 +32,20 @@
 ([azure-keyvault-secrets](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-secrets)) -
 securely store and control access to tokens, passwords, certificates, API keys,
 and other secrets
 - Certificate management
 ([azure-keyvault-certificates](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-certificates)) -
 create, manage, and deploy public and private SSL/TLS certificates
 
-[Source code][library_src] | [Package (PyPI)][pypi_package_administration] | [API reference documentation][reference_docs] | [Product documentation][keyvault_docs] | [Samples][administration_samples]
+[Source code][library_src]
+| [Package (PyPI)][pypi_package_administration]
+| [Package (Conda)](https://anaconda.org/microsoft/azure-keyvault/)
+| [API reference documentation][reference_docs]
+| [Product documentation][keyvault_docs]
+| [Samples][administration_samples]
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691._
 _Python 3.7 or later is required to use this package. For more details, please refer to [Azure SDK for Python version support policy](https://github.com/Azure/azure-sdk-for-python/wiki/Azure-SDKs-Python-version-support-policy)._
 
 ## Getting started
@@ -61,44 +66,66 @@
 ### Authenticate the client
 In order to interact with the Azure Key Vault service, you will need an instance of either a [KeyVaultAccessControlClient](#create-a-keyvaultaccesscontrolclient) or [KeyVaultBackupClient](#create-a-keyvaultbackupclient), as well as a **vault url** (which you may see as "DNS Name" in the Azure Portal) and a credential object. This document demonstrates using a [DefaultAzureCredential][default_cred_ref], which is appropriate for most scenarios, including local development and production environments. We recommend using a [managed identity][managed_identity] for authentication in production environments.
 
 See [azure-identity][azure_identity] documentation for more information about other methods of authentication and their corresponding credential types.
 
 #### Create a KeyVaultAccessControlClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create an access control client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:access_control_operations.create_an_access_control_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultAccessControlClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultAccessControlClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultAccessControlClient` instead.
 
 #### Create a KeyVaultBackupClient
 After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a backup client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:backup_restore_operations.create_a_backup_restore_client -->
+
 ```python
 from azure.identity import DefaultAzureCredential
 from azure.keyvault.administration import KeyVaultBackupClient
 
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
 credential = DefaultAzureCredential()
-
-client = KeyVaultBackupClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+client = KeyVaultBackupClient(vault_url=MANAGED_HSM_URL, credential=credential)
 ```
 
+<!-- END SNIPPET -->
+
 > **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultBackupClient` instead.
 
+#### Create a KeyVaultSettingsClient
+After configuring your environment for the [DefaultAzureCredential][default_cred_ref] to use a suitable method of authentication, you can do the following to create a settings client (replacing the value of `vault_url` with your Managed HSM's URL):
+
+<!-- SNIPPET:settings_operations.create_a_settings_client -->
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.keyvault.administration import KeyVaultSettingsClient
+
+MANAGED_HSM_URL = os.environ["MANAGED_HSM_URL"]
+credential = DefaultAzureCredential()
+client = KeyVaultSettingsClient(vault_url=MANAGED_HSM_URL, credential=credential)
+```
+
+<!-- END SNIPPET -->
+
+> **NOTE:** For an asynchronous client, import `azure.keyvault.administration.aio`'s `KeyVaultSettingsClient` instead.
+
 ## Key concepts
 
 ### Role definition
 A role definition defines the operations that can be performed, such as read, write, and delete. It can also define the operations that are excluded from allowed operations.
 
 A role definition is specified as part of a role assignment.
 
@@ -107,200 +134,208 @@
 
 ### KeyVaultAccessControlClient
 A `KeyVaultAccessControlClient` manages role definitions and role assignments.
 
 ### KeyVaultBackupClient
 A `KeyVaultBackupClient` performs full key backups, full key restores, and selective key restores.
 
+### KeyVaultSettingsClient
+
+A `KeyVaultSettingsClient` manages Managed HSM account settings.
+
 ## Examples
 This section contains code snippets covering common tasks:
 * Access control
     * [List all role definitions](#list-all-role-definitions)
     * [Set, get, and delete a role definition](#set-get-and-delete-a-role-defintion)
     * [List all role assignments](#list-all-role-assignments)
     * [Create, get, and delete a role assignment](#create-get-and-delete-a-role-assignment)
 * Backup and restore
     * [Perform a full key backup](#perform-a-full-key-backup)
     * [Perform a full key restore](#perform-a-full-key-restore)
+    * [Perform a selective key restore](#perform-a-selective-key-restore)
 
 ### List all role definitions
-List the role definitions available for assignment.
+`list_role_definitions` can be used by a `KeyVaultAccessControlClient` to list the role definitions available for
+assignment.
 
-```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
-
-credential = DefaultAzureCredential()
-
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- SNIPPET:access_control_operations.list_role_definitions -->
 
-# this will list all role definitions available for assignment
-role_definitions = client.list_role_definitions(KeyVaultRoleScope.GLOBAL)
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
 
+role_definitions = client.list_role_definitions(scope=KeyVaultRoleScope.GLOBAL)
 for definition in role_definitions:
-    print(definition.id)
-    print(definition.role_name)
-    print(definition.description)
+    print(f"Role name: {definition.role_name}; Role definition name: {definition.name}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Set, get, and delete a role definition
 
-`set_role_definition` can be used to either create a custom role definition or update an existing definition with the specified name.
+`set_role_definition` can be used by a `KeyVaultAccessControlClient` to either create a custom role definition or update
+an existing definition with the specified unique `name` (a UUID).
+
+<!-- SNIPPET:access_control_operations.create_a_role_definition -->
 
 ```python
-import uuid
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import (
-    KeyVaultAccessControlClient,
-    KeyVaultDataAction,
-    KeyVaultPermission,
-    KeyVaultRoleScope
-)
+from azure.keyvault.administration import KeyVaultDataAction, KeyVaultPermission, KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+role_name = "customRole"
+scope = KeyVaultRoleScope.GLOBAL
+permissions = [KeyVaultPermission(data_actions=[KeyVaultDataAction.CREATE_HSM_KEY])]
+role_definition = client.set_role_definition(scope=scope, role_name=role_name, permissions=permissions)
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
 
-# create a custom role definition
-permissions = [KeyVaultPermission(allowed_data_actions=[KeyVaultDataAction.READ_HSM_KEY])]
-created_definition = client.set_role_definition(KeyVaultRoleScope.GLOBAL, permissions=permissions)
-
-# update the custom role definition
-permissions = [
-    KeyVaultPermission(allowed_data_actions=[], denied_data_actions=[KeyVaultDataAction.READ_HSM_KEY])
+<!-- SNIPPET:access_control_operations.update_a_role_definition -->
+
+```python
+new_permissions = [
+    KeyVaultPermission(
+        data_actions=[KeyVaultDataAction.READ_HSM_KEY],
+        not_data_actions=[KeyVaultDataAction.CREATE_HSM_KEY]
+    )
 ]
+unique_definition_name = role_definition.name
 updated_definition = client.set_role_definition(
-    KeyVaultRoleScope.GLOBAL, permissions=permissions, role_name=created_definition.name
+    scope=scope, name=unique_definition_name, role_name=role_name, permissions=new_permissions
 )
+```
+
+<!-- END SNIPPET -->
+
+`get_role_definition` can be used by a `KeyVaultAccessControlClient` to fetch a role definition with the specified scope
+and unique name.
 
-# get the custom role definition
-definition = client.get_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+<!-- SNIPPET:access_control_operations.get_a_role_definition -->
 
-# delete the custom role definition
-deleted_definition = client.delete_role_definition(KeyVaultRoleScope.GLOBAL, role_name=definition_name)
+```python
+fetched_definition = client.get_role_definition(scope=scope, name=unique_definition_name)
 ```
 
-### List all role assignments
-Before creating a new role assignment in the [next snippet](#create-get-and-delete-a-role-assignment), list all of the current role assignments:
+<!-- END SNIPPET -->
+
+`delete_role_definition` can be used by a `KeyVaultAccessControlClient` to delete a role definition with the specified
+scope and unique name.
+
+<!-- SNIPPET:access_control_operations.delete_a_role_definition -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+client.delete_role_definition(scope=scope, name=unique_definition_name)
+```
 
-credential = DefaultAzureCredential()
+<!-- END SNIPPET -->
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+### List all role assignments
+`list_role_assignments` can be used by a `KeyVaultAccessControlClient` to list all of the current role assignments.
 
-# this will list all role assignments
-role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
+<!-- SNIPPET:access_control_operations.list_role_assignments -->
 
+```python
+from azure.keyvault.administration import KeyVaultRoleScope
+
+role_assignments = client.list_role_assignments(KeyVaultRoleScope.GLOBAL)
 for assignment in role_assignments:
-    print(assignment.name)
-    print(assignment.principal_id)
-    print(assignment.role_definition_id)
+    print(f"Role assignment name: {assignment.name}")
+    print(f"Principal ID associated with this assignment: {assignment.properties.principal_id}")
 ```
 
+<!-- END SNIPPET -->
+
 ### Create, get, and delete a role assignment
-Assign a role to a service principal. This will require a role definition ID and service principal object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former, and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the latter.
+Role assignments assign a role to a service principal. This will require a role definition ID and service principal
+object ID. You can use an ID from the retrieved [list of role definitions](#list-all-role-definitions) for the former,
+and an assignment's `principal_id` from the list retrieved in the [above snippet](#list-all-role-assignments) for the
+latter. Provide these values, and a scope, to a `KeyVaultAccessControlClient`'s `create_role_assignment` method.
+
+<!-- SNIPPET:access_control_operations.create_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultAccessControlClient, KeyVaultRoleScope
+from azure.keyvault.administration import KeyVaultRoleScope
 
-credential = DefaultAzureCredential()
+scope = KeyVaultRoleScope.GLOBAL
+role_assignment = client.create_role_assignment(scope=scope, definition_id=definition_id, principal_id=principal_id)
+print(f"Role assignment {role_assignment.name} created successfully.")
+```
 
-client = KeyVaultAccessControlClient(
-    vault_url="https://my-managed-hsm-name.managedhsm.azure.net/",
-    credential=credential
-)
+<!-- END SNIPPET -->
 
-# Replace <role-definition-id> with the id of a definition from the fetched list from an earlier example
-role_definition_id = "<role-definition-id>"
-# Replace <service-principal-object-id> with the principal_id of an assignment returned from the previous example
-principal_id = "<service-principal-object-id>"
-
-# first, let's create the role assignment
-role_assignment = client.create_role_assignment(KeyVaultRoleScope.GLOBAL, role_definition_id, principal_id)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# now, we get it
-role_assignment = client.get_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
-
-# finally, we delete this role assignment
-role_assignment = client.delete_role_assignment(KeyVaultRoleScope.GLOBAL, role_assignment.name)
-print(role_assignment.name)
-print(role_assignment.principal_id)
-print(role_assignment.role_definition_id)
+`get_role_assignment` can be used by a `KeyVaultAccessControlClient` to fetch an existing role assignment with the
+specified scope and unique name.
+
+<!-- SNIPPET:access_control_operations.get_a_role_assignment -->
+
+```python
+fetched_assignment = client.get_role_assignment(scope=scope, name=role_assignment.name)
+print(f"Role assignment for principal {fetched_assignment.properties.principal_id} fetched successfully.")
 ```
 
-### Perform a full key backup
-Back up your entire collection of keys. The backing store for full key backups is a blob storage container using Shared Access Signature authentication.
+<!-- END SNIPPET -->
+
+`delete_role_assignment` can be used by a `KeyVaultAccessControlClient` to delete a role assignment with the specified
+scope and unique name.
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+<!-- SNIPPET:access_control_operations.delete_a_role_assignment -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.delete_role_assignment(scope=scope, name=role_assignment.name)
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
+
+### Perform a full key backup
+The `KeyVaultBackupClient` can be used to back up your entire collection of keys. The backing store for full key
+backups is a blob storage container using Shared Access Signature (SAS) authentication.
 
-# blob storage container URL, for example https://<account name>.blob.core.windows.net/backup
-blob_storage_url = "<your-blob-storage-url>"
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
-
-# Backup is a long-running operation. The client returns a poller object whose result() method
-# blocks until the backup is complete, then returns an object representing the backup operation.
-backup_poller = client.begin_backup(blob_storage_url, sas_token)
-backup_operation = backup_poller.result()
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-# this is the Azure Storage Blob URL of the backup
-print(backup_operation.folder_url)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
+
+```python
+CONTAINER_URL = os.environ["CONTAINER_URL"]
+SAS_TOKEN = os.environ["SAS_TOKEN"]
+
+backup_result = client.begin_backup(CONTAINER_URL, SAS_TOKEN).result()
+print(f"Azure Storage Blob URL of the backup: {backup_result.folder_url}")
 ```
 
+<!-- END SNIPPET -->
+
+Note that the `begin_backup` method returns a poller. Calling `result()` on this poller returns a
+`KeyVaultBackupResult` containing information about the backup. Calling `wait()` on the poller will instead block until
+the operation is complete without returning an object.
 
 ### Perform a full key restore
-Restore your entire collection of keys from a backup. The data source for a full key restore is a storage blob accessed using Shared Access Signature authentication.
-You will also need the `azure_storage_blob_container_uri` from the [above snippet](#perform-a-full-key-backup).
+The `KeyVaultBackupClient` can be used to restore your entire collection of keys from a backup. The data source for a
+full key restore is a storage blob accessed using Shared Access Signature authentication. You will also need the URL of
+the backup (`KeyVaultBackupResult.folder_url`) from the [above snippet](#perform-a-full-key-backup).
+
+For more details on creating a SAS token using a `BlobServiceClient` from [`azure-storage-blob`][storage_blob], refer
+to the library's [credential documentation][sas_docs]. Alternatively, it is possible to
+[generate a SAS token in Storage Explorer][storage_explorer].
 
-For more details on creating a SAS token using the `BlobServiceClient`, see the sample [here](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/samples/blob_samples_authentication.py#L105).
-Alternatively, it is possible to [generate a SAS token in Storage Explorer](https://docs.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer?tabs=windows#generate-a-shared-access-signature-in-storage-explorer)
+<!-- SNIPPET:backup_restore_operations.begin_backup -->
 
 ```python
-from azure.identity import DefaultAzureCredential
-from azure.keyvault.administration import KeyVaultBackupClient
+client.begin_restore(backup_result.folder_url, SAS_TOKEN).wait()
+```
 
-credential = DefaultAzureCredential()
-client = KeyVaultBackupClient(vault_url="https://my-managed-hsm-name.managedhsm.azure.net/", credential=credential)
+<!-- END SNIPPET -->
 
-sas_token = "<your-sas-token>"  # replace with a sas token to your storage account
+Note that the `begin_restore` method returns a poller. Unlike the poller returned by `begin_backup`, this poller's
+`result` method returns `None`; therefore, calling `wait()` is functionally the same.
 
-# URL to a storage blob, for example https://<account name>.blob.core.windows.net/backup/mhsm-account-2020090117323313
-blob_url = "<your-blob-url>"
+### Perform a selective key restore
 
-# Restore is a long-running operation. The client returns a poller object whose wait() method
-# blocks until the restore is complete.
-restore_poller = client.begin_restore(blob_url, sas_token)
-restore_poller.wait()
-```
+To restore a single key from a backed up vault instead of all keys, provide the key name as a `key_name` argument to the
+`begin_restore` method [shown above](#perform-a-full-key-restore).
 
 ## Troubleshooting
 
 See the `azure-keyvault-administration`
 [troubleshooting guide](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/TROUBLESHOOTING.md)
 for details on how to diagnose various failure scenarios.
 
@@ -329,14 +364,16 @@
 Several samples are available in the Azure SDK for Python GitHub repository. These samples provide example code for additional Key Vault scenarios:
 | File | Description |
 |-------------|-------------|
 | [access_control_operations.py][access_control_operations_sample] | create/update/delete role definitions and role assignments |
 | [access_control_operations_async.py][access_control_operations_async_sample] | create/update/delete role definitions and role assignments with an async client |
 | [backup_restore_operations.py][backup_operations_sample] | full backup and restore |
 | [backup_restore_operations_async.py][backup_operations_async_sample] | full backup and restore with an async client |
+| [settings_operations.py][settings_operations_sample] | list and update Key Vault settings |
+| [settings_operations_async.py][settings_operations_async_sample] | list and update Key Vault settings with an async client |
 
 ###  Additional documentation
 For more extensive documentation on Azure Key Vault, see the [API reference documentation][reference_docs].
 
 For more extensive documentation on Managed HSM, see the [service documentation][managed_hsm].
 
 ## Contributing
@@ -385,20 +422,58 @@
 [managed_identity]: https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview
 
 [pip]: https://pypi.org/project/pip/
 [pypi_package_administration]: https://pypi.org/project/azure-keyvault-administration
 
 [reference_docs]: https://aka.ms/azsdk/python/keyvault-administration/docs
 
+[sas_docs]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/storage/azure-storage-blob/README.md#types-of-credentials
+[settings_operations_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations.py
+[settings_operations_async_sample]: https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-administration/samples/settings_operations_async.py
+[storage_blob]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/storage/azure-storage-blob/README.md
+[storage_explorer]: https://learn.microsoft.com/azure/vs-azure-tools-storage-manage-with-storage-explorer
+
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fkeyvault%2Fazure-keyvault-administration%2FREADME.png)
 
 
 # Release History
 
+## 4.4.0b1 (2023-05-16)
+
+### Bugs Fixed
+- Token requests made during AD FS authentication no longer specify an erroneous "adfs" tenant ID
+  ([#29888](https://github.com/Azure/azure-sdk-for-python/issues/29888))
+
+## 4.3.0 (2023-03-16)
+
+### Features Added
+- Added support for service API version `7.4`
+- Clients each have a `send_request` method that can be used to send custom requests using the
+  client's existing pipeline ([#25172](https://github.com/Azure/azure-sdk-for-python/issues/25172))
+- (From 4.3.0b1) Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings
+- The `KeyVaultSetting` class has a `getboolean` method that will return the setting's `value` as a `bool`, if possible,
+  and raise a `ValueError` otherwise
+
+### Breaking Changes
+> These changes do not impact the API of stable versions such as 4.2.0. Only code written against a beta version such as 4.3.0b1 may be affected.
+- `KeyVaultSettingsClient.update_setting` now accepts a single `setting` argument (a `KeyVaultSetting` instance)
+  instead of a `name` and `value`
+- The `KeyVaultSetting` model's `type` parameter and attribute have been renamed to `setting_type`
+- The `SettingType` enum has been renamed to `KeyVaultSettingType`
+
+### Other Changes
+- Key Vault API version `7.4` is now the default
+- (From 4.3.0b1) Python 3.6 is no longer supported. Please use Python version 3.7 or later.
+- (From 4.3.0b1) Updated minimum `azure-core` version to 1.24.0
+- (From 4.3.0b1) Dropped `msrest` requirement
+- (From 4.3.0b1) Dropped `six` requirement
+- (From 4.3.0b1) Added requirement for `isodate>=0.6.1` (`isodate` was required by `msrest`)
+- (From 4.3.0b1) Added requirement for `typing-extensions>=4.0.1`
+
 ## 4.3.0b1 (2022-11-15)
 
 ### Features Added
 - Added sync and async `KeyVaultSettingsClient`s for getting and updating Managed HSM settings.
 - Added support for service API version `7.4-preview.1`
 
 ### Other Changes
```

## Comparing `azure-keyvault-administration-4.3.0b1/azure_keyvault_administration.egg-info/SOURCES.txt` & `azure-keyvault-administration-4.4.0b1/azure_keyvault_administration.egg-info/SOURCES.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 CHANGELOG.md
 LICENSE
 MANIFEST.in
 README.md
 TROUBLESHOOTING.md
+pyproject.toml
 setup.py
 azure/__init__.py
 azure/keyvault/__init__.py
 azure/keyvault/administration/__init__.py
 azure/keyvault/administration/_access_control_client.py
 azure/keyvault/administration/_backup_client.py
 azure/keyvault/administration/_enums.py
@@ -71,38 +72,38 @@
 azure/keyvault/administration/_generated/v7_3/models/_models_py3.py
 azure/keyvault/administration/_generated/v7_3/models/_patch.py
 azure/keyvault/administration/_generated/v7_3/operations/__init__.py
 azure/keyvault/administration/_generated/v7_3/operations/_key_vault_client_operations.py
 azure/keyvault/administration/_generated/v7_3/operations/_patch.py
 azure/keyvault/administration/_generated/v7_3/operations/_role_assignments_operations.py
 azure/keyvault/administration/_generated/v7_3/operations/_role_definitions_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/__init__.py
-azure/keyvault/administration/_generated/v7_4_preview_1/_configuration.py
-azure/keyvault/administration/_generated/v7_4_preview_1/_key_vault_client.py
-azure/keyvault/administration/_generated/v7_4_preview_1/_patch.py
-azure/keyvault/administration/_generated/v7_4_preview_1/_vendor.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/__init__.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/_configuration.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/_key_vault_client.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/_patch.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/_vendor.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/__init__.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_key_vault_client_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_patch.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_assignments_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/aio/operations/_role_definitions_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/models/__init__.py
-azure/keyvault/administration/_generated/v7_4_preview_1/models/_key_vault_client_enums.py
-azure/keyvault/administration/_generated/v7_4_preview_1/models/_models_py3.py
-azure/keyvault/administration/_generated/v7_4_preview_1/models/_patch.py
-azure/keyvault/administration/_generated/v7_4_preview_1/operations/__init__.py
-azure/keyvault/administration/_generated/v7_4_preview_1/operations/_key_vault_client_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/operations/_patch.py
-azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_assignments_operations.py
-azure/keyvault/administration/_generated/v7_4_preview_1/operations/_role_definitions_operations.py
+azure/keyvault/administration/_generated/v7_4/__init__.py
+azure/keyvault/administration/_generated/v7_4/_configuration.py
+azure/keyvault/administration/_generated/v7_4/_key_vault_client.py
+azure/keyvault/administration/_generated/v7_4/_patch.py
+azure/keyvault/administration/_generated/v7_4/_vendor.py
+azure/keyvault/administration/_generated/v7_4/aio/__init__.py
+azure/keyvault/administration/_generated/v7_4/aio/_configuration.py
+azure/keyvault/administration/_generated/v7_4/aio/_key_vault_client.py
+azure/keyvault/administration/_generated/v7_4/aio/_patch.py
+azure/keyvault/administration/_generated/v7_4/aio/_vendor.py
+azure/keyvault/administration/_generated/v7_4/aio/operations/__init__.py
+azure/keyvault/administration/_generated/v7_4/aio/operations/_key_vault_client_operations.py
+azure/keyvault/administration/_generated/v7_4/aio/operations/_patch.py
+azure/keyvault/administration/_generated/v7_4/aio/operations/_role_assignments_operations.py
+azure/keyvault/administration/_generated/v7_4/aio/operations/_role_definitions_operations.py
+azure/keyvault/administration/_generated/v7_4/models/__init__.py
+azure/keyvault/administration/_generated/v7_4/models/_key_vault_client_enums.py
+azure/keyvault/administration/_generated/v7_4/models/_models_py3.py
+azure/keyvault/administration/_generated/v7_4/models/_patch.py
+azure/keyvault/administration/_generated/v7_4/operations/__init__.py
+azure/keyvault/administration/_generated/v7_4/operations/_key_vault_client_operations.py
+azure/keyvault/administration/_generated/v7_4/operations/_patch.py
+azure/keyvault/administration/_generated/v7_4/operations/_role_assignments_operations.py
+azure/keyvault/administration/_generated/v7_4/operations/_role_definitions_operations.py
 azure/keyvault/administration/_internal/__init__.py
 azure/keyvault/administration/_internal/async_challenge_auth_policy.py
 azure/keyvault/administration/_internal/async_client_base.py
 azure/keyvault/administration/_internal/async_polling.py
 azure/keyvault/administration/_internal/challenge_auth_policy.py
 azure/keyvault/administration/_internal/client_base.py
 azure/keyvault/administration/_internal/exceptions.py
@@ -119,14 +120,16 @@
 azure_keyvault_administration.egg-info/not-zip-safe
 azure_keyvault_administration.egg-info/requires.txt
 azure_keyvault_administration.egg-info/top_level.txt
 samples/access_control_operations.py
 samples/access_control_operations_async.py
 samples/backup_restore_operations.py
 samples/backup_restore_operations_async.py
+samples/settings_operations.py
+samples/settings_operations_async.py
 tests/_async_test_case.py
 tests/_test_case.py
 tests/conftest.py
 tests/test_access_control.py
 tests/test_access_control_async.py
 tests/test_backup_client.py
 tests/test_backup_client_async.py
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_examples_administration_async.py` & `azure-keyvault-administration-4.4.0b1/tests/test_examples_administration_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_examples_administration.py` & `azure-keyvault-administration-4.4.0b1/tests/test_examples_administration.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_backup_client_async.py` & `azure-keyvault-administration-4.4.0b1/tests/test_backup_client_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_access_control.py` & `azure-keyvault-administration-4.4.0b1/tests/test_access_control.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/conftest.py` & `azure-keyvault-administration-4.4.0b1/tests/conftest.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_settings_client.py` & `azure-keyvault-administration-4.4.0b1/tests/test_settings_client.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,50 @@
 # ------------------------------------
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT License.
 # ------------------------------------
 import pytest
-from azure.keyvault.administration import ApiVersion
+
+from azure.keyvault.administration import KeyVaultSetting, KeyVaultSettingsClient, KeyVaultSettingType
+from azure.keyvault.administration._internal.client_base import DEFAULT_VERSION
+
 from devtools_testutils import recorded_by_proxy
 
 from _shared.test_case import KeyVaultTestCase
 from _test_case import KeyVaultSettingsClientPreparer, get_decorator
 
-only_7_4 = get_decorator(api_versions=[ApiVersion.V7_4_PREVIEW_1])
+only_latest = get_decorator(api_versions=[DEFAULT_VERSION])
 
 
 class TestSettings(KeyVaultTestCase):
-    @pytest.mark.parametrize("api_version", only_7_4)
+    @pytest.mark.parametrize("api_version", only_latest)
     @KeyVaultSettingsClientPreparer()
     @recorded_by_proxy
-    def test_list_settings(self, client, **kwargs):
+    def test_list_settings(self, client: KeyVaultSettingsClient, **kwargs):
         default_settings = [setting for setting in client.list_settings()]
         assert len(default_settings)
         for setting in default_settings:
-            assert setting.name and setting.type and setting.value
+            assert setting.name and setting.setting_type and setting.value is not None
 
-    @pytest.mark.parametrize("api_version", only_7_4)
+    @pytest.mark.parametrize("api_version", only_latest)
     @KeyVaultSettingsClientPreparer()
     @recorded_by_proxy
-    def test_update_settings(self, client, **kwargs):
+    def test_update_settings(self, client: KeyVaultSettingsClient, **kwargs):
         setting = client.get_setting("AllowKeyManagementOperationsThroughARM")
-        assert setting.name and setting.type and setting.value
+        assert setting.name and setting.setting_type and setting.value
 
-        opposite_value = "false" if setting.value.lower() == "true" else "true"
-        updated = client.update_setting("AllowKeyManagementOperationsThroughARM", opposite_value)
+        # Set value by using a bool
+        opposite_value = KeyVaultSetting(
+            name=setting.name, value=not setting.getboolean(), setting_type=KeyVaultSettingType.BOOLEAN
+        )
+        updated = client.update_setting(opposite_value)
         assert updated.name == setting.name
-        assert updated.value != setting.value
+        if setting.getboolean():
+            assert not updated.getboolean()
+        else:
+            assert updated.getboolean()
+
+        # Set value by using a string
+        new_opposite = KeyVaultSetting(name=updated.name, value="false" if updated.getboolean() else "true")
+        new_updated = client.update_setting(new_opposite)
+        assert new_updated.name == updated.name
+        assert new_updated.value != updated.value
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_access_control_async.py` & `azure-keyvault-administration-4.4.0b1/tests/test_access_control_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/test_backup_client.py` & `azure-keyvault-administration-4.4.0b1/tests/test_backup_client.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_async_test_case.py` & `azure-keyvault-administration-4.4.0b1/tests/_async_test_case.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,15 @@
         playback_sas_token = "fake-sas"
 
         if self.is_live:
             self.managed_hsm_url = os.environ.get("AZURE_MANAGEDHSM_URL")
             storage_name = os.environ.get("BLOB_STORAGE_ACCOUNT_NAME")
             storage_endpoint_suffix = os.environ.get("KEYVAULT_STORAGE_ENDPOINT_SUFFIX")
             container_name = os.environ.get("BLOB_CONTAINER_NAME")
-            self.container_uri = "https://{}.blob.{}/{}".format(storage_name, storage_endpoint_suffix, container_name)
+            self.container_uri = f"https://{storage_name}.blob.{storage_endpoint_suffix}/{container_name}"
 
             self.sas_token = os.environ.get("BLOB_STORAGE_SAS_TOKEN")
             
         else:
             self.managed_hsm_url = hsm_playback_url
             self.container_uri = container_playback_uri
             self.sas_token = playback_sas_token
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_test_case.py` & `azure-keyvault-administration-4.4.0b1/tests/_test_case.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
         playback_sas_token = "fake-sas"
 
         if self.is_live:
             self.managed_hsm_url = os.environ.get("AZURE_MANAGEDHSM_URL")
             storage_name = os.environ.get("BLOB_STORAGE_ACCOUNT_NAME")
             storage_endpoint_suffix = os.environ.get("KEYVAULT_STORAGE_ENDPOINT_SUFFIX")
             container_name = os.environ.get("BLOB_CONTAINER_NAME")
-            self.container_uri = "https://{}.blob.{}/{}".format(storage_name, storage_endpoint_suffix, container_name)
+            self.container_uri = f"https://{storage_name}.blob.{storage_endpoint_suffix}/{container_name}"
 
             self.sas_token = os.environ.get("BLOB_STORAGE_SAS_TOKEN")
             
         else:
             self.managed_hsm_url = hsm_playback_url
             self.container_uri = container_playback_uri
             self.sas_token = playback_sas_token
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/test_case.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/test_case.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 # Licensed under the MIT License.
 # ------------------------------------
 import time
 
 from devtools_testutils import AzureRecordedTestCase
 
 from azure.keyvault.administration._internal import HttpChallengeCache
+from azure.keyvault.keys._shared import HttpChallengeCache as _HttpChallengeCache
 
 
 class KeyVaultTestCase(AzureRecordedTestCase):
     def _poll_until_no_exception(self, fn, expected_exception, max_retries=20, retry_delay=3):
         """polling helper for live tests because some operations take an unpredictable amount of time to complete"""
 
         for i in range(max_retries):
@@ -33,8 +34,10 @@
             except expected_exception:
                 return
 
         self.fail("expected exception {expected_exception} was not raised")
 
     def teardown_method(self, method):
         HttpChallengeCache.clear()
+        _HttpChallengeCache.clear()
         assert len(HttpChallengeCache._cache) == 0
+        assert len(_HttpChallengeCache._cache) == 0
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/test_case_async.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/test_case_async.py`

 * *Files 17% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 # ------------------------------------
 import asyncio
 
 from azure_devtools.scenario_tests.patches import mock_in_unit_test
 from devtools_testutils import AzureRecordedTestCase
 
 from azure.keyvault.administration._internal import HttpChallengeCache
+from azure.keyvault.keys._shared import HttpChallengeCache as _HttpChallengeCache
 
 
 def skip_sleep(unit_test):
     async def immediate_return(_):
         return
 
     return mock_in_unit_test(unit_test, "asyncio.sleep", immediate_return)
@@ -45,8 +46,10 @@
                         await asyncio.sleep(retry_delay)
                 except expected_exception:
                     return
         self.fail("expected exception {expected_exception} was not raised")
 
     def teardown_method(self, method):
         HttpChallengeCache.clear()
+        _HttpChallengeCache.clear()
         assert len(HttpChallengeCache._cache) == 0
+        assert len(_HttpChallengeCache._cache) == 0
```

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/preparer.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/preparer.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/preparer_async.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/preparer_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/json_attribute_matcher.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/json_attribute_matcher.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/helpers.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/helpers.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/_shared/helpers_async.py` & `azure-keyvault-administration-4.4.0b1/tests/_shared/helpers_async.py`

 * *Files identical despite different names*

## Comparing `azure-keyvault-administration-4.3.0b1/tests/perfstress_tests/get_role_definition.py` & `azure-keyvault-administration-4.4.0b1/tests/perfstress_tests/get_role_definition.py`

 * *Files identical despite different names*

