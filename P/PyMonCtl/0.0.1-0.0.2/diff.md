# Comparing `tmp/PyMonCtl-0.0.1-py3-none-any.whl.zip` & `tmp/PyMonCtl-0.0.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 107603 bytes, number of entries: 22
+Zip file size: 107648 bytes, number of entries: 22
 -rw-rw-rw-  2.0 fat    11349 b- defN 23-May-12 17:40 monitorctl/__init__.py
 -rw-rw-rw-  2.0 fat     5308 b- defN 23-May-12 18:06 monitorctl/_monitorctl_linux.py
 -rw-rw-rw-  2.0 fat     4234 b- defN 23-May-12 18:06 monitorctl/_monitorctl_macos.py
 -rw-rw-rw-  2.0 fat     4862 b- defN 23-May-12 18:06 monitorctl/_monitorctl_win.py
 -rw-rw-rw-  2.0 fat    10749 b- defN 23-May-11 11:43 monitorctl/_mybox.py
 -rw-rw-rw-  2.0 fat   165002 b- defN 23-Apr-19 07:41 monitorctl/_xlibcontainer.py
 -rw-rw-rw-  2.0 fat     2448 b- defN 23-May-12 16:32 monitorctl/multi_monitor.py
 -rw-rw-rw-  2.0 fat     1477 b- defN 23-May-11 08:44 monitorctl/test.py
--rw-rw-rw-  2.0 fat    14246 b- defN 23-May-16 17:41 pymonctl/__init__.py
+-rw-rw-rw-  2.0 fat    14965 b- defN 23-May-16 22:20 pymonctl/__init__.py
 -rw-rw-rw-  2.0 fat    10723 b- defN 23-May-12 18:38 pymonctl/_mybox.py
--rw-rw-rw-  2.0 fat    15098 b- defN 23-May-16 09:40 pymonctl/_pymonctl_linux.py
--rw-rw-rw-  2.0 fat    10050 b- defN 23-May-16 15:14 pymonctl/_pymonctl_macos.py
--rw-rw-rw-  2.0 fat     9206 b- defN 23-May-16 15:59 pymonctl/_pymonctl_win.py
+-rw-rw-rw-  2.0 fat    13569 b- defN 23-May-16 21:23 pymonctl/_pymonctl_linux.py
+-rw-rw-rw-  2.0 fat     8614 b- defN 23-May-16 22:12 pymonctl/_pymonctl_macos.py
+-rw-rw-rw-  2.0 fat     8141 b- defN 23-May-16 21:58 pymonctl/_pymonctl_win.py
 -rw-rw-rw-  2.0 fat   165002 b- defN 23-Apr-19 07:41 pymonctl/_xlibcontainer.py
 -rw-rw-rw-  2.0 fat     2448 b- defN 23-May-12 16:32 pymonctl/multi_monitor.py
 -rw-rw-rw-  2.0 fat     1477 b- defN 23-May-11 08:44 pymonctl/test.py
--rw-rw-rw-  2.0 fat       85 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/AUTHORS.txt
--rw-rw-rw-  2.0 fat     3202 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     7113 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        9 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1797 b- defN 23-May-16 17:42 PyMonCtl-0.0.1.dist-info/RECORD
-22 files, 445977 bytes uncompressed, 104721 bytes compressed:  76.5%
+-rw-rw-rw-  2.0 fat       85 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/AUTHORS.txt
+-rw-rw-rw-  2.0 fat     3202 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     7113 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        9 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1796 b- defN 23-May-16 22:20 PyMonCtl-0.0.2.dist-info/RECORD
+22 files, 442665 bytes uncompressed, 104766 bytes compressed:  76.3%
```

## zipnote {}

```diff
@@ -42,26 +42,26 @@
 
 Filename: pymonctl/multi_monitor.py
 Comment: 
 
 Filename: pymonctl/test.py
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/AUTHORS.txt
+Filename: PyMonCtl-0.0.2.dist-info/AUTHORS.txt
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/LICENSE.txt
+Filename: PyMonCtl-0.0.2.dist-info/LICENSE.txt
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/METADATA
+Filename: PyMonCtl-0.0.2.dist-info/METADATA
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/WHEEL
+Filename: PyMonCtl-0.0.2.dist-info/WHEEL
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/top_level.txt
+Filename: PyMonCtl-0.0.2.dist-info/top_level.txt
 Comment: 
 
-Filename: PyMonCtl-0.0.1.dist-info/RECORD
+Filename: PyMonCtl-0.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pymonctl/__init__.py

```diff
@@ -3,52 +3,78 @@
 from __future__ import annotations
 
 import sys
 import threading
 from collections.abc import Callable
 from typing import List, Tuple, TypedDict, Optional, NamedTuple
 
-from ._mybox import Rect, Point, Size, pointInBox
-
 
 __all__ = [
     "enableUpdate", "disableUpdate", "isUpdateEnabled", "updateInterval",
     "getMonitors", "_getMonitorsCount", "findMonitorName", "findMonitorInfo",
-    "getMonitorSize", "_getWorkArea", "_getMousePos",
+    "getMonitorSize", "_getWorkArea", "_getMousePos", "pointInBox",
     "Structs", "_getCurrentMode", "_getAllowedModes", "_changeMode",
 ]
 # Mac only
-__version__ = "0.0.1"
+__version__ = "0.0.2"
 
 
 def version(numberOnly: bool = True):
     """Returns the current version of MonitorCtl module, in the form ''x.x.xx'' as string"""
     return ("" if numberOnly else "MonitorCtl-")+__version__
 
 
 class Structs:
 
+    class Box(NamedTuple):
+        left: int
+        top: int
+        width: int
+        height: int
+
+    class Rect(NamedTuple):
+        left: int
+        top: int
+        right: int
+        bottom: int
+
+    BoundingBox = Rect  # BoundingBox is an alias for Rect class (just for retro-compatibility)
+
+    class Point(NamedTuple):
+        x: int
+        y: int
+
+    class Size(NamedTuple):
+        width: int
+        height: int
+
     class ScreenValue(TypedDict):
         id: int
         is_primary: bool
-        pos: Point
-        size: Size
-        workarea: Rect
+        pos: Structs.Point
+        size: Structs.Size
+        workarea: Structs.Rect
         scale: Tuple[int, int]
         dpi: Tuple[int, int]
         orientation: int
         frequency: float
         colordepth: int
 
     class DisplayMode(NamedTuple):
         width: int
         height: int
         frequency: float
 
 
+def pointInBox(x: int, y: int, left: int, top: int, width: int, height: int):
+    """Returns ``True`` if the ``(x, y)`` point is within the box described
+    by ``(left, top, width, height)``."""
+    return left < x < left + width and top < y < top + height
+
+
 class _UpdateScreens(threading.Thread):
 
     def __init__(self, interval: float = 0.3,
                  monitorCountChanged: Optional[Callable[[List[str], dict[str, Structs.ScreenValue]], None]] = None,
                  monitorPropsChanged: Optional[Callable[[List[str], dict[str, Structs.ScreenValue]], None]] = None):
         threading.Thread.__init__(self)
 
@@ -240,26 +266,26 @@
     :param name: name of the monitor as returned by getMonitors() and getDisplay() methods.
     :return: Size struct or None
     """
     return _getScreenSize(name)
 resolution = getMonitorSize  # resolution is an alias for getMonitorSize
 
 
-def getPosition(name: str = "") -> Optional[Point]:
+def getPosition(name: str = "") -> Optional[Structs.Point]:
     """
     Get position (x, y) of the given monitor, or main monitor if no monitor name provided
 
     :param name: name of the monitor as returned by getMonitors() and getDisplay() methods.
     :return: Point struct or None
     """
     return _getPosition(name)
 position = getPosition  # position is an alias for getPosition
 
 
-def getRect(name: str = "") -> Optional[Rect]:
+def getRect(name: str = "") -> Optional[Structs.Rect]:
     """
     Get rect (x, y) of the given monitor, or main monitor if no monitor name provided
 
     :param name: name of the monitor as returned by getMonitors() and getDisplay() methods.
     :return: Point struct or None
     """
     return _getRect(name)
```

## pymonctl/_pymonctl_linux.py

```diff
@@ -11,17 +11,16 @@
 import os
 from typing import Optional, List, Tuple
 
 import Xlib.display
 import Xlib.X
 import Xlib.ext.randr
 
-from pymonctl._xlibcontainer import Props, defaultRootWindow
-from pymonctl._mybox import Rect, Point, Size, pointInBox
-from pymonctl import Structs
+from pymonctl._xlibcontainer import Props, defaultRootWindow, getProperty, getPropertyValue
+from pymonctl import Structs, pointInBox
 
 
 def __getDisplays() -> List[Xlib.display.Display]:
     displays: List[Xlib.display.Display] = []
     try:
         files = os.listdir("/tmp/.X11-unix")
     except:
@@ -30,227 +29,226 @@
         if f.startswith("X"):
             displays.append(Xlib.display.Display(":"+f[1:]))
     if not displays:
         displays = [Xlib.display.Display()]
     return displays
 
 
+def __getRoots():
+    for display in __getDisplays():
+        for i in range(display.screen_count()):
+            try:
+                screen = display.screen(i)
+                yield [display, screen, screen.root]
+            except:
+                continue
+
+
+def __getAllOutputs(name: str = ""):
+    for rootData in __getRoots():
+        display, screen, root = rootData
+        res = root.xrandr_get_screen_resources()
+        for output in res.outputs:
+            outputInfo = display.xrandr_get_output_info(output, res.config_timestamp)
+            if not name or (name and name == outputInfo.name):
+                yield [display, screen, root, res, outputInfo]
+
+
+def __getAllCrtcs(name: str = ""):
+    for rootData in __getAllOutputs():
+        display, screen, root, res, outputInfo = rootData
+        res = root.xrandr_get_screen_resources()
+        for output in res.outputs:
+            outputInfo = display.xrandr_get_output_info(output, res.config_timestamp)
+            if not name or (name and name == outputInfo.name):
+                for crtc in outputInfo.crtcs:
+                    crtcInfo = defaultRootWindow.display.xrandr_get_crtc_info(crtc, res.config_timestamp)
+                    yield [display, screen, root, res, output, outputInfo, crtc, crtcInfo]
+
+
+def __getAllMonitors():
+    for rootData in __getRoots():
+        display, screen, root = rootData
+        for monitor in root.xrandr_get_monitors().monitors:
+            yield [display, root, monitor, display.get_atom_name(monitor.name)]
+
+
+def __getMonitorsNames() -> List[str]:
+    for rootData in __getRoots():
+        display, screen, root = rootData
+        for monitor in root.xrandr_get_monitors().monitors:
+            yield display.get_atom_name(monitor.name)
+
+
 def _getAllScreens():
     # https://stackoverflow.com/questions/8705814/get-display-count-and-resolution-for-each-display-in-python-without-xrandr
     # https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#Obtaining_Information_about_the_Display_Image_Formats_or_Screens
     # https://github.com/alexer/python-xlib/blob/master/examples/xrandr.py
     result: dict[str, Structs.ScreenValue] = {}
-    displays = __getDisplays()
-    for dsp in displays:
-        for i in range(dsp.screen_count()):
+
+    for crtc in __getAllCrtcs():
+        display, screen, root, res, output, outputInfo, crtcNumber, crtcInfo = crtc
+
+        if crtcInfo.mode:
+            name = outputInfo.name
+            dId = output
+            x, y, w, h = crtcInfo.x, crtcInfo.y, crtcInfo.width, crtcInfo.height
+            wa: List[int] = getPropertyValue(getProperty(window=root, prop=Props.Root.WORKAREA.value, display=display), display=display)
+            wx, wy, wr, wb = x + wa[0], y + wa[1], x + w - (crtcInfo.width - wa[2] - wa[0]), y + h - (crtcInfo.height - wa[3] - wa[1])
             try:
-                screen = dsp.screen(i)
-                root = screen.root
+                dpiX, dpiY = round(crtcInfo.width * 25.4 / outputInfo.mm_width), round(crtcInfo.height * 25.4 / outputInfo.mm_height)
             except:
-                continue
+                try:
+                    dpiX, dpiY = round(w * 25.4 / screen.width_in_mms), round(h * 25.4 / screen.height_in_mms)
+                except:
+                    dpiX = dpiY = 0
+            scaleX, scaleY = round(dpiX / 96 * 100), round(dpiY / 96 * 100)
+            rot = int(math.log(crtcInfo.rotation, 2))
+            freq = 0.0
+            for mode in res.modes:
+                if crtcInfo.mode == mode.id:
+                    freq = mode.dot_clock / ((mode.h_total * mode.v_total) or 1)
+                    break
+            depth = screen.root_depth
 
-            res = root.xrandr_get_screen_resources()
-            modes = res.modes
-            wa = root.get_full_property(dsp.get_atom(Props.Root.WORKAREA.value, True), Xlib.X.AnyPropertyType).value
-            for output in res.outputs:
-                outputInfo = dsp.xrandr_get_output_info(output, res.config_timestamp)
-                for crtc in outputInfo.crtcs:
-                    crtcInfo = defaultRootWindow.display.xrandr_get_crtc_info(crtc, res.config_timestamp)
-                    if crtcInfo.mode:  # displays with empty (0) mode seem not to be valid
-                        name = outputInfo.name
-                        dId = output
-                        x, y, w, h = crtcInfo.x, crtcInfo.y, crtcInfo.width, crtcInfo.height
-                        wx, wy, wr, wb = x + wa[0], y + wa[1], x + w - (screen.width_in_pixels - wa[2] - wa[0]), y + h - (screen.height_in_pixels - wa[3] - wa[1])
-                        # check all these values using dpi, mms or other possible values or props
-                        try:
-                            dpiX, dpiY = round(crtcInfo.width * 25.4 / outputInfo.mm_width), round(crtcInfo.height * 25.4 / outputInfo.mm_height)
-                        except:
-                            try:
-                                dpiX, dpiY = round(w * 25.4 / screen.width_in_mms), round(h * 25.4 / screen.height_in_mms)
-                            except:
-                                dpiX = dpiY = 0
-                        scaleX, scaleY = round(dpiX / 96 * 100), round(dpiY / 96 * 100)
-                        rot = int(math.log(crtcInfo.rotation, 2))
-                        freq = 0.0
-                        for mode in modes:
-                            if crtcInfo.mode == mode.id:
-                                freq = mode.dot_clock / ((mode.h_total * mode.v_total) or 1)
-                                break
-                        depth = screen.root_depth
-
-                        result[name] = {
-                            'id': dId,
-                            'is_primary': (x, y) == (0, 0),
-                            'pos': Point(x, y),
-                            'size': Size(w, h),
-                            'workarea': Rect(wx, wy, wr, wb),
-                            'scale': (scaleX, scaleY),
-                            'dpi': (dpiX, dpiY),
-                            'orientation': rot,
-                            'frequency': freq,
-                            'colordepth': depth
-                        }
-        dsp.close()
+            result[name] = {
+                'id': dId,
+                'is_primary': (x, y) == (0, 0),
+                'pos': Structs.Point(x, y),
+                'size': Structs.Size(w, h),
+                'workarea': Structs.Rect(wx, wy, wr, wb),
+                'scale': (scaleX, scaleY),
+                'dpi': (dpiX, dpiY),
+                'orientation': rot,
+                'frequency': freq,
+                'colordepth': depth
+            }
     return result
 
 
 def _getMonitorsCount() -> int:
-    count: int = 0
-    displays: List[Xlib.display.Display] = __getDisplays()
-    if len(displays) > 1:
-        for display in displays:
-            root = display.screen().root
-            count += len(root.xrandr_get_monitors().monitors)
+    monitors = [__getAllMonitors()]
+    count = len(monitors)
     if count == 0:
         count = len(defaultRootWindow.root.xrandr_get_monitors().monitors)
     return count
 
 
-def __getMonitorsNames() -> List[str]:
-    names: List[str] = []
-    displays: List[Xlib.display.Display] = __getDisplays()
-    if len(displays) > 1:
-        for dsp in displays:
-            root = dsp.screen().root
-            for monitor in root.xrandr_get_monitors().monitors:
-                names.append(dsp.get_atom_name(monitor.name))
-    else:
-        for monitor in defaultRootWindow.root.xrandr_get_monitors().monitors:
-            names.append(defaultRootWindow.display.get_atom_name(monitor.name))
-    return names
-
-
-def _getScreenSize(name: str = "") -> Optional[Size]:
-    res: Optional[Size] = None
+def _getScreenSize(name: str = "") -> Optional[Structs.Size]:
+    res: Optional[Structs.Size] = None
     if name:
-        displays: List[Xlib.display.Display] = __getDisplays()
-        for dsp in displays:
-            root = dsp.screen().root
-            for monitor in root.xrandr_get_monitors().monitors:
-                if dsp.get_atom_name(monitor.name) == name:
-                    size: Tuple[int, int] = monitor.width_in_pixels, monitor.height_in_pixels
-                    res = Size(*size)
-                    break
+        for mon in __getAllMonitors():
+            monitor = mon[2]
+            monName = mon[3]
+            if monName == name:
+                size: Tuple[int, int] = monitor.width_in_pixels, monitor.height_in_pixels
+                res = Structs.Size(*size)
+                break
     else:
         size = defaultRootWindow.getDesktopGeometry()
-        res = Size(*size)
+        res = Structs.Size(*size)
     return res
 
 
-def _getWorkArea(name: str = "") -> Optional[Rect]:
-    res: Optional[Rect] = None
+def _getWorkArea(name: str = "") -> Optional[Structs.Rect]:
+    res: Optional[Structs.Rect] = None
     if name:
-        displays: List[Xlib.display.Display] = __getDisplays()
-        for dsp in displays:
-            root = dsp.screen().root
-            for monitor in root.xrandr_get_monitors().monitors:
-                if dsp.get_atom_name(monitor.name) == name:
-                    x, y, w, h = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
-                    wa: List[int] = root.get_full_property(dsp.get_atom(Props.Root.WORKAREA.value, True), Xlib.X.AnyPropertyType).value
-                    wx, wy, wr, wb = x + wa[0], y + wa[1], x + w - (w - wa[2] - wa[0]), y + h - (h - wa[3] - wa[1])
-                    res = Rect(wx, wy, wr, wb)
-                    break
+        for mon in __getAllMonitors():
+            display, root, monitor, monName = mon
+            if monName == name:
+                x, y, w, h = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
+                wa: List[int] = getPropertyValue(getProperty(window=root, prop=Props.Root.WORKAREA.value, display=display), display=display)
+                wx, wy, wr, wb = x + wa[0], y + wa[1], x + w - (w - wa[2] - wa[0]), y + h - (h - wa[3] - wa[1])
+                res = Structs.Rect(wx, wy, wr, wb)
+                break
     else:
-        out: List[int] = defaultRootWindow.getWorkArea()
-        wa = out[:4]
-        res = Rect(*wa)
+        wa = defaultRootWindow.getWorkArea()
+        res = Structs.Rect(wa[0], wa[1], wa[2], wa[3])
     return res
 
 
-def _getPosition(name: str = "") -> Optional[Point]:
-    pos: Optional[Point] = None
-    displays: List[Xlib.display.Display] = __getDisplays()
-    for dsp in displays:
-        root = dsp.screen().root
-        for monitor in root.xrandr_get_monitors().monitors:
-            if (not name and monitor.primary == 1) or (name and dsp.get_atom_name(monitor.name) == name):
-                pos = Point(monitor.x, monitor.y)
-                break
+def _getPosition(name: str = "") -> Optional[Structs.Point]:
+    pos: Optional[Structs.Point] = None
+    for mon in __getAllMonitors():
+        monitor = mon[2]
+        monName = mon[3]
+        if (not name and monitor.primary == 1) or (name and monName == name):
+            pos = Structs.Point(monitor.x, monitor.y)
+            break
     return pos
 
 
-def _getRect(name: str = "") -> Optional[Rect]:
-    rect: Optional[Rect] = None
-    displays: List[Xlib.display.Display] = __getDisplays()
-    for dsp in displays:
-        root = dsp.screen().root
-        for monitor in root.xrandr_get_monitors().monitors:
-            if (not name and monitor.primary == 1) or (name and dsp.get_atom_name(monitor.name) == name):
-                rect = Rect(monitor.x, monitor.y, monitor.x + monitor.width_in_pixels, monitor.y + monitor.height_in_pixels)
-                break
+def _getRect(name: str = "") -> Optional[Structs.Rect]:
+    rect: Optional[Structs.Rect] = None
+    for mon in __getAllMonitors():
+        monitor = mon[2]
+        monName = mon[3]
+        if (not name and monitor.primary == 1) or (name and monName == name):
+            rect = Structs.Rect(monitor.x, monitor.y, monitor.x + monitor.width_in_pixels, monitor.y + monitor.height_in_pixels)
+            break
     return rect
 
 
 def _findMonitorName(x: int, y: int) -> str:
     name: str = ""
-    displays: List[Xlib.display.Display] = __getDisplays()
-    for dsp in displays:
-        root = dsp.screen().root
-        for monitor in root.xrandr_get_monitors().monitors:
-            sx, sy, sw, sh = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
-            if pointInBox(x, y, sx, sy, sw, sh):
-                name = dsp.get_atom_name(monitor.name)
-                break
+    for mon in __getAllMonitors():
+        monitor = mon[2]
+        monName = mon[3]
+        sx, sy, sw, sh = monitor.x, monitor.y, monitor.width_in_pixels, monitor.height_in_pixels
+        if pointInBox(x, y, sx, sy, sw, sh):
+            name = monName
+            break
     return name
 
 
 def _getCurrentMode(name: str = "") -> Optional[Structs.DisplayMode]:
 
     outMode: Optional[Structs.DisplayMode] = None
     allModes = []
-
     mode = None
+
     if name:
-        displays: List[Xlib.display.Display] = __getDisplays()
-        for dsp in displays:
-            root = dsp.screen().root
-            res = root.xrandr_get_screen_resources()
-            for output in res.outputs:
-                outputInfo = defaultRootWindow.display.xrandr_get_output_info(output, res.config_timestamp)
-                if outputInfo.name == name:
-                    for crtc in outputInfo.crtcs:
-                        crtcInfo = defaultRootWindow.display.xrandr_get_crtc_info(crtc, res.config_timestamp)
-                        if crtcInfo.mode:
-                            mode = crtcInfo.mode
-                            allModes = res.modes
-                            break
+        for crtc in __getAllCrtcs(name):
+            res = crtc[3]
+            crtcInfo = crtc[7]
+            if crtcInfo.mode:
+                mode = crtcInfo.mode
+                allModes = res.modes
+                break
     else:
         root = defaultRootWindow.root
         res = root.xrandr_get_screen_resources()
         for output in res.outputs:
             outputInfo = defaultRootWindow.display.xrandr_get_output_info(output, res.config_timestamp)
             for crtc in outputInfo.crtcs:
                 crtcInfo = defaultRootWindow.display.xrandr_get_crtc_info(crtc, res.config_timestamp)
                 if crtcInfo.mode:
                     mode = crtcInfo.mode
                     allModes = res.modes
                     break
+            if mode: break
 
     if mode and allModes:
         for m in allModes:
             if mode == m.id:
                 outMode = Structs.DisplayMode(m.width, m.height, m.dot_clock / ((m.h_total * m.v_total) or 1))
+                break
     return outMode
 
 
 def __getAllowedModesID(name: str = "") -> List[Tuple[int, Structs.DisplayMode]]:
 
     modes: List[Tuple[int, Structs.DisplayMode]] = []
     allModes = []
 
     if name:
-        displays: List[Xlib.display.Display] = __getDisplays()
-        for dsp in displays:
-            root = dsp.screen().root
-            res = root.xrandr_get_screen_resources()
-            for output in res.outputs:
-                outputInfo = defaultRootWindow.display.xrandr_get_output_info(output, res.config_timestamp)
-                if outputInfo.name == name:
-                    allModes = res.modes
-                    break
+        for crtc in __getAllCrtcs(name):
+            res = crtc[3]
+            allModes = res.modes
+            break
     else:
         root = defaultRootWindow.root
         res = root.xrandr_get_screen_resources()
         allModes = res.modes
 
     for mode in allModes:
         modes.append((mode.id, Structs.DisplayMode(mode.width, mode.height, mode.dot_clock / ((mode.h_total * mode.v_total) or 1))))
@@ -259,23 +257,20 @@
 
 def _getAllowedModes(name: str = "") -> List[Structs.DisplayMode]:
 
     modes: List[Structs.DisplayMode] = []
     allModes = []
 
     if name:
-        displays: List[Xlib.display.Display] = __getDisplays()
-        for dsp in displays:
-            root = dsp.screen().root
-            res = root.xrandr_get_screen_resources()
-            for output in res.outputs:
-                outputInfo = defaultRootWindow.display.xrandr_get_output_info(output, res.config_timestamp)
-                if outputInfo.name == name:
-                    allModes = res.modes
-                    break
+        for crtc in __getAllCrtcs(name):
+            res = crtc[3]
+            crtcInfo = crtc[7]
+            if crtcInfo.mode:
+                allModes = res.modes
+                break
     else:
         root = defaultRootWindow.root
         res = root.xrandr_get_screen_resources()
         allModes = res.modes
 
     for mode in allModes:
         modes.append(Structs.DisplayMode(mode.width, mode.height, mode.dot_clock / ((mode.h_total * mode.v_total) or 1)))
@@ -333,15 +328,15 @@
 
 
 def _changeMode(mode: Structs.DisplayMode, name: str = ""):
     # https://stackoverflow.com/questions/12706631/x11-change-resolution-and-make-window-fullscreen
     # Xlib.ext.randr.set_screen_size(defaultRootWindow.root, mode.width, mode.height, 0, 0)
     # Xlib.ext.randr.set_screen_config(defaultRootWindow.root, size_id, 0, 0, round(mode.frequency), 0)
     # Xlib.ext.randr.change_output_property()
-    allModes = _getAllowedModes()
+    allModes = _getAllowedModes(name)
     if mode in allModes:
         cmd = " -s %sx%s -r %s" % (mode.width, mode.height, round(mode.frequency))
         if name and name in __getMonitorsNames():
             cmd = (" --output %s" % name) + cmd
             # cmd = (" --screen %s" % 0) + cmd
         cmd = "xrandr" + cmd
         ret = subprocess.check_output(cmd, shell=True).decode(encoding="utf-8").replace("\n", "")
@@ -355,15 +350,15 @@
     pass
 
 
 def _changePosition(newX: int, newY: int, name: str = ""):
     pass
 
 
-def _getMousePos() -> Point:
+def _getMousePos() -> Structs.Point:
     """
     Get the current (x, y) coordinates of the mouse pointer on screen, in pixels
 
     :return: Point struct
     """
     mp = defaultRootWindow.root.query_pointer()
-    return Point(mp.root_x, mp.root_y)
+    return Structs.Point(mp.root_x, mp.root_y)
```

## pymonctl/_pymonctl_macos.py

```diff
@@ -9,164 +9,138 @@
 assert sys.platform == "darwin"
 
 from typing import Optional, List
 
 import AppKit
 import Quartz
 
-from pymonctl._mybox import Rect, Point, Size, pointInBox
-from pymonctl import Structs
+from pymonctl import Structs, pointInBox
 
 
-def _getAllScreens():
-    result: dict[str, Structs.ScreenValue] = {}
+def __getAllMonitors(name: str = ""):
     screens = AppKit.NSScreen.screens()
     for screen in screens:
+        desc = screen.deviceDescription()
+        displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
         try:
-            name = screen.localizedName()   # In older macOS, screen doesn't have localizedName() method
+            scrName = screen.localizedName() + "_" + str(displayId)  # In older macOS, screen doesn't have localizedName() method
         except:
-            name = "Display"
+            scrName = "Display" + "_" + str(displayId)
 
-        desc = screen.deviceDescription()
-        display = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
+        if not name or (name and scrName == name):
+            yield [screen, desc, displayId, scrName]
+            if name:
+                break
+
+
+def __getDisplayId(name: str = ""):
+    displayId = 0
+    if name:
+        for mon in __getAllMonitors(name):
+            screen, desc, displayId, scrName = mon
+            displayId = desc['NSScreenNumber']
+            break
+    else:
+        displayId = Quartz.CGMainDisplayID()
+    return displayId
+
+
+def _getAllScreens():
+    result: dict[str, Structs.ScreenValue] = {}
+    for mon in __getAllMonitors():
+        screen, desc, displayId, scrName = mon
+
+        display = displayId
         is_primary = Quartz.CGDisplayIsMain(display) == 1
         x, y, w, h = int(screen.frame().origin.x), int(screen.frame().origin.y), int(screen.frame().size.width), int(screen.frame().size.height)
         wa = screen.visibleFrame()
         wx, wy, wr, wb = int(wa.origin.x), int(wa.origin.y), int(wa.size.width), int(wa.size.height)
         scale = int(screen.backingScaleFactor() * 100)
         dpi = desc[Quartz.NSDeviceResolution].sizeValue()
         dpiX, dpiY = int(dpi.width), int(dpi.height)
         rot = int(Quartz.CGDisplayRotation(display))
         freq = Quartz.CGDisplayModeGetRefreshRate(Quartz.CGDisplayCopyDisplayMode(display))
         depth = Quartz.CGDisplayBitsPerPixel(display)
 
-        result[name + "_" + str(display)] = {
+        result[scrName + "_" + str(display)] = {
             'id': display,
             'is_primary': is_primary,
-            'pos': Point(x, y),
-            'size': Size(w, h),
-            'workarea': Rect(wx, wy, wr, wb),
+            'pos': Structs.Point(x, y),
+            'size': Structs.Size(w, h),
+            'workarea': Structs.Rect(wx, wy, wr, wb),
             'scale': (scale, scale),
             'dpi': (dpiX, dpiY),
             'orientation': rot,
             'frequency': freq,
             'colordepth': depth
         }
     return result
 
 
 def _getMonitorsCount() -> int:
     return len(AppKit.NSScreen.screens())
 
 
-def _getScreenSize(name: str = "") -> Optional[Size]:
-    res: Optional[Size] = None
+def _getScreenSize(name: str = "") -> Optional[Structs.Size]:
+    res: Optional[Structs.Size] = None
     if name:
-        screens = AppKit.NSScreen.screens()
-        for screen in screens:
-            desc = screen.deviceDescription()
-            displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
-            try:
-                scrName = screen.localizedName() + "_" + str(displayId)  # In older macOS, screen doesn't have localizedName() method
-            except:
-                scrName = "Display" + "_" + str(displayId)
-
-            if scrName == name:
-                size = screen.frame().size
-                res = Size(int(size.width), int(size.height))
+        for mon in __getAllMonitors(name):
+            screen, desc, displayId, scrName = mon
+            size = screen.frame().size
+            res = Structs.Size(int(size.width), int(size.height))
+            break
     else:
         size = AppKit.NSScreen.mainScreen().frame().size
-        res = Size(int(size.width), int(size.height))
+        res = Structs.Size(int(size.width), int(size.height))
     return res
 
 
-def _getWorkArea(name: str = "") -> Optional[Rect]:
-    res: Optional[Rect] = None
+def _getWorkArea(name: str = "") -> Optional[Structs.Rect]:
+    res: Optional[Structs.Rect] = None
     if name:
-        screens = AppKit.NSScreen.screens()
-        for screen in screens:
-            desc = screen.deviceDescription()
-            displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
-            try:
-                scrName = screen.localizedName() + "_" + str(displayId)  # In older macOS, screen doesn't have localizedName() method
-            except:
-                scrName = "Display" + "_" + str(displayId)
-
-            if scrName == name:
-                wa = screen.visibleFrame()
-                wx, wy, wr, wb = int(wa.origin.x), int(wa.origin.y), int(wa.size.width), int(wa.size.height)
-                res = Rect(wx, wy, wr, wb)
+        for mon in __getAllMonitors(name):
+            screen, desc, displayId, scrName = mon
+            wa = screen.visibleFrame()
+            wx, wy, wr, wb = int(wa.origin.x), int(wa.origin.y), int(wa.size.width), int(wa.size.height)
+            res = Structs.Rect(wx, wy, wr, wb)
+            break
     else:
         wa = AppKit.NSScreen.mainScreen().visibleFrame()
         wx, wy, wr, wb = int(wa.origin.x), int(wa.origin.y), int(wa.size.width), int(wa.size.height)
-        res = Rect(wx, wy, wr, wb)
+        res = Structs.Rect(wx, wy, wr, wb)
     return res
 
 
-def __getDisplayId(name: str = ""):
+def _getPosition(name: str = "") -> Optional[Structs.Point]:
+    res: Optional[Structs.Point] = None
     if name:
-        displayId = None
-        screens = AppKit.NSScreen.screens()
-        for screen in screens:
-            desc = screen.deviceDescription()
-            number = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
-            try:
-                scrName = screen.localizedName() + "_" + str(number)  # In older macOS, screen doesn't have localizedName() method
-            except:
-                scrName = "Display" + "_" + str(number)
-
-            if scrName == name:
-                desc = screen.deviceDescription()
-                displayId = desc['NSScreenNumber']
-    else:
-        displayId = Quartz.CGMainDisplayID()
-    return displayId
-
-
-def _getPosition(name: str = "") -> Optional[Point]:
-    res: Optional[Point] = None
-    if name:
-        screens = AppKit.NSScreen.screens()
-        for screen in screens:
-            desc = screen.deviceDescription()
-            displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
-            try:
-                scrName = screen.localizedName() + "_" + str(displayId)  # In older macOS, screen doesn't have localizedName() method
-            except:
-                scrName = "Display" + "_" + str(displayId)
-
-            if scrName == name:
-                origin = screen.frame().origin
-                res = Point(int(origin.x), int(origin.y))
+        for mon in __getAllMonitors(name):
+            screen, desc, displayId, scrName = mon
+            origin = screen.frame().origin
+            res = Structs.Point(int(origin.x), int(origin.y))
+            break
     else:
         origin = AppKit.NSScreen.mainScreen().frame().origin
-        res = Point(int(origin.x), int(origin.y))
+        res = Structs.Point(int(origin.x), int(origin.y))
     return res
 
 
-def _getRect(name: str = "") -> Optional[Rect]:
-    res: Optional[Rect] = None
+def _getRect(name: str = "") -> Optional[Structs.Rect]:
+    res: Optional[Structs.Rect] = None
     if name:
-        screens = AppKit.NSScreen.screens()
-        for screen in screens:
-            desc = screen.deviceDescription()
-            displayId = desc['NSScreenNumber']  # Quartz.NSScreenNumber seems to be wrong
-            try:
-                scrName = screen.localizedName() + "_" + str(displayId)  # In older macOS, screen doesn't have localizedName() method
-            except:
-                scrName = "Display" + "_" + str(displayId)
-
-            if scrName == name:
-                frame = screen.frame()
-                res = Rect(int(frame.origin.x), int(frame.origin.y),
-                           int(frame.origin.x) + int(frame.size.width), int(frame.origin.y) + int(frame.size.height))
+        for mon in __getAllMonitors(name):
+            screen, desc, displayId, scrName = mon
+            frame = screen.frame()
+            res = Structs.Rect(int(frame.origin.x), int(frame.origin.y),
+                               int(frame.origin.x) + int(frame.size.width), int(frame.origin.y) + int(frame.size.height))
+            break
     else:
         frame = AppKit.NSScreen.mainScreen().frame()
-        res = Rect(int(frame.origin.x), int(frame.origin.y),
-                   int(frame.origin.x) + int(frame.size.width),  int(frame.origin.y) + int(frame.size.height))
+        res = Structs.Rect(int(frame.origin.x), int(frame.origin.y),
+                           int(frame.origin.x) + int(frame.size.width),  int(frame.origin.y) + int(frame.size.height))
     return res
 
 
 def _findMonitorName(x: int, y: int) -> str:
     name = ""
     screens = AppKit.NSScreen.screens()
     for screen in screens:
@@ -227,15 +201,15 @@
     pass
 
 
 def _changePosition(newX: int, newY: int, name: str = ""):
     pass
 
 
-def _getMousePos(unflipValues: bool = False) -> Point:
+def _getMousePos(unflipValues: bool = False) -> Structs.Point:
     """
     Get the current (x, y) coordinates of the mouse pointer on screen, in pixels
 
     Notice in AppKit the origin (0, 0) is bottom left (unflipped), which may differ to coordinates obtained
     using AppScript or CoreGraphics (flipped). To manage this, use 'unflipValues' accordingly.
 
     :param unflipValues: set to ''True'' to convert coordinates to origin (0, 0) at upper left corner
@@ -248,8 +222,8 @@
         screens = AppKit.NSScreen.screens()
         for screen in screens:
             frame = screen.frame()
             sx, sy, sw, sh = int(frame.origin.x), int(frame.origin.y), int(frame.size.width), int(frame.size.height)
             if pointInBox(x, y, sx, sy, sw, sh):
                 y = (-1 if y < 0 else 1) * int(sh) - abs(y)
                 break
-    return Point(x, y)
+    return Structs.Point(x, y)
```

## pymonctl/_pymonctl_win.py

```diff
@@ -8,156 +8,147 @@
 
 import ctypes
 import pywintypes
 from typing import Optional, List
 import win32api
 import win32con
 
-from pymonctl._mybox import Rect, Point, Size
 from pymonctl import Structs
 
 
+dpiAware = ctypes.windll.user32.GetAwarenessFromDpiAwarenessContext(ctypes.windll.user32.GetThreadDpiAwarenessContext())
+if dpiAware == 0:
+    # It seems that this can't be invoked twice. Setting it to 2 for apps having 0 (unaware) may have less impact
+    ctypes.windll.shcore.SetProcessDpiAwareness(2)
+
+
+def __getAllMonitors(name: str = ""):
+    for monitor in win32api.EnumDisplayMonitors():
+        hMon = monitor[0].handle
+        monitorInfo = win32api.GetMonitorInfo(hMon)
+        if not name or (name and monitorInfo["Device"] == name):
+            yield [hMon, monitorInfo]
+
+
 def _getAllScreens() -> dict[str, Structs.ScreenValue]:
     # https://stackoverflow.com/questions/35814309/winapi-changedisplaysettingsex-does-not-work
     result: dict[str, Structs.ScreenValue] = {}
-    # dpiAware = ctypes.windll.user32.GetAwarenessFromDpiAwarenessContext(ctypes.windll.user32.GetThreadDpiAwarenessContext())
-    # if dpiAware == 0:
-    #     ctypes.windll.shcore.SetProcessDpiAwareness(2)
     monitors = win32api.EnumDisplayMonitors()
     i = 0
     while True:
         try:
             dev = win32api.EnumDisplayDevices(None, i, 0)
         except:
             break
 
-        if dev and dev.StateFlags & win32con.DISPLAY_DEVICE_ATTACHED_TO_DESKTOP:
-            try:
-                # Device content: http://timgolden.me.uk/pywin32-docs/PyDISPLAY_DEVICE.html
-                # Settings content: http://timgolden.me.uk/pywin32-docs/PyDEVMODE.html
-                monitor_info = None
-                monitor = None
-                for mon in monitors:
-                    monitor = mon[0].handle
-                    monitor_info = win32api.GetMonitorInfo(monitor)
-                    if monitor_info["Device"] == dev.DeviceName:
-                        break
-
-                if monitor_info:
-                    name = dev.DeviceName
-                    x, y, r, b = monitor_info["Monitor"]
-                    wx, wy, wr, wb = monitor_info["Work"]
-                    settings = win32api.EnumDisplaySettings(dev.DeviceName, win32con.ENUM_CURRENT_SETTINGS)
-                    # values seem to be affected by the scale factor of the first display
-                    wr, wb = wx + settings.PelsWidth + (wr - r), wy + settings.PelsHeight + (wb - b)
-                    is_primary = ((x, y) == (0, 0))
-                    r, b = x + settings.PelsWidth, y + settings.PelsHeight
-                    pScale = ctypes.c_uint()
-                    ctypes.windll.shcore.GetScaleFactorForMonitor(monitor, ctypes.byref(pScale))
-                    scale = pScale.value
-                    dpiX = ctypes.c_uint()
-                    dpiY = ctypes.c_uint()
-                    ctypes.windll.shcore.GetDpiForMonitor(monitor, 0, ctypes.byref(dpiX), ctypes.byref(dpiY))
-                    rot = settings.DisplayOrientation
-                    freq = settings.DisplayFrequency
-                    depth = settings.BitsPerPel
-
-                    result[name] = {
-                        "id": i,
-                        # "is_primary": monitor_info.get("Flags", 0) & win32con.MONITORINFOF_PRIMARY == 1,
-                        "is_primary": is_primary,
-                        "pos": Point(x, y),
-                        "size": Size(abs(r - x), abs(b - y)),
-                        "workarea": Rect(wx, wy, wr, wb),
-                        "scale": (scale, scale),
-                        "dpi": (dpiX.value, dpiY.value),
-                        "orientation": rot,
-                        "frequency": freq,
-                        "colordepth": depth
-                    }
-            except:
-                pass
+        if dev.StateFlags & win32con.DISPLAY_DEVICE_ATTACHED_TO_DESKTOP:
+            # Device content: http://timgolden.me.uk/pywin32-docs/PyDISPLAY_DEVICE.html
+            # Settings content: http://timgolden.me.uk/pywin32-docs/PyDEVMODE.html
+            monitorInfo = None
+            monitor = None
+            for mon in monitors:
+                monitor = mon[0].handle
+                monitorInfo = win32api.GetMonitorInfo(monitor)
+                if monitorInfo["Device"] == dev.DeviceName:
+                    break
+
+            if monitorInfo:
+                print(monitorInfo)
+                print()
+                name = dev.DeviceName
+                x, y, r, b = monitorInfo["Monitor"]
+                wx, wy, wr, wb = monitorInfo["Work"]
+                is_primary = monitorInfo["Flags"] == 1
+                pScale = ctypes.c_uint()
+                ctypes.windll.shcore.GetScaleFactorForMonitor(monitor, ctypes.byref(pScale))
+                scale = pScale.value
+                dpiX = ctypes.c_uint()
+                dpiY = ctypes.c_uint()
+                ctypes.windll.shcore.GetDpiForMonitor(monitor, 0, ctypes.byref(dpiX), ctypes.byref(dpiY))
+                settings = win32api.EnumDisplaySettings(dev.DeviceName, win32con.ENUM_CURRENT_SETTINGS)
+                rot = settings.DisplayOrientation
+                freq = settings.DisplayFrequency
+                depth = settings.BitsPerPel
+
+                result[name] = {
+                    "id": win32api.MonitorFromPoint((x, y)),
+                    # "is_primary": monitor_info.get("Flags", 0) & win32con.MONITORINFOF_PRIMARY == 1,
+                    "is_primary": is_primary,
+                    "pos": Structs.Point(x, y),
+                    "size": Structs.Size(abs(r - x), abs(b - y)),
+                    "workarea": Structs.Rect(wx, wy, wr, wb),
+                    "scale": (scale, scale),
+                    "dpi": (dpiX.value, dpiY.value),
+                    "orientation": rot,
+                    "frequency": freq,
+                    "colordepth": depth
+                }
         i += 1
     return result
 
 
 def _getMonitorsCount() -> int:
     return len(win32api.EnumDisplayMonitors())
 
 
-def _getScreenSize(name: str = "") -> Optional[Size]:
-    size: Optional[Size] = None
+def _getScreenSize(name: str = "") -> Optional[Structs.Size]:
+    size: Optional[Structs.Size] = None
     if name:
-        screens = win32api.EnumDisplayMonitors()
-        for screen in screens:
-            scr = screen[0].handle
-            monitorInfo = win32api.GetMonitorInfo(scr)
-            if monitorInfo["Device"] == name:
-                x, y, r, b = monitorInfo["Monitor"]
-                size = Size(abs(r - x), abs(b - y))
-                break
+        for mon in __getAllMonitors(name):
+            monitorInfo = mon[1]
+            x, y, r, b = monitorInfo["Monitor"]
+            size = Structs.Size(abs(r - x), abs(b - y))
+            break
     else:
-        size = Size(ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1))
+        size = Structs.Size(ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1))
     return size
 
 
-def _getWorkArea(name: str = "") -> Optional[Rect]:
-    workarea: Optional[Rect] = None
+def _getWorkArea(name: str = "") -> Optional[Structs.Rect]:
+    workarea: Optional[Structs.Rect] = None
     if name:
-        screens = win32api.EnumDisplayMonitors()
-        for screen in screens:
-            scr = screen[0].handle
-            monitorInfo = win32api.GetMonitorInfo(scr)
-            if monitorInfo["Device"] == name:
-                x, y, r, b = monitorInfo["Monitor"]
-                wx, wy, wr, wb = monitorInfo["Work"]
-                # values seem to be affected by the scale factor of the primary display
-                settings = win32api.EnumDisplaySettings(name, win32con.ENUM_CURRENT_SETTINGS)
-                wr, wb = wx + settings.PelsWidth + (wr - r), wy + settings.PelsHeight + (wb - b)
-                workarea = Rect(wx, wy, wr, wb)
-                break
+        for mon in __getAllMonitors(name):
+            monitorInfo = mon[1]
+            wx, wy, wr, wb = monitorInfo["Work"]
+            # # values seem to be affected by the scale factor of the primary display
+            # x, y, r, b = monitorInfo["Monitor"]
+            # settings = win32api.EnumDisplaySettings(name, win32con.ENUM_CURRENT_SETTINGS)
+            # wr, wb = wx + settings.PelsWidth + (wr - r), wy + settings.PelsHeight + (wb - b)
+            workarea = Structs.Rect(wx, wy, wr, wb)
+            break
     else:
         monitorInfo = win32api.GetMonitorInfo(win32api.MonitorFromPoint((0, 0)))
-        x, y, r, b = monitorInfo["Monitor"]
         wx, wy, wr, wb = monitorInfo["Work"]
-        settings = win32api.EnumDisplaySettings(None, win32con.ENUM_CURRENT_SETTINGS)
-        wr, wb = wx + settings.PelsWidth + (wr - r), wy + settings.PelsHeight + (wb - b)
-        workarea = Rect(wx, wy, wr, wb)
+        workarea = Structs.Rect(wx, wy, wr, wb)
     return workarea
 
 
-def _getPosition(name: str = "") -> Optional[Point]:
-    pos: Optional[Point] = None
+def _getPosition(name: str = "") -> Optional[Structs.Point]:
+    pos: Optional[Structs.Point] = None
     if name:
-        screens = win32api.EnumDisplayMonitors()
-        for screen in screens:
-            scr = screen[0].handle
-            monitorInfo = win32api.GetMonitorInfo(scr)
-            if monitorInfo["Device"] == name:
-                x, y, r, b = monitorInfo["Monitor"]
-                pos = Point(x, y)
-                break
+        for mon in __getAllMonitors(name):
+            monitorInfo = mon[1]
+            x, y, r, b = monitorInfo["Monitor"]
+            pos = Structs.Point(x, y)
+            break
     else:
-        pos = Point(0, 0)
+        pos = Structs.Point(0, 0)
     return pos
 
 
-def _getRect(name: str = "") -> Optional[Rect]:
-    rect: Optional[Rect] = None
+def _getRect(name: str = "") -> Optional[Structs.Rect]:
+    rect: Optional[Structs.Rect] = None
     if name:
-        screens = win32api.EnumDisplayMonitors()
-        for screen in screens:
-            scr = screen[0].handle
-            monitorInfo = win32api.GetMonitorInfo(scr)
-            if monitorInfo["Device"] == name:
-                x, y, r, b = monitorInfo["Monitor"]
-                rect = Rect(x, y, r, b)
-                break
+        for mon in __getAllMonitors(name):
+            monitorInfo = mon[1]
+            x, y, r, b = monitorInfo["Monitor"]
+            rect = Structs.Rect(x, y, r, b)
+            break
     else:
-        rect = Rect(0, 0, ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1))
+        rect = Structs.Rect(0, 0, ctypes.windll.user32.GetSystemMetrics(0), ctypes.windll.user32.GetSystemMetrics(1))
     return rect
 
 
 def _findMonitorName(x: int, y: int) -> str:
     name = ""
     monitor = win32api.MonitorFromPoint((x, y))
     if monitor:
@@ -228,19 +219,15 @@
     pass
 
 
 def _changePosition(newX: int, newY: int, name: str = ""):
     pass
 
 
-def _getMousePos() -> Point:
+def _getMousePos() -> Structs.Point:
     """
     Get the current (x, y) coordinates of the mouse pointer on screen, in pixels
 
     :return: Point struct
     """
-    # dpiAware = ctypes.windll.user32.GetAwarenessFromDpiAwarenessContext(ctypes.windll.user32.GetThreadDpiAwarenessContext())
-    # if dpiAware == 0:
-    #     # It seems that this can't be invoked twice. Setting it to 2 for apps having 0 (unaware) may have less impact
-    #     ctypes.windll.shcore.SetProcessDpiAwareness(2)
     x, y = win32api.GetCursorPos()
-    return Point(x, y)
+    return Structs.Point(x, y)
```

## Comparing `PyMonCtl-0.0.1.dist-info/LICENSE.txt` & `PyMonCtl-0.0.2.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `PyMonCtl-0.0.1.dist-info/METADATA` & `PyMonCtl-0.0.2.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: PyMonCtl
-Version: 0.0.1
+Version: 0.0.2
 Summary: Cross-Platform toolkit to get info on and control monitors connected
 Home-page: https://github.com/Kalmat/PyMonCtl
 Author: Kalmat
 Author-email: palookjones@gmail.com
 License: BSD 3
 Keywords: screen display monitor control geometry size position frequency scale orientation screen-size mouse-position
 Classifier: Development Status :: 4 - Beta
```

