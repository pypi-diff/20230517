# Comparing `tmp/k1lib-1.3.8.4-py3-none-any.whl.zip` & `tmp/k1lib-1.3.8.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 2539854 bytes, number of entries: 84
+Zip file size: 2541207 bytes, number of entries: 84
 -rw-rw-r--  2.0 unx     1435 b- defN 23-Feb-08 00:13 k1lib/__init__.py
 -rw-rw-r--  2.0 unx    53793 b- defN 23-Apr-02 08:25 k1lib/_baseClasses.py
 -rw-rw-r--  2.0 unx    13494 b- defN 23-May-05 13:41 k1lib/_basics.py
 -rw-rw-r--  2.0 unx     4908 b- defN 23-May-08 18:53 k1lib/_context.py
 -rw-rw-r--  2.0 unx     2866 b- defN 22-Jul-20 04:30 k1lib/_higher.py
 -rw-rw-r--  2.0 unx      948 b- defN 22-Sep-21 23:54 k1lib/_k1a.py
 -rw-rw-r--  2.0 unx    11646 b- defN 23-Jan-14 15:37 k1lib/_learner.py
@@ -43,44 +43,44 @@
 -rw-rw-r--  2.0 unx     3465 b- defN 22-Nov-27 08:16 k1lib/callbacks/lossFunctions/shorts.py
 -rw-rw-r--  2.0 unx       45 b- defN 21-Aug-11 18:19 k1lib/callbacks/profilers/__init__.py
 -rw-rw-r--  2.0 unx     5054 b- defN 22-May-15 09:01 k1lib/callbacks/profilers/computation.py
 -rw-rw-r--  2.0 unx     2319 b- defN 22-May-15 08:59 k1lib/callbacks/profilers/io.py
 -rw-rw-r--  2.0 unx     4419 b- defN 22-May-15 09:00 k1lib/callbacks/profilers/memory.py
 -rw-rw-r--  2.0 unx     4215 b- defN 22-May-15 09:03 k1lib/callbacks/profilers/time.py
 -rw-rw-r--  2.0 unx      925 b- defN 22-Nov-16 09:22 k1lib/cli/__init__.py
--rw-rw-r--  2.0 unx    12928 b- defN 23-May-17 03:26 k1lib/cli/_applyCl.py
+-rw-rw-r--  2.0 unx    13717 b- defN 23-May-17 17:15 k1lib/cli/_applyCl.py
 -rw-rw-r--  2.0 unx     8308 b- defN 22-Nov-27 07:16 k1lib/cli/bio.py
 -rw-rw-r--  2.0 unx     4033 b- defN 23-Jan-25 02:02 k1lib/cli/cif.py
--rw-rw-r--  2.0 unx    19291 b- defN 23-May-12 02:55 k1lib/cli/conv.py
+-rw-rw-r--  2.0 unx    19311 b- defN 23-May-17 18:09 k1lib/cli/conv.py
 -rw-rw-r--  2.0 unx    24071 b- defN 23-May-17 03:12 k1lib/cli/filt.py
 -rw-rw-r--  2.0 unx     6672 b- defN 23-Jan-25 02:02 k1lib/cli/gb.py
 -rw-rw-r--  2.0 unx     6348 b- defN 23-Apr-05 15:10 k1lib/cli/grep.py
 -rw-rw-r--  2.0 unx    18351 b- defN 23-May-12 23:10 k1lib/cli/init.py
--rw-rw-r--  2.0 unx    25932 b- defN 23-May-16 19:47 k1lib/cli/inp.py
+-rw-rw-r--  2.0 unx    25961 b- defN 23-May-17 14:30 k1lib/cli/inp.py
 -rw-rw-r--  2.0 unx      623 b- defN 22-Jun-22 10:43 k1lib/cli/kcsv.py
 -rw-rw-r--  2.0 unx     4819 b- defN 22-Aug-11 20:44 k1lib/cli/kxml.py
 -rw-rw-r--  2.0 unx     1915 b- defN 21-Nov-12 16:48 k1lib/cli/mgi.py
--rw-rw-r--  2.0 unx    57496 b- defN 23-May-17 03:30 k1lib/cli/modifier.py
+-rw-rw-r--  2.0 unx    60829 b- defN 23-May-17 18:02 k1lib/cli/modifier.py
 -rw-rw-r--  2.0 unx      694 b- defN 22-Nov-27 07:17 k1lib/cli/mol.py
 -rw-rw-r--  2.0 unx     4038 b- defN 23-May-09 15:53 k1lib/cli/nb.py
 -rw-rw-r--  2.0 unx     3530 b- defN 22-Aug-16 15:08 k1lib/cli/optimizations.py
 -rw-rw-r--  2.0 unx    11762 b- defN 23-May-16 18:04 k1lib/cli/output.py
 -rw-rw-r--  2.0 unx     2394 b- defN 23-Jan-25 02:03 k1lib/cli/sam.py
 -rw-rw-r--  2.0 unx    49930 b- defN 23-May-11 15:29 k1lib/cli/structural.py
 -rw-rw-r--  2.0 unx    10399 b- defN 22-Aug-05 01:15 k1lib/cli/trace.py
 -rw-rw-r--  2.0 unx    23319 b- defN 22-Sep-29 07:14 k1lib/cli/typehint.py
--rw-rw-r--  2.0 unx    20345 b- defN 23-Apr-26 17:09 k1lib/cli/utils.py
+-rw-rw-r--  2.0 unx    21101 b- defN 23-May-17 16:57 k1lib/cli/utils.py
 -rw-rw-r--  2.0 unx       20 b- defN 23-Jan-19 22:00 k1lib/k1ui/__init__.py
 -rw-rw-r--  2.0 unx    61803 b- defN 23-Feb-10 12:10 k1lib/k1ui/main.py
 -rw-rw-r--  2.0 unx       20 b- defN 22-Sep-16 01:12 k1lib/serve/__init__.py
 -rw-rw-r--  2.0 unx    10361 b- defN 23-May-05 16:49 k1lib/serve/main.py
 -rw-rw-r--  2.0 unx      153 b- defN 23-May-05 16:00 k1lib/serve/suffix-dash.py
 -rw-rw-r--  2.0 unx      642 b- defN 23-Feb-13 19:00 k1lib/serve/suffix.py
--rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.3.8.4.data/data/k1lib/k1ui/256.model.state_dict.pth
--rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.3.8.4.data/data/k1lib/k1ui/mouseKey.pth
--rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.3.8.4.data/data/k1lib/serve/main.html
--rw-rw-r--  2.0 unx     1049 b- defN 23-May-17 03:31 k1lib-1.3.8.4.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3864 b- defN 23-May-17 03:31 k1lib-1.3.8.4.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-17 03:31 k1lib-1.3.8.4.dist-info/WHEEL
--rw-rw-r--  2.0 unx        6 b- defN 23-May-17 03:31 k1lib-1.3.8.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6704 b- defN 23-May-17 03:31 k1lib-1.3.8.4.dist-info/RECORD
-84 files, 3505198 bytes uncompressed, 2529514 bytes compressed:  27.8%
+-rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.3.8.5.data/data/k1lib/k1ui/256.model.state_dict.pth
+-rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.3.8.5.data/data/k1lib/k1ui/mouseKey.pth
+-rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.3.8.5.data/data/k1lib/serve/main.html
+-rw-rw-r--  2.0 unx     1049 b- defN 23-May-17 18:09 k1lib-1.3.8.5.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3864 b- defN 23-May-17 18:09 k1lib-1.3.8.5.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-17 18:09 k1lib-1.3.8.5.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-17 18:09 k1lib-1.3.8.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6704 b- defN 23-May-17 18:09 k1lib-1.3.8.5.dist-info/RECORD
+84 files, 3510125 bytes uncompressed, 2530867 bytes compressed:  27.9%
```

## zipnote {}

```diff
@@ -222,32 +222,32 @@
 
 Filename: k1lib/serve/suffix-dash.py
 Comment: 
 
 Filename: k1lib/serve/suffix.py
 Comment: 
 
-Filename: k1lib-1.3.8.4.data/data/k1lib/k1ui/256.model.state_dict.pth
+Filename: k1lib-1.3.8.5.data/data/k1lib/k1ui/256.model.state_dict.pth
 Comment: 
 
-Filename: k1lib-1.3.8.4.data/data/k1lib/k1ui/mouseKey.pth
+Filename: k1lib-1.3.8.5.data/data/k1lib/k1ui/mouseKey.pth
 Comment: 
 
-Filename: k1lib-1.3.8.4.data/data/k1lib/serve/main.html
+Filename: k1lib-1.3.8.5.data/data/k1lib/serve/main.html
 Comment: 
 
-Filename: k1lib-1.3.8.4.dist-info/LICENSE
+Filename: k1lib-1.3.8.5.dist-info/LICENSE
 Comment: 
 
-Filename: k1lib-1.3.8.4.dist-info/METADATA
+Filename: k1lib-1.3.8.5.dist-info/METADATA
 Comment: 
 
-Filename: k1lib-1.3.8.4.dist-info/WHEEL
+Filename: k1lib-1.3.8.5.dist-info/WHEEL
 Comment: 
 
-Filename: k1lib-1.3.8.4.dist-info/top_level.txt
+Filename: k1lib-1.3.8.5.dist-info/top_level.txt
 Comment: 
 
-Filename: k1lib-1.3.8.4.dist-info/RECORD
+Filename: k1lib-1.3.8.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## k1lib/cli/_applyCl.py

```diff
@@ -1,10 +1,12 @@
 # AUTOGENERATED FILE! PLEASE DON'T EDIT
 from k1lib.imports import *
-def getIr(base): return None | applyCl.aS(lambda: ls(base) | iden() & apply(os.path.getsize) | transpose() | deref()) | ungroup(begin=True) | insertIdColumn(True) | deref()
+getFolderSize = ls() | filt(os.path.isdir).split() | apply(lambda x: x | (tryout(0) | getFolderSize)) + apply(os.path.getsize) | toSum().all() | toSum() | deref()
+getFilesInFolder = aS(os.walk) | cut(0, 2) | ungroup(True, True) | join(os.sep).all()
+def getIr(base): return None | applyCl.aS(lambda: ls(base) | iden() & apply(lambda x: x | (tryout(0) | (aS(os.path.getsize) if os.path.isfile(x) else getFolderSize))) | transpose() | deref()) | ungroup(begin=True) | insertIdColumn(True) | deref()
 def normalize(d):
     d = d | deref(); s = d | cut(1) | toSum()
     return d | apply(op()/s, 1) | sort(0, False) | deref()
 @lru_cache
 def statsCpu():
     cpu = None | applyCl.aS(applyCl.cpu) | sort(0, False) | deref()
     cpuF = None | applyCl.aS(applyCl.cpu) | aS(normalize); cpuF # "cpuF" = cpu fraction. List[nodeId, cpu fraction]
@@ -38,36 +40,45 @@
     # print(f"sfA: {sfA}, cfA: {cfA}")
     exp = 5 # intuition says that exp should be even. But that doesn't work. Odd values work tho, but I have no idea why
     idx = fA[1][((sfA-cfA)**exp + (sfB-cfB)**exp).argmin()][0]
     ir2 = move(ir, nA, nB, idx)
     return ir2, [nA, nB, idx, score(ir2)]
 def traj(ir, maxSteps=20):
     sc = score(ir); aux = None; auxs = []; irs = []
+    maxSteps = maxSteps if maxSteps is not None else int(1e10)
     for i in range(maxSteps):
         ir, aux = optimize(ir)
         if aux[3] > sc: break
         irs.append(ir); auxs.append(aux); sc = aux[3]
     return irs, auxs
 def collapse(it):
     a, b = it | rows(0, -1)
     c = [a[0], b[1], a[2], b[3]]
     if c[0] == c[1]: return []
     return [c]
 def traj2(ir, maxSteps=20):
     idx2FileName = ir | apply(lambda arr: [arr[0], arr[2]]) | toDict()
     a = traj(ir, maxSteps)[1] | groupBy(2) | filt(lambda x: len(x) > 1).split() | (apply(collapse)) + iden() | joinStreams(2) | deref()
     return a | lookup(idx2FileName, 2) | deref()
-def moveFile(fileName:str, destNodeId:str, timeout=60): # executed on remotes
+def moveFile(fileName:str, destNodeId:str, timeout=60):
+    """Moves file from the current node to the destination node. Usually executed on other nodes than the driver node"""
     fn = os.path.expanduser(fileName); dirname = os.path.dirname(fn)
     [destNodeId] | applyCl.aS(lambda: None | cmd(f"mkdir -p {dirname}; rm -f {fn}") | deref(), timeout=timeout) | deref()
     for chunk in cat(fn, False, True): [destNodeId] | applyCl.aS(lambda: chunk >> file(fn), timeout=timeout) | deref()
     None | cmd(f"rm {fn}") | deref()
-def balanceFolder(base, maxSteps=20):
+def moveFF(ff:str, destNodeId:str, timeout=60):
+    """Moves file or folder from the current node to the destination node"""
+    if os.path.isfile(ff): return moveFile(ff, destNodeId, timeout)
+    ff | getFilesInFolder | apply(aS(moveFile, destNodeId, timeout)) | deref()
+    None | cmd(f"rm -rf {ff}") | ignore()
+def balanceFolder(base, audit=False, maxSteps=20): # currently executing each move step serially, will change in the future if it's too slow
     applyCl.cmd(f"mkdir -p {base}")
-    traj2(getIr(base), maxSteps) | apply(lambda arr: [arr[0], arr]) | ~applyCl(lambda a,b,fn,sc: moveFile(fn, b), pre=True, timeout=60) | deref()
+    tr = traj2(getIr(base), maxSteps)
+    if audit: return tr
+    tr | apply(lambda arr: [arr[0], arr]) | ~applyCl(lambda a,b,fn,sc: moveFF(fn, b), pre=True, timeout=60) | deref()
 def getSize(url):
     for i in range(10):
         try: return requests.head(url, timeout=3).headers.items() | apply(op().lower(), 0) | toDict() | op()["content-length"].ab_int()
         except Exception as e:
             if i == 9: raise Exception(f"Can't get size of file")
 class NoPartialContent(Exception): pass
 def getChunk(url:str, sB:int, eB:int, timeout:float) -> bytes:
@@ -165,13 +176,12 @@
     dFolders = []; folders, files = diskScan1(base) | op().split("\ue000").all() | toInt(0) | filt(op(), 0).split() | (join("\ue000")).all(2) | deref()
     for folder in folders:
         fol, fil = diskScan2(folder)
         if len(fol) + len(fil) == 0: dFolders.append(folder)
         else: files.extend(fil)
     return [dFolders, files]
 def diskScan3(base:str): base = os.path.expanduser(base); return diskScan2(f"1\ue000{base}") | op().split("\ue000")[1].all(2) | deref()
-getFolderSize = ls() | filt(os.path.isdir).split() | apply(lambda x: x | getFolderSize) + apply(os.path.getsize) | toSum().all() | toSum() | deref()
 def diskScan4(base:str):
     folders, files = diskScan3(base)
     folders = [folders, None | applyCl.aS(lambda: folders | apply(lambda x: (x | getFolderSize) if os.path.exists(x) else 0) | deref()) | cut(1) | transpose()] | transpose() | deref()
     files   = [files,   None | applyCl.aS(lambda: files   | apply(lambda x: os.path.getsize(x)  if os.path.exists(x) else 0) | deref()) | cut(1) | transpose()] | transpose() | deref()
-    return folders, files
+    return [folders, files]
```

## k1lib/cli/conv.py

```diff
@@ -413,15 +413,16 @@
         if isinstance(it, str): return it.encode()
         if hasPIL:
             if isinstance(it, PIL.Image.Image):
                 it = it | toRgb()
                 buffered = io.BytesIO()
                 it.save(buffered, format=self.imgType)
                 return buffered.getvalue()
-        return NotImplemented
+        import dill
+        return dill.dumps(it)
 class toHtml(BaseCli):
     def __init__(self):
         """Converts several object types to bytes.
 Example::
 
     # converts PIL image to html <img> tag
     torch.randn(200, 100) | toImg() | toHtml()
```

## k1lib/cli/inp.py

```diff
@@ -351,15 +351,16 @@
 
 :param url: The url of the file
 :param fileName: if None, then tries to infer it from the url
 :param mkdir: whether to make the directory leading up to the file or not"""
     if fileName is None: fileName = url.split("/")[-1]
     fileName = os.path.expanduser(fileName); dirname = os.path.dirname(fileName)
     if mkdir: os.makedirs(dirname, exist_ok=True)
-    urllib.request.urlretrieve(url, fileName); return fileName
+    try: urllib.request.urlretrieve(url, fileName); return fileName
+    except: return None
 def ls(folder:str=None):
     """List every file and folder inside the specified folder.
 Example::
 
     # returns List[str]
     ls("/home")
     # same as above
```

## k1lib/cli/modifier.py

```diff
@@ -2,15 +2,15 @@
 """
 This is for quick modifiers, think of them as changing formats
 """
 __all__ = ["applyS", "aS", "apply", "map_", "applyMp", "parallel", "applyCl",
            "applyTh", "applySerial",
            "sort", "sortF", "consume", "randomize", "stagger", "op",
            "integrate"]
-from typing import Callable, Iterator, Any, Union, List
+from typing import Callable, Iterator, Any, Union, List, Tuple
 from k1lib.cli.init import patchDefaultDelim, BaseCli, T, fastF
 import k1lib.cli as cli, numpy as np, threading, gc; import k1lib
 from collections import deque
 from functools import partial, update_wrapper, lru_cache
 from k1lib.cli.typehint import *
 import dill, pickle, k1lib, warnings, atexit, signal, time, os, random
 try: import torch; import torch.multiprocessing as mp; hasTorch = True
@@ -81,22 +81,24 @@
     # returns 10
     [2, 3] | ~aS(f)
     # returns 11
     [2, 3] | ~aS(f, a=5)"""
         f = self.f; a = self.args; kw = self.kwargs; return applyS(lambda x: f(*x, *a, **kw));
 aS = applyS
 class apply(BaseCli):
-    def __init__(self, f:Callable[[T], T], column:int=None, cache:int=0, **kwargs):
+    def __init__(self, f:Callable[[T], T], column:Union[int, List[int]]=None, cache:int=0, **kwargs):
         """Applies a function f to every element in the incoming list/iterator.
 Example::
 
     # returns [0, 1, 4, 9, 16]
     range(5) | apply(lambda x: x**2) | deref()
-    # returns [[3.0, 1.0, 1.0], [3.0, 1.0, 1.0]]
+    # returns [[3.0, 1.0, 1.0], [3.0, 1.0, 1.0]], running the function on the 0th column
     torch.ones(2, 3) | apply(lambda x: x+2, 0) | deref()
+    # returns [[0, -1, 2, 3, -4], [2, -3, 4, 5, -6], [0, -1, 4, 9, -16]], running the function on the 1st (0-index btw) and 4th columns
+    [[0, 1, 2, 3, 4], [2, 3, 4, 5, 6], [0, 1, 4, 9, 16]] | apply(lambda x: -x, [1, 4]) | deref()
 
 You can also use this as a decorator, like this::
 
     @apply
     def f(x):
         return x**2
     # returns [0, 1, 4, 9, 16]
@@ -114,35 +116,47 @@
 
     def f(x, y, z=3):
         return x + y + z
     # returns [15, 17, 19, 21, 23]
     [range(5), range(10, 15)] | transpose() | ~apply(f, z=5) | deref()
 
 If "apply" is too hard to remember, this cli also has an alias :class:`map_`
-that kinda mimics Python's ``map()``.
+that kinda mimics Python's ``map()``. Also slight reminder that you can't pass
+in extra positional args like in :class:`aS`, just extra keyword arguments.
 
-:param column: if not None, then applies the function to that column only
+:param column: if not None, then applies the function to that column or columns only
 :param cache: if specified, then caches this much number of values
 :param kwargs: extra keyword arguments to pass in the function"""
         super().__init__(fs=[f]); self.f = f; self.kwargs = kwargs
-        if column and column < 0: raise Exception(f"Applying a function on a negative-indexed column ({column}) is not supported")
+        if column:
+            ex = Exception(f"Applying a function on a negative-indexed column ({column}) is not supported")
+            if isinstance(column, int):
+                if column < 0: raise ex
+            else:
+                column = list(column)
+                if len([c for c in column if c < 0]): raise ex
         self.column = column; self.cache = cache; self._fC = fastF(f)
         if cache > 0: self._fC = lru_cache(cache)(self._fC)
         self.normal = self.column is None and self.cache == 0 # cached value to say that this apply is just being used as a wrapper, nothing out of the ordinary
     def _typehint(self, inp):
         if self.column is None:
             if isinstance(inp, tListIterSet):
                 try: return tIter(self.f._typehint(inp.child))
                 except: return tIter(tAny())
         return super()._typehint(inp)
+    def _copy(self): return apply(self.f, self.column, self.cache, **self.kwargs) # ~apply() case handled automatically
     def __ror__(self, it:Iterator[str]):
         c = self.column; f = self._fC; kwargs = self.kwargs
         if c is None: return (f(line, **kwargs) for line in it)
-        else: return ([(e if i != c else f(e, **kwargs)) 
-                       for i, e in enumerate(row)] for row in it)
+        else:
+            if isinstance(c, int): return ([(e if i != c else f(e, **kwargs)) for i, e in enumerate(row)] for row in it)
+            else:
+                ops = []
+                for c_ in c: a = self._copy(); a.column = c_; ops.append(a)
+                return it | cli.serial(*ops)
     def __invert__(self):
         """Same mechanism as in :class:`applyS`, it expands the
 arguments out. Just for convenience really. Example::
 
     # returns [10, 12, 14, 16, 18]
     [range(5), range(10, 15)] | transpose() | ~apply(lambda x, y: x+y) | deref()"""
         return apply(lambda x: self.f(*x, **self.kwargs), self.column, self.cache)
@@ -287,25 +301,30 @@
                     print("applyMp encounter errors. Terminating pool now")
                     for p in self.ps: p.close(); p.terminate();
                     raise e
                 else:
                     for p in self.ps: p.close(); p.terminate();
         return gen(it)
     @staticmethod
-    def cat(fileName: str, f:Callable, n:int=None, **kwargs):
+    def cat(fileName: str, f:Callable, n:int=None, rS=None, **kwargs):
         """Like :meth:`applyCl.cat`, this will split a file up into multiple
 sections, execute ``f`` over all sections and return the results.
 Example::
 
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyMp.cat"
     "0123456789\\n"*100 | file(fn)
     # returns [6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 8]
     applyMp.cat(fn, shape(0), 16) | deref()
-"""
-        return fileName | cli.splitSeek(n or os.cpu_count()) | cli.splitSeek.window() | ~applyMp(lambda x,y: cli.cat(fileName, sB=x, eB=y) | f, **kwargs)
+
+:param f: function to execute on an iterator of lines
+:param n: how many chunks should it split the file into. Defaulted to the number of cpu cores available
+:param rS: :class:`~k1lib.cli.inp.refineSeek` instance, if you need more fine-grained
+    control over section boundaries so as to not make everything corrupted
+:param kwargs: extra keyword arguments for :class:`applyMp`"""
+        return fileName | cli.splitSeek(n or os.cpu_count()) | (rS or cli.iden()) | cli.window(2) | ~applyMp(lambda x,y: cli.cat(fileName, sB=x, eB=y) | f, **kwargs)
     @staticmethod
     def shared(f, **kwargs):
         """Execution model where the input iterator is dereferenced and shared across
 all processes, bypassing serialization. Example::
 
     a = range(1_000_000_000) | apply(lambda x: x*1.5 - 2000) | aS(list) # giant data structure
     a | batched(50_000_000, True) | applyMp(toSum()) | toSum() # has to serialize and deserialize lists of numbers, which wastes lots of cpu cycles and memory
@@ -646,15 +665,15 @@
         from k1lib.cli._applyCl import balanceFile
         balanceFile(fn, nAs, nBs, rS or cli.iden())
     def decommission(self, fn, nAs:List[str], rS=None):
         """Convenience function for :meth:`balanceFile`. See docs over there."""
         from k1lib.cli._applyCl import balanceFile
         balanceFile(fn, None, applyCl.nodeIds() | ~cli.inSet(nAs) | deref(), rS or cli.iden())
     @staticmethod
-    def cat(fn:str, f:Callable, timeout:float=60, keepNodeIds:bool=False, multiplier:int=1, includeId:bool=False):
+    def cat(fn:str=None, f:Callable=None, timeout:float=60, keepNodeIds:bool=False, multiplier:int=1, includeId:bool=False):
         """Reads a file distributedly, does some operation on them, collects and
 returns all of the data together. Example::
 
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.cat.data"
     ("0123456789"*5 + "\\n") * 1000 | file(fn)
     applyCl.splitFile(fn)
     applyCl.cat(fn, shape(0), keepNodeIds=True) | deref()
@@ -683,28 +702,59 @@
     applyCl.cmd(f"rm -r {dir_}/applyCl")    # clear out old folders
     applyCl.cmd(f"mkdir -p {dir_}/applyCl") # creating folders
     # do processing on fn distributedly, then dump results into multiple files
     applyCl.cat(fn, ~aS(lambda idx, lines: lines | shape(0) | aS(dill.dumps) | file(f"{dir_}/applyCl/{idx}.pth")), includeId=True) | deref()
     # reading all files and summing them together
     None | applyCl.aS(lambda: ls(f"{dir_}/applyCl")) | ungroup(single=True, begin=True) | applyCl(cat(text=False) | aS(dill.loads), pre=True) | cut(1) | toSum()
 
+.. admonition:: Simple mode
+
+    There's also another mode that's activated whenever f is not specified that feels
+    more like vanilla :class:`~inp.cat`. Say you have a file on a specific node::
+    
+        nodeId = "7bb387b2920694abe9f7d2a2ed939b6d31843faf91d174d0221e871d"
+        fn = "~/ssd2/randomFile.txt"
+        
+        # -------------- file is on current node --------------
+        cat(fn) # returns iterator of lines inside the file
+        fn | cat() # same thing as above
+        # -------------- file is on remote node --------------
+        [nodeId, fn] | applyCl.cat() # returns iterator of lines of the file
+        applyCl.cat([nodeId, fn]) # same thing
+        nodeId | applyCl.cat(fn) # also same thing
+    
+    So yeah, there're lots of ways to just simply read a file on a remote node. Is
+    it too much? Probably, but good thing is that you can pick any that's intuitive
+    for you. Note that this mode is just for convenience only, for when you want to do
+    exploratory analysis on a single remote file. To be efficient at bulk processing,
+    use the normal mode instead.
+
 :param fn: file name
 :param f: function to execute in every process
 :param timeout: kills the processes if it takes longer than this amount of seconds
 :param keepNodeIds: whether to keep the node id column or not
 :param multiplier: by default, each node will spawn as many process as there
     are cpus. Sometimes you want to spawn more process, change this to a higher number
 :param includeId: includes a unique id for this process
 """
+        if f is None: # simple case
+            def inner(nodeId_fn:Tuple[str, str]):
+                nodeId, fn = nodeId_fn; seeks = [nodeId] | applyCl.aS(lambda: fn | cli.splitSeek(round(os.path.getsize(fn)/settings.cat.chunkSize+1))) | cli.cut(1) | cli.item() | cli.deref()
+                inter = seeks | cli.window(2) | apply(cli.wrapList() | cli.insert(nodeId)) | cli.deref()
+                return inter | ~applyCl(lambda sB, eB: cli.cat(fn,sB=sB,eB=eB) | cli.deref(), pre=True) | cli.cut(1) | cli.joinStreams()
+                # return [nodeId_fn] | applyCl(cat() | deref(), pre=True) | cut(1) | item() # direct, no chunking method
+            if fn is None: return aS(inner) # [nodeId, fn] | applyCl.cat()
+            if isinstance(fn, str): return aS(lambda nodeId: inner([nodeId, fn])) # nodeId | applyCl.cat()
+            else: return inner(fn) # applyCl.cat([nodeId, fn])
         postprocess = cli.insertIdColumn(True, False) | ~apply(lambda x,y,z: [x,[*y,z]])
         checkpoints = None | applyCl.aS(lambda: fn | cli.splitSeek(int(applyCl.meta()["Resources"]["CPU"]*multiplier)) | cli.window(2) | cli.deref()) | cli.ungroup(single=True, begin=True) | postprocess | cli.deref()
         postprocess = cli.iden() if keepNodeIds else cli.cut(1)
         return checkpoints | applyCl(~aS(lambda x,y,idx: cli.cat(fn, sB=x, eB=y) | ((cli.wrapList() | cli.insert(idx)) if includeId else cli.iden()) | f), pre=True, timeout=timeout, num_cpus=1) | postprocess
     @staticmethod
-    def balanceFolder(folder:str, audit:bool=False, maxSteps:int=20):
+    def balanceFolder(folder:str, maxSteps:int=None, audit:bool=False):
         """Balances all files within a folder across all nodes.
 Example::
 
     base = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.balance"
     # deletes old structures and making test folder    
     applyCl.cmd(f"rm -r {base}"); applyCl.cmd(f"mkdir -p {base}")
     # creates 20 files of different sizes and dump it in the base folder of the current node
@@ -727,15 +777,15 @@
 more files, just dump it to any node (or download distributed across all nodes),
 then rebalance the folders and do your analysis.
 
 :param folder: folder to rebalance all of the files
 :param audit: if True, don't actually move files around and just return what files are going to be moved where
 :param maxSteps: what's the maximum number of file transfers?"""
         from k1lib.cli._applyCl import balanceFolder
-        balanceFolder(folder, maxSteps)
+        return balanceFolder(folder, audit, maxSteps)
     def download(url:str, folder:str, merge:bool=False, timeout=120, chunkTimeout=5):
         """Downloads a file distributedly to a specified folder.
 Example::
 
     url = "https://vim.kelvinho.org"
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.download" # file/folder name
     applyCl.download(url, fn)       # will download distributedly and dump file fragments into the folder fn
```

## k1lib/cli/utils.py

```diff
@@ -10,15 +10,15 @@
 try: import torch; hasTorch = True
 except: torch = k1lib.Object().withAutoDeclare(lambda: type("RandomClass", (object, ), {})); hasTorch = False
 try: import PIL; hasPIL = True
 except: hasPIL = False
 __all__ = ["size", "shape", "item", "rItem", "iden", "join", "wrapList",
            "equals", "reverse", "ignore", "rateLimit", "timeLimit", "tab", "indent",
            "clipboard", "deref", "bindec", "smooth", "disassemble",
-           "tree", "lookup", "dictFields"]
+           "tree", "lookup", "dictFields", "backup"]
 settings = k1lib.settings.cli
 def exploreSize(it):
     """Returns first element and length of array. Returns [first item, length]"""
     if isinstance(it, str): return None, len(it)
     try: return it[0], len(it)
     except: pass
     sentinel = object(); it = iter(it)
@@ -512,8 +512,30 @@
 Example::
 
     # returns [3, 1, '']
     {"a": 1, "b": 2, "c": 3} | dictFields("c", "a", "d")
 """
         self.fields = fields; self.default = default
     def __ror__(self, d):
-        return [d.get(f, self.default) for f in self.fields]
+        return [d.get(f, self.default) for f in self.fields]
+class backup(BaseCli):
+    def __init__(self):
+        """Backs up a file/folder.
+Example::
+
+    "some/folderOrFile" | backup()
+    "some/folderOrFile" | backup.restore()
+
+Really straightforward. Uses bash internally to copy files recursively, so
+not available on Windows."""
+        pass
+    def __ror__(self, it):
+        it = os.path.expanduser(it)
+        None | cli.cmd(f"rm -rf '{it}.backup'") | cli.ignore()
+        None | cli.cmd(f"cp -r '{it}' '{it}.backup'") | cli.ignore()
+    @staticmethod
+    def restore():
+        def inner(it):
+            it = os.path.expanduser(it)
+            None | cli.cmd(f"rm -rf '{it}'") | cli.ignore()
+            None | cli.cmd(f"cp -r '{it}.backup' '{it}'") | cli.ignore()
+        return cli.aS(inner)
```

## Comparing `k1lib-1.3.8.4.data/data/k1lib/k1ui/256.model.state_dict.pth` & `k1lib-1.3.8.5.data/data/k1lib/k1ui/256.model.state_dict.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.4.data/data/k1lib/k1ui/mouseKey.pth` & `k1lib-1.3.8.5.data/data/k1lib/k1ui/mouseKey.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.4.data/data/k1lib/serve/main.html` & `k1lib-1.3.8.5.data/data/k1lib/serve/main.html`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.4.dist-info/LICENSE` & `k1lib-1.3.8.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.4.dist-info/METADATA` & `k1lib-1.3.8.5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: k1lib
-Version: 1.3.8.4
+Version: 1.3.8.5
 Summary: Some nice ML overhaul
 Home-page: https://k1lib.com
 Author: Quang Ho
 Author-email: 157239q@gmail.com
 License: MIT
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
```

## Comparing `k1lib-1.3.8.4.dist-info/RECORD` & `k1lib-1.3.8.5.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -42,43 +42,43 @@
 k1lib/callbacks/lossFunctions/shorts.py,sha256=wXeUSgGDIdu_nsiAvn4pKs3fQrcO2FwpNXKcBCFvGzY,3465
 k1lib/callbacks/profilers/__init__.py,sha256=Gp5IvLRABYAg1J0ilTT2v72gfDbyTvUUHUEpvlSo1Lc,45
 k1lib/callbacks/profilers/computation.py,sha256=gPNsoioghh4PI5w8s2p8qYOrR7XObslqCLH5EkNOPSI,5054
 k1lib/callbacks/profilers/io.py,sha256=H8E0YzmLWRD9T2_RyDG2eXvbQQnJgzEnEyx8PqfQ4wY,2319
 k1lib/callbacks/profilers/memory.py,sha256=L0F5pc5LB0dtSnRot8ReR-amZn1uIXv0py0XmGS166U,4419
 k1lib/callbacks/profilers/time.py,sha256=R2-2ZooDwLQIeyonLp2Zz5E_uXzdy6mWUgw6uavQbpE,4215
 k1lib/cli/__init__.py,sha256=hF0ODhL20OSM9o1j68VhcIVflibgSpPuqeyYlsh8oow,925
-k1lib/cli/_applyCl.py,sha256=P3kNWJ3tqcIFXmihzfVNc0E_qtuX3ddwndBzhD7NRX8,12928
+k1lib/cli/_applyCl.py,sha256=NeORAWaBsBWQ_XG5fxwaeJAN5QuMMfzCu7STN-r4SCA,13717
 k1lib/cli/bio.py,sha256=PhGvy-fDA-wrUzzEDpuRe4x-Kbylx0sNmoXCEZfE_FA,8308
 k1lib/cli/cif.py,sha256=77FX83m1FRYEeZkdXJ8MiVapqCSzZ-1xOQ8ZLeHfhf8,4033
-k1lib/cli/conv.py,sha256=-P7YTTEi3lks1Lz6dQRkN4NiL37wySVDAbcc3cReJgw,19291
+k1lib/cli/conv.py,sha256=FAre9_Juu0A3b4gX15BgSBIelNW9NeEncaRX-ktnclQ,19311
 k1lib/cli/filt.py,sha256=c-bueTrH_5KAgRTtNiK4t4jfCy6xu-d0rYEUVF9KKGA,24071
 k1lib/cli/gb.py,sha256=xxjuNYgWrrElRckon3gP0sj-dShYnKs3jmHAb1U0kVI,6672
 k1lib/cli/grep.py,sha256=Lu4PFOe2pkaqd-UfJe_HhHCUFTUifE6Bh96_k80sQDA,6348
 k1lib/cli/init.py,sha256=2FaWeRqZnb--XWV4Xpo0z4ANDdyWpNQlHKkALtOGHKQ,18351
-k1lib/cli/inp.py,sha256=_2nW-IkK0UWXmPRcIQZrz_6yOsnuyQ_1ZOmmQD1JKPo,25932
+k1lib/cli/inp.py,sha256=BRwyBjLmo6DZbl0S3XZzKv5hnA27lDHgW6jJPSIYXGE,25961
 k1lib/cli/kcsv.py,sha256=YGUVVLTZGGujokhxtj5MfjU9t1jRGqp23d58JK8lhq0,623
 k1lib/cli/kxml.py,sha256=YQGutvKNm0_xAi_NhCNtuGey7fx3zZSmSo33kS--54c,4819
 k1lib/cli/mgi.py,sha256=aLke90nG89tgWLPwyKmTj3kM8yJnIBCJSrPS1jT8mUk,1915
-k1lib/cli/modifier.py,sha256=bY7622dZlM5ovAGeaK0lwDn5IrmvbCwRuy7ZJy1T9vY,57496
+k1lib/cli/modifier.py,sha256=IHT2WKL2W2C3SRrWeAN3gbZVS-osi5zbKic7XLA8ey4,60829
 k1lib/cli/mol.py,sha256=wNFuCPXtdEcH4DRBbmYaLAWxtDzjN2MOKFX7ynJhaJs,694
 k1lib/cli/nb.py,sha256=LsNN7OFJ6KzAYKvZpm4fj9WRpsX6Srx6D_xpSTCV328,4038
 k1lib/cli/optimizations.py,sha256=iZ73DwLqZCxRm0sECVZ7A2nDxf5D4rsoSGzrKTgzGaI,3530
 k1lib/cli/output.py,sha256=JVOMyvvNmdf7CTpK8cTZesaJL4EDWZECpcDvg-NtHhQ,11762
 k1lib/cli/sam.py,sha256=_ersEPP2ue0Oa3AyftNjQu2PABpH4L7iFBbRJDOkeug,2394
 k1lib/cli/structural.py,sha256=4fa04Qe5Uoi7ZtKsQB1QGzkfkzkL6IsDsccOGOn-o3Q,49930
 k1lib/cli/trace.py,sha256=nzZgOyXqFJYkQfbpR0lpX0Nnp0bQHXPjk8sDUBIe2hk,10399
 k1lib/cli/typehint.py,sha256=VBYxrOQaSnu5266lNWpgXIhXF7htdT0FT_NEvXjYBVk,23319
-k1lib/cli/utils.py,sha256=gaHYEw2_gjqNjOQFLUfa3JAXXwi6vZPCQqKwDuhrUDg,20345
+k1lib/cli/utils.py,sha256=XF-H1Ce5ssOw6Dp3htiosHce7xxTgxptrlUsMYxI7uE,21101
 k1lib/k1ui/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/k1ui/main.py,sha256=PnmdOhkjYgRSZnDyGYNMYtQ5Nvcb1NhQ9yjfP_3QORI,61803
 k1lib/serve/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/serve/main.py,sha256=Xh2SzgABfsBp2dRLUJRMftsG_We8ReVHYqXLi3ntMVA,10361
 k1lib/serve/suffix-dash.py,sha256=HMNJvB4d-PTHXDRDQTdYUKtzgirJ0LVnqqAkXxO0B4w,153
 k1lib/serve/suffix.py,sha256=UH3ITN6O2vzoha2f6v4bcQG3_Boav7VA7EC8wf8r9f8,642
-k1lib-1.3.8.4.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
-k1lib-1.3.8.4.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
-k1lib-1.3.8.4.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
-k1lib-1.3.8.4.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
-k1lib-1.3.8.4.dist-info/METADATA,sha256=_Y-COK9xmwpwt4Gc-OgtZJa8UgHAoLYwFAiub8hCREM,3864
-k1lib-1.3.8.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-k1lib-1.3.8.4.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
-k1lib-1.3.8.4.dist-info/RECORD,,
+k1lib-1.3.8.5.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
+k1lib-1.3.8.5.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
+k1lib-1.3.8.5.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
+k1lib-1.3.8.5.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
+k1lib-1.3.8.5.dist-info/METADATA,sha256=8sxpa059YPScS_fgPp-7zQyqBfLy61aIpy-baVyT83U,3864
+k1lib-1.3.8.5.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+k1lib-1.3.8.5.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
+k1lib-1.3.8.5.dist-info/RECORD,,
```

