# Comparing `tmp/k1lib-1.3.8.2-py3-none-any.whl.zip` & `tmp/k1lib-1.3.8.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 2538210 bytes, number of entries: 84
+Zip file size: 2538957 bytes, number of entries: 84
 -rw-rw-r--  2.0 unx     1435 b- defN 23-Feb-08 00:13 k1lib/__init__.py
 -rw-rw-r--  2.0 unx    53793 b- defN 23-Apr-02 08:25 k1lib/_baseClasses.py
 -rw-rw-r--  2.0 unx    13494 b- defN 23-May-05 13:41 k1lib/_basics.py
 -rw-rw-r--  2.0 unx     4908 b- defN 23-May-08 18:53 k1lib/_context.py
 -rw-rw-r--  2.0 unx     2866 b- defN 22-Jul-20 04:30 k1lib/_higher.py
 -rw-rw-r--  2.0 unx      948 b- defN 22-Sep-21 23:54 k1lib/_k1a.py
 -rw-rw-r--  2.0 unx    11646 b- defN 23-Jan-14 15:37 k1lib/_learner.py
@@ -43,44 +43,44 @@
 -rw-rw-r--  2.0 unx     3465 b- defN 22-Nov-27 08:16 k1lib/callbacks/lossFunctions/shorts.py
 -rw-rw-r--  2.0 unx       45 b- defN 21-Aug-11 18:19 k1lib/callbacks/profilers/__init__.py
 -rw-rw-r--  2.0 unx     5054 b- defN 22-May-15 09:01 k1lib/callbacks/profilers/computation.py
 -rw-rw-r--  2.0 unx     2319 b- defN 22-May-15 08:59 k1lib/callbacks/profilers/io.py
 -rw-rw-r--  2.0 unx     4419 b- defN 22-May-15 09:00 k1lib/callbacks/profilers/memory.py
 -rw-rw-r--  2.0 unx     4215 b- defN 22-May-15 09:03 k1lib/callbacks/profilers/time.py
 -rw-rw-r--  2.0 unx      925 b- defN 22-Nov-16 09:22 k1lib/cli/__init__.py
--rw-rw-r--  2.0 unx    11353 b- defN 23-May-15 18:50 k1lib/cli/_applyCl.py
+-rw-rw-r--  2.0 unx    11387 b- defN 23-May-16 19:00 k1lib/cli/_applyCl.py
 -rw-rw-r--  2.0 unx     8308 b- defN 22-Nov-27 07:16 k1lib/cli/bio.py
 -rw-rw-r--  2.0 unx     4033 b- defN 23-Jan-25 02:02 k1lib/cli/cif.py
 -rw-rw-r--  2.0 unx    19291 b- defN 23-May-12 02:55 k1lib/cli/conv.py
--rw-rw-r--  2.0 unx    24092 b- defN 23-May-10 23:07 k1lib/cli/filt.py
+-rw-rw-r--  2.0 unx    24071 b- defN 23-May-17 03:12 k1lib/cli/filt.py
 -rw-rw-r--  2.0 unx     6672 b- defN 23-Jan-25 02:02 k1lib/cli/gb.py
 -rw-rw-r--  2.0 unx     6348 b- defN 23-Apr-05 15:10 k1lib/cli/grep.py
 -rw-rw-r--  2.0 unx    18351 b- defN 23-May-12 23:10 k1lib/cli/init.py
--rw-rw-r--  2.0 unx    24799 b- defN 23-May-16 07:23 k1lib/cli/inp.py
+-rw-rw-r--  2.0 unx    25932 b- defN 23-May-16 19:47 k1lib/cli/inp.py
 -rw-rw-r--  2.0 unx      623 b- defN 22-Jun-22 10:43 k1lib/cli/kcsv.py
 -rw-rw-r--  2.0 unx     4819 b- defN 22-Aug-11 20:44 k1lib/cli/kxml.py
 -rw-rw-r--  2.0 unx     1915 b- defN 21-Nov-12 16:48 k1lib/cli/mgi.py
--rw-rw-r--  2.0 unx    55103 b- defN 23-May-15 19:32 k1lib/cli/modifier.py
+-rw-rw-r--  2.0 unx    55936 b- defN 23-May-16 18:45 k1lib/cli/modifier.py
 -rw-rw-r--  2.0 unx      694 b- defN 22-Nov-27 07:17 k1lib/cli/mol.py
 -rw-rw-r--  2.0 unx     4038 b- defN 23-May-09 15:53 k1lib/cli/nb.py
 -rw-rw-r--  2.0 unx     3530 b- defN 22-Aug-16 15:08 k1lib/cli/optimizations.py
--rw-rw-r--  2.0 unx    11559 b- defN 23-Apr-25 00:01 k1lib/cli/output.py
+-rw-rw-r--  2.0 unx    11762 b- defN 23-May-16 18:04 k1lib/cli/output.py
 -rw-rw-r--  2.0 unx     2394 b- defN 23-Jan-25 02:03 k1lib/cli/sam.py
 -rw-rw-r--  2.0 unx    49930 b- defN 23-May-11 15:29 k1lib/cli/structural.py
 -rw-rw-r--  2.0 unx    10399 b- defN 22-Aug-05 01:15 k1lib/cli/trace.py
 -rw-rw-r--  2.0 unx    23319 b- defN 22-Sep-29 07:14 k1lib/cli/typehint.py
 -rw-rw-r--  2.0 unx    20345 b- defN 23-Apr-26 17:09 k1lib/cli/utils.py
 -rw-rw-r--  2.0 unx       20 b- defN 23-Jan-19 22:00 k1lib/k1ui/__init__.py
 -rw-rw-r--  2.0 unx    61803 b- defN 23-Feb-10 12:10 k1lib/k1ui/main.py
 -rw-rw-r--  2.0 unx       20 b- defN 22-Sep-16 01:12 k1lib/serve/__init__.py
 -rw-rw-r--  2.0 unx    10361 b- defN 23-May-05 16:49 k1lib/serve/main.py
 -rw-rw-r--  2.0 unx      153 b- defN 23-May-05 16:00 k1lib/serve/suffix-dash.py
 -rw-rw-r--  2.0 unx      642 b- defN 23-Feb-13 19:00 k1lib/serve/suffix.py
--rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.3.8.2.data/data/k1lib/k1ui/256.model.state_dict.pth
--rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.3.8.2.data/data/k1lib/k1ui/mouseKey.pth
--rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.3.8.2.data/data/k1lib/serve/main.html
--rw-rw-r--  2.0 unx     1049 b- defN 23-May-16 07:23 k1lib-1.3.8.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3864 b- defN 23-May-16 07:23 k1lib-1.3.8.2.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-16 07:23 k1lib-1.3.8.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx        6 b- defN 23-May-16 07:23 k1lib-1.3.8.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6704 b- defN 23-May-16 07:23 k1lib-1.3.8.2.dist-info/RECORD
-84 files, 3499915 bytes uncompressed, 2527870 bytes compressed:  27.8%
+-rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.3.8.3.data/data/k1lib/k1ui/256.model.state_dict.pth
+-rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.3.8.3.data/data/k1lib/k1ui/mouseKey.pth
+-rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.3.8.3.data/data/k1lib/serve/main.html
+-rw-rw-r--  2.0 unx     1049 b- defN 23-May-17 03:13 k1lib-1.3.8.3.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3864 b- defN 23-May-17 03:13 k1lib-1.3.8.3.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-17 03:13 k1lib-1.3.8.3.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-17 03:13 k1lib-1.3.8.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6704 b- defN 23-May-17 03:13 k1lib-1.3.8.3.dist-info/RECORD
+84 files, 3502097 bytes uncompressed, 2528617 bytes compressed:  27.8%
```

## zipnote {}

```diff
@@ -222,32 +222,32 @@
 
 Filename: k1lib/serve/suffix-dash.py
 Comment: 
 
 Filename: k1lib/serve/suffix.py
 Comment: 
 
-Filename: k1lib-1.3.8.2.data/data/k1lib/k1ui/256.model.state_dict.pth
+Filename: k1lib-1.3.8.3.data/data/k1lib/k1ui/256.model.state_dict.pth
 Comment: 
 
-Filename: k1lib-1.3.8.2.data/data/k1lib/k1ui/mouseKey.pth
+Filename: k1lib-1.3.8.3.data/data/k1lib/k1ui/mouseKey.pth
 Comment: 
 
-Filename: k1lib-1.3.8.2.data/data/k1lib/serve/main.html
+Filename: k1lib-1.3.8.3.data/data/k1lib/serve/main.html
 Comment: 
 
-Filename: k1lib-1.3.8.2.dist-info/LICENSE
+Filename: k1lib-1.3.8.3.dist-info/LICENSE
 Comment: 
 
-Filename: k1lib-1.3.8.2.dist-info/METADATA
+Filename: k1lib-1.3.8.3.dist-info/METADATA
 Comment: 
 
-Filename: k1lib-1.3.8.2.dist-info/WHEEL
+Filename: k1lib-1.3.8.3.dist-info/WHEEL
 Comment: 
 
-Filename: k1lib-1.3.8.2.dist-info/top_level.txt
+Filename: k1lib-1.3.8.3.dist-info/top_level.txt
 Comment: 
 
-Filename: k1lib-1.3.8.2.dist-info/RECORD
+Filename: k1lib-1.3.8.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## k1lib/cli/_applyCl.py

```diff
@@ -40,34 +40,34 @@
     idx = fA[1][((sfA-cfA)**exp + (sfB-cfB)**exp).argmin()][0]
     ir2 = move(ir, nA, nB, idx)
     return ir2, [nA, nB, idx, score(ir2)]
 def traj(ir, maxSteps=20):
     sc = score(ir); aux = None; auxs = []; irs = []
     for i in range(maxSteps):
         ir, aux = optimize(ir)
-        if aux[3] > sc:
-            #irs.append(ir); auxs.append(aux)
-            break
+        if aux[3] > sc: break
         irs.append(ir); auxs.append(aux); sc = aux[3]
     return irs, auxs
 def collapse(it):
     a, b = it | rows(0, -1)
     c = [a[0], b[1], a[2], b[3]]
     if c[0] == c[1]: return []
     return [c]
-def traj2(ir):
+def traj2(ir, maxSteps=20):
     idx2FileName = ir | apply(lambda arr: [arr[0], arr[2]]) | toDict()
-    a = traj(ir)[1] | groupBy(2) | filt(lambda x: len(x) > 1).split() | (apply(collapse)) + iden() | joinStreams(2) | deref()
+    a = traj(ir, maxSteps)[1] | groupBy(2) | filt(lambda x: len(x) > 1).split() | (apply(collapse)) + iden() | joinStreams(2) | deref()
     return a | lookup(idx2FileName, 2) | deref()
 def moveFile(fileName:str, destNodeId:str, timeout=60): # executed on remotes
     fn = os.path.expanduser(fileName); dirname = os.path.dirname(fn)
     [destNodeId] | applyCl.aS(lambda: None | cmd(f"mkdir -p {dirname}; rm -f {fn}") | deref(), timeout=timeout) | deref()
     for chunk in cat(fn, False, True): [destNodeId] | applyCl.aS(lambda: chunk >> file(fn), timeout=timeout) | deref()
     None | cmd(f"rm {fn}") | deref()
-def balance(base): traj2(getIr(base)) | apply(lambda arr: [arr[0], arr]) | ~applyCl(lambda a,b,fn,sc: moveFile(fn, b), pre=True, timeout=60) | deref()
+def balanceFolder(base, maxSteps=20):
+    applyCl.cmd(f"mkdir -p {base}")
+    traj2(getIr(base), maxSteps) | apply(lambda arr: [arr[0], arr]) | ~applyCl(lambda a,b,fn,sc: moveFile(fn, b), pre=True, timeout=60) | deref()
 def getSize(url):
     for i in range(10):
         try: return requests.head(url, timeout=3).headers.items() | apply(op().lower(), 0) | toDict() | op()["content-length"].ab_int()
         except Exception as e:
             if i == 9: raise Exception(f"Can't get size of file")
 class NoPartialContent(Exception): pass
 def getChunk(url:str, sB:int, eB:int, timeout:float) -> bytes:
```

## k1lib/cli/filt.py

```diff
@@ -55,24 +55,23 @@
 :param predicate: function that returns True or False
 :param column: if not specified, then filters elements of the input
     array, else filters the specific column only
 :param catchErrors: whether to catch errors in the function or not (reject
     elements that raise errors). Runs slower if enabled though"""
         fs = [predicate]; super().__init__(fs)
         if column and column < 0: raise Exception(f"Filtering using a function on a negative-indexed column ({column}) is not supported")
-        f = fs[0]; self.column = column
+        f = fs[0]; _fP = fastF(f); self.column = column
         if catchErrors:
             def g(x):
-                try: return f(x)
+                try: return _fP(x)
                 except: return False
             self.predicate = g
-        else: self.predicate = f
-        self._fastP = fastF(self.predicate)
+        else: self.predicate = _fP
     def __ror__(self, it:Iterator[T]) -> Iterator[T]:
-        p = self._fastP; c = self.column
+        p = self.predicate; c = self.column
         if c is None:
             if isinstance(it, settings.arrayTypes):
                 try: return it[p(it)]
                 except Exception as e: print(e)
             return (l for l in it if p(l))
         else:
             if isinstance(it, settings.arrayTypes):
```

## k1lib/cli/inp.py

```diff
@@ -1,16 +1,16 @@
 # AUTOGENERATED FILE! PLEASE DON'T EDIT
 """This module for tools that will likely start the processing stream."""
 from typing import Iterator, Union, Any
-import k1lib, urllib, subprocess, warnings, os, k1lib, threading, time, warnings, math, io, dill
+import k1lib, urllib, subprocess, warnings, os, k1lib, threading, time, warnings, math, io, dill, urllib
 from k1lib.cli import BaseCli; import k1lib.cli as cli
 from k1lib.cli.typehint import *
 try: import minio; hasMinio = True
 except: hasMinio = False
-__all__ = ["cat", "splitSeek", "refineSeek", "curl", "wget", "ls", "cmd", "walk", "requireCli"]
+__all__ = ["cat", "splitSeek", "refineSeek", "curl", "wget", "ls", "cmd", "walk", "requireCli", "urlPath"]
 settings = k1lib.settings.cli
 catSettings = k1lib.Settings().add("chunkSize", 100000, "file reading chunk size for binary+chunk mode. Decrease it to avoid wasting memory and increase it to avoid disk latency")
 catSettings.add("every", k1lib.Settings().add("text", 1000, "for text mode, will print every n lines").add("binary", 10, "for binary mode, will print every n 100000-byte blocks"), "profiler print frequency")
 settings.add("cat", catSettings, "inp.cat() settings")
 def _catGenText(fn, sB, eB): # fn for "file name"
     try:
         if sB == 0 and eB == -1: # fast path without bounds (90-160 MB/s expected)
@@ -324,33 +324,42 @@
         if isinstance(fn, str):
             with open(fn, "rb") as fio: return process(fio)
         else: return process(fn)
     @classmethod
     def fastq(cls):
         """Refine fastq file's seek points"""
         return cls(lambda x: x[0][0] == b"@"[0] and x[2][0] == b"+"[0], 3)
-def curl(url:str) -> Iterator[str]:
+def curl(url:str, tries=3) -> Iterator[str]:
     """Gets file from url. File can't be a binary blob.
 Example::
 
     # prints out first 10 lines of the website
-    curl("https://k1lib.github.io/") | headOut()"""
-    for line in urllib.request.urlopen(url):
-        line = line.decode()
-        if line[-1] == "\n": yield line[:-1]
-        else: yield line
-def wget(url:str, fileName:str=None):
+    curl("https://k1lib.github.io/") | headOut()
+
+:param url: the url to get the contents of
+:param tries: how many times to retry the request"""
+    for i in range(tries):
+        try:
+            for line in urllib.request.urlopen(url):
+                line = line.decode()
+                if line[-1] == "\n": yield line[:-1]
+                else: yield line
+        except Exception as e:
+            if i == tries-1: raise e
+def wget(url:str, fileName:str=None, mkdir=True):
     """Downloads a file. Also returns the file name, in case you want to pipe it
 to something else.
 
 :param url: The url of the file
-:param fileName: if None, then tries to infer it from the url"""
+:param fileName: if None, then tries to infer it from the url
+:param mkdir: whether to make the directory leading up to the file or not"""
     if fileName is None: fileName = url.split("/")[-1]
-    urllib.request.urlretrieve(url, fileName)
-    return fileName
+    fileName = os.path.expanduser(fileName); dirname = os.path.dirname(fileName)
+    if mkdir: os.makedirs(dirname, exist_ok=True)
+    urllib.request.urlretrieve(url, fileName); return fileName
 def ls(folder:str=None):
     """List every file and folder inside the specified folder.
 Example::
 
     # returns List[str]
     ls("/home")
     # same as above
@@ -506,8 +515,24 @@
         """Recursively get all files inside a dictionary.
 Example::
 
     # prints out first 10 files
     "." | walk() | headOut()"""
         self.kwargs = kwargs
     def __ror__(self, path):
-        return os.walk(path, **self.kwargs) | ~cli.apply(lambda x, y, z: z | cli.apply(lambda e: x + os.sep + e)) | cli.joinStreams()
+        return os.walk(path, **self.kwargs) | ~cli.apply(lambda x, y, z: z | cli.apply(lambda e: x + os.sep + e)) | cli.joinStreams()
+def urlPath(base:str, host:bool=True):
+    """Translates from a url to a file path.
+Example::
+
+    base = "~/ssd/some/other/path"
+    url = "http://example.com/some/path/to/file.txt"
+    url | urlPath(base) # returns "~/ssd/some/other/path/example_com/some/path/to/file.txt"
+    url | urlPath(base, False) # returns "~/ssd/some/other/path/some/path/to/file.txt"
+
+:param base: base directory you want the files to be in"""
+    base = base.rstrip("/\\")
+    def inner(url):
+        p = urllib.parse.urlparse(url)
+        a = (p.netloc.replace(".", "_") + os.sep) if host else ""
+        return f"{base}{os.sep}{a}{p.path.strip('/')}"
+    return cli.aS(inner)
```

## k1lib/cli/modifier.py

```diff
@@ -225,14 +225,17 @@
 process is forked (at least on linux), every variable is still there, even the big
 ones. So, you can potentially do something like this::
 
     bigData = [] # 1B items in the list
     # summing up all items together. No input data transfers (because it's forked instead)
     range(1_000_000_000) | batched(100) | applyMp(lambda r: r | apply(lambda i: bigData[i]) | toSum()) | toSum()
 
+In fact, I use this loophole all the time, and thus has made the function :meth:`shared`,
+so check it out.
+
 :param prefetch: if not specified, schedules all jobs at the same time. If
     specified, schedules jobs so that there'll only be a specified amount of
     jobs, and will only schedule more if results are actually being used.
 :param timeout: seconds to wait for job before raising an error
 :param utilization: how many percent cores are we running? 0 for no cores, 1 for
     all the cores. Defaulted to 0.8
 :param bs: if specified, groups ``bs`` number of transforms into 1 job to be more
@@ -290,15 +293,15 @@
     @staticmethod
     def cat(fileName: str, f:Callable, n:int=None, **kwargs):
         """Like :meth:`applyCl.cat`, this will split a file up into multiple
 sections, execute ``f`` over all sections and return the results.
 Example::
 
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyMp.cat"
-    "0123456789\n"*100 | file(fn)
+    "0123456789\\n"*100 | file(fn)
     # returns [6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 8]
     applyMp.cat(fn, shape(0), 16) | deref()
 """
         return fileName | cli.splitSeek(n or os.cpu_count()) | cli.splitSeek.window() | ~applyMp(lambda x,y: cli.cat(fileName, sB=x, eB=y) | f, **kwargs)
     @staticmethod
     def shared(f, **kwargs):
         """Execution model where the input iterator is dereferenced and shared across
@@ -306,15 +309,15 @@
 
     a = range(1_000_000_000) | apply(lambda x: x*1.5 - 2000) | aS(list) # giant data structure
     a | batched(50_000_000, True) | applyMp(toSum()) | toSum() # has to serialize and deserialize lists of numbers, which wastes lots of cpu cycles and memory
     a | applyMp.shared(toSum()) | toSum() # giant data structure is forked, no serialization happens, no memory even gets copied, much faster
 
 In the 2nd line, most of the time is spent on serializing the data and transferring
 it to other processes, while in the 3rd line, most of the time is spent on calculating
-the sum instead."""
+the sum instead, as the giant data structure is forked, and Linux doesn't copy it internally."""
         def inner(it):
             try: n = len(it)
             except: it = list(it); n = len(it)
             # this is pretty unintuitive right? Why do it this way? Turns out, if you were to reference `it` directly, it will store it in f's co_freevars,
             # which will be serialized, defeating the purpose. Moving it to a global variable forces it to move to co_names instead, avoiding serialization. This took forever to understand
             idx = _k1_applyMp_global_ctx_autoInc(); _k1_applyMp_global_ctx[idx] = it
             res = range(n) | cli.batched(round(n/os.cpu_count()+1), True) | applyMp(lambda r: f(_k1_applyMp_global_ctx[idx][r.start:r.stop]), **kwargs) | aS(list)
@@ -349,15 +352,15 @@
             if self.p in applyMp._pools: applyMp._pools.remove(self.p)
 # apparently, this doesn't do anything, at least in jupyter environment
 atexit.register(lambda: applyMp.clearPools())
 parallel = applyMp
 def specificNode(obj, nodeId:str):
     return obj.options(scheduling_strategy=ray.util.scheduling_strategies.NodeAffinitySchedulingStrategy(node_id=nodeId, soft=False))
 class applyCl(BaseCli):
-    def __init__(self, f, prefetch=None, timeout=8, bs=1, rss:Union[dict, str]={}, pre:bool=False, orPatch=True, num_cpus=1, **kwargs):
+    def __init__(self, f, prefetch=None, timeout=60, bs=1, rss:Union[dict, str]={}, pre:bool=False, orPatch=True, num_cpus=1, **kwargs):
         """Like :class:`apply`, but execute a function over the input iterator
 in multiple processes on multiple nodes inside of a cluster (hence "cl"). So, just a more
 powerful version of :class:`applyMp`, assuming you have a cluster to run it on.
 Example::
 
     # returns [3, 2]
     ["abc", "de"] | applyCl(len) | deref()
@@ -562,14 +565,24 @@
     applyCl.balanceFile("~/cron.log")
 
 This will split the big files up into multiple segments (1 for each node). Then
 for each segment, it will read through it chunk by chunk into memory, and then
 deposits it into the respective nodes. Finally, it truncates the original files
 down to its segment boundary.
 
+The main goal of this is so that you can analyze a single big (say 200GB) file
+quickly. If that file is on a single node, then it will take forever, even with
+:class:`applyMp`. So splitting things up on multiple nodes will make analyzing
+it a lot faster.
+
+There's also the function :meth:`balanceFolder`, which has the opposite problem of
+having lots of small (say 100MB) files. So it will try to move files around (keeping
+them intact in the meantime) to different nodes so that the folder size ratio is
+roughly proportional to the cpu count.
+
 The exact split rule depends on the number of CPUs of each node. Best to see an
 example::
 
     Command:         applyCl.balanceFile("~/cron.log")
     Verbose command: applyCl.balanceFile("~/cron.log", ["1"], ["1", "2", "3", "4", "5"])
     ----------- Before -----------
     Node:      1  2  3  4 5
@@ -633,15 +646,15 @@
         from k1lib.cli._applyCl import balanceFile
         balanceFile(fn, nAs, nBs, rS or cli.iden())
     def decommission(self, fn, nAs:List[str], rS=None):
         """Convenience function for :meth:`balanceFile`. See docs over there."""
         from k1lib.cli._applyCl import balanceFile
         balanceFile(fn, None, applyCl.nodeIds() | ~cli.inSet(nAs) | deref(), rS or cli.iden())
     @staticmethod
-    def cat(fn:str, f:Callable, timeout:float=30, keepNodeIds:bool=False, multiplier:int=1, includeId:bool=False):
+    def cat(fn:str, f:Callable, timeout:float=60, keepNodeIds:bool=False, multiplier:int=1, includeId:bool=False):
         """Reads a file distributedly, does some operation on them, collects and
 returns all of the data together. Example::
 
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.cat.data"
     ("0123456789"*5 + "\\n") * 1000 | file(fn)
     applyCl.splitFile(fn)
     applyCl.cat(fn, shape(0), keepNodeIds=True) | deref()
@@ -683,15 +696,15 @@
 :param includeId: includes a unique id for this process
 """
         postprocess = cli.insertIdColumn(True, False) | ~apply(lambda x,y,z: [x,[*y,z]])
         checkpoints = None | applyCl.aS(lambda: fn | cli.splitSeek(int(applyCl.meta()["Resources"]["CPU"]*multiplier)) | cli.window(2) | cli.deref()) | cli.ungroup(single=True, begin=True) | postprocess | cli.deref()
         postprocess = cli.iden() if keepNodeIds else cli.cut(1)
         return checkpoints | applyCl(~aS(lambda x,y,idx: cli.cat(fn, sB=x, eB=y) | ((cli.wrapList() | cli.insert(idx)) if includeId else cli.iden()) | f), pre=True, timeout=timeout, num_cpus=1) | postprocess
     @staticmethod
-    def balanceFolder(folder:str, audit:bool=False):
+    def balanceFolder(folder:str, audit:bool=False, maxSteps:int=20):
         """Balances all files within a folder across all nodes.
 Example::
 
     base = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.balance"
     # deletes old structures and making test folder    
     applyCl.cmd(f"rm -r {base}"); applyCl.cmd(f"mkdir -p {base}")
     # creates 20 files of different sizes and dump it in the base folder of the current node
@@ -711,17 +724,18 @@
 So imagine that you just downloaded 1000 files to a single node on a specific folder,
 but you need to analyze all of them in a distributed manner. What you can do is to
 move some files to other nodes and then do your analysis. If you want to download
 more files, just dump it to any node (or download distributed across all nodes),
 then rebalance the folders and do your analysis.
 
 :param folder: folder to rebalance all of the files
-:param audit: if True, don't actually move files around and just return what files are going to be moved where"""
-        from k1lib.cli._applyCl import balance
-        balance(folder)
+:param audit: if True, don't actually move files around and just return what files are going to be moved where
+:param maxSteps: what's the maximum number of file transfers?"""
+        from k1lib.cli._applyCl import balanceFolder
+        balanceFolder(folder, maxSteps)
     def download(url:str, folder:str, merge:bool=False, timeout=120, chunkTimeout=5):
         """Downloads a file distributedly to a specified folder.
 Example::
 
     url = "https://vim.kelvinho.org"
     fn = "~/repos/labs/k1lib/k1lib/cli/test/applyCl.download" # file/folder name
     applyCl.download(url, fn)       # will download distributedly and dump file fragments into the folder fn
```

## k1lib/cli/output.py

```diff
@@ -69,15 +69,15 @@
         beginTime = time.time()
         f = (lambda x: x) if self.f == _defaultTeeF else self.f
         self.f = lambda s: f"\r{f(s)}, {int(time.time() - beginTime)}s elapsed"; return self
 try:
     import PIL; hasPIL = True
 except: hasPIL = False
 class file(BaseCli):
-    def __init__(self, fileName:str=None, flush:bool=False):
+    def __init__(self, fileName:str=None, flush:bool=False, mkdir:bool=False):
         """Opens a new file for writing. This will iterate through
 the iterator fed to it and put each element on a separate line. Example::
 
     # writes "0\\n1\\n2\\n" to file
     range(3) | file("test/f.txt")
     # same as above, but (maybe?) more familiar
     range(3) > file("text/f.txt")
@@ -129,23 +129,25 @@
     # appended to file
     range(10, 13) >> file(url)
     # returns ['0', '1', '2', '10', '11', '12']
     cat(url) | deref()
 
 :param fileName: if not specified, create new temporary file and returns the url
     when pipes into it
-:param flush: whether to flush to file immediately after every iteration"""
-        super().__init__(); self.fileName = fileName; self.flush = flush
+:param flush: whether to flush to file immediately after every iteration
+:param mkdir: whether to recursively make directories going to the file location or not"""
+        super().__init__(); self.fileName = fileName; self.flush = flush; self.mkdir = mkdir
         self.append = False # whether to append to file rather than erasing it
     def __ror__(self, it:Iterator[str]) -> None:
         super().__ror__(it); fileName = self.fileName; flushF = (lambda f: f.flush()) if self.flush else (lambda _: 0)
         if fileName is None:
             f = tempfile.NamedTemporaryFile()
             fileName = f.name; f.close()
         fileName = os.path.expanduser(fileName); firstLine = None
+        if self.mkdir: os.makedirs(os.path.dirname(fileName), exist_ok=True)
         if hasPIL and isinstance(it, PIL.Image.Image): it.save(fileName); return fileName
         if isinstance(it, str): it = [it]; text = True
         elif isinstance(it, bytes): text = False
         else:
             it = iter(it); sentinel = object(); firstLine = next(it, sentinel)
             if firstLine is sentinel: # no elements at all
                 with open(fileName, "w") as f: f.write("")
```

## Comparing `k1lib-1.3.8.2.data/data/k1lib/k1ui/256.model.state_dict.pth` & `k1lib-1.3.8.3.data/data/k1lib/k1ui/256.model.state_dict.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.2.data/data/k1lib/k1ui/mouseKey.pth` & `k1lib-1.3.8.3.data/data/k1lib/k1ui/mouseKey.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.2.data/data/k1lib/serve/main.html` & `k1lib-1.3.8.3.data/data/k1lib/serve/main.html`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.2.dist-info/LICENSE` & `k1lib-1.3.8.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.8.2.dist-info/METADATA` & `k1lib-1.3.8.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: k1lib
-Version: 1.3.8.2
+Version: 1.3.8.3
 Summary: Some nice ML overhaul
 Home-page: https://k1lib.com
 Author: Quang Ho
 Author-email: 157239q@gmail.com
 License: MIT
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
```

## Comparing `k1lib-1.3.8.2.dist-info/RECORD` & `k1lib-1.3.8.3.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -42,43 +42,43 @@
 k1lib/callbacks/lossFunctions/shorts.py,sha256=wXeUSgGDIdu_nsiAvn4pKs3fQrcO2FwpNXKcBCFvGzY,3465
 k1lib/callbacks/profilers/__init__.py,sha256=Gp5IvLRABYAg1J0ilTT2v72gfDbyTvUUHUEpvlSo1Lc,45
 k1lib/callbacks/profilers/computation.py,sha256=gPNsoioghh4PI5w8s2p8qYOrR7XObslqCLH5EkNOPSI,5054
 k1lib/callbacks/profilers/io.py,sha256=H8E0YzmLWRD9T2_RyDG2eXvbQQnJgzEnEyx8PqfQ4wY,2319
 k1lib/callbacks/profilers/memory.py,sha256=L0F5pc5LB0dtSnRot8ReR-amZn1uIXv0py0XmGS166U,4419
 k1lib/callbacks/profilers/time.py,sha256=R2-2ZooDwLQIeyonLp2Zz5E_uXzdy6mWUgw6uavQbpE,4215
 k1lib/cli/__init__.py,sha256=hF0ODhL20OSM9o1j68VhcIVflibgSpPuqeyYlsh8oow,925
-k1lib/cli/_applyCl.py,sha256=y3olIGpaTxnExD14JEOvh01LdPcAbTShamQfqHYz16w,11353
+k1lib/cli/_applyCl.py,sha256=FCE9ps4TEVRAgFmy1DMJ4O4CyPw9Qx8Qr6DyZvFswmI,11387
 k1lib/cli/bio.py,sha256=PhGvy-fDA-wrUzzEDpuRe4x-Kbylx0sNmoXCEZfE_FA,8308
 k1lib/cli/cif.py,sha256=77FX83m1FRYEeZkdXJ8MiVapqCSzZ-1xOQ8ZLeHfhf8,4033
 k1lib/cli/conv.py,sha256=-P7YTTEi3lks1Lz6dQRkN4NiL37wySVDAbcc3cReJgw,19291
-k1lib/cli/filt.py,sha256=VJ5Jfep6KFvVeYQm6n8czsy7TEsNIoE3zeUtKAYNIRs,24092
+k1lib/cli/filt.py,sha256=c-bueTrH_5KAgRTtNiK4t4jfCy6xu-d0rYEUVF9KKGA,24071
 k1lib/cli/gb.py,sha256=xxjuNYgWrrElRckon3gP0sj-dShYnKs3jmHAb1U0kVI,6672
 k1lib/cli/grep.py,sha256=Lu4PFOe2pkaqd-UfJe_HhHCUFTUifE6Bh96_k80sQDA,6348
 k1lib/cli/init.py,sha256=2FaWeRqZnb--XWV4Xpo0z4ANDdyWpNQlHKkALtOGHKQ,18351
-k1lib/cli/inp.py,sha256=mDCKKg_Zq1MFcl47l6GzP0GU9-gg1bCf9cp4zN0K-vQ,24799
+k1lib/cli/inp.py,sha256=_2nW-IkK0UWXmPRcIQZrz_6yOsnuyQ_1ZOmmQD1JKPo,25932
 k1lib/cli/kcsv.py,sha256=YGUVVLTZGGujokhxtj5MfjU9t1jRGqp23d58JK8lhq0,623
 k1lib/cli/kxml.py,sha256=YQGutvKNm0_xAi_NhCNtuGey7fx3zZSmSo33kS--54c,4819
 k1lib/cli/mgi.py,sha256=aLke90nG89tgWLPwyKmTj3kM8yJnIBCJSrPS1jT8mUk,1915
-k1lib/cli/modifier.py,sha256=JVK52iP8GmQjhBP9zae_q8CLHjrB7sV5FWjFRm_k25k,55103
+k1lib/cli/modifier.py,sha256=u1V6pO3ZcZzIWAX4gbAu93KWG_--hhjilRJcnrH3klA,55936
 k1lib/cli/mol.py,sha256=wNFuCPXtdEcH4DRBbmYaLAWxtDzjN2MOKFX7ynJhaJs,694
 k1lib/cli/nb.py,sha256=LsNN7OFJ6KzAYKvZpm4fj9WRpsX6Srx6D_xpSTCV328,4038
 k1lib/cli/optimizations.py,sha256=iZ73DwLqZCxRm0sECVZ7A2nDxf5D4rsoSGzrKTgzGaI,3530
-k1lib/cli/output.py,sha256=HQD61-Epy6WfteMHXW6SV14SiprXF55ELnfer2CWXEA,11559
+k1lib/cli/output.py,sha256=JVOMyvvNmdf7CTpK8cTZesaJL4EDWZECpcDvg-NtHhQ,11762
 k1lib/cli/sam.py,sha256=_ersEPP2ue0Oa3AyftNjQu2PABpH4L7iFBbRJDOkeug,2394
 k1lib/cli/structural.py,sha256=4fa04Qe5Uoi7ZtKsQB1QGzkfkzkL6IsDsccOGOn-o3Q,49930
 k1lib/cli/trace.py,sha256=nzZgOyXqFJYkQfbpR0lpX0Nnp0bQHXPjk8sDUBIe2hk,10399
 k1lib/cli/typehint.py,sha256=VBYxrOQaSnu5266lNWpgXIhXF7htdT0FT_NEvXjYBVk,23319
 k1lib/cli/utils.py,sha256=gaHYEw2_gjqNjOQFLUfa3JAXXwi6vZPCQqKwDuhrUDg,20345
 k1lib/k1ui/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/k1ui/main.py,sha256=PnmdOhkjYgRSZnDyGYNMYtQ5Nvcb1NhQ9yjfP_3QORI,61803
 k1lib/serve/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/serve/main.py,sha256=Xh2SzgABfsBp2dRLUJRMftsG_We8ReVHYqXLi3ntMVA,10361
 k1lib/serve/suffix-dash.py,sha256=HMNJvB4d-PTHXDRDQTdYUKtzgirJ0LVnqqAkXxO0B4w,153
 k1lib/serve/suffix.py,sha256=UH3ITN6O2vzoha2f6v4bcQG3_Boav7VA7EC8wf8r9f8,642
-k1lib-1.3.8.2.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
-k1lib-1.3.8.2.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
-k1lib-1.3.8.2.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
-k1lib-1.3.8.2.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
-k1lib-1.3.8.2.dist-info/METADATA,sha256=QxhHa7bo2yyJ8ZRbR-lTUu-5BxgMP7xTKOBMu86vmjo,3864
-k1lib-1.3.8.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-k1lib-1.3.8.2.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
-k1lib-1.3.8.2.dist-info/RECORD,,
+k1lib-1.3.8.3.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
+k1lib-1.3.8.3.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
+k1lib-1.3.8.3.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
+k1lib-1.3.8.3.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
+k1lib-1.3.8.3.dist-info/METADATA,sha256=wCRTdHOctfTBxR9x5aw9vJwkv_QR9fWuUEhsLDh-aPc,3864
+k1lib-1.3.8.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+k1lib-1.3.8.3.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
+k1lib-1.3.8.3.dist-info/RECORD,,
```

